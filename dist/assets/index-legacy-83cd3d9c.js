System.register([],(function(e,t){"use strict";return{execute:function(){var n=document.createElement("style");function r(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}n.textContent='@media screen and (max-width: 768px){body{background-color:#90ee90}}IonContent{display:flex;justify-content:center;align-items:center;height:100vh;width:100vw}#container{text-align:center;position:absolute;left:0;right:0;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;align-items:center;width:100%;font-size:16px}#container h2{font-size:2.125rem;line-height:26px}#container p{font-size:1.25em;line-height:22px;color:#8c8c8c}#setting-container{float:right;padding-right:20px}#setting-container button{background-color:transparent}.button-container{flex-direction:row}#title{float:left}ion-col{display:flex;align-items:center;justify-content:center;text-align:center;place-items:center;border:solid 1px #fff;color:#fff;font-size:16px}.text_container h2{font-size:2.125rem;color:#000}.text_container p{font-size:1.25em;color:#8c8c8c}ion-button.button1{width:38vw;height:43vh;--border-radius: 30px;color:#fff;--background: #5480F2;font-size:2.125rem}ion-button.button2{width:38vw;height:43vh;--border-radius: 30px;color:#fff;--background: #DF1044;--background-hover: #f3124a;--background-activated: #f3124a;--background-focused: #f3124a;font-size:2.125rem}ion-button.enumButton{width:38vw;height:43vh;--border-radius: 30px;color:#fff;--background: #059D53;font-size:2.125rem}ion-button.pnumButton{width:38vw;height:43vh;--border-radius: 30px;color:#fff;--background: #074728;font-size:2.125rem}ion-grid.input_box{background-color:#232323;width:100%;height:100%;margin:0 auto;padding:0}ion-row.input_box{background-color:#232323;border:0px}ion-col.input_box{padding:0 10px;border:0px;width:100%;height:100%}ion-row.input_segment{width:100%;height:60px;border:0px}.input_segment{--background: #232323}ion-segment-button::part(native){color:#fff}.segment-button-checked.md::part(native){color:#ff6300}ion-segment-button::part(indicator-background){background:#FF6300}ion-row.input_div_row{background-color:#232323;width:100%;height:84px;border:0px}div.input_div{background-color:#232323;color:#bababa;width:100%;height:84px;font-size:large;border:0px;display:flex;align-items:center;justify-content:center}ion-row.input_desc{background-color:#232323;width:100%;height:138px;border:0px}div.input_desc{background-color:#232323;color:#bababa;width:100%;height:100%;font-size:small;margin:0 28px;white-space:pre-line;line-height:30px;display:flex;align-items:center;text-align:left}.hr{border-bottom:1px solid #393A3A;border-radius:1px;margin:0;width:100%}ion-row.input_pad{background-color:#232323;height:298px;padding-top:9px;padding-bottom:9px;border:0px}ion-row.input_row{width:100%;height:70px;border:0px}ion-button.input_btn{--background: #313131;width:33.3%;height:60px;margin:5px 1%;font-size:2rem}div.background-image-img{position:absolute;background-image:url(/assets/testimg-c9b9e420.jpg);background-repeat:no-repeat;background-size:contain;filter:blur(10px);width:100vw;height:100vh}div.background-image-gradient{position:absolute;background:linear-gradient(rgba(255,255,255,0) 0%,rgb(0,0,0) 30%,rgba(0,0,0,1) 100%);width:100vw;height:100vh}div.background-image-init{position:absolute;background:linear-gradient(rgba(0,0,0,1),rgba(0,0,0,1));width:100vw;height:100vh}div.content{z-index:10}ion-grid.window{position:absolute;width:100%;height:100%;padding:40px}@media (orientation: portrait){ion-row.title{height:320px}}@media (orientation: landscape){ion-row.title{height:155px}}ion-row.title ion-col{border:0px}ion-row.announcement{height:300px;border:0px}ion-col.announcement{margin:0 auto;padding:5px;border:0px}ion-row.bottom_side{width:100%;height:590px;padding:5px 0}ion-col.main_input_box{height:100%;border:0px;padding:0 5px;margin:5px 0}div.main_input_box{width:100%;height:100%;margin:0 auto;padding:0px auto}ion-col.btn_and_face{height:100%;border:0px;padding:0 5px;margin:5px 0}ion-col.face{display:block;width:100%;height:420px;margin-bottom:20px;position:relative}ion-col.face video{width:100%;height:100%;object-fit:cover}ion-col.btn{width:100%;height:140px;border:0px}.btns{margin:0;padding:0}ion-col.out_btn{color:#000;border:0px;height:65px;margin:0 0 5px;padding:0}ion-button.out_btn{--background: #A8B1CE;width:100%;height:100%;padding:0}ion-col.call_btn{color:#000;border:0px;height:65px;margin:0 0 5px;padding:0}ion-button.call_btn{--background: #2C3D8F;width:100%;height:100%;padding:0}ion-col.in_btn{color:#000;border:0px;height:65px;margin:5px 0 0;padding:0}ion-button.in_btn{--background: #FF6300;width:100%;height:100%;font-size:large}html.ios{--ion-default-font: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Roboto", sans-serif}html.md{--ion-default-font: "Roboto", "Helvetica Neue", sans-serif}html{--ion-font-family: var(--ion-default-font)}body{background:var(--ion-background-color)}body.backdrop-no-scroll{overflow:hidden}html.ios ion-modal.modal-card ion-header ion-toolbar:first-of-type,html.ios ion-modal.modal-sheet ion-header ion-toolbar:first-of-type,html.ios ion-modal ion-footer ion-toolbar:first-of-type{padding-top:6px}html.ios ion-modal.modal-card ion-header ion-toolbar:last-of-type,html.ios ion-modal.modal-sheet ion-header ion-toolbar:last-of-type{padding-bottom:6px}html.ios ion-modal ion-toolbar{padding-right:calc(var(--ion-safe-area-right) + 8px);padding-left:calc(var(--ion-safe-area-left) + 8px)}@media screen and (min-width: 768px){html.ios ion-modal.modal-card:first-of-type{--backdrop-opacity: .18}}ion-modal.modal-default.show-modal~ion-modal.modal-default{--backdrop-opacity: 0;--box-shadow: none}html.ios ion-modal.modal-card .ion-page{border-top-left-radius:var(--border-radius)}.ion-color-primary{--ion-color-base: var(--ion-color-primary, #3880ff) !important;--ion-color-base-rgb: var(--ion-color-primary-rgb, 56, 128, 255) !important;--ion-color-contrast: var(--ion-color-primary-contrast, #fff) !important;--ion-color-contrast-rgb: var(--ion-color-primary-contrast-rgb, 255, 255, 255) !important;--ion-color-shade: var(--ion-color-primary-shade, #3171e0) !important;--ion-color-tint: var(--ion-color-primary-tint, #4c8dff) !important}.ion-color-secondary{--ion-color-base: var(--ion-color-secondary, #3dc2ff) !important;--ion-color-base-rgb: var(--ion-color-secondary-rgb, 61, 194, 255) !important;--ion-color-contrast: var(--ion-color-secondary-contrast, #fff) !important;--ion-color-contrast-rgb: var(--ion-color-secondary-contrast-rgb, 255, 255, 255) !important;--ion-color-shade: var(--ion-color-secondary-shade, #36abe0) !important;--ion-color-tint: var(--ion-color-secondary-tint, #50c8ff) !important}.ion-color-tertiary{--ion-color-base: var(--ion-color-tertiary, #5260ff) !important;--ion-color-base-rgb: var(--ion-color-tertiary-rgb, 82, 96, 255) !important;--ion-color-contrast: var(--ion-color-tertiary-contrast, #fff) !important;--ion-color-contrast-rgb: var(--ion-color-tertiary-contrast-rgb, 255, 255, 255) !important;--ion-color-shade: var(--ion-color-tertiary-shade, #4854e0) !important;--ion-color-tint: var(--ion-color-tertiary-tint, #6370ff) !important}.ion-color-success{--ion-color-base: var(--ion-color-success, #2dd36f) !important;--ion-color-base-rgb: var(--ion-color-success-rgb, 45, 211, 111) !important;--ion-color-contrast: var(--ion-color-success-contrast, #fff) !important;--ion-color-contrast-rgb: var(--ion-color-success-contrast-rgb, 255, 255, 255) !important;--ion-color-shade: var(--ion-color-success-shade, #28ba62) !important;--ion-color-tint: var(--ion-color-success-tint, #42d77d) !important}.ion-color-warning{--ion-color-base: var(--ion-color-warning, #ffc409) !important;--ion-color-base-rgb: var(--ion-color-warning-rgb, 255, 196, 9) !important;--ion-color-contrast: var(--ion-color-warning-contrast, #000) !important;--ion-color-contrast-rgb: var(--ion-color-warning-contrast-rgb, 0, 0, 0) !important;--ion-color-shade: var(--ion-color-warning-shade, #e0ac08) !important;--ion-color-tint: var(--ion-color-warning-tint, #ffca22) !important}.ion-color-danger{--ion-color-base: var(--ion-color-danger, #eb445a) !important;--ion-color-base-rgb: var(--ion-color-danger-rgb, 235, 68, 90) !important;--ion-color-contrast: var(--ion-color-danger-contrast, #fff) !important;--ion-color-contrast-rgb: var(--ion-color-danger-contrast-rgb, 255, 255, 255) !important;--ion-color-shade: var(--ion-color-danger-shade, #cf3c4f) !important;--ion-color-tint: var(--ion-color-danger-tint, #ed576b) !important}.ion-color-light{--ion-color-base: var(--ion-color-light, #f4f5f8) !important;--ion-color-base-rgb: var(--ion-color-light-rgb, 244, 245, 248) !important;--ion-color-contrast: var(--ion-color-light-contrast, #000) !important;--ion-color-contrast-rgb: var(--ion-color-light-contrast-rgb, 0, 0, 0) !important;--ion-color-shade: var(--ion-color-light-shade, #d7d8da) !important;--ion-color-tint: var(--ion-color-light-tint, #f5f6f9) !important}.ion-color-medium{--ion-color-base: var(--ion-color-medium, #92949c) !important;--ion-color-base-rgb: var(--ion-color-medium-rgb, 146, 148, 156) !important;--ion-color-contrast: var(--ion-color-medium-contrast, #fff) !important;--ion-color-contrast-rgb: var(--ion-color-medium-contrast-rgb, 255, 255, 255) !important;--ion-color-shade: var(--ion-color-medium-shade, #808289) !important;--ion-color-tint: var(--ion-color-medium-tint, #9d9fa6) !important}.ion-color-dark{--ion-color-base: var(--ion-color-dark, #222428) !important;--ion-color-base-rgb: var(--ion-color-dark-rgb, 34, 36, 40) !important;--ion-color-contrast: var(--ion-color-dark-contrast, #fff) !important;--ion-color-contrast-rgb: var(--ion-color-dark-contrast-rgb, 255, 255, 255) !important;--ion-color-shade: var(--ion-color-dark-shade, #1e2023) !important;--ion-color-tint: var(--ion-color-dark-tint, #383a3e) !important}.ion-page{left:0;right:0;top:0;bottom:0;display:flex;position:absolute;flex-direction:column;justify-content:space-between;contain:layout size style;overflow:hidden;z-index:0}ion-modal>.ion-page{position:relative;contain:layout style;height:100%}.split-pane-visible>.ion-page.split-pane-main{position:relative}ion-route,ion-route-redirect,ion-router,ion-select-option,ion-nav-controller,ion-menu-controller,ion-action-sheet-controller,ion-alert-controller,ion-loading-controller,ion-modal-controller,ion-picker-controller,ion-popover-controller,ion-toast-controller,.ion-page-hidden{display:none!important}.ion-page-invisible{opacity:0}.can-go-back>ion-header ion-back-button{display:block}html.plt-ios.plt-hybrid,html.plt-ios.plt-pwa{--ion-statusbar-padding: 20px}@supports (padding-top: 20px){html{--ion-safe-area-top: var(--ion-statusbar-padding)}}@supports (padding-top: constant(safe-area-inset-top)){html{--ion-safe-area-top: constant(safe-area-inset-top);--ion-safe-area-bottom: constant(safe-area-inset-bottom);--ion-safe-area-left: constant(safe-area-inset-left);--ion-safe-area-right: constant(safe-area-inset-right)}}@supports (padding-top: env(safe-area-inset-top)){html{--ion-safe-area-top: env(safe-area-inset-top);--ion-safe-area-bottom: env(safe-area-inset-bottom);--ion-safe-area-left: env(safe-area-inset-left);--ion-safe-area-right: env(safe-area-inset-right)}}ion-card.ion-color .ion-inherit-color,ion-card-header.ion-color .ion-inherit-color{color:inherit}.menu-content{transform:translateZ(0)}.menu-content-open{cursor:pointer;touch-action:manipulation;pointer-events:none}.ios .menu-content-reveal{box-shadow:-8px 0 42px rgba(0,0,0,.08)}[dir=rtl].ios .menu-content-reveal{box-shadow:8px 0 42px rgba(0,0,0,.08)}.md .menu-content-reveal,.md .menu-content-push{box-shadow:4px 0 16px rgba(0,0,0,.18)}ion-accordion-group.accordion-group-expand-inset>ion-accordion:first-of-type{border-top-left-radius:8px;border-top-right-radius:8px}ion-accordion-group.accordion-group-expand-inset>ion-accordion:last-of-type{border-bottom-left-radius:8px;border-bottom-right-radius:8px}ion-accordion-group>ion-accordion:last-of-type ion-item[slot=header]{--border-width: 0px}ion-accordion.accordion-animated>[slot=header] .ion-accordion-toggle-icon{transition:.3s transform cubic-bezier(.25,.8,.5,1)}@media (prefers-reduced-motion: reduce){ion-accordion .ion-accordion-toggle-icon{transition:none!important}}ion-accordion.accordion-expanding>[slot=header] .ion-accordion-toggle-icon,ion-accordion.accordion-expanded>[slot=header] .ion-accordion-toggle-icon{transform:rotate(180deg)}ion-accordion-group.accordion-group-expand-inset.md>ion-accordion.accordion-previous ion-item[slot=header]{--border-width: 0px;--inner-border-width: 0px}ion-accordion-group.accordion-group-expand-inset.md>ion-accordion.accordion-expanding:first-of-type,ion-accordion-group.accordion-group-expand-inset.md>ion-accordion.accordion-expanded:first-of-type{margin-top:0}ion-input input::-webkit-date-and-time-value{text-align:start}.ion-datetime-button-overlay{--width: fit-content;--height: fit-content}.ion-datetime-button-overlay ion-datetime.datetime-grid{width:320px;min-height:320px}audio,canvas,progress,video{vertical-align:baseline}audio:not([controls]){display:none;height:0}b,strong{font-weight:700}img{max-width:100%}hr{height:1px;border-width:0;box-sizing:content-box}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}label,input,select,textarea{font-family:inherit;line-height:normal}textarea{overflow:auto;height:auto;font:inherit;color:inherit}textarea::placeholder{padding-left:2px}form,input,optgroup,select{margin:0;font:inherit;color:inherit}html input[type=button],input[type=reset],input[type=submit]{cursor:pointer;-webkit-appearance:button}a,a div,a span,a ion-icon,a ion-label,button,button div,button span,button ion-icon,button ion-label,.ion-tappable,[tappable],[tappable] div,[tappable] span,[tappable] ion-icon,[tappable] ion-label,input,textarea{touch-action:manipulation}a ion-label,button ion-label{pointer-events:none}button{padding:0;border:0;border-radius:0;font-family:inherit;font-style:inherit;font-variant:inherit;line-height:1;text-transform:none;cursor:pointer;-webkit-appearance:button}[tappable]{cursor:pointer}a[disabled],button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}*{box-sizing:border-box;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none}html{width:100%;height:100%;text-size-adjust:100%}html:not(.hydrated) body{display:none}html.ion-ce body{display:block}html.plt-pwa{height:100vh}body{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin:0;padding:0;position:fixed;width:100%;max-width:100%;height:100%;max-height:100%;transform:translateZ(0);text-rendering:optimizeLegibility;overflow:hidden;touch-action:manipulation;-webkit-user-drag:none;-ms-content-zooming:none;word-wrap:break-word;overscroll-behavior-y:none;text-size-adjust:none}html{font-family:var(--ion-font-family)}a{background-color:transparent;color:var(--ion-color-primary, #3880ff)}h1,h2,h3,h4,h5,h6{margin-top:16px;margin-bottom:10px;font-weight:500;line-height:1.2}h1{margin-top:20px;font-size:26px}h2{margin-top:18px;font-size:24px}h3{font-size:22px}h4{font-size:20px}h5{font-size:18px}h6{font-size:16px}small{font-size:75%}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}.ion-no-padding{--padding-start: 0;--padding-end: 0;--padding-top: 0;--padding-bottom: 0;padding:0}.ion-padding{--padding-start: var(--ion-padding, 16px);--padding-end: var(--ion-padding, 16px);--padding-top: var(--ion-padding, 16px);--padding-bottom: var(--ion-padding, 16px);-webkit-padding-start:var(--ion-padding, 16px);padding-inline-start:var(--ion-padding, 16px);-webkit-padding-end:var(--ion-padding, 16px);padding-inline-end:var(--ion-padding, 16px);padding-top:var(--ion-padding, 16px);padding-bottom:var(--ion-padding, 16px)}.ion-padding-top{--padding-top: var(--ion-padding, 16px);padding-top:var(--ion-padding, 16px)}.ion-padding-start{--padding-start: var(--ion-padding, 16px);-webkit-padding-start:var(--ion-padding, 16px);padding-inline-start:var(--ion-padding, 16px)}.ion-padding-end{--padding-end: var(--ion-padding, 16px);-webkit-padding-end:var(--ion-padding, 16px);padding-inline-end:var(--ion-padding, 16px)}.ion-padding-bottom{--padding-bottom: var(--ion-padding, 16px);padding-bottom:var(--ion-padding, 16px)}.ion-padding-vertical{--padding-top: var(--ion-padding, 16px);--padding-bottom: var(--ion-padding, 16px);padding-top:var(--ion-padding, 16px);padding-bottom:var(--ion-padding, 16px)}.ion-padding-horizontal{--padding-start: var(--ion-padding, 16px);--padding-end: var(--ion-padding, 16px);-webkit-padding-start:var(--ion-padding, 16px);padding-inline-start:var(--ion-padding, 16px);-webkit-padding-end:var(--ion-padding, 16px);padding-inline-end:var(--ion-padding, 16px)}.ion-no-margin{--margin-start: 0;--margin-end: 0;--margin-top: 0;--margin-bottom: 0;margin:0}.ion-margin{--margin-start: var(--ion-margin, 16px);--margin-end: var(--ion-margin, 16px);--margin-top: var(--ion-margin, 16px);--margin-bottom: var(--ion-margin, 16px);-webkit-margin-start:var(--ion-margin, 16px);margin-inline-start:var(--ion-margin, 16px);-webkit-margin-end:var(--ion-margin, 16px);margin-inline-end:var(--ion-margin, 16px);margin-top:var(--ion-margin, 16px);margin-bottom:var(--ion-margin, 16px)}.ion-margin-top{--margin-top: var(--ion-margin, 16px);margin-top:var(--ion-margin, 16px)}.ion-margin-start{--margin-start: var(--ion-margin, 16px);-webkit-margin-start:var(--ion-margin, 16px);margin-inline-start:var(--ion-margin, 16px)}.ion-margin-end{--margin-end: var(--ion-margin, 16px);-webkit-margin-end:var(--ion-margin, 16px);margin-inline-end:var(--ion-margin, 16px)}.ion-margin-bottom{--margin-bottom: var(--ion-margin, 16px);margin-bottom:var(--ion-margin, 16px)}.ion-margin-vertical{--margin-top: var(--ion-margin, 16px);--margin-bottom: var(--ion-margin, 16px);margin-top:var(--ion-margin, 16px);margin-bottom:var(--ion-margin, 16px)}.ion-margin-horizontal{--margin-start: var(--ion-margin, 16px);--margin-end: var(--ion-margin, 16px);-webkit-margin-start:var(--ion-margin, 16px);margin-inline-start:var(--ion-margin, 16px);-webkit-margin-end:var(--ion-margin, 16px);margin-inline-end:var(--ion-margin, 16px)}.ion-float-left{float:left!important}.ion-float-right{float:right!important}.ion-float-start{float:left!important}:host-context([dir=rtl]) .ion-float-start{float:right!important}[dir=rtl] .ion-float-start{float:right!important}@supports selector(:dir(rtl)){.ion-float-start:dir(rtl){float:right!important}}.ion-float-end{float:right!important}:host-context([dir=rtl]) .ion-float-end{float:left!important}[dir=rtl] .ion-float-end{float:left!important}@supports selector(:dir(rtl)){.ion-float-end:dir(rtl){float:left!important}}@media (min-width: 576px){.ion-float-sm-left{float:left!important}.ion-float-sm-right{float:right!important}.ion-float-sm-start{float:left!important}:host-context([dir=rtl]) .ion-float-sm-start{float:right!important}[dir=rtl] .ion-float-sm-start{float:right!important}@supports selector(:dir(rtl)){.ion-float-sm-start:dir(rtl){float:right!important}}.ion-float-sm-end{float:right!important}:host-context([dir=rtl]) .ion-float-sm-end{float:left!important}[dir=rtl] .ion-float-sm-end{float:left!important}@supports selector(:dir(rtl)){.ion-float-sm-end:dir(rtl){float:left!important}}}@media (min-width: 768px){.ion-float-md-left{float:left!important}.ion-float-md-right{float:right!important}.ion-float-md-start{float:left!important}:host-context([dir=rtl]) .ion-float-md-start{float:right!important}[dir=rtl] .ion-float-md-start{float:right!important}@supports selector(:dir(rtl)){.ion-float-md-start:dir(rtl){float:right!important}}.ion-float-md-end{float:right!important}:host-context([dir=rtl]) .ion-float-md-end{float:left!important}[dir=rtl] .ion-float-md-end{float:left!important}@supports selector(:dir(rtl)){.ion-float-md-end:dir(rtl){float:left!important}}}@media (min-width: 992px){.ion-float-lg-left{float:left!important}.ion-float-lg-right{float:right!important}.ion-float-lg-start{float:left!important}:host-context([dir=rtl]) .ion-float-lg-start{float:right!important}[dir=rtl] .ion-float-lg-start{float:right!important}@supports selector(:dir(rtl)){.ion-float-lg-start:dir(rtl){float:right!important}}.ion-float-lg-end{float:right!important}:host-context([dir=rtl]) .ion-float-lg-end{float:left!important}[dir=rtl] .ion-float-lg-end{float:left!important}@supports selector(:dir(rtl)){.ion-float-lg-end:dir(rtl){float:left!important}}}@media (min-width: 1200px){.ion-float-xl-left{float:left!important}.ion-float-xl-right{float:right!important}.ion-float-xl-start{float:left!important}:host-context([dir=rtl]) .ion-float-xl-start{float:right!important}[dir=rtl] .ion-float-xl-start{float:right!important}@supports selector(:dir(rtl)){.ion-float-xl-start:dir(rtl){float:right!important}}.ion-float-xl-end{float:right!important}:host-context([dir=rtl]) .ion-float-xl-end{float:left!important}[dir=rtl] .ion-float-xl-end{float:left!important}@supports selector(:dir(rtl)){.ion-float-xl-end:dir(rtl){float:left!important}}}.ion-text-center{text-align:center!important}.ion-text-justify{text-align:justify!important}.ion-text-start{text-align:start!important}.ion-text-end{text-align:end!important}.ion-text-left{text-align:left!important}.ion-text-right{text-align:right!important}.ion-text-nowrap{white-space:nowrap!important}.ion-text-wrap{white-space:normal!important}@media (min-width: 576px){.ion-text-sm-center{text-align:center!important}.ion-text-sm-justify{text-align:justify!important}.ion-text-sm-start{text-align:start!important}.ion-text-sm-end{text-align:end!important}.ion-text-sm-left{text-align:left!important}.ion-text-sm-right{text-align:right!important}.ion-text-sm-nowrap{white-space:nowrap!important}.ion-text-sm-wrap{white-space:normal!important}}@media (min-width: 768px){.ion-text-md-center{text-align:center!important}.ion-text-md-justify{text-align:justify!important}.ion-text-md-start{text-align:start!important}.ion-text-md-end{text-align:end!important}.ion-text-md-left{text-align:left!important}.ion-text-md-right{text-align:right!important}.ion-text-md-nowrap{white-space:nowrap!important}.ion-text-md-wrap{white-space:normal!important}}@media (min-width: 992px){.ion-text-lg-center{text-align:center!important}.ion-text-lg-justify{text-align:justify!important}.ion-text-lg-start{text-align:start!important}.ion-text-lg-end{text-align:end!important}.ion-text-lg-left{text-align:left!important}.ion-text-lg-right{text-align:right!important}.ion-text-lg-nowrap{white-space:nowrap!important}.ion-text-lg-wrap{white-space:normal!important}}@media (min-width: 1200px){.ion-text-xl-center{text-align:center!important}.ion-text-xl-justify{text-align:justify!important}.ion-text-xl-start{text-align:start!important}.ion-text-xl-end{text-align:end!important}.ion-text-xl-left{text-align:left!important}.ion-text-xl-right{text-align:right!important}.ion-text-xl-nowrap{white-space:nowrap!important}.ion-text-xl-wrap{white-space:normal!important}}.ion-text-uppercase{text-transform:uppercase!important}.ion-text-lowercase{text-transform:lowercase!important}.ion-text-capitalize{text-transform:capitalize!important}@media (min-width: 576px){.ion-text-sm-uppercase{text-transform:uppercase!important}.ion-text-sm-lowercase{text-transform:lowercase!important}.ion-text-sm-capitalize{text-transform:capitalize!important}}@media (min-width: 768px){.ion-text-md-uppercase{text-transform:uppercase!important}.ion-text-md-lowercase{text-transform:lowercase!important}.ion-text-md-capitalize{text-transform:capitalize!important}}@media (min-width: 992px){.ion-text-lg-uppercase{text-transform:uppercase!important}.ion-text-lg-lowercase{text-transform:lowercase!important}.ion-text-lg-capitalize{text-transform:capitalize!important}}@media (min-width: 1200px){.ion-text-xl-uppercase{text-transform:uppercase!important}.ion-text-xl-lowercase{text-transform:lowercase!important}.ion-text-xl-capitalize{text-transform:capitalize!important}}.ion-align-self-start{align-self:flex-start!important}.ion-align-self-end{align-self:flex-end!important}.ion-align-self-center{align-self:center!important}.ion-align-self-stretch{align-self:stretch!important}.ion-align-self-baseline{align-self:baseline!important}.ion-align-self-auto{align-self:auto!important}.ion-wrap{flex-wrap:wrap!important}.ion-nowrap{flex-wrap:nowrap!important}.ion-wrap-reverse{flex-wrap:wrap-reverse!important}.ion-justify-content-start{justify-content:flex-start!important}.ion-justify-content-center{justify-content:center!important}.ion-justify-content-end{justify-content:flex-end!important}.ion-justify-content-around{justify-content:space-around!important}.ion-justify-content-between{justify-content:space-between!important}.ion-justify-content-evenly{justify-content:space-evenly!important}.ion-align-items-start{align-items:flex-start!important}.ion-align-items-center{align-items:center!important}.ion-align-items-end{align-items:flex-end!important}.ion-align-items-stretch{align-items:stretch!important}.ion-align-items-baseline{align-items:baseline!important}.ion-hide,.ion-hide-up,.ion-hide-down{display:none!important}@media (min-width: 576px){.ion-hide-sm-up{display:none!important}}@media (max-width: 575.98px){.ion-hide-sm-down{display:none!important}}@media (min-width: 768px){.ion-hide-md-up{display:none!important}}@media (max-width: 767.98px){.ion-hide-md-down{display:none!important}}@media (min-width: 992px){.ion-hide-lg-up{display:none!important}}@media (max-width: 991.98px){.ion-hide-lg-down{display:none!important}}@media (min-width: 1200px){.ion-hide-xl-up{display:none!important}}@media (max-width: 1199.98px){.ion-hide-xl-down{display:none!important}}:root{--ion-color-primary: #3880ff;--ion-color-primary-rgb: 56, 128, 255;--ion-color-primary-contrast: #ffffff;--ion-color-primary-contrast-rgb: 255, 255, 255;--ion-color-primary-shade: #3171e0;--ion-color-primary-tint: #4c8dff;--ion-color-secondary: #3dc2ff;--ion-color-secondary-rgb: 61, 194, 255;--ion-color-secondary-contrast: #ffffff;--ion-color-secondary-contrast-rgb: 255, 255, 255;--ion-color-secondary-shade: #36abe0;--ion-color-secondary-tint: #50c8ff;--ion-color-tertiary: #5260ff;--ion-color-tertiary-rgb: 82, 96, 255;--ion-color-tertiary-contrast: #ffffff;--ion-color-tertiary-contrast-rgb: 255, 255, 255;--ion-color-tertiary-shade: #4854e0;--ion-color-tertiary-tint: #6370ff;--ion-color-success: #2dd36f;--ion-color-success-rgb: 45, 211, 111;--ion-color-success-contrast: #ffffff;--ion-color-success-contrast-rgb: 255, 255, 255;--ion-color-success-shade: #28ba62;--ion-color-success-tint: #42d77d;--ion-color-warning: #ffc409;--ion-color-warning-rgb: 255, 196, 9;--ion-color-warning-contrast: #000000;--ion-color-warning-contrast-rgb: 0, 0, 0;--ion-color-warning-shade: #e0ac08;--ion-color-warning-tint: #ffca22;--ion-color-danger: #eb445a;--ion-color-danger-rgb: 235, 68, 90;--ion-color-danger-contrast: #ffffff;--ion-color-danger-contrast-rgb: 255, 255, 255;--ion-color-danger-shade: #cf3c4f;--ion-color-danger-tint: #ed576b;--ion-color-dark: #222428;--ion-color-dark-rgb: 34, 36, 40;--ion-color-dark-contrast: #ffffff;--ion-color-dark-contrast-rgb: 255, 255, 255;--ion-color-dark-shade: #1e2023;--ion-color-dark-tint: #383a3e;--ion-color-medium: #92949c;--ion-color-medium-rgb: 146, 148, 156;--ion-color-medium-contrast: #ffffff;--ion-color-medium-contrast-rgb: 255, 255, 255;--ion-color-medium-shade: #808289;--ion-color-medium-tint: #9d9fa6;--ion-color-light: #f4f5f8;--ion-color-light-rgb: 244, 245, 248;--ion-color-light-contrast: #000000;--ion-color-light-contrast-rgb: 0, 0, 0;--ion-color-light-shade: #d7d8da;--ion-color-light-tint: #f5f6f9}@media (prefers-color-scheme: dark){body{--ion-color-primary: #428cff;--ion-color-primary-rgb: 66,140,255;--ion-color-primary-contrast: #ffffff;--ion-color-primary-contrast-rgb: 255,255,255;--ion-color-primary-shade: #3a7be0;--ion-color-primary-tint: #5598ff;--ion-color-secondary: #50c8ff;--ion-color-secondary-rgb: 80,200,255;--ion-color-secondary-contrast: #ffffff;--ion-color-secondary-contrast-rgb: 255,255,255;--ion-color-secondary-shade: #46b0e0;--ion-color-secondary-tint: #62ceff;--ion-color-tertiary: #6a64ff;--ion-color-tertiary-rgb: 106,100,255;--ion-color-tertiary-contrast: #ffffff;--ion-color-tertiary-contrast-rgb: 255,255,255;--ion-color-tertiary-shade: #5d58e0;--ion-color-tertiary-tint: #7974ff;--ion-color-success: #2fdf75;--ion-color-success-rgb: 47,223,117;--ion-color-success-contrast: #000000;--ion-color-success-contrast-rgb: 0,0,0;--ion-color-success-shade: #29c467;--ion-color-success-tint: #44e283;--ion-color-warning: #ffd534;--ion-color-warning-rgb: 255,213,52;--ion-color-warning-contrast: #000000;--ion-color-warning-contrast-rgb: 0,0,0;--ion-color-warning-shade: #e0bb2e;--ion-color-warning-tint: #ffd948;--ion-color-danger: #ff4961;--ion-color-danger-rgb: 255,73,97;--ion-color-danger-contrast: #ffffff;--ion-color-danger-contrast-rgb: 255,255,255;--ion-color-danger-shade: #e04055;--ion-color-danger-tint: #ff5b71;--ion-color-dark: #f4f5f8;--ion-color-dark-rgb: 244,245,248;--ion-color-dark-contrast: #000000;--ion-color-dark-contrast-rgb: 0,0,0;--ion-color-dark-shade: #d7d8da;--ion-color-dark-tint: #f5f6f9;--ion-color-medium: #989aa2;--ion-color-medium-rgb: 152,154,162;--ion-color-medium-contrast: #000000;--ion-color-medium-contrast-rgb: 0,0,0;--ion-color-medium-shade: #86888f;--ion-color-medium-tint: #a2a4ab;--ion-color-light: #222428;--ion-color-light-rgb: 34,36,40;--ion-color-light-contrast: #ffffff;--ion-color-light-contrast-rgb: 255,255,255;--ion-color-light-shade: #1e2023;--ion-color-light-tint: #383a3e}.ios body{--ion-background-color: #000000;--ion-background-color-rgb: 0,0,0;--ion-text-color: #ffffff;--ion-text-color-rgb: 255,255,255;--ion-color-step-50: #0d0d0d;--ion-color-step-100: #1a1a1a;--ion-color-step-150: #262626;--ion-color-step-200: #333333;--ion-color-step-250: #404040;--ion-color-step-300: #4d4d4d;--ion-color-step-350: #595959;--ion-color-step-400: #666666;--ion-color-step-450: #737373;--ion-color-step-500: #808080;--ion-color-step-550: #8c8c8c;--ion-color-step-600: #999999;--ion-color-step-650: #a6a6a6;--ion-color-step-700: #b3b3b3;--ion-color-step-750: #bfbfbf;--ion-color-step-800: #cccccc;--ion-color-step-850: #d9d9d9;--ion-color-step-900: #e6e6e6;--ion-color-step-950: #f2f2f2;--ion-item-background: #000000;--ion-card-background: #1c1c1d}.ios ion-modal{--ion-background-color: var(--ion-color-step-100);--ion-toolbar-background: var(--ion-color-step-150);--ion-toolbar-border-color: var(--ion-color-step-250)}.md body{--ion-background-color: #121212;--ion-background-color-rgb: 18,18,18;--ion-text-color: #ffffff;--ion-text-color-rgb: 255,255,255;--ion-border-color: #222222;--ion-color-step-50: #1e1e1e;--ion-color-step-100: #2a2a2a;--ion-color-step-150: #363636;--ion-color-step-200: #414141;--ion-color-step-250: #4d4d4d;--ion-color-step-300: #595959;--ion-color-step-350: #656565;--ion-color-step-400: #717171;--ion-color-step-450: #7d7d7d;--ion-color-step-500: #898989;--ion-color-step-550: #949494;--ion-color-step-600: #a0a0a0;--ion-color-step-650: #acacac;--ion-color-step-700: #b8b8b8;--ion-color-step-750: #c4c4c4;--ion-color-step-800: #d0d0d0;--ion-color-step-850: #dbdbdb;--ion-color-step-900: #e7e7e7;--ion-color-step-950: #f3f3f3;--ion-item-background: #1e1e1e;--ion-toolbar-background: #1f1f1f;--ion-tab-bar-background: #1f1f1f;--ion-card-background: #1e1e1e}}\n',document.head.appendChild(n);var a={exports:{}},i={},o={exports:{}},s={},l=Symbol.for("react.element"),u=Symbol.for("react.portal"),d=Symbol.for("react.fragment"),c=Symbol.for("react.strict_mode"),p=Symbol.for("react.profiler"),h=Symbol.for("react.provider"),f=Symbol.for("react.context"),m=Symbol.for("react.forward_ref"),g=Symbol.for("react.suspense"),b=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),v=Symbol.iterator,x={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},w=Object.assign,k={};function S(e,t,n){this.props=e,this.context=t,this.refs=k,this.updater=n||x}function I(){}function N(e,t,n){this.props=e,this.context=t,this.refs=k,this.updater=n||x}S.prototype.isReactComponent={},S.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},S.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},I.prototype=S.prototype;var C=N.prototype=new I;C.constructor=N,w(C,S.prototype),C.isPureReactComponent=!0;var T=Array.isArray,$=Object.prototype.hasOwnProperty,E={current:null},_={key:!0,ref:!0,__self:!0,__source:!0};function A(e,t,n){var r,a={},i=null,o=null;if(null!=t)for(r in void 0!==t.ref&&(o=t.ref),void 0!==t.key&&(i=""+t.key),t)$.call(t,r)&&!_.hasOwnProperty(r)&&(a[r]=t[r]);var s=arguments.length-2;if(1===s)a.children=n;else if(1<s){for(var u=Array(s),d=0;d<s;d++)u[d]=arguments[d+2];a.children=u}if(e&&e.defaultProps)for(r in s=e.defaultProps)void 0===a[r]&&(a[r]=s[r]);return{$$typeof:l,type:e,key:i,ref:o,props:a,_owner:E.current}}function R(e){return"object"==typeof e&&null!==e&&e.$$typeof===l}var F=/\/+/g;function D(e,t){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function M(e,t,n,r,a){var i=typeof e;"undefined"!==i&&"boolean"!==i||(e=null);var o=!1;if(null===e)o=!0;else switch(i){case"string":case"number":o=!0;break;case"object":switch(e.$$typeof){case l:case u:o=!0}}if(o)return a=a(o=e),e=""===r?"."+D(o,0):r,T(a)?(n="",null!=e&&(n=e.replace(F,"$&/")+"/"),M(a,t,n,"",(function(e){return e}))):null!=a&&(R(a)&&(a=function(e,t){return{$$typeof:l,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(a,n+(!a.key||o&&o.key===a.key?"":(""+a.key).replace(F,"$&/")+"/")+e)),t.push(a)),1;if(o=0,r=""===r?".":r+":",T(e))for(var s=0;s<e.length;s++){var d=r+D(i=e[s],s);o+=M(i,t,n,d,a)}else if(d=function(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=v&&e[v]||e["@@iterator"])?e:null}(e),"function"==typeof d)for(e=d.call(e),s=0;!(i=e.next()).done;)o+=M(i=i.value,t,n,d=r+D(i,s++),a);else if("object"===i)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return o}function O(e,t,n){if(null==e)return e;var r=[],a=0;return M(e,r,"","",(function(e){return t.call(n,e,a++)})),r}function z(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var P={current:null},L={transition:null},B={ReactCurrentDispatcher:P,ReactCurrentBatchConfig:L,ReactCurrentOwner:E};s.Children={map:O,forEach:function(e,t,n){O(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return O(e,(function(){t++})),t},toArray:function(e){return O(e,(function(e){return e}))||[]},only:function(e){if(!R(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},s.Component=S,s.Fragment=d,s.Profiler=p,s.PureComponent=N,s.StrictMode=c,s.Suspense=g,s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B,s.cloneElement=function(e,t,n){if(null==e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var r=w({},e.props),a=e.key,i=e.ref,o=e._owner;if(null!=t){if(void 0!==t.ref&&(i=t.ref,o=E.current),void 0!==t.key&&(a=""+t.key),e.type&&e.type.defaultProps)var s=e.type.defaultProps;for(u in t)$.call(t,u)&&!_.hasOwnProperty(u)&&(r[u]=void 0===t[u]&&void 0!==s?s[u]:t[u])}var u=arguments.length-2;if(1===u)r.children=n;else if(1<u){s=Array(u);for(var d=0;d<u;d++)s[d]=arguments[d+2];r.children=s}return{$$typeof:l,type:e.type,key:a,ref:i,props:r,_owner:o}},s.createContext=function(e){return(e={$$typeof:f,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:h,_context:e},e.Consumer=e},s.createElement=A,s.createFactory=function(e){var t=A.bind(null,e);return t.type=e,t},s.createRef=function(){return{current:null}},s.forwardRef=function(e){return{$$typeof:m,render:e}},s.isValidElement=R,s.lazy=function(e){return{$$typeof:y,_payload:{_status:-1,_result:e},_init:z}},s.memo=function(e,t){return{$$typeof:b,type:e,compare:void 0===t?null:t}},s.startTransition=function(e){var t=L.transition;L.transition={};try{e()}finally{L.transition=t}},s.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")},s.useCallback=function(e,t){return P.current.useCallback(e,t)},s.useContext=function(e){return P.current.useContext(e)},s.useDebugValue=function(){},s.useDeferredValue=function(e){return P.current.useDeferredValue(e)},s.useEffect=function(e,t){return P.current.useEffect(e,t)},s.useId=function(){return P.current.useId()},s.useImperativeHandle=function(e,t,n){return P.current.useImperativeHandle(e,t,n)},s.useInsertionEffect=function(e,t){return P.current.useInsertionEffect(e,t)},s.useLayoutEffect=function(e,t){return P.current.useLayoutEffect(e,t)},s.useMemo=function(e,t){return P.current.useMemo(e,t)},s.useReducer=function(e,t,n){return P.current.useReducer(e,t,n)},s.useRef=function(e){return P.current.useRef(e)},s.useState=function(e){return P.current.useState(e)},s.useSyncExternalStore=function(e,t,n){return P.current.useSyncExternalStore(e,t,n)},s.useTransition=function(){return P.current.useTransition()},s.version="18.2.0",o.exports=s;var W=o.exports;const V=r(W);
/**
             * @license React
             * react-jsx-runtime.production.min.js
             *
             * Copyright (c) Facebook, Inc. and its affiliates.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */var U=W,j=Symbol.for("react.element"),H=Symbol.for("react.fragment"),G=Object.prototype.hasOwnProperty,q=U.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,K={key:!0,ref:!0,__self:!0,__source:!0};function X(e,t,n){var r,a={},i=null,o=null;for(r in void 0!==n&&(i=""+n),void 0!==t.key&&(i=""+t.key),void 0!==t.ref&&(o=t.ref),t)G.call(t,r)&&!K.hasOwnProperty(r)&&(a[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps)void 0===a[r]&&(a[r]=t[r]);return{$$typeof:j,type:e,key:i,ref:o,props:a,_owner:q.current}}i.Fragment=H,i.jsx=X,i.jsxs=X,a.exports=i;var Y=a.exports,Q={exports:{}},Z={},J={exports:{}},ee={};
/**
             * @license React
             * scheduler.production.min.js
             *
             * Copyright (c) Facebook, Inc. and its affiliates.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */
!function(e){function t(e,t){var n=e.length;e.push(t);e:for(;0<n;){var r=n-1>>>1,i=e[r];if(!(0<a(i,t)))break e;e[r]=t,e[n]=i,n=r}}function n(e){return 0===e.length?null:e[0]}function r(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var r=0,i=e.length,o=i>>>1;r<o;){var s=2*(r+1)-1,l=e[s],u=s+1,d=e[u];if(0>a(l,n))u<i&&0>a(d,l)?(e[r]=d,e[u]=n,r=u):(e[r]=l,e[s]=n,r=s);else{if(!(u<i&&0>a(d,n)))break e;e[r]=d,e[u]=n,r=u}}}return t}function a(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"==typeof performance&&"function"==typeof performance.now){var i=performance;e.unstable_now=function(){return i.now()}}else{var o=Date,s=o.now();e.unstable_now=function(){return o.now()-s}}var l=[],u=[],d=1,c=null,p=3,h=!1,f=!1,m=!1,g="function"==typeof setTimeout?setTimeout:null,b="function"==typeof clearTimeout?clearTimeout:null,y="undefined"!=typeof setImmediate?setImmediate:null;function v(e){for(var a=n(u);null!==a;){if(null===a.callback)r(u);else{if(!(a.startTime<=e))break;r(u),a.sortIndex=a.expirationTime,t(l,a)}a=n(u)}}function x(e){if(m=!1,v(e),!f)if(null!==n(l))f=!0,R(w);else{var t=n(u);null!==t&&F(x,t.startTime-e)}}function w(t,a){f=!1,m&&(m=!1,b(N),N=-1),h=!0;var i=p;try{for(v(a),c=n(l);null!==c&&(!(c.expirationTime>a)||t&&!$());){var o=c.callback;if("function"==typeof o){c.callback=null,p=c.priorityLevel;var s=o(c.expirationTime<=a);a=e.unstable_now(),"function"==typeof s?c.callback=s:c===n(l)&&r(l),v(a)}else r(l);c=n(l)}if(null!==c)var d=!0;else{var g=n(u);null!==g&&F(x,g.startTime-a),d=!1}return d}finally{c=null,p=i,h=!1}}"undefined"!=typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var k,S=!1,I=null,N=-1,C=5,T=-1;function $(){return!(e.unstable_now()-T<C)}function E(){if(null!==I){var t=e.unstable_now();T=t;var n=!0;try{n=I(!0,t)}finally{n?k():(S=!1,I=null)}}else S=!1}if("function"==typeof y)k=function(){y(E)};else if("undefined"!=typeof MessageChannel){var _=new MessageChannel,A=_.port2;_.port1.onmessage=E,k=function(){A.postMessage(null)}}else k=function(){g(E,0)};function R(e){I=e,S||(S=!0,k())}function F(t,n){N=g((function(){t(e.unstable_now())}),n)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(e){e.callback=null},e.unstable_continueExecution=function(){f||h||(f=!0,R(w))},e.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):C=0<e?Math.floor(1e3/e):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return n(l)},e.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},e.unstable_scheduleCallback=function(r,a,i){var o=e.unstable_now();switch(i="object"==typeof i&&null!==i&&"number"==typeof(i=i.delay)&&0<i?o+i:o,r){case 1:var s=-1;break;case 2:s=250;break;case 5:s=1073741823;break;case 4:s=1e4;break;default:s=5e3}return r={id:d++,callback:a,priorityLevel:r,startTime:i,expirationTime:s=i+s,sortIndex:-1},i>o?(r.sortIndex=i,t(u,r),null===n(l)&&r===n(u)&&(m?(b(N),N=-1):m=!0,F(x,i-o))):(r.sortIndex=s,t(l,r),f||h||(f=!0,R(w))),r},e.unstable_shouldYield=$,e.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}}(ee),J.exports=ee;var te=J.exports,ne=W,re=te;
/**
             * @license React
             * react-dom.production.min.js
             *
             * Copyright (c) Facebook, Inc. and its affiliates.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */function ae(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var ie=new Set,oe={};function se(e,t){le(e,t),le(e+"Capture",t)}function le(e,t){for(oe[e]=t,e=0;e<t.length;e++)ie.add(t[e])}var ue=!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement),de=Object.prototype.hasOwnProperty,ce=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,pe={},he={};function fe(e,t,n,r,a,i,o){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=r,this.attributeNamespace=a,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=i,this.removeEmptyString=o}var me={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){me[e]=new fe(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];me[t]=new fe(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){me[e]=new fe(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){me[e]=new fe(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){me[e]=new fe(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){me[e]=new fe(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){me[e]=new fe(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){me[e]=new fe(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){me[e]=new fe(e,5,!1,e.toLowerCase(),null,!1,!1)}));var ge=/[\-:]([a-z])/g;function be(e){return e[1].toUpperCase()}function ye(e,t,n,r){var a=me.hasOwnProperty(t)?me[t]:null;(null!==a?0!==a.type:r||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,r){if(null==t||function(e,t,n,r){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!r&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,r))return!0;if(r)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,a,r)&&(n=null),r||null===a?function(e){return!!de.call(he,e)||!de.call(pe,e)&&(ce.test(e)?he[e]=!0:(pe[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):a.mustUseProperty?e[a.propertyName]=null===n?3!==a.type&&"":n:(t=a.attributeName,r=a.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(a=a.type)||4===a&&!0===n?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(ge,be);me[t]=new fe(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(ge,be);me[t]=new fe(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(ge,be);me[t]=new fe(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){me[e]=new fe(e,1,!1,e.toLowerCase(),null,!1,!1)})),me.xlinkHref=new fe("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){me[e]=new fe(e,1,!1,e.toLowerCase(),null,!0,!0)}));var ve=ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,xe=Symbol.for("react.element"),we=Symbol.for("react.portal"),ke=Symbol.for("react.fragment"),Se=Symbol.for("react.strict_mode"),Ie=Symbol.for("react.profiler"),Ne=Symbol.for("react.provider"),Ce=Symbol.for("react.context"),Te=Symbol.for("react.forward_ref"),$e=Symbol.for("react.suspense"),Ee=Symbol.for("react.suspense_list"),_e=Symbol.for("react.memo"),Ae=Symbol.for("react.lazy"),Re=Symbol.for("react.offscreen"),Fe=Symbol.iterator;function De(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=Fe&&e[Fe]||e["@@iterator"])?e:null}var Me,Oe=Object.assign;function ze(e){if(void 0===Me)try{throw Error()}catch(xp){var t=xp.stack.trim().match(/\n( *(at )?)/);Me=t&&t[1]||""}return"\n"+Me+e}var Pe=!1;function Le(e,t){if(!e||Pe)return"";Pe=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"==typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(Tp){var r=Tp}Reflect.construct(e,[],t)}else{try{t.call()}catch(Tp){r=Tp}e.call(t.prototype)}else{try{throw Error()}catch(Tp){r=Tp}e()}}catch(Tp){if(Tp&&r&&"string"==typeof Tp.stack){for(var a=Tp.stack.split("\n"),i=r.stack.split("\n"),o=a.length-1,s=i.length-1;1<=o&&0<=s&&a[o]!==i[s];)s--;for(;1<=o&&0<=s;o--,s--)if(a[o]!==i[s]){if(1!==o||1!==s)do{if(o--,0>--s||a[o]!==i[s]){var l="\n"+a[o].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}}while(1<=o&&0<=s);break}}}finally{Pe=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?ze(e):""}function Be(e){switch(e.tag){case 5:return ze(e.type);case 16:return ze("Lazy");case 13:return ze("Suspense");case 19:return ze("SuspenseList");case 0:case 2:case 15:return e=Le(e.type,!1);case 11:return e=Le(e.type.render,!1);case 1:return e=Le(e.type,!0);default:return""}}function We(e){if(null==e)return null;if("function"==typeof e)return e.displayName||e.name||null;if("string"==typeof e)return e;switch(e){case ke:return"Fragment";case we:return"Portal";case Ie:return"Profiler";case Se:return"StrictMode";case $e:return"Suspense";case Ee:return"SuspenseList"}if("object"==typeof e)switch(e.$$typeof){case Ce:return(e.displayName||"Context")+".Consumer";case Ne:return(e._context.displayName||"Context")+".Provider";case Te:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case _e:return null!==(t=e.displayName||null)?t:We(e.type)||"Memo";case Ae:t=e._payload,e=e._init;try{return We(e(t))}catch(xp){}}return null}function Ve(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return We(t);case 8:return t===Se?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"==typeof t)return t.displayName||t.name||null;if("string"==typeof t)return t}return null}function Ue(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function je(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function He(e){e._valueTracker||(e._valueTracker=function(e){var t=je(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&void 0!==n&&"function"==typeof n.get&&"function"==typeof n.set){var a=n.get,i=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return a.call(this)},set:function(e){r=""+e,i.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(e){r=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function Ge(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=je(e)?e.checked?"true":"false":e.value),(e=r)!==n&&(t.setValue(e),!0)}function qe(e){if(void 0===(e=e||("undefined"!=typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(vp){return e.body}}function Ke(e,t){var n=t.checked;return Oe({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Xe(e,t){var n=null==t.defaultValue?"":t.defaultValue,r=null!=t.checked?t.checked:t.defaultChecked;n=Ue(null!=t.value?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function Ye(e,t){null!=(t=t.checked)&&ye(e,"checked",t,!1)}function Qe(e,t){Ye(e,t);var n=Ue(t.value),r=t.type;if(null!=n)"number"===r?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===r||"reset"===r)return void e.removeAttribute("value");t.hasOwnProperty("value")?Je(e,t.type,n):t.hasOwnProperty("defaultValue")&&Je(e,t.type,Ue(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function Ze(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!("submit"!==r&&"reset"!==r||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function Je(e,t,n){"number"===t&&qe(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var et=Array.isArray;function tt(e,t,n,r){if(e=e.options,t){t={};for(var a=0;a<n.length;a++)t["$"+n[a]]=!0;for(n=0;n<e.length;n++)a=t.hasOwnProperty("$"+e[n].value),e[n].selected!==a&&(e[n].selected=a),a&&r&&(e[n].defaultSelected=!0)}else{for(n=""+Ue(n),t=null,a=0;a<e.length;a++){if(e[a].value===n)return e[a].selected=!0,void(r&&(e[a].defaultSelected=!0));null!==t||e[a].disabled||(t=e[a])}null!==t&&(t.selected=!0)}}function nt(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(ae(91));return Oe({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function rt(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(ae(92));if(et(n)){if(1<n.length)throw Error(ae(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:Ue(n)}}function at(e,t){var n=Ue(t.value),r=Ue(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=r&&(e.defaultValue=""+r)}function it(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function ot(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function st(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?ot(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var lt,ut,dt=(ut=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((lt=lt||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=lt.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!=typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,r){MSApp.execUnsafeLocalFunction((function(){return ut(e,t)}))}:ut);function ct(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var pt={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},ht=["Webkit","ms","Moz","O"];function ft(e,t,n){return null==t||"boolean"==typeof t||""===t?"":n||"number"!=typeof t||0===t||pt.hasOwnProperty(e)&&pt[e]?(""+t).trim():t+"px"}function mt(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var r=0===n.indexOf("--"),a=ft(n,t[n],r);"float"===n&&(n="cssFloat"),r?e.setProperty(n,a):e[n]=a}}Object.keys(pt).forEach((function(e){ht.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),pt[t]=pt[e]}))}));var gt=Oe({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function bt(e,t){if(t){if(gt[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(ae(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(ae(60));if("object"!=typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(ae(61))}if(null!=t.style&&"object"!=typeof t.style)throw Error(ae(62))}}function yt(e,t){if(-1===e.indexOf("-"))return"string"==typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var vt=null;function xt(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var wt=null,kt=null,St=null;function It(e){if(e=yi(e)){if("function"!=typeof wt)throw Error(ae(280));var t=e.stateNode;t&&(t=xi(t),wt(e.stateNode,e.type,t))}}function Nt(e){kt?St?St.push(e):St=[e]:kt=e}function Ct(){if(kt){var e=kt,t=St;if(St=kt=null,It(e),t)for(e=0;e<t.length;e++)It(t[e])}}function Tt(e,t){return e(t)}function $t(){}var Et=!1;function _t(e,t,n){if(Et)return e(t,n);Et=!0;try{return Tt(e,t,n)}finally{Et=!1,(null!==kt||null!==St)&&($t(),Ct())}}function At(e,t){var n=e.stateNode;if(null===n)return null;var r=xi(n);if(null===r)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!r;break e;default:e=!1}if(e)return null;if(n&&"function"!=typeof n)throw Error(ae(231,t,typeof n));return n}var Rt=!1;if(ue)try{var Ft={};Object.defineProperty(Ft,"passive",{get:function(){Rt=!0}}),window.addEventListener("test",Ft,Ft),window.removeEventListener("test",Ft,Ft)}catch(ut){Rt=!1}function Dt(e,t,n,r,a,i,o,s,l){var u=Array.prototype.slice.call(arguments,3);try{t.apply(n,u)}catch($p){this.onError($p)}}var Mt=!1,Ot=null,zt=!1,Pt=null,Lt={onError:function(e){Mt=!0,Ot=e}};function Bt(e,t,n,r,a,i,o,s,l){Mt=!1,Ot=null,Dt.apply(Lt,arguments)}function Wt(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!=(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function Vt(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&null!==(e=e.alternate)&&(t=e.memoizedState),null!==t)return t.dehydrated}return null}function Ut(e){if(Wt(e)!==e)throw Error(ae(188))}function jt(e){return e=function(e){var t=e.alternate;if(!t){if(null===(t=Wt(e)))throw Error(ae(188));return t!==e?null:e}for(var n=e,r=t;;){var a=n.return;if(null===a)break;var i=a.alternate;if(null===i){if(null!==(r=a.return)){n=r;continue}break}if(a.child===i.child){for(i=a.child;i;){if(i===n)return Ut(a),e;if(i===r)return Ut(a),t;i=i.sibling}throw Error(ae(188))}if(n.return!==r.return)n=a,r=i;else{for(var o=!1,s=a.child;s;){if(s===n){o=!0,n=a,r=i;break}if(s===r){o=!0,r=a,n=i;break}s=s.sibling}if(!o){for(s=i.child;s;){if(s===n){o=!0,n=i,r=a;break}if(s===r){o=!0,r=i,n=a;break}s=s.sibling}if(!o)throw Error(ae(189))}}if(n.alternate!==r)throw Error(ae(190))}if(3!==n.tag)throw Error(ae(188));return n.stateNode.current===n?e:t}(e),null!==e?Ht(e):null}function Ht(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=Ht(e);if(null!==t)return t;e=e.sibling}return null}var Gt=re.unstable_scheduleCallback,qt=re.unstable_cancelCallback,Kt=re.unstable_shouldYield,Xt=re.unstable_requestPaint,Yt=re.unstable_now,Qt=re.unstable_getCurrentPriorityLevel,Zt=re.unstable_ImmediatePriority,Jt=re.unstable_UserBlockingPriority,en=re.unstable_NormalPriority,tn=re.unstable_LowPriority,nn=re.unstable_IdlePriority,rn=null,an=null,on=Math.clz32?Math.clz32:function(e){return 0===(e>>>=0)?32:31-(sn(e)/ln|0)|0},sn=Math.log,ln=Math.LN2,un=64,dn=4194304;function cn(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function pn(e,t){var n=e.pendingLanes;if(0===n)return 0;var r=0,a=e.suspendedLanes,i=e.pingedLanes,o=268435455&n;if(0!==o){var s=o&~a;0!==s?r=cn(s):0!=(i&=o)&&(r=cn(i))}else 0!=(o=n&~a)?r=cn(o):0!==i&&(r=cn(i));if(0===r)return 0;if(0!==t&&t!==r&&0==(t&a)&&((a=r&-r)>=(i=t&-t)||16===a&&0!=(4194240&i)))return t;if(0!=(4&r)&&(r|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=r;0<t;)a=1<<(n=31-on(t)),r|=e[n],t&=~a;return r}function hn(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function fn(e){return 0!=(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function mn(){var e=un;return 0==(4194240&(un<<=1))&&(un=64),e}function gn(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function bn(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-on(t)]=n}function yn(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-on(n),a=1<<r;a&t|e[r]&t&&(e[r]|=t),n&=~a}}var vn=0;function xn(e){return 1<(e&=-e)?4<e?0!=(268435455&e)?16:536870912:4:1}var wn,kn,Sn,In,Nn,Cn=!1,Tn=[],$n=null,En=null,_n=null,An=new Map,Rn=new Map,Fn=[],Dn="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Mn(e,t){switch(e){case"focusin":case"focusout":$n=null;break;case"dragenter":case"dragleave":En=null;break;case"mouseover":case"mouseout":_n=null;break;case"pointerover":case"pointerout":An.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Rn.delete(t.pointerId)}}function On(e,t,n,r,a,i){return null===e||e.nativeEvent!==i?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:i,targetContainers:[a]},null!==t&&null!==(t=yi(t))&&kn(t),e):(e.eventSystemFlags|=r,t=e.targetContainers,null!==a&&-1===t.indexOf(a)&&t.push(a),e)}function zn(e){var t=bi(e.target);if(null!==t){var n=Wt(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=Vt(n)))return e.blockedOn=t,void Nn(e.priority,(function(){Sn(n)}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function Pn(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Xn(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=yi(n))&&kn(t),e.blockedOn=n,!1;var r=new(n=e.nativeEvent).constructor(n.type,n);vt=r,n.target.dispatchEvent(r),vt=null,t.shift()}return!0}function Ln(e,t,n){Pn(e)&&n.delete(t)}function Bn(){Cn=!1,null!==$n&&Pn($n)&&($n=null),null!==En&&Pn(En)&&(En=null),null!==_n&&Pn(_n)&&(_n=null),An.forEach(Ln),Rn.forEach(Ln)}function Wn(e,t){e.blockedOn===t&&(e.blockedOn=null,Cn||(Cn=!0,re.unstable_scheduleCallback(re.unstable_NormalPriority,Bn)))}function Vn(e){function t(t){return Wn(t,e)}if(0<Tn.length){Wn(Tn[0],e);for(var n=1;n<Tn.length;n++){var r=Tn[n];r.blockedOn===e&&(r.blockedOn=null)}}for(null!==$n&&Wn($n,e),null!==En&&Wn(En,e),null!==_n&&Wn(_n,e),An.forEach(t),Rn.forEach(t),n=0;n<Fn.length;n++)(r=Fn[n]).blockedOn===e&&(r.blockedOn=null);for(;0<Fn.length&&null===(n=Fn[0]).blockedOn;)zn(n),null===n.blockedOn&&Fn.shift()}var Un=ve.ReactCurrentBatchConfig,jn=!0;function Hn(e,t,n,r){var a=vn,i=Un.transition;Un.transition=null;try{vn=1,qn(e,t,n,r)}finally{vn=a,Un.transition=i}}function Gn(e,t,n,r){var a=vn,i=Un.transition;Un.transition=null;try{vn=4,qn(e,t,n,r)}finally{vn=a,Un.transition=i}}function qn(e,t,n,r){if(jn){var a=Xn(e,t,n,r);if(null===a)Ua(e,t,r,Kn,n),Mn(e,r);else if(function(e,t,n,r,a){switch(t){case"focusin":return $n=On($n,e,t,n,r,a),!0;case"dragenter":return En=On(En,e,t,n,r,a),!0;case"mouseover":return _n=On(_n,e,t,n,r,a),!0;case"pointerover":var i=a.pointerId;return An.set(i,On(An.get(i)||null,e,t,n,r,a)),!0;case"gotpointercapture":return i=a.pointerId,Rn.set(i,On(Rn.get(i)||null,e,t,n,r,a)),!0}return!1}(a,e,t,n,r))r.stopPropagation();else if(Mn(e,r),4&t&&-1<Dn.indexOf(e)){for(;null!==a;){var i=yi(a);if(null!==i&&wn(i),null===(i=Xn(e,t,n,r))&&Ua(e,t,r,Kn,n),i===a)break;a=i}null!==a&&r.stopPropagation()}else Ua(e,t,r,null,n)}}var Kn=null;function Xn(e,t,n,r){if(Kn=null,null!==(e=bi(e=xt(r))))if(null===(t=Wt(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=Vt(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Kn=e,null}function Yn(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Qt()){case Zt:return 1;case Jt:return 4;case en:case tn:return 16;case nn:return 536870912;default:return 16}default:return 16}}var Qn=null,Zn=null,Jn=null;function er(){if(Jn)return Jn;var e,t,n=Zn,r=n.length,a="value"in Qn?Qn.value:Qn.textContent,i=a.length;for(e=0;e<r&&n[e]===a[e];e++);var o=r-e;for(t=1;t<=o&&n[r-t]===a[i-t];t++);return Jn=a.slice(e,1<t?1-t:void 0)}function tr(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nr(){return!0}function rr(){return!1}function ar(e){function t(t,n,r,a,i){for(var o in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=a,this.target=i,this.currentTarget=null,e)e.hasOwnProperty(o)&&(t=e[o],this[o]=t?t(a):a[o]);return this.isDefaultPrevented=(null!=a.defaultPrevented?a.defaultPrevented:!1===a.returnValue)?nr:rr,this.isPropagationStopped=rr,this}return Oe(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!=typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nr)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!=typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nr)},persist:function(){},isPersistent:nr}),t}var ir,or,sr,lr={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},ur=ar(lr),dr=Oe({},lr,{view:0,detail:0}),cr=ar(dr),pr=Oe({},dr,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Ir,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==sr&&(sr&&"mousemove"===e.type?(ir=e.screenX-sr.screenX,or=e.screenY-sr.screenY):or=ir=0,sr=e),ir)},movementY:function(e){return"movementY"in e?e.movementY:or}}),hr=ar(pr),fr=ar(Oe({},pr,{dataTransfer:0})),mr=ar(Oe({},dr,{relatedTarget:0})),gr=ar(Oe({},lr,{animationName:0,elapsedTime:0,pseudoElement:0})),br=Oe({},lr,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),yr=ar(br),vr=ar(Oe({},lr,{data:0})),xr={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},wr={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},kr={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Sr(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=kr[e])&&!!t[e]}function Ir(){return Sr}var Nr=Oe({},dr,{key:function(e){if(e.key){var t=xr[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tr(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?wr[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Ir,charCode:function(e){return"keypress"===e.type?tr(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tr(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),Cr=ar(Nr),Tr=ar(Oe({},pr,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),$r=ar(Oe({},dr,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Ir})),Er=ar(Oe({},lr,{propertyName:0,elapsedTime:0,pseudoElement:0})),_r=Oe({},pr,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Ar=ar(_r),Rr=[9,13,27,32],Fr=ue&&"CompositionEvent"in window,Dr=null;ue&&"documentMode"in document&&(Dr=document.documentMode);var Mr=ue&&"TextEvent"in window&&!Dr,Or=ue&&(!Fr||Dr&&8<Dr&&11>=Dr),zr=String.fromCharCode(32),Pr=!1;function Lr(e,t){switch(e){case"keyup":return-1!==Rr.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Br(e){return"object"==typeof(e=e.detail)&&"data"in e?e.data:null}var Wr=!1,Vr={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Ur(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Vr[e.type]:"textarea"===t}function jr(e,t,n,r){Nt(r),0<(t=Ha(t,"onChange")).length&&(n=new ur("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var Hr=null,Gr=null;function qr(e){za(e,0)}function Kr(e){if(Ge(vi(e)))return e}function Xr(e,t){if("change"===e)return t}var Yr=!1;if(ue){var Qr;if(ue){var Zr="oninput"in document;if(!Zr){var Jr=document.createElement("div");Jr.setAttribute("oninput","return;"),Zr="function"==typeof Jr.oninput}Qr=Zr}else Qr=!1;Yr=Qr&&(!document.documentMode||9<document.documentMode)}function ea(){Hr&&(Hr.detachEvent("onpropertychange",ta),Gr=Hr=null)}function ta(e){if("value"===e.propertyName&&Kr(Gr)){var t=[];jr(t,Gr,e,xt(e)),_t(qr,t)}}function na(e,t,n){"focusin"===e?(ea(),Gr=n,(Hr=t).attachEvent("onpropertychange",ta)):"focusout"===e&&ea()}function ra(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Kr(Gr)}function aa(e,t){if("click"===e)return Kr(t)}function ia(e,t){if("input"===e||"change"===e)return Kr(t)}var oa="function"==typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e==1/t)||e!=e&&t!=t};function sa(e,t){if(oa(e,t))return!0;if("object"!=typeof e||null===e||"object"!=typeof t||null===t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var a=n[r];if(!de.call(t,a)||!oa(e[a],t[a]))return!1}return!0}function la(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function ua(e,t){var n,r=la(e);for(e=0;r;){if(3===r.nodeType){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=la(r)}}function da(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?da(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function ca(){for(var e=window,t=qe();t instanceof e.HTMLIFrameElement;){try{var n="string"==typeof t.contentWindow.location.href}catch(wp){n=!1}if(!n)break;t=qe((e=t.contentWindow).document)}return t}function pa(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function ha(e){var t=ca(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&da(n.ownerDocument.documentElement,n)){if(null!==r&&pa(n))if(t=r.start,void 0===(e=r.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var a=n.textContent.length,i=Math.min(r.start,a);r=void 0===r.end?i:Math.min(r.end,a),!e.extend&&i>r&&(a=r,r=i,i=a),a=ua(n,i);var o=ua(n,r);a&&o&&(1!==e.rangeCount||e.anchorNode!==a.node||e.anchorOffset!==a.offset||e.focusNode!==o.node||e.focusOffset!==o.offset)&&((t=t.createRange()).setStart(a.node,a.offset),e.removeAllRanges(),i>r?(e.addRange(t),e.extend(o.node,o.offset)):(t.setEnd(o.node,o.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"==typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var fa=ue&&"documentMode"in document&&11>=document.documentMode,ma=null,ga=null,ba=null,ya=!1;function va(e,t,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;ya||null==ma||ma!==qe(r)||(r="selectionStart"in(r=ma)&&pa(r)?{start:r.selectionStart,end:r.selectionEnd}:{anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},ba&&sa(ba,r)||(ba=r,0<(r=Ha(ga,"onSelect")).length&&(t=new ur("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=ma)))}function xa(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var wa={animationend:xa("Animation","AnimationEnd"),animationiteration:xa("Animation","AnimationIteration"),animationstart:xa("Animation","AnimationStart"),transitionend:xa("Transition","TransitionEnd")},ka={},Sa={};function Ia(e){if(ka[e])return ka[e];if(!wa[e])return e;var t,n=wa[e];for(t in n)if(n.hasOwnProperty(t)&&t in Sa)return ka[e]=n[t];return e}ue&&(Sa=document.createElement("div").style,"AnimationEvent"in window||(delete wa.animationend.animation,delete wa.animationiteration.animation,delete wa.animationstart.animation),"TransitionEvent"in window||delete wa.transitionend.transition);var Na=Ia("animationend"),Ca=Ia("animationiteration"),Ta=Ia("animationstart"),$a=Ia("transitionend"),Ea=new Map,_a="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Aa(e,t){Ea.set(e,t),se(t,[e])}for(var Ra=0;Ra<_a.length;Ra++){var Fa=_a[Ra];Aa(Fa.toLowerCase(),"on"+(Fa[0].toUpperCase()+Fa.slice(1)))}Aa(Na,"onAnimationEnd"),Aa(Ca,"onAnimationIteration"),Aa(Ta,"onAnimationStart"),Aa("dblclick","onDoubleClick"),Aa("focusin","onFocus"),Aa("focusout","onBlur"),Aa($a,"onTransitionEnd"),le("onMouseEnter",["mouseout","mouseover"]),le("onMouseLeave",["mouseout","mouseover"]),le("onPointerEnter",["pointerout","pointerover"]),le("onPointerLeave",["pointerout","pointerover"]),se("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),se("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),se("onBeforeInput",["compositionend","keypress","textInput","paste"]),se("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),se("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),se("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Da="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Ma=new Set("cancel close invalid load scroll toggle".split(" ").concat(Da));function Oa(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,r,a,i,o,s,l){if(Bt.apply(this,arguments),Mt){if(!Mt)throw Error(ae(198));var u=Ot;Mt=!1,Ot=null,zt||(zt=!0,Pt=u)}}(r,t,void 0,e),e.currentTarget=null}function za(e,t){t=0!=(4&t);for(var n=0;n<e.length;n++){var r=e[n],a=r.event;r=r.listeners;e:{var i=void 0;if(t)for(var o=r.length-1;0<=o;o--){var s=r[o],l=s.instance,u=s.currentTarget;if(s=s.listener,l!==i&&a.isPropagationStopped())break e;Oa(a,s,u),i=l}else for(o=0;o<r.length;o++){if(l=(s=r[o]).instance,u=s.currentTarget,s=s.listener,l!==i&&a.isPropagationStopped())break e;Oa(a,s,u),i=l}}}if(zt)throw e=Pt,zt=!1,Pt=null,e}function Pa(e,t){var n=t[fi];void 0===n&&(n=t[fi]=new Set);var r=e+"__bubble";n.has(r)||(Va(t,e,2,!1),n.add(r))}function La(e,t,n){var r=0;t&&(r|=4),Va(n,e,r,t)}var Ba="_reactListening"+Math.random().toString(36).slice(2);function Wa(e){if(!e[Ba]){e[Ba]=!0,ie.forEach((function(t){"selectionchange"!==t&&(Ma.has(t)||La(t,!1,e),La(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Ba]||(t[Ba]=!0,La("selectionchange",!1,t))}}function Va(e,t,n,r){switch(Yn(t)){case 1:var a=Hn;break;case 4:a=Gn;break;default:a=qn}n=a.bind(null,t,n,e),a=void 0,!Rt||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(a=!0),r?void 0!==a?e.addEventListener(t,n,{capture:!0,passive:a}):e.addEventListener(t,n,!0):void 0!==a?e.addEventListener(t,n,{passive:a}):e.addEventListener(t,n,!1)}function Ua(e,t,n,r,a){var i=r;if(0==(1&t)&&0==(2&t)&&null!==r)e:for(;;){if(null===r)return;var o=r.tag;if(3===o||4===o){var s=r.stateNode.containerInfo;if(s===a||8===s.nodeType&&s.parentNode===a)break;if(4===o)for(o=r.return;null!==o;){var l=o.tag;if((3===l||4===l)&&((l=o.stateNode.containerInfo)===a||8===l.nodeType&&l.parentNode===a))return;o=o.return}for(;null!==s;){if(null===(o=bi(s)))return;if(5===(l=o.tag)||6===l){r=i=o;continue e}s=s.parentNode}}r=r.return}_t((function(){var r=i,a=xt(n),o=[];e:{var s=Ea.get(e);if(void 0!==s){var l=ur,u=e;switch(e){case"keypress":if(0===tr(n))break e;case"keydown":case"keyup":l=Cr;break;case"focusin":u="focus",l=mr;break;case"focusout":u="blur",l=mr;break;case"beforeblur":case"afterblur":l=mr;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=hr;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=fr;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=$r;break;case Na:case Ca:case Ta:l=gr;break;case $a:l=Er;break;case"scroll":l=cr;break;case"wheel":l=Ar;break;case"copy":case"cut":case"paste":l=yr;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=Tr}var d=0!=(4&t),c=!d&&"scroll"===e,p=d?null!==s?s+"Capture":null:s;d=[];for(var h,f=r;null!==f;){var m=(h=f).stateNode;if(5===h.tag&&null!==m&&(h=m,null!==p&&null!=(m=At(f,p))&&d.push(ja(f,m,h))),c)break;f=f.return}0<d.length&&(s=new l(s,u,null,n,a),o.push({event:s,listeners:d}))}}if(0==(7&t)){if(l="mouseout"===e||"pointerout"===e,(!(s="mouseover"===e||"pointerover"===e)||n===vt||!(u=n.relatedTarget||n.fromElement)||!bi(u)&&!u[hi])&&(l||s)&&(s=a.window===a?a:(s=a.ownerDocument)?s.defaultView||s.parentWindow:window,l?(l=r,null!==(u=(u=n.relatedTarget||n.toElement)?bi(u):null)&&(u!==(c=Wt(u))||5!==u.tag&&6!==u.tag)&&(u=null)):(l=null,u=r),l!==u)){if(d=hr,m="onMouseLeave",p="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(d=Tr,m="onPointerLeave",p="onPointerEnter",f="pointer"),c=null==l?s:vi(l),h=null==u?s:vi(u),(s=new d(m,f+"leave",l,n,a)).target=c,s.relatedTarget=h,m=null,bi(a)===r&&((d=new d(p,f+"enter",u,n,a)).target=h,d.relatedTarget=c,m=d),c=m,l&&u)e:{for(p=u,f=0,h=d=l;h;h=Ga(h))f++;for(h=0,m=p;m;m=Ga(m))h++;for(;0<f-h;)d=Ga(d),f--;for(;0<h-f;)p=Ga(p),h--;for(;f--;){if(d===p||null!==p&&d===p.alternate)break e;d=Ga(d),p=Ga(p)}d=null}else d=null;null!==l&&qa(o,s,l,d,!1),null!==u&&null!==c&&qa(o,c,u,d,!0)}if("select"===(l=(s=r?vi(r):window).nodeName&&s.nodeName.toLowerCase())||"input"===l&&"file"===s.type)var g=Xr;else if(Ur(s))if(Yr)g=ia;else{g=ra;var b=na}else(l=s.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===s.type||"radio"===s.type)&&(g=aa);switch(g&&(g=g(e,r))?jr(o,g,n,a):(b&&b(e,s,r),"focusout"===e&&(b=s._wrapperState)&&b.controlled&&"number"===s.type&&Je(s,"number",s.value)),b=r?vi(r):window,e){case"focusin":(Ur(b)||"true"===b.contentEditable)&&(ma=b,ga=r,ba=null);break;case"focusout":ba=ga=ma=null;break;case"mousedown":ya=!0;break;case"contextmenu":case"mouseup":case"dragend":ya=!1,va(o,n,a);break;case"selectionchange":if(fa)break;case"keydown":case"keyup":va(o,n,a)}var y;if(Fr)e:{switch(e){case"compositionstart":var v="onCompositionStart";break e;case"compositionend":v="onCompositionEnd";break e;case"compositionupdate":v="onCompositionUpdate";break e}v=void 0}else Wr?Lr(e,n)&&(v="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(v="onCompositionStart");v&&(Or&&"ko"!==n.locale&&(Wr||"onCompositionStart"!==v?"onCompositionEnd"===v&&Wr&&(y=er()):(Zn="value"in(Qn=a)?Qn.value:Qn.textContent,Wr=!0)),0<(b=Ha(r,v)).length&&(v=new vr(v,e,null,n,a),o.push({event:v,listeners:b}),(y||null!==(y=Br(n)))&&(v.data=y))),(y=Mr?function(e,t){switch(e){case"compositionend":return Br(t);case"keypress":return 32!==t.which?null:(Pr=!0,zr);case"textInput":return(e=t.data)===zr&&Pr?null:e;default:return null}}(e,n):function(e,t){if(Wr)return"compositionend"===e||!Fr&&Lr(e,t)?(e=er(),Jn=Zn=Qn=null,Wr=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Or&&"ko"!==t.locale?null:t.data}}(e,n))&&0<(r=Ha(r,"onBeforeInput")).length&&(a=new vr("onBeforeInput","beforeinput",null,n,a),o.push({event:a,listeners:r}),a.data=y)}za(o,t)}))}function ja(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Ha(e,t){for(var n=t+"Capture",r=[];null!==e;){var a=e,i=a.stateNode;5===a.tag&&null!==i&&(a=i,null!=(i=At(e,n))&&r.unshift(ja(e,i,a)),null!=(i=At(e,t))&&r.push(ja(e,i,a))),e=e.return}return r}function Ga(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function qa(e,t,n,r,a){for(var i=t._reactName,o=[];null!==n&&n!==r;){var s=n,l=s.alternate,u=s.stateNode;if(null!==l&&l===r)break;5===s.tag&&null!==u&&(s=u,a?null!=(l=At(n,i))&&o.unshift(ja(n,l,s)):a||null!=(l=At(n,i))&&o.push(ja(n,l,s))),n=n.return}0!==o.length&&e.push({event:t,listeners:o})}var Ka=/\r\n?/g,Xa=/\u0000|\uFFFD/g;function Ya(e){return("string"==typeof e?e:""+e).replace(Ka,"\n").replace(Xa,"")}function Qa(e,t,n){if(t=Ya(t),Ya(e)!==t&&n)throw Error(ae(425))}function Za(){}var Ja=null,ei=null;function ti(e,t){return"textarea"===e||"noscript"===e||"string"==typeof t.children||"number"==typeof t.children||"object"==typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var ni="function"==typeof setTimeout?setTimeout:void 0,ri="function"==typeof clearTimeout?clearTimeout:void 0,ai="function"==typeof Promise?Promise:void 0,ii="function"==typeof queueMicrotask?queueMicrotask:void 0!==ai?function(e){return ai.resolve(null).then(e).catch(oi)}:ni;function oi(e){setTimeout((function(){throw e}))}function si(e,t){var n=t,r=0;do{var a=n.nextSibling;if(e.removeChild(n),a&&8===a.nodeType)if("/$"===(n=a.data)){if(0===r)return e.removeChild(a),void Vn(t);r--}else"$"!==n&&"$?"!==n&&"$!"!==n||r++;n=a}while(n);Vn(t)}function li(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function ui(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var di=Math.random().toString(36).slice(2),ci="__reactFiber$"+di,pi="__reactProps$"+di,hi="__reactContainer$"+di,fi="__reactEvents$"+di,mi="__reactListeners$"+di,gi="__reactHandles$"+di;function bi(e){var t=e[ci];if(t)return t;for(var n=e.parentNode;n;){if(t=n[hi]||n[ci]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=ui(e);null!==e;){if(n=e[ci])return n;e=ui(e)}return t}n=(e=n).parentNode}return null}function yi(e){return!(e=e[ci]||e[hi])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function vi(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(ae(33))}function xi(e){return e[pi]||null}var wi=[],ki=-1;function Si(e){return{current:e}}function Ii(e){0>ki||(e.current=wi[ki],wi[ki]=null,ki--)}function Ni(e,t){ki++,wi[ki]=e.current,e.current=t}var Ci={},Ti=Si(Ci),$i=Si(!1),Ei=Ci;function _i(e,t){var n=e.type.contextTypes;if(!n)return Ci;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var a,i={};for(a in n)i[a]=t[a];return r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=i),i}function Ai(e){return null!=(e=e.childContextTypes)}function Ri(){Ii($i),Ii(Ti)}function Fi(e,t,n){if(Ti.current!==Ci)throw Error(ae(168));Ni(Ti,t),Ni($i,n)}function Di(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,"function"!=typeof r.getChildContext)return n;for(var a in r=r.getChildContext())if(!(a in t))throw Error(ae(108,Ve(e)||"Unknown",a));return Oe({},n,r)}function Mi(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Ci,Ei=Ti.current,Ni(Ti,e),Ni($i,$i.current),!0}function Oi(e,t,n){var r=e.stateNode;if(!r)throw Error(ae(169));n?(e=Di(e,t,Ei),r.__reactInternalMemoizedMergedChildContext=e,Ii($i),Ii(Ti),Ni(Ti,e)):Ii($i),Ni($i,n)}var zi=null,Pi=!1,Li=!1;function Bi(e){null===zi?zi=[e]:zi.push(e)}function Wi(){if(!Li&&null!==zi){Li=!0;var e=0,t=vn;try{var n=zi;for(vn=1;e<n.length;e++){var r=n[e];do{r=r(!0)}while(null!==r)}zi=null,Pi=!1}catch(kp){throw null!==zi&&(zi=zi.slice(e+1)),Gt(Zt,Wi),kp}finally{vn=t,Li=!1}}return null}var Vi=[],Ui=0,ji=null,Hi=0,Gi=[],qi=0,Ki=null,Xi=1,Yi="";function Qi(e,t){Vi[Ui++]=Hi,Vi[Ui++]=ji,ji=e,Hi=t}function Zi(e,t,n){Gi[qi++]=Xi,Gi[qi++]=Yi,Gi[qi++]=Ki,Ki=e;var r=Xi;e=Yi;var a=32-on(r)-1;r&=~(1<<a),n+=1;var i=32-on(t)+a;if(30<i){var o=a-a%5;i=(r&(1<<o)-1).toString(32),r>>=o,a-=o,Xi=1<<32-on(t)+a|n<<a|r,Yi=i+e}else Xi=1<<i|n<<a|r,Yi=e}function Ji(e){null!==e.return&&(Qi(e,1),Zi(e,1,0))}function eo(e){for(;e===ji;)ji=Vi[--Ui],Vi[Ui]=null,Hi=Vi[--Ui],Vi[Ui]=null;for(;e===Ki;)Ki=Gi[--qi],Gi[qi]=null,Yi=Gi[--qi],Gi[qi]=null,Xi=Gi[--qi],Gi[qi]=null}var to=null,no=null,ro=!1,ao=null;function io(e,t){var n=Ad(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function oo(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,to=e,no=li(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,to=e,no=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==Ki?{id:Xi,overflow:Yi}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=Ad(18,null,null,0)).stateNode=t,n.return=e,e.child=n,to=e,no=null,!0);default:return!1}}function so(e){return 0!=(1&e.mode)&&0==(128&e.flags)}function lo(e){if(ro){var t=no;if(t){var n=t;if(!oo(e,t)){if(so(e))throw Error(ae(418));t=li(n.nextSibling);var r=to;t&&oo(e,t)?io(r,n):(e.flags=-4097&e.flags|2,ro=!1,to=e)}}else{if(so(e))throw Error(ae(418));e.flags=-4097&e.flags|2,ro=!1,to=e}}}function uo(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;to=e}function co(e){if(e!==to)return!1;if(!ro)return uo(e),ro=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!ti(e.type,e.memoizedProps)),t&&(t=no)){if(so(e))throw po(),Error(ae(418));for(;t;)io(e,t),t=li(t.nextSibling)}if(uo(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(ae(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){no=li(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}no=null}}else no=to?li(e.stateNode.nextSibling):null;return!0}function po(){for(var e=no;e;)e=li(e.nextSibling)}function ho(){no=to=null,ro=!1}function fo(e){null===ao?ao=[e]:ao.push(e)}var mo=ve.ReactCurrentBatchConfig;function go(e,t){if(e&&e.defaultProps){for(var n in t=Oe({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}var bo=Si(null),yo=null,vo=null,xo=null;function wo(){xo=vo=yo=null}function ko(e){var t=bo.current;Ii(bo),e._currentValue=t}function So(e,t,n){for(;null!==e;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==r&&(r.childLanes|=t)):null!==r&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function Io(e,t){yo=e,xo=vo=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!=(e.lanes&t)&&(vl=!0),e.firstContext=null)}function No(e){var t=e._currentValue;if(xo!==e)if(e={context:e,memoizedValue:t,next:null},null===vo){if(null===yo)throw Error(ae(308));vo=e,yo.dependencies={lanes:0,firstContext:e}}else vo=vo.next=e;return t}var Co=null;function To(e){null===Co?Co=[e]:Co.push(e)}function $o(e,t,n,r){var a=t.interleaved;return null===a?(n.next=n,To(t)):(n.next=a.next,a.next=n),t.interleaved=n,Eo(e,r)}function Eo(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var _o=!1;function Ao(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Ro(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Fo(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function Do(e,t,n){var r=e.updateQueue;if(null===r)return null;if(r=r.shared,0!=(2&$u)){var a=r.pending;return null===a?t.next=t:(t.next=a.next,a.next=t),r.pending=t,Eo(e,n)}return null===(a=r.interleaved)?(t.next=t,To(r)):(t.next=a.next,a.next=t),r.interleaved=t,Eo(e,n)}function Mo(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!=(4194240&n))){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,yn(e,n)}}function Oo(e,t){var n=e.updateQueue,r=e.alternate;if(null!==r&&n===(r=r.updateQueue)){var a=null,i=null;if(null!==(n=n.firstBaseUpdate)){do{var o={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===i?a=i=o:i=i.next=o,n=n.next}while(null!==n);null===i?a=i=t:i=i.next=t}else a=i=t;return n={baseState:r.baseState,firstBaseUpdate:a,lastBaseUpdate:i,shared:r.shared,effects:r.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function zo(e,t,n,r){var a=e.updateQueue;_o=!1;var i=a.firstBaseUpdate,o=a.lastBaseUpdate,s=a.shared.pending;if(null!==s){a.shared.pending=null;var l=s,u=l.next;l.next=null,null===o?i=u:o.next=u,o=l;var d=e.alternate;null!==d&&(s=(d=d.updateQueue).lastBaseUpdate)!==o&&(null===s?d.firstBaseUpdate=u:s.next=u,d.lastBaseUpdate=l)}if(null!==i){var c=a.baseState;for(o=0,d=u=l=null,s=i;;){var p=s.lane,h=s.eventTime;if((r&p)===p){null!==d&&(d=d.next={eventTime:h,lane:0,tag:s.tag,payload:s.payload,callback:s.callback,next:null});e:{var f=e,m=s;switch(p=t,h=n,m.tag){case 1:if("function"==typeof(f=m.payload)){c=f.call(h,c,p);break e}c=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null==(p="function"==typeof(f=m.payload)?f.call(h,c,p):f))break e;c=Oe({},c,p);break e;case 2:_o=!0}}null!==s.callback&&0!==s.lane&&(e.flags|=64,null===(p=a.effects)?a.effects=[s]:p.push(s))}else h={eventTime:h,lane:p,tag:s.tag,payload:s.payload,callback:s.callback,next:null},null===d?(u=d=h,l=c):d=d.next=h,o|=p;if(null===(s=s.next)){if(null===(s=a.shared.pending))break;s=(p=s).next,p.next=null,a.lastBaseUpdate=p,a.shared.pending=null}}if(null===d&&(l=c),a.baseState=l,a.firstBaseUpdate=u,a.lastBaseUpdate=d,null!==(t=a.shared.interleaved)){a=t;do{o|=a.lane,a=a.next}while(a!==t)}else null===i&&(a.shared.lanes=0);Ou|=o,e.lanes=o,e.memoizedState=c}}function Po(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var r=e[t],a=r.callback;if(null!==a){if(r.callback=null,r=n,"function"!=typeof a)throw Error(ae(191,a));a.call(r)}}}var Lo=(new ne.Component).refs;function Bo(e,t,n,r){n=null==(n=n(r,t=e.memoizedState))?t:Oe({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var Wo={isMounted:function(e){return!!(e=e._reactInternals)&&Wt(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=ed(),a=td(e),i=Fo(r,a);i.payload=t,null!=n&&(i.callback=n),null!==(t=Do(e,i,a))&&(nd(t,e,a,r),Mo(t,e,a))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=ed(),a=td(e),i=Fo(r,a);i.tag=1,i.payload=t,null!=n&&(i.callback=n),null!==(t=Do(e,i,a))&&(nd(t,e,a,r),Mo(t,e,a))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=ed(),r=td(e),a=Fo(n,r);a.tag=2,null!=t&&(a.callback=t),null!==(t=Do(e,a,r))&&(nd(t,e,r,n),Mo(t,e,r))}};function Vo(e,t,n,r,a,i,o){return"function"==typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(r,i,o):!(t.prototype&&t.prototype.isPureReactComponent&&sa(n,r)&&sa(a,i))}function Uo(e,t,n){var r=!1,a=Ci,i=t.contextType;return"object"==typeof i&&null!==i?i=No(i):(a=Ai(t)?Ei:Ti.current,i=(r=null!=(r=t.contextTypes))?_i(e,a):Ci),t=new t(n,i),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=Wo,e.stateNode=t,t._reactInternals=e,r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=a,e.__reactInternalMemoizedMaskedChildContext=i),t}function jo(e,t,n,r){e=t.state,"function"==typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,r),"function"==typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&Wo.enqueueReplaceState(t,t.state,null)}function Ho(e,t,n,r){var a=e.stateNode;a.props=n,a.state=e.memoizedState,a.refs=Lo,Ao(e);var i=t.contextType;"object"==typeof i&&null!==i?a.context=No(i):(i=Ai(t)?Ei:Ti.current,a.context=_i(e,i)),a.state=e.memoizedState,"function"==typeof(i=t.getDerivedStateFromProps)&&(Bo(e,t,i,n),a.state=e.memoizedState),"function"==typeof t.getDerivedStateFromProps||"function"==typeof a.getSnapshotBeforeUpdate||"function"!=typeof a.UNSAFE_componentWillMount&&"function"!=typeof a.componentWillMount||(t=a.state,"function"==typeof a.componentWillMount&&a.componentWillMount(),"function"==typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount(),t!==a.state&&Wo.enqueueReplaceState(a,a.state,null),zo(e,n,a,r),a.state=e.memoizedState),"function"==typeof a.componentDidMount&&(e.flags|=4194308)}function Go(e,t,n){if(null!==(e=n.ref)&&"function"!=typeof e&&"object"!=typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(ae(309));var r=n.stateNode}if(!r)throw Error(ae(147,e));var a=r,i=""+e;return null!==t&&null!==t.ref&&"function"==typeof t.ref&&t.ref._stringRef===i?t.ref:(t=function(e){var t=a.refs;t===Lo&&(t=a.refs={}),null===e?delete t[i]:t[i]=e},t._stringRef=i,t)}if("string"!=typeof e)throw Error(ae(284));if(!n._owner)throw Error(ae(290,e))}return e}function qo(e,t){throw e=Object.prototype.toString.call(t),Error(ae(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function Ko(e){return(0,e._init)(e._payload)}function Xo(e){function t(t,n){if(e){var r=t.deletions;null===r?(t.deletions=[n],t.flags|=16):r.push(n)}}function n(n,r){if(!e)return null;for(;null!==r;)t(n,r),r=r.sibling;return null}function r(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function a(e,t){return(e=Fd(e,t)).index=0,e.sibling=null,e}function i(t,n,r){return t.index=r,e?null!==(r=t.alternate)?(r=r.index)<n?(t.flags|=2,n):r:(t.flags|=2,n):(t.flags|=1048576,n)}function o(t){return e&&null===t.alternate&&(t.flags|=2),t}function s(e,t,n,r){return null===t||6!==t.tag?((t=zd(n,e.mode,r)).return=e,t):((t=a(t,n)).return=e,t)}function l(e,t,n,r){var i=n.type;return i===ke?d(e,t,n.props.children,r,n.key):null!==t&&(t.elementType===i||"object"==typeof i&&null!==i&&i.$$typeof===Ae&&Ko(i)===t.type)?((r=a(t,n.props)).ref=Go(e,t,n),r.return=e,r):((r=Dd(n.type,n.key,n.props,null,e.mode,r)).ref=Go(e,t,n),r.return=e,r)}function u(e,t,n,r){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Pd(n,e.mode,r)).return=e,t):((t=a(t,n.children||[])).return=e,t)}function d(e,t,n,r,i){return null===t||7!==t.tag?((t=Md(n,e.mode,r,i)).return=e,t):((t=a(t,n)).return=e,t)}function c(e,t,n){if("string"==typeof t&&""!==t||"number"==typeof t)return(t=zd(""+t,e.mode,n)).return=e,t;if("object"==typeof t&&null!==t){switch(t.$$typeof){case xe:return(n=Dd(t.type,t.key,t.props,null,e.mode,n)).ref=Go(e,null,t),n.return=e,n;case we:return(t=Pd(t,e.mode,n)).return=e,t;case Ae:return c(e,(0,t._init)(t._payload),n)}if(et(t)||De(t))return(t=Md(t,e.mode,n,null)).return=e,t;qo(e,t)}return null}function p(e,t,n,r){var a=null!==t?t.key:null;if("string"==typeof n&&""!==n||"number"==typeof n)return null!==a?null:s(e,t,""+n,r);if("object"==typeof n&&null!==n){switch(n.$$typeof){case xe:return n.key===a?l(e,t,n,r):null;case we:return n.key===a?u(e,t,n,r):null;case Ae:return p(e,t,(a=n._init)(n._payload),r)}if(et(n)||De(n))return null!==a?null:d(e,t,n,r,null);qo(e,n)}return null}function h(e,t,n,r,a){if("string"==typeof r&&""!==r||"number"==typeof r)return s(t,e=e.get(n)||null,""+r,a);if("object"==typeof r&&null!==r){switch(r.$$typeof){case xe:return l(t,e=e.get(null===r.key?n:r.key)||null,r,a);case we:return u(t,e=e.get(null===r.key?n:r.key)||null,r,a);case Ae:return h(e,t,n,(0,r._init)(r._payload),a)}if(et(r)||De(r))return d(t,e=e.get(n)||null,r,a,null);qo(t,r)}return null}function f(a,o,s,l){for(var u=null,d=null,f=o,m=o=0,g=null;null!==f&&m<s.length;m++){f.index>m?(g=f,f=null):g=f.sibling;var b=p(a,f,s[m],l);if(null===b){null===f&&(f=g);break}e&&f&&null===b.alternate&&t(a,f),o=i(b,o,m),null===d?u=b:d.sibling=b,d=b,f=g}if(m===s.length)return n(a,f),ro&&Qi(a,m),u;if(null===f){for(;m<s.length;m++)null!==(f=c(a,s[m],l))&&(o=i(f,o,m),null===d?u=f:d.sibling=f,d=f);return ro&&Qi(a,m),u}for(f=r(a,f);m<s.length;m++)null!==(g=h(f,a,m,s[m],l))&&(e&&null!==g.alternate&&f.delete(null===g.key?m:g.key),o=i(g,o,m),null===d?u=g:d.sibling=g,d=g);return e&&f.forEach((function(e){return t(a,e)})),ro&&Qi(a,m),u}function m(a,o,s,l){var u=De(s);if("function"!=typeof u)throw Error(ae(150));if(null==(s=u.call(s)))throw Error(ae(151));for(var d=u=null,f=o,m=o=0,g=null,b=s.next();null!==f&&!b.done;m++,b=s.next()){f.index>m?(g=f,f=null):g=f.sibling;var y=p(a,f,b.value,l);if(null===y){null===f&&(f=g);break}e&&f&&null===y.alternate&&t(a,f),o=i(y,o,m),null===d?u=y:d.sibling=y,d=y,f=g}if(b.done)return n(a,f),ro&&Qi(a,m),u;if(null===f){for(;!b.done;m++,b=s.next())null!==(b=c(a,b.value,l))&&(o=i(b,o,m),null===d?u=b:d.sibling=b,d=b);return ro&&Qi(a,m),u}for(f=r(a,f);!b.done;m++,b=s.next())null!==(b=h(f,a,m,b.value,l))&&(e&&null!==b.alternate&&f.delete(null===b.key?m:b.key),o=i(b,o,m),null===d?u=b:d.sibling=b,d=b);return e&&f.forEach((function(e){return t(a,e)})),ro&&Qi(a,m),u}return function e(r,i,s,l){if("object"==typeof s&&null!==s&&s.type===ke&&null===s.key&&(s=s.props.children),"object"==typeof s&&null!==s){switch(s.$$typeof){case xe:e:{for(var u=s.key,d=i;null!==d;){if(d.key===u){if((u=s.type)===ke){if(7===d.tag){n(r,d.sibling),(i=a(d,s.props.children)).return=r,r=i;break e}}else if(d.elementType===u||"object"==typeof u&&null!==u&&u.$$typeof===Ae&&Ko(u)===d.type){n(r,d.sibling),(i=a(d,s.props)).ref=Go(r,d,s),i.return=r,r=i;break e}n(r,d);break}t(r,d),d=d.sibling}s.type===ke?((i=Md(s.props.children,r.mode,l,s.key)).return=r,r=i):((l=Dd(s.type,s.key,s.props,null,r.mode,l)).ref=Go(r,i,s),l.return=r,r=l)}return o(r);case we:e:{for(d=s.key;null!==i;){if(i.key===d){if(4===i.tag&&i.stateNode.containerInfo===s.containerInfo&&i.stateNode.implementation===s.implementation){n(r,i.sibling),(i=a(i,s.children||[])).return=r,r=i;break e}n(r,i);break}t(r,i),i=i.sibling}(i=Pd(s,r.mode,l)).return=r,r=i}return o(r);case Ae:return e(r,i,(d=s._init)(s._payload),l)}if(et(s))return f(r,i,s,l);if(De(s))return m(r,i,s,l);qo(r,s)}return"string"==typeof s&&""!==s||"number"==typeof s?(s=""+s,null!==i&&6===i.tag?(n(r,i.sibling),(i=a(i,s)).return=r,r=i):(n(r,i),(i=zd(s,r.mode,l)).return=r,r=i),o(r)):n(r,i)}}var Yo=Xo(!0),Qo=Xo(!1),Zo={},Jo=Si(Zo),es=Si(Zo),ts=Si(Zo);function ns(e){if(e===Zo)throw Error(ae(174));return e}function rs(e,t){switch(Ni(ts,t),Ni(es,e),Ni(Jo,Zo),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:st(null,"");break;default:t=st(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Ii(Jo),Ni(Jo,t)}function as(){Ii(Jo),Ii(es),Ii(ts)}function is(e){ns(ts.current);var t=ns(Jo.current),n=st(t,e.type);t!==n&&(Ni(es,e),Ni(Jo,n))}function os(e){es.current===e&&(Ii(Jo),Ii(es))}var ss=Si(0);function ls(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!=(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var us=[];function ds(){for(var e=0;e<us.length;e++)us[e]._workInProgressVersionPrimary=null;us.length=0}var cs=ve.ReactCurrentDispatcher,ps=ve.ReactCurrentBatchConfig,hs=0,fs=null,ms=null,gs=null,bs=!1,ys=!1,vs=0,xs=0;function ws(){throw Error(ae(321))}function ks(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!oa(e[n],t[n]))return!1;return!0}function Ss(e,t,n,r,a,i){if(hs=i,fs=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,cs.current=null===e||null===e.memoizedState?ol:sl,e=n(r,a),ys){i=0;do{if(ys=!1,vs=0,25<=i)throw Error(ae(301));i+=1,gs=ms=null,t.updateQueue=null,cs.current=ll,e=n(r,a)}while(ys)}if(cs.current=il,t=null!==ms&&null!==ms.next,hs=0,gs=ms=fs=null,bs=!1,t)throw Error(ae(300));return e}function Is(){var e=0!==vs;return vs=0,e}function Ns(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===gs?fs.memoizedState=gs=e:gs=gs.next=e,gs}function Cs(){if(null===ms){var e=fs.alternate;e=null!==e?e.memoizedState:null}else e=ms.next;var t=null===gs?fs.memoizedState:gs.next;if(null!==t)gs=t,ms=e;else{if(null===e)throw Error(ae(310));e={memoizedState:(ms=e).memoizedState,baseState:ms.baseState,baseQueue:ms.baseQueue,queue:ms.queue,next:null},null===gs?fs.memoizedState=gs=e:gs=gs.next=e}return gs}function Ts(e,t){return"function"==typeof t?t(e):t}function $s(e){var t=Cs(),n=t.queue;if(null===n)throw Error(ae(311));n.lastRenderedReducer=e;var r=ms,a=r.baseQueue,i=n.pending;if(null!==i){if(null!==a){var o=a.next;a.next=i.next,i.next=o}r.baseQueue=a=i,n.pending=null}if(null!==a){i=a.next,r=r.baseState;var s=o=null,l=null,u=i;do{var d=u.lane;if((hs&d)===d)null!==l&&(l=l.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),r=u.hasEagerState?u.eagerState:e(r,u.action);else{var c={lane:d,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};null===l?(s=l=c,o=r):l=l.next=c,fs.lanes|=d,Ou|=d}u=u.next}while(null!==u&&u!==i);null===l?o=r:l.next=s,oa(r,t.memoizedState)||(vl=!0),t.memoizedState=r,t.baseState=o,t.baseQueue=l,n.lastRenderedState=r}if(null!==(e=n.interleaved)){a=e;do{i=a.lane,fs.lanes|=i,Ou|=i,a=a.next}while(a!==e)}else null===a&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function Es(e){var t=Cs(),n=t.queue;if(null===n)throw Error(ae(311));n.lastRenderedReducer=e;var r=n.dispatch,a=n.pending,i=t.memoizedState;if(null!==a){n.pending=null;var o=a=a.next;do{i=e(i,o.action),o=o.next}while(o!==a);oa(i,t.memoizedState)||(vl=!0),t.memoizedState=i,null===t.baseQueue&&(t.baseState=i),n.lastRenderedState=i}return[i,r]}function _s(){}function As(e,t){var n=fs,r=Cs(),a=t(),i=!oa(r.memoizedState,a);if(i&&(r.memoizedState=a,vl=!0),r=r.queue,Us(Ds.bind(null,n,r,e),[e]),r.getSnapshot!==t||i||null!==gs&&1&gs.memoizedState.tag){if(n.flags|=2048,Ps(9,Fs.bind(null,n,r,a,t),void 0,null),null===Eu)throw Error(ae(349));0!=(30&hs)||Rs(n,t,a)}return a}function Rs(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=fs.updateQueue)?(t={lastEffect:null,stores:null},fs.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Fs(e,t,n,r){t.value=n,t.getSnapshot=r,Ms(t)&&Os(e)}function Ds(e,t,n){return n((function(){Ms(t)&&Os(e)}))}function Ms(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!oa(e,n)}catch(wp){return!0}}function Os(e){var t=Eo(e,1);null!==t&&nd(t,e,1,-1)}function zs(e){var t=Ns();return"function"==typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Ts,lastRenderedState:e},t.queue=e,e=e.dispatch=tl.bind(null,fs,e),[t.memoizedState,e]}function Ps(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},null===(t=fs.updateQueue)?(t={lastEffect:null,stores:null},fs.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function Ls(){return Cs().memoizedState}function Bs(e,t,n,r){var a=Ns();fs.flags|=e,a.memoizedState=Ps(1|t,n,void 0,void 0===r?null:r)}function Ws(e,t,n,r){var a=Cs();r=void 0===r?null:r;var i=void 0;if(null!==ms){var o=ms.memoizedState;if(i=o.destroy,null!==r&&ks(r,o.deps))return void(a.memoizedState=Ps(t,n,i,r))}fs.flags|=e,a.memoizedState=Ps(1|t,n,i,r)}function Vs(e,t){return Bs(8390656,8,e,t)}function Us(e,t){return Ws(2048,8,e,t)}function js(e,t){return Ws(4,2,e,t)}function Hs(e,t){return Ws(4,4,e,t)}function Gs(e,t){return"function"==typeof t?(e=e(),t(e),function(){t(null)}):null!=t?(e=e(),t.current=e,function(){t.current=null}):void 0}function qs(e,t,n){return n=null!=n?n.concat([e]):null,Ws(4,4,Gs.bind(null,t,e),n)}function Ks(){}function Xs(e,t){var n=Cs();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&ks(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Ys(e,t){var n=Cs();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&ks(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function Qs(e,t,n){return 0==(21&hs)?(e.baseState&&(e.baseState=!1,vl=!0),e.memoizedState=n):(oa(n,t)||(n=mn(),fs.lanes|=n,Ou|=n,e.baseState=!0),t)}function Zs(e,t){var n=vn;vn=0!==n&&4>n?n:4,e(!0);var r=ps.transition;ps.transition={};try{e(!1),t()}finally{vn=n,ps.transition=r}}function Js(){return Cs().memoizedState}function el(e,t,n){var r=td(e);n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},nl(e)?rl(t,n):null!==(n=$o(e,t,n,r))&&(nd(n,e,r,ed()),al(n,t,r))}function tl(e,t,n){var r=td(e),a={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(nl(e))rl(t,a);else{var i=e.alternate;if(0===e.lanes&&(null===i||0===i.lanes)&&null!==(i=t.lastRenderedReducer))try{var o=t.lastRenderedState,s=i(o,n);if(a.hasEagerState=!0,a.eagerState=s,oa(s,o)){var l=t.interleaved;return null===l?(a.next=a,To(t)):(a.next=l.next,l.next=a),void(t.interleaved=a)}}catch(Tp){}null!==(n=$o(e,t,a,r))&&(nd(n,e,r,a=ed()),al(n,t,r))}}function nl(e){var t=e.alternate;return e===fs||null!==t&&t===fs}function rl(e,t){ys=bs=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function al(e,t,n){if(0!=(4194240&n)){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,yn(e,n)}}var il={readContext:No,useCallback:ws,useContext:ws,useEffect:ws,useImperativeHandle:ws,useInsertionEffect:ws,useLayoutEffect:ws,useMemo:ws,useReducer:ws,useRef:ws,useState:ws,useDebugValue:ws,useDeferredValue:ws,useTransition:ws,useMutableSource:ws,useSyncExternalStore:ws,useId:ws,unstable_isNewReconciler:!1},ol={readContext:No,useCallback:function(e,t){return Ns().memoizedState=[e,void 0===t?null:t],e},useContext:No,useEffect:Vs,useImperativeHandle:function(e,t,n){return n=null!=n?n.concat([e]):null,Bs(4194308,4,Gs.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Bs(4194308,4,e,t)},useInsertionEffect:function(e,t){return Bs(4,2,e,t)},useMemo:function(e,t){var n=Ns();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=Ns();return t=void 0!==n?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=el.bind(null,fs,e),[r.memoizedState,e]},useRef:function(e){return e={current:e},Ns().memoizedState=e},useState:zs,useDebugValue:Ks,useDeferredValue:function(e){return Ns().memoizedState=e},useTransition:function(){var e=zs(!1),t=e[0];return e=Zs.bind(null,e[1]),Ns().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=fs,a=Ns();if(ro){if(void 0===n)throw Error(ae(407));n=n()}else{if(n=t(),null===Eu)throw Error(ae(349));0!=(30&hs)||Rs(r,t,n)}a.memoizedState=n;var i={value:n,getSnapshot:t};return a.queue=i,Vs(Ds.bind(null,r,i,e),[e]),r.flags|=2048,Ps(9,Fs.bind(null,r,i,n,t),void 0,null),n},useId:function(){var e=Ns(),t=Eu.identifierPrefix;if(ro){var n=Yi;t=":"+t+"R"+(n=(Xi&~(1<<32-on(Xi)-1)).toString(32)+n),0<(n=vs++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=xs++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},sl={readContext:No,useCallback:Xs,useContext:No,useEffect:Us,useImperativeHandle:qs,useInsertionEffect:js,useLayoutEffect:Hs,useMemo:Ys,useReducer:$s,useRef:Ls,useState:function(){return $s(Ts)},useDebugValue:Ks,useDeferredValue:function(e){return Qs(Cs(),ms.memoizedState,e)},useTransition:function(){return[$s(Ts)[0],Cs().memoizedState]},useMutableSource:_s,useSyncExternalStore:As,useId:Js,unstable_isNewReconciler:!1},ll={readContext:No,useCallback:Xs,useContext:No,useEffect:Us,useImperativeHandle:qs,useInsertionEffect:js,useLayoutEffect:Hs,useMemo:Ys,useReducer:Es,useRef:Ls,useState:function(){return Es(Ts)},useDebugValue:Ks,useDeferredValue:function(e){var t=Cs();return null===ms?t.memoizedState=e:Qs(t,ms.memoizedState,e)},useTransition:function(){return[Es(Ts)[0],Cs().memoizedState]},useMutableSource:_s,useSyncExternalStore:As,useId:Js,unstable_isNewReconciler:!1};function ul(e,t){try{var n="",r=t;do{n+=Be(r),r=r.return}while(r);var a=n}catch(Sp){a="\nError generating stack: "+Sp.message+"\n"+Sp.stack}return{value:e,source:t,stack:a,digest:null}}function dl(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}function cl(e,t){try{console.error(t.value)}catch(xp){setTimeout((function(){throw xp}))}}var pl="function"==typeof WeakMap?WeakMap:Map;function hl(e,t,n){(n=Fo(-1,n)).tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){ju||(ju=!0,Hu=r),cl(0,t)},n}function fl(e,t,n){(n=Fo(-1,n)).tag=3;var r=e.type.getDerivedStateFromError;if("function"==typeof r){var a=t.value;n.payload=function(){return r(a)},n.callback=function(){cl(0,t)}}var i=e.stateNode;return null!==i&&"function"==typeof i.componentDidCatch&&(n.callback=function(){cl(0,t),"function"!=typeof r&&(null===Gu?Gu=new Set([this]):Gu.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function ml(e,t,n){var r=e.pingCache;if(null===r){r=e.pingCache=new pl;var a=new Set;r.set(t,a)}else void 0===(a=r.get(t))&&(a=new Set,r.set(t,a));a.has(n)||(a.add(n),e=Nd.bind(null,e,t,n),t.then(e,e))}function gl(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function bl(e,t,n,r,a){return 0==(1&e.mode)?(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=Fo(-1,1)).tag=2,Do(n,t,1))),n.lanes|=1),e):(e.flags|=65536,e.lanes=a,e)}var yl=ve.ReactCurrentOwner,vl=!1;function xl(e,t,n,r){t.child=null===e?Qo(t,null,n,r):Yo(t,e.child,n,r)}function wl(e,t,n,r,a){n=n.render;var i=t.ref;return Io(t,a),r=Ss(e,t,n,r,i,a),n=Is(),null===e||vl?(ro&&n&&Ji(t),t.flags|=1,xl(e,t,r,a),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,jl(e,t,a))}function kl(e,t,n,r,a){if(null===e){var i=n.type;return"function"!=typeof i||Rd(i)||void 0!==i.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Dd(n.type,null,r,t,t.mode,a)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=i,Sl(e,t,i,r,a))}if(i=e.child,0==(e.lanes&a)){var o=i.memoizedProps;if((n=null!==(n=n.compare)?n:sa)(o,r)&&e.ref===t.ref)return jl(e,t,a)}return t.flags|=1,(e=Fd(i,r)).ref=t.ref,e.return=t,t.child=e}function Sl(e,t,n,r,a){if(null!==e){var i=e.memoizedProps;if(sa(i,r)&&e.ref===t.ref){if(vl=!1,t.pendingProps=r=i,0==(e.lanes&a))return t.lanes=e.lanes,jl(e,t,a);0!=(131072&e.flags)&&(vl=!0)}}return Cl(e,t,n,r,a)}function Il(e,t,n){var r=t.pendingProps,a=r.children,i=null!==e?e.memoizedState:null;if("hidden"===r.mode)if(0==(1&t.mode))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Ni(Fu,Ru),Ru|=n;else{if(0==(1073741824&n))return e=null!==i?i.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Ni(Fu,Ru),Ru|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=null!==i?i.baseLanes:n,Ni(Fu,Ru),Ru|=r}else null!==i?(r=i.baseLanes|n,t.memoizedState=null):r=n,Ni(Fu,Ru),Ru|=r;return xl(e,t,a,n),t.child}function Nl(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function Cl(e,t,n,r,a){var i=Ai(n)?Ei:Ti.current;return i=_i(t,i),Io(t,a),n=Ss(e,t,n,r,i,a),r=Is(),null===e||vl?(ro&&r&&Ji(t),t.flags|=1,xl(e,t,n,a),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,jl(e,t,a))}function Tl(e,t,n,r,a){if(Ai(n)){var i=!0;Mi(t)}else i=!1;if(Io(t,a),null===t.stateNode)Ul(e,t),Uo(t,n,r),Ho(t,n,r,a),r=!0;else if(null===e){var o=t.stateNode,s=t.memoizedProps;o.props=s;var l=o.context,u=n.contextType;u="object"==typeof u&&null!==u?No(u):_i(t,u=Ai(n)?Ei:Ti.current);var d=n.getDerivedStateFromProps,c="function"==typeof d||"function"==typeof o.getSnapshotBeforeUpdate;c||"function"!=typeof o.UNSAFE_componentWillReceiveProps&&"function"!=typeof o.componentWillReceiveProps||(s!==r||l!==u)&&jo(t,o,r,u),_o=!1;var p=t.memoizedState;o.state=p,zo(t,r,o,a),l=t.memoizedState,s!==r||p!==l||$i.current||_o?("function"==typeof d&&(Bo(t,n,d,r),l=t.memoizedState),(s=_o||Vo(t,n,s,r,p,l,u))?(c||"function"!=typeof o.UNSAFE_componentWillMount&&"function"!=typeof o.componentWillMount||("function"==typeof o.componentWillMount&&o.componentWillMount(),"function"==typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount()),"function"==typeof o.componentDidMount&&(t.flags|=4194308)):("function"==typeof o.componentDidMount&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=l),o.props=r,o.state=l,o.context=u,r=s):("function"==typeof o.componentDidMount&&(t.flags|=4194308),r=!1)}else{o=t.stateNode,Ro(e,t),s=t.memoizedProps,u=t.type===t.elementType?s:go(t.type,s),o.props=u,c=t.pendingProps,p=o.context,l="object"==typeof(l=n.contextType)&&null!==l?No(l):_i(t,l=Ai(n)?Ei:Ti.current);var h=n.getDerivedStateFromProps;(d="function"==typeof h||"function"==typeof o.getSnapshotBeforeUpdate)||"function"!=typeof o.UNSAFE_componentWillReceiveProps&&"function"!=typeof o.componentWillReceiveProps||(s!==c||p!==l)&&jo(t,o,r,l),_o=!1,p=t.memoizedState,o.state=p,zo(t,r,o,a);var f=t.memoizedState;s!==c||p!==f||$i.current||_o?("function"==typeof h&&(Bo(t,n,h,r),f=t.memoizedState),(u=_o||Vo(t,n,u,r,p,f,l)||!1)?(d||"function"!=typeof o.UNSAFE_componentWillUpdate&&"function"!=typeof o.componentWillUpdate||("function"==typeof o.componentWillUpdate&&o.componentWillUpdate(r,f,l),"function"==typeof o.UNSAFE_componentWillUpdate&&o.UNSAFE_componentWillUpdate(r,f,l)),"function"==typeof o.componentDidUpdate&&(t.flags|=4),"function"==typeof o.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!=typeof o.componentDidUpdate||s===e.memoizedProps&&p===e.memoizedState||(t.flags|=4),"function"!=typeof o.getSnapshotBeforeUpdate||s===e.memoizedProps&&p===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=f),o.props=r,o.state=f,o.context=l,r=u):("function"!=typeof o.componentDidUpdate||s===e.memoizedProps&&p===e.memoizedState||(t.flags|=4),"function"!=typeof o.getSnapshotBeforeUpdate||s===e.memoizedProps&&p===e.memoizedState||(t.flags|=1024),r=!1)}return $l(e,t,n,r,i,a)}function $l(e,t,n,r,a,i){Nl(e,t);var o=0!=(128&t.flags);if(!r&&!o)return a&&Oi(t,n,!1),jl(e,t,i);r=t.stateNode,yl.current=t;var s=o&&"function"!=typeof n.getDerivedStateFromError?null:r.render();return t.flags|=1,null!==e&&o?(t.child=Yo(t,e.child,null,i),t.child=Yo(t,null,s,i)):xl(e,t,s,i),t.memoizedState=r.state,a&&Oi(t,n,!0),t.child}function El(e){var t=e.stateNode;t.pendingContext?Fi(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Fi(0,t.context,!1),rs(e,t.containerInfo)}function _l(e,t,n,r,a){return ho(),fo(a),t.flags|=256,xl(e,t,n,r),t.child}var Al,Rl,Fl,Dl,Ml={dehydrated:null,treeContext:null,retryLane:0};function Ol(e){return{baseLanes:e,cachePool:null,transitions:null}}function zl(e,t,n){var r,a=t.pendingProps,i=ss.current,o=!1,s=0!=(128&t.flags);if((r=s)||(r=(null===e||null!==e.memoizedState)&&0!=(2&i)),r?(o=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(i|=1),Ni(ss,1&i),null===e)return lo(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(0==(1&t.mode)?t.lanes=1:"$!"===e.data?t.lanes=8:t.lanes=1073741824,null):(s=a.children,e=a.fallback,o?(a=t.mode,o=t.child,s={mode:"hidden",children:s},0==(1&a)&&null!==o?(o.childLanes=0,o.pendingProps=s):o=Od(s,a,0,null),e=Md(e,a,n,null),o.return=t,e.return=t,o.sibling=e,t.child=o,t.child.memoizedState=Ol(n),t.memoizedState=Ml,e):Pl(t,s));if(null!==(i=e.memoizedState)&&null!==(r=i.dehydrated))return function(e,t,n,r,a,i,o){if(n)return 256&t.flags?(t.flags&=-257,Ll(e,t,o,r=dl(Error(ae(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(i=r.fallback,a=t.mode,r=Od({mode:"visible",children:r.children},a,0,null),(i=Md(i,a,o,null)).flags|=2,r.return=t,i.return=t,r.sibling=i,t.child=r,0!=(1&t.mode)&&Yo(t,e.child,null,o),t.child.memoizedState=Ol(o),t.memoizedState=Ml,i);if(0==(1&t.mode))return Ll(e,t,o,null);if("$!"===a.data){if(r=a.nextSibling&&a.nextSibling.dataset)var s=r.dgst;return r=s,Ll(e,t,o,r=dl(i=Error(ae(419)),r,void 0))}if(s=0!=(o&e.childLanes),vl||s){if(null!==(r=Eu)){switch(o&-o){case 4:a=2;break;case 16:a=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:a=32;break;case 536870912:a=268435456;break;default:a=0}0!==(a=0!=(a&(r.suspendedLanes|o))?0:a)&&a!==i.retryLane&&(i.retryLane=a,Eo(e,a),nd(r,e,a,-1))}return md(),Ll(e,t,o,r=dl(Error(ae(421))))}return"$?"===a.data?(t.flags|=128,t.child=e.child,t=Td.bind(null,e),a._reactRetry=t,null):(e=i.treeContext,no=li(a.nextSibling),to=t,ro=!0,ao=null,null!==e&&(Gi[qi++]=Xi,Gi[qi++]=Yi,Gi[qi++]=Ki,Xi=e.id,Yi=e.overflow,Ki=t),(t=Pl(t,r.children)).flags|=4096,t)}(e,t,s,a,r,i,n);if(o){o=a.fallback,s=t.mode,r=(i=e.child).sibling;var l={mode:"hidden",children:a.children};return 0==(1&s)&&t.child!==i?((a=t.child).childLanes=0,a.pendingProps=l,t.deletions=null):(a=Fd(i,l)).subtreeFlags=14680064&i.subtreeFlags,null!==r?o=Fd(r,o):(o=Md(o,s,n,null)).flags|=2,o.return=t,a.return=t,a.sibling=o,t.child=a,a=o,o=t.child,s=null===(s=e.child.memoizedState)?Ol(n):{baseLanes:s.baseLanes|n,cachePool:null,transitions:s.transitions},o.memoizedState=s,o.childLanes=e.childLanes&~n,t.memoizedState=Ml,a}return e=(o=e.child).sibling,a=Fd(o,{mode:"visible",children:a.children}),0==(1&t.mode)&&(a.lanes=n),a.return=t,a.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=a,t.memoizedState=null,a}function Pl(e,t){return(t=Od({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function Ll(e,t,n,r){return null!==r&&fo(r),Yo(t,e.child,null,n),(e=Pl(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Bl(e,t,n){e.lanes|=t;var r=e.alternate;null!==r&&(r.lanes|=t),So(e.return,t,n)}function Wl(e,t,n,r,a){var i=e.memoizedState;null===i?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:a}:(i.isBackwards=t,i.rendering=null,i.renderingStartTime=0,i.last=r,i.tail=n,i.tailMode=a)}function Vl(e,t,n){var r=t.pendingProps,a=r.revealOrder,i=r.tail;if(xl(e,t,r.children,n),0!=(2&(r=ss.current)))r=1&r|2,t.flags|=128;else{if(null!==e&&0!=(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Bl(e,n,t);else if(19===e.tag)Bl(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(Ni(ss,r),0==(1&t.mode))t.memoizedState=null;else switch(a){case"forwards":for(n=t.child,a=null;null!==n;)null!==(e=n.alternate)&&null===ls(e)&&(a=n),n=n.sibling;null===(n=a)?(a=t.child,t.child=null):(a=n.sibling,n.sibling=null),Wl(t,!1,a,n,i);break;case"backwards":for(n=null,a=t.child,t.child=null;null!==a;){if(null!==(e=a.alternate)&&null===ls(e)){t.child=a;break}e=a.sibling,a.sibling=n,n=a,a=e}Wl(t,!0,n,null,i);break;case"together":Wl(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Ul(e,t){0==(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function jl(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Ou|=t.lanes,0==(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(ae(153));if(null!==t.child){for(n=Fd(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Fd(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Hl(e,t){if(!ro)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?t||null===e.tail?e.tail=null:e.tail.sibling=null:r.sibling=null}}function Gl(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,r=0;if(t)for(var a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=14680064&a.subtreeFlags,r|=14680064&a.flags,a.return=e,a=a.sibling;else for(a=e.child;null!==a;)n|=a.lanes|a.childLanes,r|=a.subtreeFlags,r|=a.flags,a.return=e,a=a.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function ql(e,t,n){var r=t.pendingProps;switch(eo(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Gl(t),null;case 1:case 17:return Ai(t.type)&&Ri(),Gl(t),null;case 3:return r=t.stateNode,as(),Ii($i),Ii(Ti),ds(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==e&&null!==e.child||(co(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&0==(256&t.flags)||(t.flags|=1024,null!==ao&&(od(ao),ao=null))),Rl(e,t),Gl(t),null;case 5:os(t);var a=ns(ts.current);if(n=t.type,null!==e&&null!=t.stateNode)Fl(e,t,n,r,a),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(null===t.stateNode)throw Error(ae(166));return Gl(t),null}if(e=ns(Jo.current),co(t)){r=t.stateNode,n=t.type;var i=t.memoizedProps;switch(r[ci]=t,r[pi]=i,e=0!=(1&t.mode),n){case"dialog":Pa("cancel",r),Pa("close",r);break;case"iframe":case"object":case"embed":Pa("load",r);break;case"video":case"audio":for(a=0;a<Da.length;a++)Pa(Da[a],r);break;case"source":Pa("error",r);break;case"img":case"image":case"link":Pa("error",r),Pa("load",r);break;case"details":Pa("toggle",r);break;case"input":Xe(r,i),Pa("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!i.multiple},Pa("invalid",r);break;case"textarea":rt(r,i),Pa("invalid",r)}for(var o in bt(n,i),a=null,i)if(i.hasOwnProperty(o)){var s=i[o];"children"===o?"string"==typeof s?r.textContent!==s&&(!0!==i.suppressHydrationWarning&&Qa(r.textContent,s,e),a=["children",s]):"number"==typeof s&&r.textContent!==""+s&&(!0!==i.suppressHydrationWarning&&Qa(r.textContent,s,e),a=["children",""+s]):oe.hasOwnProperty(o)&&null!=s&&"onScroll"===o&&Pa("scroll",r)}switch(n){case"input":He(r),Ze(r,i,!0);break;case"textarea":He(r),it(r);break;case"select":case"option":break;default:"function"==typeof i.onClick&&(r.onclick=Za)}r=a,t.updateQueue=r,null!==r&&(t.flags|=4)}else{o=9===a.nodeType?a:a.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=ot(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=o.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"==typeof r.is?e=o.createElement(n,{is:r.is}):(e=o.createElement(n),"select"===n&&(o=e,r.multiple?o.multiple=!0:r.size&&(o.size=r.size))):e=o.createElementNS(e,n),e[ci]=t,e[pi]=r,Al(e,t,!1,!1),t.stateNode=e;e:{switch(o=yt(n,r),n){case"dialog":Pa("cancel",e),Pa("close",e),a=r;break;case"iframe":case"object":case"embed":Pa("load",e),a=r;break;case"video":case"audio":for(a=0;a<Da.length;a++)Pa(Da[a],e);a=r;break;case"source":Pa("error",e),a=r;break;case"img":case"image":case"link":Pa("error",e),Pa("load",e),a=r;break;case"details":Pa("toggle",e),a=r;break;case"input":Xe(e,r),a=Ke(e,r),Pa("invalid",e);break;case"option":default:a=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},a=Oe({},r,{value:void 0}),Pa("invalid",e);break;case"textarea":rt(e,r),a=nt(e,r),Pa("invalid",e)}for(i in bt(n,a),s=a)if(s.hasOwnProperty(i)){var l=s[i];"style"===i?mt(e,l):"dangerouslySetInnerHTML"===i?null!=(l=l?l.__html:void 0)&&dt(e,l):"children"===i?"string"==typeof l?("textarea"!==n||""!==l)&&ct(e,l):"number"==typeof l&&ct(e,""+l):"suppressContentEditableWarning"!==i&&"suppressHydrationWarning"!==i&&"autoFocus"!==i&&(oe.hasOwnProperty(i)?null!=l&&"onScroll"===i&&Pa("scroll",e):null!=l&&ye(e,i,l,o))}switch(n){case"input":He(e),Ze(e,r,!1);break;case"textarea":He(e),it(e);break;case"option":null!=r.value&&e.setAttribute("value",""+Ue(r.value));break;case"select":e.multiple=!!r.multiple,null!=(i=r.value)?tt(e,!!r.multiple,i,!1):null!=r.defaultValue&&tt(e,!!r.multiple,r.defaultValue,!0);break;default:"function"==typeof a.onClick&&(e.onclick=Za)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return Gl(t),null;case 6:if(e&&null!=t.stateNode)Dl(e,t,e.memoizedProps,r);else{if("string"!=typeof r&&null===t.stateNode)throw Error(ae(166));if(n=ns(ts.current),ns(Jo.current),co(t)){if(r=t.stateNode,n=t.memoizedProps,r[ci]=t,(i=r.nodeValue!==n)&&null!==(e=to))switch(e.tag){case 3:Qa(r.nodeValue,n,0!=(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Qa(r.nodeValue,n,0!=(1&e.mode))}i&&(t.flags|=4)}else(r=(9===n.nodeType?n:n.ownerDocument).createTextNode(r))[ci]=t,t.stateNode=r}return Gl(t),null;case 13:if(Ii(ss),r=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(ro&&null!==no&&0!=(1&t.mode)&&0==(128&t.flags))po(),ho(),t.flags|=98560,i=!1;else if(i=co(t),null!==r&&null!==r.dehydrated){if(null===e){if(!i)throw Error(ae(318));if(!(i=null!==(i=t.memoizedState)?i.dehydrated:null))throw Error(ae(317));i[ci]=t}else ho(),0==(128&t.flags)&&(t.memoizedState=null),t.flags|=4;Gl(t),i=!1}else null!==ao&&(od(ao),ao=null),i=!0;if(!i)return 65536&t.flags?t:null}return 0!=(128&t.flags)?(t.lanes=n,t):((r=null!==r)!=(null!==e&&null!==e.memoizedState)&&r&&(t.child.flags|=8192,0!=(1&t.mode)&&(null===e||0!=(1&ss.current)?0===Du&&(Du=3):md())),null!==t.updateQueue&&(t.flags|=4),Gl(t),null);case 4:return as(),Rl(e,t),null===e&&Wa(t.stateNode.containerInfo),Gl(t),null;case 10:return ko(t.type._context),Gl(t),null;case 19:if(Ii(ss),null===(i=t.memoizedState))return Gl(t),null;if(r=0!=(128&t.flags),null===(o=i.rendering))if(r)Hl(i,!1);else{if(0!==Du||null!==e&&0!=(128&e.flags))for(e=t.child;null!==e;){if(null!==(o=ls(e))){for(t.flags|=128,Hl(i,!1),null!==(r=o.updateQueue)&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;null!==n;)e=r,(i=n).flags&=14680066,null===(o=i.alternate)?(i.childLanes=0,i.lanes=e,i.child=null,i.subtreeFlags=0,i.memoizedProps=null,i.memoizedState=null,i.updateQueue=null,i.dependencies=null,i.stateNode=null):(i.childLanes=o.childLanes,i.lanes=o.lanes,i.child=o.child,i.subtreeFlags=0,i.deletions=null,i.memoizedProps=o.memoizedProps,i.memoizedState=o.memoizedState,i.updateQueue=o.updateQueue,i.type=o.type,e=o.dependencies,i.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Ni(ss,1&ss.current|2),t.child}e=e.sibling}null!==i.tail&&Yt()>Vu&&(t.flags|=128,r=!0,Hl(i,!1),t.lanes=4194304)}else{if(!r)if(null!==(e=ls(o))){if(t.flags|=128,r=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),Hl(i,!0),null===i.tail&&"hidden"===i.tailMode&&!o.alternate&&!ro)return Gl(t),null}else 2*Yt()-i.renderingStartTime>Vu&&1073741824!==n&&(t.flags|=128,r=!0,Hl(i,!1),t.lanes=4194304);i.isBackwards?(o.sibling=t.child,t.child=o):(null!==(n=i.last)?n.sibling=o:t.child=o,i.last=o)}return null!==i.tail?(t=i.tail,i.rendering=t,i.tail=t.sibling,i.renderingStartTime=Yt(),t.sibling=null,n=ss.current,Ni(ss,r?1&n|2:1&n),t):(Gl(t),null);case 22:case 23:return cd(),r=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==r&&(t.flags|=8192),r&&0!=(1&t.mode)?0!=(1073741824&Ru)&&(Gl(t),6&t.subtreeFlags&&(t.flags|=8192)):Gl(t),null;case 24:case 25:return null}throw Error(ae(156,t.tag))}function Kl(e,t){switch(eo(t),t.tag){case 1:return Ai(t.type)&&Ri(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return as(),Ii($i),Ii(Ti),ds(),0!=(65536&(e=t.flags))&&0==(128&e)?(t.flags=-65537&e|128,t):null;case 5:return os(t),null;case 13:if(Ii(ss),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(ae(340));ho()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return Ii(ss),null;case 4:return as(),null;case 10:return ko(t.type._context),null;case 22:case 23:return cd(),null;default:return null}}Al=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Rl=function(){},Fl=function(e,t,n,r){var a=e.memoizedProps;if(a!==r){e=t.stateNode,ns(Jo.current);var i,o=null;switch(n){case"input":a=Ke(e,a),r=Ke(e,r),o=[];break;case"select":a=Oe({},a,{value:void 0}),r=Oe({},r,{value:void 0}),o=[];break;case"textarea":a=nt(e,a),r=nt(e,r),o=[];break;default:"function"!=typeof a.onClick&&"function"==typeof r.onClick&&(e.onclick=Za)}for(u in bt(n,r),n=null,a)if(!r.hasOwnProperty(u)&&a.hasOwnProperty(u)&&null!=a[u])if("style"===u){var s=a[u];for(i in s)s.hasOwnProperty(i)&&(n||(n={}),n[i]="")}else"dangerouslySetInnerHTML"!==u&&"children"!==u&&"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&"autoFocus"!==u&&(oe.hasOwnProperty(u)?o||(o=[]):(o=o||[]).push(u,null));for(u in r){var l=r[u];if(s=null!=a?a[u]:void 0,r.hasOwnProperty(u)&&l!==s&&(null!=l||null!=s))if("style"===u)if(s){for(i in s)!s.hasOwnProperty(i)||l&&l.hasOwnProperty(i)||(n||(n={}),n[i]="");for(i in l)l.hasOwnProperty(i)&&s[i]!==l[i]&&(n||(n={}),n[i]=l[i])}else n||(o||(o=[]),o.push(u,n)),n=l;else"dangerouslySetInnerHTML"===u?(l=l?l.__html:void 0,s=s?s.__html:void 0,null!=l&&s!==l&&(o=o||[]).push(u,l)):"children"===u?"string"!=typeof l&&"number"!=typeof l||(o=o||[]).push(u,""+l):"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&(oe.hasOwnProperty(u)?(null!=l&&"onScroll"===u&&Pa("scroll",e),o||s===l||(o=[])):(o=o||[]).push(u,l))}n&&(o=o||[]).push("style",n);var u=o;(t.updateQueue=u)&&(t.flags|=4)}},Dl=function(e,t,n,r){n!==r&&(t.flags|=4)};var Xl=!1,Yl=!1,Ql="function"==typeof WeakSet?WeakSet:Set,Zl=null;function Jl(e,t){var n=e.ref;if(null!==n)if("function"==typeof n)try{n(null)}catch(wp){Id(e,t,wp)}else n.current=null}function eu(e,t,n){try{n()}catch(wp){Id(e,t,wp)}}var tu=!1;function nu(e,t,n){var r=t.updateQueue;if(null!==(r=null!==r?r.lastEffect:null)){var a=r=r.next;do{if((a.tag&e)===e){var i=a.destroy;a.destroy=void 0,void 0!==i&&eu(t,n,i)}a=a.next}while(a!==r)}}function ru(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function au(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"==typeof t?t(e):t.current=e}}function iu(e){var t=e.alternate;null!==t&&(e.alternate=null,iu(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&null!==(t=e.stateNode)&&(delete t[ci],delete t[pi],delete t[fi],delete t[mi],delete t[gi]),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function ou(e){return 5===e.tag||3===e.tag||4===e.tag}function su(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||ou(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function lu(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!=(n=n._reactRootContainer)||null!==t.onclick||(t.onclick=Za));else if(4!==r&&null!==(e=e.child))for(lu(e,t,n),e=e.sibling;null!==e;)lu(e,t,n),e=e.sibling}function uu(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==r&&null!==(e=e.child))for(uu(e,t,n),e=e.sibling;null!==e;)uu(e,t,n),e=e.sibling}var du=null,cu=!1;function pu(e,t,n){for(n=n.child;null!==n;)hu(e,t,n),n=n.sibling}function hu(e,t,n){if(an&&"function"==typeof an.onCommitFiberUnmount)try{an.onCommitFiberUnmount(rn,n)}catch(hy){}switch(n.tag){case 5:Yl||Jl(n,t);case 6:var r=du,a=cu;du=null,pu(e,t,n),cu=a,null!==(du=r)&&(cu?(e=du,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):du.removeChild(n.stateNode));break;case 18:null!==du&&(cu?(e=du,n=n.stateNode,8===e.nodeType?si(e.parentNode,n):1===e.nodeType&&si(e,n),Vn(e)):si(du,n.stateNode));break;case 4:r=du,a=cu,du=n.stateNode.containerInfo,cu=!0,pu(e,t,n),du=r,cu=a;break;case 0:case 11:case 14:case 15:if(!Yl&&null!==(r=n.updateQueue)&&null!==(r=r.lastEffect)){a=r=r.next;do{var i=a,o=i.destroy;i=i.tag,void 0!==o&&(0!=(2&i)||0!=(4&i))&&eu(n,t,o),a=a.next}while(a!==r)}pu(e,t,n);break;case 1:if(!Yl&&(Jl(n,t),"function"==typeof(r=n.stateNode).componentWillUnmount))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(hy){Id(n,t,hy)}pu(e,t,n);break;case 21:pu(e,t,n);break;case 22:1&n.mode?(Yl=(r=Yl)||null!==n.memoizedState,pu(e,t,n),Yl=r):pu(e,t,n);break;default:pu(e,t,n)}}function fu(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Ql),t.forEach((function(t){var r=$d.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))}))}}function mu(e,t){var n=t.deletions;if(null!==n)for(var r=0;r<n.length;r++){var a=n[r];try{var i=e,o=t,s=o;e:for(;null!==s;){switch(s.tag){case 5:du=s.stateNode,cu=!1;break e;case 3:case 4:du=s.stateNode.containerInfo,cu=!0;break e}s=s.return}if(null===du)throw Error(ae(160));hu(i,o,a),du=null,cu=!1;var l=a.alternate;null!==l&&(l.return=null),a.return=null}catch(Tp){Id(a,t,Tp)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)gu(t,e),t=t.sibling}function gu(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(mu(t,e),bu(e),4&r){try{nu(3,e,e.return),ru(3,e)}catch(Fp){Id(e,e.return,Fp)}try{nu(5,e,e.return)}catch(Fp){Id(e,e.return,Fp)}}break;case 1:mu(t,e),bu(e),512&r&&null!==n&&Jl(n,n.return);break;case 5:if(mu(t,e),bu(e),512&r&&null!==n&&Jl(n,n.return),32&e.flags){var a=e.stateNode;try{ct(a,"")}catch(Fp){Id(e,e.return,Fp)}}if(4&r&&null!=(a=e.stateNode)){var i=e.memoizedProps,o=null!==n?n.memoizedProps:i,s=e.type,l=e.updateQueue;if(e.updateQueue=null,null!==l)try{"input"===s&&"radio"===i.type&&null!=i.name&&Ye(a,i),yt(s,o);var u=yt(s,i);for(o=0;o<l.length;o+=2){var d=l[o],c=l[o+1];"style"===d?mt(a,c):"dangerouslySetInnerHTML"===d?dt(a,c):"children"===d?ct(a,c):ye(a,d,c,u)}switch(s){case"input":Qe(a,i);break;case"textarea":at(a,i);break;case"select":var p=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!i.multiple;var h=i.value;null!=h?tt(a,!!i.multiple,h,!1):p!==!!i.multiple&&(null!=i.defaultValue?tt(a,!!i.multiple,i.defaultValue,!0):tt(a,!!i.multiple,i.multiple?[]:"",!1))}a[pi]=i}catch(Fp){Id(e,e.return,Fp)}}break;case 6:if(mu(t,e),bu(e),4&r){if(null===e.stateNode)throw Error(ae(162));a=e.stateNode,i=e.memoizedProps;try{a.nodeValue=i}catch(Fp){Id(e,e.return,Fp)}}break;case 3:if(mu(t,e),bu(e),4&r&&null!==n&&n.memoizedState.isDehydrated)try{Vn(t.containerInfo)}catch(Fp){Id(e,e.return,Fp)}break;case 4:default:mu(t,e),bu(e);break;case 13:mu(t,e),bu(e),8192&(a=e.child).flags&&(i=null!==a.memoizedState,a.stateNode.isHidden=i,!i||null!==a.alternate&&null!==a.alternate.memoizedState||(Wu=Yt())),4&r&&fu(e);break;case 22:if(d=null!==n&&null!==n.memoizedState,1&e.mode?(Yl=(u=Yl)||d,mu(t,e),Yl=u):mu(t,e),bu(e),8192&r){if(u=null!==e.memoizedState,(e.stateNode.isHidden=u)&&!d&&0!=(1&e.mode))for(Zl=e,d=e.child;null!==d;){for(c=Zl=d;null!==Zl;){switch(h=(p=Zl).child,p.tag){case 0:case 11:case 14:case 15:nu(4,p,p.return);break;case 1:Jl(p,p.return);var f=p.stateNode;if("function"==typeof f.componentWillUnmount){r=p,n=p.return;try{t=r,f.props=t.memoizedProps,f.state=t.memoizedState,f.componentWillUnmount()}catch(Fp){Id(r,n,Fp)}}break;case 5:Jl(p,p.return);break;case 22:if(null!==p.memoizedState){wu(c);continue}}null!==h?(h.return=p,Zl=h):wu(c)}d=d.sibling}e:for(d=null,c=e;;){if(5===c.tag){if(null===d){d=c;try{a=c.stateNode,u?"function"==typeof(i=a.style).setProperty?i.setProperty("display","none","important"):i.display="none":(s=c.stateNode,o=null!=(l=c.memoizedProps.style)&&l.hasOwnProperty("display")?l.display:null,s.style.display=ft("display",o))}catch(Fp){Id(e,e.return,Fp)}}}else if(6===c.tag){if(null===d)try{c.stateNode.nodeValue=u?"":c.memoizedProps}catch(Fp){Id(e,e.return,Fp)}}else if((22!==c.tag&&23!==c.tag||null===c.memoizedState||c===e)&&null!==c.child){c.child.return=c,c=c.child;continue}if(c===e)break e;for(;null===c.sibling;){if(null===c.return||c.return===e)break e;d===c&&(d=null),c=c.return}d===c&&(d=null),c.sibling.return=c.return,c=c.sibling}}break;case 19:mu(t,e),bu(e),4&r&&fu(e);case 21:}}function bu(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(ou(n)){var r=n;break e}n=n.return}throw Error(ae(160))}switch(r.tag){case 5:var a=r.stateNode;32&r.flags&&(ct(a,""),r.flags&=-33),uu(e,su(e),a);break;case 3:case 4:var i=r.stateNode.containerInfo;lu(e,su(e),i);break;default:throw Error(ae(161))}}catch(aK){Id(e,e.return,aK)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function yu(e,t,n){Zl=e,vu(e)}function vu(e,t,n){for(var r=0!=(1&e.mode);null!==Zl;){var a=Zl,i=a.child;if(22===a.tag&&r){var o=null!==a.memoizedState||Xl;if(!o){var s=a.alternate,l=null!==s&&null!==s.memoizedState||Yl;s=Xl;var u=Yl;if(Xl=o,(Yl=l)&&!u)for(Zl=a;null!==Zl;)l=(o=Zl).child,22===o.tag&&null!==o.memoizedState?ku(a):null!==l?(l.return=o,Zl=l):ku(a);for(;null!==i;)Zl=i,vu(i),i=i.sibling;Zl=a,Xl=s,Yl=u}xu(e)}else 0!=(8772&a.subtreeFlags)&&null!==i?(i.return=a,Zl=i):xu(e)}}function xu(e){for(;null!==Zl;){var t=Zl;if(0!=(8772&t.flags)){var n=t.alternate;try{if(0!=(8772&t.flags))switch(t.tag){case 0:case 11:case 15:Yl||ru(5,t);break;case 1:var r=t.stateNode;if(4&t.flags&&!Yl)if(null===n)r.componentDidMount();else{var a=t.elementType===t.type?n.memoizedProps:go(t.type,n.memoizedProps);r.componentDidUpdate(a,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var i=t.updateQueue;null!==i&&Po(t,i,r);break;case 3:var o=t.updateQueue;if(null!==o){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Po(t,o,n)}break;case 5:var s=t.stateNode;if(null===n&&4&t.flags){n=s;var l=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var u=t.alternate;if(null!==u){var d=u.memoizedState;if(null!==d){var c=d.dehydrated;null!==c&&Vn(c)}}}break;default:throw Error(ae(163))}Yl||512&t.flags&&au(t)}catch(Rp){Id(t,t.return,Rp)}}if(t===e){Zl=null;break}if(null!==(n=t.sibling)){n.return=t.return,Zl=n;break}Zl=t.return}}function wu(e){for(;null!==Zl;){var t=Zl;if(t===e){Zl=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Zl=n;break}Zl=t.return}}function ku(e){for(;null!==Zl;){var t=Zl;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{ru(4,t)}catch(aK){Id(t,n,aK)}break;case 1:var r=t.stateNode;if("function"==typeof r.componentDidMount){var a=t.return;try{r.componentDidMount()}catch(aK){Id(t,a,aK)}}var i=t.return;try{au(t)}catch(aK){Id(t,i,aK)}break;case 5:var o=t.return;try{au(t)}catch(aK){Id(t,o,aK)}}}catch(aK){Id(t,t.return,aK)}if(t===e){Zl=null;break}var s=t.sibling;if(null!==s){s.return=t.return,Zl=s;break}Zl=t.return}}var Su,Iu=Math.ceil,Nu=ve.ReactCurrentDispatcher,Cu=ve.ReactCurrentOwner,Tu=ve.ReactCurrentBatchConfig,$u=0,Eu=null,_u=null,Au=0,Ru=0,Fu=Si(0),Du=0,Mu=null,Ou=0,zu=0,Pu=0,Lu=null,Bu=null,Wu=0,Vu=1/0,Uu=null,ju=!1,Hu=null,Gu=null,qu=!1,Ku=null,Xu=0,Yu=0,Qu=null,Zu=-1,Ju=0;function ed(){return 0!=(6&$u)?Yt():-1!==Zu?Zu:Zu=Yt()}function td(e){return 0==(1&e.mode)?1:0!=(2&$u)&&0!==Au?Au&-Au:null!==mo.transition?(0===Ju&&(Ju=mn()),Ju):0!==(e=vn)?e:e=void 0===(e=window.event)?16:Yn(e.type)}function nd(e,t,n,r){if(50<Yu)throw Yu=0,Qu=null,Error(ae(185));bn(e,n,r),0!=(2&$u)&&e===Eu||(e===Eu&&(0==(2&$u)&&(zu|=n),4===Du&&sd(e,Au)),rd(e,r),1===n&&0===$u&&0==(1&t.mode)&&(Vu=Yt()+500,Pi&&Wi()))}function rd(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,a=e.expirationTimes,i=e.pendingLanes;0<i;){var o=31-on(i),s=1<<o,l=a[o];-1===l?0!=(s&n)&&0==(s&r)||(a[o]=hn(s,t)):l<=t&&(e.expiredLanes|=s),i&=~s}}(e,t);var r=pn(e,e===Eu?Au:0);if(0===r)null!==n&&qt(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(null!=n&&qt(n),1===t)0===e.tag?function(e){Pi=!0,Bi(e)}(ld.bind(null,e)):Bi(ld.bind(null,e)),ii((function(){0==(6&$u)&&Wi()})),n=null;else{switch(xn(r)){case 1:n=Zt;break;case 4:n=Jt;break;case 16:default:n=en;break;case 536870912:n=nn}n=Ed(n,ad.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function ad(e,t){if(Zu=-1,Ju=0,0!=(6&$u))throw Error(ae(327));var n=e.callbackNode;if(kd()&&e.callbackNode!==n)return null;var r=pn(e,e===Eu?Au:0);if(0===r)return null;if(0!=(30&r)||0!=(r&e.expiredLanes)||t)t=gd(e,r);else{t=r;var a=$u;$u|=2;var i=fd();for(Eu===e&&Au===t||(Uu=null,Vu=Yt()+500,pd(e,t));;)try{yd();break}catch(hy){hd(e,hy)}wo(),Nu.current=i,$u=a,null!==_u?t=0:(Eu=null,Au=0,t=Du)}if(0!==t){if(2===t&&0!==(a=fn(e))&&(r=a,t=id(e,a)),1===t)throw n=Mu,pd(e,0),sd(e,r),rd(e,Yt()),n;if(6===t)sd(e,r);else{if(a=e.current.alternate,0==(30&r)&&!function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var r=0;r<n.length;r++){var a=n[r],i=a.getSnapshot;a=a.value;try{if(!oa(i(),a))return!1}catch(o){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(a)&&(2===(t=gd(e,r))&&0!==(i=fn(e))&&(r=i,t=id(e,i)),1===t))throw n=Mu,pd(e,0),sd(e,r),rd(e,Yt()),n;switch(e.finishedWork=a,e.finishedLanes=r,t){case 0:case 1:throw Error(ae(345));case 2:case 5:wd(e,Bu,Uu);break;case 3:if(sd(e,r),(130023424&r)===r&&10<(t=Wu+500-Yt())){if(0!==pn(e,0))break;if(((a=e.suspendedLanes)&r)!==r){ed(),e.pingedLanes|=e.suspendedLanes&a;break}e.timeoutHandle=ni(wd.bind(null,e,Bu,Uu),t);break}wd(e,Bu,Uu);break;case 4:if(sd(e,r),(4194240&r)===r)break;for(t=e.eventTimes,a=-1;0<r;){var o=31-on(r);i=1<<o,(o=t[o])>a&&(a=o),r&=~i}if(r=a,10<(r=(120>(r=Yt()-r)?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*Iu(r/1960))-r)){e.timeoutHandle=ni(wd.bind(null,e,Bu,Uu),r);break}wd(e,Bu,Uu);break;default:throw Error(ae(329))}}}return rd(e,Yt()),e.callbackNode===n?ad.bind(null,e):null}function id(e,t){var n=Lu;return e.current.memoizedState.isDehydrated&&(pd(e,t).flags|=256),2!==(e=gd(e,t))&&(t=Bu,Bu=n,null!==t&&od(t)),e}function od(e){null===Bu?Bu=e:Bu.push.apply(Bu,e)}function sd(e,t){for(t&=~Pu,t&=~zu,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-on(t),r=1<<n;e[n]=-1,t&=~r}}function ld(e){if(0!=(6&$u))throw Error(ae(327));kd();var t=pn(e,0);if(0==(1&t))return rd(e,Yt()),null;var n=gd(e,t);if(0!==e.tag&&2===n){var r=fn(e);0!==r&&(t=r,n=id(e,r))}if(1===n)throw n=Mu,pd(e,0),sd(e,t),rd(e,Yt()),n;if(6===n)throw Error(ae(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,wd(e,Bu,Uu),rd(e,Yt()),null}function ud(e,t){var n=$u;$u|=1;try{return e(t)}finally{0===($u=n)&&(Vu=Yt()+500,Pi&&Wi())}}function dd(e){null!==Ku&&0===Ku.tag&&0==(6&$u)&&kd();var t=$u;$u|=1;var n=Tu.transition,r=vn;try{if(Tu.transition=null,vn=1,e)return e()}finally{vn=r,Tu.transition=n,0==(6&($u=t))&&Wi()}}function cd(){Ru=Fu.current,Ii(Fu)}function pd(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,ri(n)),null!==_u)for(n=_u.return;null!==n;){var r=n;switch(eo(r),r.tag){case 1:null!=(r=r.type.childContextTypes)&&Ri();break;case 3:as(),Ii($i),Ii(Ti),ds();break;case 5:os(r);break;case 4:as();break;case 13:case 19:Ii(ss);break;case 10:ko(r.type._context);break;case 22:case 23:cd()}n=n.return}if(Eu=e,_u=e=Fd(e.current,null),Au=Ru=t,Du=0,Mu=null,Pu=zu=Ou=0,Bu=Lu=null,null!==Co){for(t=0;t<Co.length;t++)if(null!==(r=(n=Co[t]).interleaved)){n.interleaved=null;var a=r.next,i=n.pending;if(null!==i){var o=i.next;i.next=a,r.next=o}n.pending=r}Co=null}return e}function hd(e,t){for(;;){var n=_u;try{if(wo(),cs.current=il,bs){for(var r=fs.memoizedState;null!==r;){var a=r.queue;null!==a&&(a.pending=null),r=r.next}bs=!1}if(hs=0,gs=ms=fs=null,ys=!1,vs=0,Cu.current=null,null===n||null===n.return){Du=1,Mu=t,_u=null;break}e:{var i=e,o=n.return,s=n,l=t;if(t=Au,s.flags|=32768,null!==l&&"object"==typeof l&&"function"==typeof l.then){var u=l,d=s,c=d.tag;if(0==(1&d.mode)&&(0===c||11===c||15===c)){var p=d.alternate;p?(d.updateQueue=p.updateQueue,d.memoizedState=p.memoizedState,d.lanes=p.lanes):(d.updateQueue=null,d.memoizedState=null)}var h=gl(o);if(null!==h){h.flags&=-257,bl(h,o,s,0,t),1&h.mode&&ml(i,u,t),l=u;var f=(t=h).updateQueue;if(null===f){var m=new Set;m.add(l),t.updateQueue=m}else f.add(l);break e}if(0==(1&t)){ml(i,u,t),md();break e}l=Error(ae(426))}else if(ro&&1&s.mode){var g=gl(o);if(null!==g){0==(65536&g.flags)&&(g.flags|=256),bl(g,o,s,0,t),fo(ul(l,s));break e}}i=l=ul(l,s),4!==Du&&(Du=2),null===Lu?Lu=[i]:Lu.push(i),i=o;do{switch(i.tag){case 3:i.flags|=65536,t&=-t,i.lanes|=t,Oo(i,hl(0,l,t));break e;case 1:s=l;var b=i.type,y=i.stateNode;if(0==(128&i.flags)&&("function"==typeof b.getDerivedStateFromError||null!==y&&"function"==typeof y.componentDidCatch&&(null===Gu||!Gu.has(y)))){i.flags|=65536,t&=-t,i.lanes|=t,Oo(i,fl(i,s,t));break e}}i=i.return}while(null!==i)}xd(n)}catch(aR){t=aR,_u===n&&null!==n&&(_u=n=n.return);continue}break}}function fd(){var e=Nu.current;return Nu.current=il,null===e?il:e}function md(){0!==Du&&3!==Du&&2!==Du||(Du=4),null===Eu||0==(268435455&Ou)&&0==(268435455&zu)||sd(Eu,Au)}function gd(e,t){var n=$u;$u|=2;var r=fd();for(Eu===e&&Au===t||(Uu=null,pd(e,t));;)try{bd();break}catch(kp){hd(e,kp)}if(wo(),$u=n,Nu.current=r,null!==_u)throw Error(ae(261));return Eu=null,Au=0,Du}function bd(){for(;null!==_u;)vd(_u)}function yd(){for(;null!==_u&&!Kt();)vd(_u)}function vd(e){var t=Su(e.alternate,e,Ru);e.memoizedProps=e.pendingProps,null===t?xd(e):_u=t,Cu.current=null}function xd(e){var t=e;do{var n=t.alternate;if(e=t.return,0==(32768&t.flags)){if(null!==(n=ql(n,t,Ru)))return void(_u=n)}else{if(null!==(n=Kl(n,t)))return n.flags&=32767,void(_u=n);if(null===e)return Du=6,void(_u=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}if(null!==(t=t.sibling))return void(_u=t);_u=t=e}while(null!==t);0===Du&&(Du=5)}function wd(e,t,n){var r=vn,a=Tu.transition;try{Tu.transition=null,vn=1,function(e,t,n,r){do{kd()}while(null!==Ku);if(0!=(6&$u))throw Error(ae(327));n=e.finishedWork;var a=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(ae(177));e.callbackNode=null,e.callbackPriority=0;var i=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var a=31-on(n),i=1<<a;t[a]=0,r[a]=-1,e[a]=-1,n&=~i}}(e,i),e===Eu&&(_u=Eu=null,Au=0),0==(2064&n.subtreeFlags)&&0==(2064&n.flags)||qu||(qu=!0,Ed(en,(function(){return kd(),null}))),i=0!=(15990&n.flags),0!=(15990&n.subtreeFlags)||i){i=Tu.transition,Tu.transition=null;var o=vn;vn=1;var s=$u;$u|=4,Cu.current=null,function(e,t){if(Ja=jn,pa(e=ca())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var r=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var a=r.anchorOffset,i=r.focusNode;r=r.focusOffset;try{n.nodeType,i.nodeType}catch(I){n=null;break e}var o=0,s=-1,l=-1,u=0,d=0,c=e,p=null;t:for(;;){for(var h;c!==n||0!==a&&3!==c.nodeType||(s=o+a),c!==i||0!==r&&3!==c.nodeType||(l=o+r),3===c.nodeType&&(o+=c.nodeValue.length),null!==(h=c.firstChild);)p=c,c=h;for(;;){if(c===e)break t;if(p===n&&++u===a&&(s=o),p===i&&++d===r&&(l=o),null!==(h=c.nextSibling))break;p=(c=p).parentNode}c=h}n=-1===s||-1===l?null:{start:s,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(ei={focusedElem:e,selectionRange:n},jn=!1,Zl=t;null!==Zl;)if(e=(t=Zl).child,0!=(1028&t.subtreeFlags)&&null!==e)e.return=t,Zl=e;else for(;null!==Zl;){t=Zl;try{var f=t.alternate;if(0!=(1024&t.flags))switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==f){var m=f.memoizedProps,g=f.memoizedState,b=t.stateNode,y=b.getSnapshotBeforeUpdate(t.elementType===t.type?m:go(t.type,m),g);b.__reactInternalSnapshotBeforeUpdate=y}break;case 3:var v=t.stateNode.containerInfo;1===v.nodeType?v.textContent="":9===v.nodeType&&v.documentElement&&v.removeChild(v.documentElement);break;default:throw Error(ae(163))}}catch(I){Id(t,t.return,I)}if(null!==(e=t.sibling)){e.return=t.return,Zl=e;break}Zl=t.return}f=tu,tu=!1}(e,n),gu(n,e),ha(ei),jn=!!Ja,ei=Ja=null,e.current=n,yu(n),Xt(),$u=s,vn=o,Tu.transition=i}else e.current=n;if(qu&&(qu=!1,Ku=e,Xu=a),0===(i=e.pendingLanes)&&(Gu=null),function(e){if(an&&"function"==typeof an.onCommitFiberRoot)try{an.onCommitFiberRoot(rn,e,void 0,128==(128&e.current.flags))}catch(t){}}(n.stateNode),rd(e,Yt()),null!==t)for(r=e.onRecoverableError,n=0;n<t.length;n++)a=t[n],r(a.value,{componentStack:a.stack,digest:a.digest});if(ju)throw ju=!1,e=Hu,Hu=null,e;0!=(1&Xu)&&0!==e.tag&&kd(),0!=(1&(i=e.pendingLanes))?e===Qu?Yu++:(Yu=0,Qu=e):Yu=0,Wi()}(e,t,n,r)}finally{Tu.transition=a,vn=r}return null}function kd(){if(null!==Ku){var e=xn(Xu),t=Tu.transition,n=vn;try{if(Tu.transition=null,vn=16>e?16:e,null===Ku)var r=!1;else{if(e=Ku,Ku=null,Xu=0,0!=(6&$u))throw Error(ae(331));var a=$u;for($u|=4,Zl=e.current;null!==Zl;){var i=Zl,o=i.child;if(0!=(16&Zl.flags)){var s=i.deletions;if(null!==s){for(var l=0;l<s.length;l++){var u=s[l];for(Zl=u;null!==Zl;){var d=Zl;switch(d.tag){case 0:case 11:case 15:nu(8,d,i)}var c=d.child;if(null!==c)c.return=d,Zl=c;else for(;null!==Zl;){var p=(d=Zl).sibling,h=d.return;if(iu(d),d===u){Zl=null;break}if(null!==p){p.return=h,Zl=p;break}Zl=h}}}var f=i.alternate;if(null!==f){var m=f.child;if(null!==m){f.child=null;do{var g=m.sibling;m.sibling=null,m=g}while(null!==m)}}Zl=i}}if(0!=(2064&i.subtreeFlags)&&null!==o)o.return=i,Zl=o;else e:for(;null!==Zl;){if(0!=(2048&(i=Zl).flags))switch(i.tag){case 0:case 11:case 15:nu(9,i,i.return)}var b=i.sibling;if(null!==b){b.return=i.return,Zl=b;break e}Zl=i.return}}var y=e.current;for(Zl=y;null!==Zl;){var v=(o=Zl).child;if(0!=(2064&o.subtreeFlags)&&null!==v)v.return=o,Zl=v;else e:for(o=y;null!==Zl;){if(0!=(2048&(s=Zl).flags))try{switch(s.tag){case 0:case 11:case 15:ru(9,s)}}catch(aR){Id(s,s.return,aR)}if(s===o){Zl=null;break e}var x=s.sibling;if(null!==x){x.return=s.return,Zl=x;break e}Zl=s.return}}if($u=a,Wi(),an&&"function"==typeof an.onPostCommitFiberRoot)try{an.onPostCommitFiberRoot(rn,e)}catch(aR){}r=!0}return r}finally{vn=n,Tu.transition=t}}return!1}function Sd(e,t,n){e=Do(e,t=hl(0,t=ul(n,t),1),1),t=ed(),null!==e&&(bn(e,1,t),rd(e,t))}function Id(e,t,n){if(3===e.tag)Sd(e,e,n);else for(;null!==t;){if(3===t.tag){Sd(t,e,n);break}if(1===t.tag){var r=t.stateNode;if("function"==typeof t.type.getDerivedStateFromError||"function"==typeof r.componentDidCatch&&(null===Gu||!Gu.has(r))){t=Do(t,e=fl(t,e=ul(n,e),1),1),e=ed(),null!==t&&(bn(t,1,e),rd(t,e));break}}t=t.return}}function Nd(e,t,n){var r=e.pingCache;null!==r&&r.delete(t),t=ed(),e.pingedLanes|=e.suspendedLanes&n,Eu===e&&(Au&n)===n&&(4===Du||3===Du&&(130023424&Au)===Au&&500>Yt()-Wu?pd(e,0):Pu|=n),rd(e,t)}function Cd(e,t){0===t&&(0==(1&e.mode)?t=1:(t=dn,0==(130023424&(dn<<=1))&&(dn=4194304)));var n=ed();null!==(e=Eo(e,t))&&(bn(e,t,n),rd(e,n))}function Td(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),Cd(e,n)}function $d(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,a=e.memoizedState;null!==a&&(n=a.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(ae(314))}null!==r&&r.delete(t),Cd(e,n)}function Ed(e,t){return Gt(e,t)}function _d(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ad(e,t,n,r){return new _d(e,t,n,r)}function Rd(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Fd(e,t){var n=e.alternate;return null===n?((n=Ad(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Dd(e,t,n,r,a,i){var o=2;if(r=e,"function"==typeof e)Rd(e)&&(o=1);else if("string"==typeof e)o=5;else e:switch(e){case ke:return Md(n.children,a,i,t);case Se:o=8,a|=8;break;case Ie:return(e=Ad(12,n,t,2|a)).elementType=Ie,e.lanes=i,e;case $e:return(e=Ad(13,n,t,a)).elementType=$e,e.lanes=i,e;case Ee:return(e=Ad(19,n,t,a)).elementType=Ee,e.lanes=i,e;case Re:return Od(n,a,i,t);default:if("object"==typeof e&&null!==e)switch(e.$$typeof){case Ne:o=10;break e;case Ce:o=9;break e;case Te:o=11;break e;case _e:o=14;break e;case Ae:o=16,r=null;break e}throw Error(ae(130,null==e?e:typeof e,""))}return(t=Ad(o,n,t,a)).elementType=e,t.type=r,t.lanes=i,t}function Md(e,t,n,r){return(e=Ad(7,e,r,t)).lanes=n,e}function Od(e,t,n,r){return(e=Ad(22,e,r,t)).elementType=Re,e.lanes=n,e.stateNode={isHidden:!1},e}function zd(e,t,n){return(e=Ad(6,e,null,t)).lanes=n,e}function Pd(e,t,n){return(t=Ad(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function Ld(e,t,n,r,a){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=gn(0),this.expirationTimes=gn(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=gn(0),this.identifierPrefix=r,this.onRecoverableError=a,this.mutableSourceEagerHydrationData=null}function Bd(e,t,n,r,a,i,o,s,l){return e=new Ld(e,t,n,s,l),1===t?(t=1,!0===i&&(t|=8)):t=0,i=Ad(3,null,null,t),e.current=i,i.stateNode=e,i.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Ao(i),e}function Wd(e){if(!e)return Ci;e:{if(Wt(e=e._reactInternals)!==e||1!==e.tag)throw Error(ae(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Ai(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(ae(171))}if(1===e.tag){var n=e.type;if(Ai(n))return Di(e,n,t)}return t}function Vd(e,t,n,r,a,i,o,s,l){return(e=Bd(n,r,!0,e,0,i,0,s,l)).context=Wd(null),n=e.current,(i=Fo(r=ed(),a=td(n))).callback=null!=t?t:null,Do(n,i,a),e.current.lanes=a,bn(e,a,r),rd(e,r),e}function Ud(e,t,n,r){var a=t.current,i=ed(),o=td(a);return n=Wd(n),null===t.context?t.context=n:t.pendingContext=n,(t=Fo(i,o)).payload={element:e},null!==(r=void 0===r?null:r)&&(t.callback=r),null!==(e=Do(a,t,o))&&(nd(e,a,o,i),Mo(e,a,o)),o}function jd(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Hd(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function Gd(e,t){Hd(e,t),(e=e.alternate)&&Hd(e,t)}Su=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||$i.current)vl=!0;else{if(0==(e.lanes&n)&&0==(128&t.flags))return vl=!1,function(e,t,n){switch(t.tag){case 3:El(t),ho();break;case 5:is(t);break;case 1:Ai(t.type)&&Mi(t);break;case 4:rs(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,a=t.memoizedProps.value;Ni(bo,r._currentValue),r._currentValue=a;break;case 13:if(null!==(r=t.memoizedState))return null!==r.dehydrated?(Ni(ss,1&ss.current),t.flags|=128,null):0!=(n&t.child.childLanes)?zl(e,t,n):(Ni(ss,1&ss.current),null!==(e=jl(e,t,n))?e.sibling:null);Ni(ss,1&ss.current);break;case 19:if(r=0!=(n&t.childLanes),0!=(128&e.flags)){if(r)return Vl(e,t,n);t.flags|=128}if(null!==(a=t.memoizedState)&&(a.rendering=null,a.tail=null,a.lastEffect=null),Ni(ss,ss.current),r)break;return null;case 22:case 23:return t.lanes=0,Il(e,t,n)}return jl(e,t,n)}(e,t,n);vl=0!=(131072&e.flags)}else vl=!1,ro&&0!=(1048576&t.flags)&&Zi(t,Hi,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;Ul(e,t),e=t.pendingProps;var a=_i(t,Ti.current);Io(t,n),a=Ss(null,t,r,e,a,n);var i=Is();return t.flags|=1,"object"==typeof a&&null!==a&&"function"==typeof a.render&&void 0===a.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Ai(r)?(i=!0,Mi(t)):i=!1,t.memoizedState=null!==a.state&&void 0!==a.state?a.state:null,Ao(t),a.updater=Wo,t.stateNode=a,a._reactInternals=t,Ho(t,r,e,n),t=$l(null,t,r,!0,i,n)):(t.tag=0,ro&&i&&Ji(t),xl(null,t,a,n),t=t.child),t;case 16:r=t.elementType;e:{switch(Ul(e,t),e=t.pendingProps,r=(a=r._init)(r._payload),t.type=r,a=t.tag=function(e){if("function"==typeof e)return Rd(e)?1:0;if(null!=e){if((e=e.$$typeof)===Te)return 11;if(e===_e)return 14}return 2}(r),e=go(r,e),a){case 0:t=Cl(null,t,r,e,n);break e;case 1:t=Tl(null,t,r,e,n);break e;case 11:t=wl(null,t,r,e,n);break e;case 14:t=kl(null,t,r,go(r.type,e),n);break e}throw Error(ae(306,r,""))}return t;case 0:return r=t.type,a=t.pendingProps,Cl(e,t,r,a=t.elementType===r?a:go(r,a),n);case 1:return r=t.type,a=t.pendingProps,Tl(e,t,r,a=t.elementType===r?a:go(r,a),n);case 3:e:{if(El(t),null===e)throw Error(ae(387));r=t.pendingProps,a=(i=t.memoizedState).element,Ro(e,t),zo(t,r,null,n);var o=t.memoizedState;if(r=o.element,i.isDehydrated){if(i={element:r,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},t.updateQueue.baseState=i,t.memoizedState=i,256&t.flags){t=_l(e,t,r,n,a=ul(Error(ae(423)),t));break e}if(r!==a){t=_l(e,t,r,n,a=ul(Error(ae(424)),t));break e}for(no=li(t.stateNode.containerInfo.firstChild),to=t,ro=!0,ao=null,n=Qo(t,null,r,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(ho(),r===a){t=jl(e,t,n);break e}xl(e,t,r,n)}t=t.child}return t;case 5:return is(t),null===e&&lo(t),r=t.type,a=t.pendingProps,i=null!==e?e.memoizedProps:null,o=a.children,ti(r,a)?o=null:null!==i&&ti(r,i)&&(t.flags|=32),Nl(e,t),xl(e,t,o,n),t.child;case 6:return null===e&&lo(t),null;case 13:return zl(e,t,n);case 4:return rs(t,t.stateNode.containerInfo),r=t.pendingProps,null===e?t.child=Yo(t,null,r,n):xl(e,t,r,n),t.child;case 11:return r=t.type,a=t.pendingProps,wl(e,t,r,a=t.elementType===r?a:go(r,a),n);case 7:return xl(e,t,t.pendingProps,n),t.child;case 8:case 12:return xl(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,a=t.pendingProps,i=t.memoizedProps,o=a.value,Ni(bo,r._currentValue),r._currentValue=o,null!==i)if(oa(i.value,o)){if(i.children===a.children&&!$i.current){t=jl(e,t,n);break e}}else for(null!==(i=t.child)&&(i.return=t);null!==i;){var s=i.dependencies;if(null!==s){o=i.child;for(var l=s.firstContext;null!==l;){if(l.context===r){if(1===i.tag){(l=Fo(-1,n&-n)).tag=2;var u=i.updateQueue;if(null!==u){var d=(u=u.shared).pending;null===d?l.next=l:(l.next=d.next,d.next=l),u.pending=l}}i.lanes|=n,null!==(l=i.alternate)&&(l.lanes|=n),So(i.return,n,t),s.lanes|=n;break}l=l.next}}else if(10===i.tag)o=i.type===t.type?null:i.child;else if(18===i.tag){if(null===(o=i.return))throw Error(ae(341));o.lanes|=n,null!==(s=o.alternate)&&(s.lanes|=n),So(o,n,t),o=i.sibling}else o=i.child;if(null!==o)o.return=i;else for(o=i;null!==o;){if(o===t){o=null;break}if(null!==(i=o.sibling)){i.return=o.return,o=i;break}o=o.return}i=o}xl(e,t,a.children,n),t=t.child}return t;case 9:return a=t.type,r=t.pendingProps.children,Io(t,n),r=r(a=No(a)),t.flags|=1,xl(e,t,r,n),t.child;case 14:return a=go(r=t.type,t.pendingProps),kl(e,t,r,a=go(r.type,a),n);case 15:return Sl(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,a=t.pendingProps,a=t.elementType===r?a:go(r,a),Ul(e,t),t.tag=1,Ai(r)?(e=!0,Mi(t)):e=!1,Io(t,n),Uo(t,r,a),Ho(t,r,a,n),$l(null,t,r,!0,e,n);case 19:return Vl(e,t,n);case 22:return Il(e,t,n)}throw Error(ae(156,t.tag))};var qd="function"==typeof reportError?reportError:function(e){console.error(e)};function Kd(e){this._internalRoot=e}function Xd(e){this._internalRoot=e}function Yd(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Qd(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Zd(){}function Jd(e,t,n,r,a){var i=n._reactRootContainer;if(i){var o=i;if("function"==typeof a){var s=a;a=function(){var e=jd(o);s.call(e)}}Ud(t,o,e,a)}else o=function(e,t,n,r,a){if(a){if("function"==typeof r){var i=r;r=function(){var e=jd(o);i.call(e)}}var o=Vd(t,r,e,0,null,!1,0,"",Zd);return e._reactRootContainer=o,e[hi]=o.current,Wa(8===e.nodeType?e.parentNode:e),dd(),o}for(;a=e.lastChild;)e.removeChild(a);if("function"==typeof r){var s=r;r=function(){var e=jd(l);s.call(e)}}var l=Bd(e,0,!1,null,0,!1,0,"",Zd);return e._reactRootContainer=l,e[hi]=l.current,Wa(8===e.nodeType?e.parentNode:e),dd((function(){Ud(t,l,n,r)})),l}(n,t,e,a,r);return jd(o)}Xd.prototype.render=Kd.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(ae(409));Ud(e,t,null,null)},Xd.prototype.unmount=Kd.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;dd((function(){Ud(null,e,null,null)})),t[hi]=null}},Xd.prototype.unstable_scheduleHydration=function(e){if(e){var t=In();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Fn.length&&0!==t&&t<Fn[n].priority;n++);Fn.splice(n,0,e),0===n&&zn(e)}},wn=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=cn(t.pendingLanes);0!==n&&(yn(t,1|n),rd(t,Yt()),0==(6&$u)&&(Vu=Yt()+500,Wi()))}break;case 13:dd((function(){var t=Eo(e,1);if(null!==t){var n=ed();nd(t,e,1,n)}})),Gd(e,1)}},kn=function(e){if(13===e.tag){var t=Eo(e,134217728);null!==t&&nd(t,e,134217728,ed()),Gd(e,134217728)}},Sn=function(e){if(13===e.tag){var t=td(e),n=Eo(e,t);null!==n&&nd(n,e,t,ed()),Gd(e,t)}},In=function(){return vn},Nn=function(e,t){var n=vn;try{return vn=e,t()}finally{vn=n}},wt=function(e,t,n){switch(t){case"input":if(Qe(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var a=xi(r);if(!a)throw Error(ae(90));Ge(r),Qe(r,a)}}}break;case"textarea":at(e,n);break;case"select":null!=(t=n.value)&&tt(e,!!n.multiple,t,!1)}},Tt=ud,$t=dd;var ec={usingClientEntryPoint:!1,Events:[yi,vi,xi,Nt,Ct,ud]},tc={findFiberByHostInstance:bi,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},nc={bundleType:tc.bundleType,version:tc.version,rendererPackageName:tc.rendererPackageName,rendererConfig:tc.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ve.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=jt(e))?null:e.stateNode},findFiberByHostInstance:tc.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var rc=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!rc.isDisabled&&rc.supportsFiber)try{rn=rc.inject(nc),an=rc}catch(ut){}}Z.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ec,Z.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Yd(t))throw Error(ae(200));return function(e,t,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:we,key:null==r?null:""+r,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},Z.createRoot=function(e,t){if(!Yd(e))throw Error(ae(299));var n=!1,r="",a=qd;return null!=t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(r=t.identifierPrefix),void 0!==t.onRecoverableError&&(a=t.onRecoverableError)),t=Bd(e,1,!1,null,0,n,0,r,a),e[hi]=t.current,Wa(8===e.nodeType?e.parentNode:e),new Kd(t)},Z.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"==typeof e.render)throw Error(ae(188));throw e=Object.keys(e).join(","),Error(ae(268,e))}return e=null===(e=jt(t))?null:e.stateNode},Z.flushSync=function(e){return dd(e)},Z.hydrate=function(e,t,n){if(!Qd(t))throw Error(ae(200));return Jd(null,e,t,!0,n)},Z.hydrateRoot=function(e,t,n){if(!Yd(e))throw Error(ae(405));var r=null!=n&&n.hydratedSources||null,a=!1,i="",o=qd;if(null!=n&&(!0===n.unstable_strictMode&&(a=!0),void 0!==n.identifierPrefix&&(i=n.identifierPrefix),void 0!==n.onRecoverableError&&(o=n.onRecoverableError)),t=Vd(t,null,e,1,null!=n?n:null,a,0,i,o),e[hi]=t.current,Wa(e),r)for(e=0;e<r.length;e++)a=(a=(n=r[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,a]:t.mutableSourceEagerHydrationData.push(n,a);return new Xd(t)},Z.render=function(e,t,n){if(!Qd(t))throw Error(ae(200));return Jd(null,e,t,!1,n)},Z.unmountComponentAtNode=function(e){if(!Qd(e))throw Error(ae(40));return!!e._reactRootContainer&&(dd((function(){Jd(null,null,e,!1,(function(){e._reactRootContainer=null,e[hi]=null}))})),!0)},Z.unstable_batchedUpdates=ud,Z.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!Qd(n))throw Error(ae(200));if(null==e||void 0===e._reactInternals)throw Error(ae(38));return Jd(e,t,n,!1,r)},Z.version="18.2.0-next-9e3b772b8-20220608",function e(){if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),Q.exports=Z;var ac=Q.exports;const ic=r(ac);var oc,sc=ac;function lc(e,t){return lc=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},lc(e,t)}function uc(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,lc(e,t)}oc=sc.createRoot,sc.hydrateRoot;var dc={exports:{}};function cc(){}function pc(){}pc.resetWarningCache=cc,dc.exports=function(){function e(e,t,n,r,a,i){if("SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"!==i){var o=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw o.name="Invariant Violation",o}}function t(){return e}e.isRequired=e;var n={array:e,bigint:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:t,element:e,elementType:e,instanceOf:t,node:e,objectOf:t,oneOf:t,oneOfType:t,shape:t,exact:t,checkPropTypes:pc,resetWarningCache:cc};return n.PropTypes=n,n}();const hc=r(dc.exports);function fc(){return fc=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},fc.apply(this,arguments)}function mc(e){return"/"===e.charAt(0)}function gc(e,t){for(var n=t,r=n+1,a=e.length;r<a;n+=1,r+=1)e[n]=e[r];e.pop()}function bc(e){return e.valueOf?e.valueOf():Object.prototype.valueOf.call(e)}function yc(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(Array.isArray(e))return Array.isArray(t)&&e.length===t.length&&e.every((function(e,n){return yc(e,t[n])}));if("object"==typeof e||"object"==typeof t){var n=bc(e),r=bc(t);return n!==e||r!==t?yc(n,r):Object.keys(Object.assign({},e,t)).every((function(n){return yc(e[n],t[n])}))}return!1}var vc=!0,xc="Invariant failed";function wc(e,t){if(!e){if(vc)throw new Error(xc);var n="function"==typeof t?t():t,r=n?"".concat(xc,": ").concat(n):xc;throw new Error(r)}}function kc(e){return"/"===e.charAt(0)?e:"/"+e}function Sc(e,t){return function(e,t){return 0===e.toLowerCase().indexOf(t.toLowerCase())&&-1!=="/?#".indexOf(e.charAt(t.length))}(e,t)?e.substr(t.length):e}function Ic(e){return"/"===e.charAt(e.length-1)?e.slice(0,-1):e}function Nc(e){var t=e.pathname,n=e.search,r=e.hash,a=t||"/";return n&&"?"!==n&&(a+="?"===n.charAt(0)?n:"?"+n),r&&"#"!==r&&(a+="#"===r.charAt(0)?r:"#"+r),a}function Cc(e,t,n,r){var a;"string"==typeof e?(a=function(e){var t=e||"/",n="",r="",a=t.indexOf("#");-1!==a&&(r=t.substr(a),t=t.substr(0,a));var i=t.indexOf("?");return-1!==i&&(n=t.substr(i),t=t.substr(0,i)),{pathname:t,search:"?"===n?"":n,hash:"#"===r?"":r}}(e),a.state=t):(void 0===(a=fc({},e)).pathname&&(a.pathname=""),a.search?"?"!==a.search.charAt(0)&&(a.search="?"+a.search):a.search="",a.hash?"#"!==a.hash.charAt(0)&&(a.hash="#"+a.hash):a.hash="",void 0!==t&&void 0===a.state&&(a.state=t));try{a.pathname=decodeURI(a.pathname)}catch(kp){throw kp instanceof URIError?new URIError('Pathname "'+a.pathname+'" could not be decoded. This is likely caused by an invalid percent-encoding.'):kp}return n&&(a.key=n),r?a.pathname?"/"!==a.pathname.charAt(0)&&(a.pathname=function(e,t){void 0===t&&(t="");var n,r=e&&e.split("/")||[],a=t&&t.split("/")||[],i=e&&mc(e),o=t&&mc(t),s=i||o;if(e&&mc(e)?a=r:r.length&&(a.pop(),a=a.concat(r)),!a.length)return"/";if(a.length){var l=a[a.length-1];n="."===l||".."===l||""===l}else n=!1;for(var u=0,d=a.length;d>=0;d--){var c=a[d];"."===c?gc(a,d):".."===c?(gc(a,d),u++):u&&(gc(a,d),u--)}if(!s)for(;u--;u)a.unshift("..");!s||""===a[0]||a[0]&&mc(a[0])||a.unshift("");var p=a.join("/");return n&&"/"!==p.substr(-1)&&(p+="/"),p}(a.pathname,r.pathname)):a.pathname=r.pathname:a.pathname||(a.pathname="/"),a}function Tc(e,t){return e.pathname===t.pathname&&e.search===t.search&&e.hash===t.hash&&e.key===t.key&&yc(e.state,t.state)}function $c(){var e=null,t=[];return{setPrompt:function(t){return e=t,function(){e===t&&(e=null)}},confirmTransitionTo:function(t,n,r,a){if(null!=e){var i="function"==typeof e?e(t,n):e;"string"==typeof i?"function"==typeof r?r(i,a):a(!0):a(!1!==i)}else a(!0)},appendListener:function(e){var n=!0;function r(){n&&e.apply(void 0,arguments)}return t.push(r),function(){n=!1,t=t.filter((function(e){return e!==r}))}},notifyListeners:function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];t.forEach((function(e){return e.apply(void 0,n)}))}}}var Ec=!("undefined"==typeof window||!window.document||!window.document.createElement);function _c(e,t){t(window.confirm(e))}var Ac="popstate",Rc="hashchange";function Fc(){try{return window.history.state||{}}catch(kp){return{}}}function Dc(e){void 0===e&&(e={}),Ec||wc(!1);var t=window.history,n=function(){var e=window.navigator.userAgent;return(-1===e.indexOf("Android 2.")&&-1===e.indexOf("Android 4.0")||-1===e.indexOf("Mobile Safari")||-1!==e.indexOf("Chrome")||-1!==e.indexOf("Windows Phone"))&&window.history&&"pushState"in window.history}(),r=!(-1===window.navigator.userAgent.indexOf("Trident")),a=e,i=a.forceRefresh,o=void 0!==i&&i,s=a.getUserConfirmation,l=void 0===s?_c:s,u=a.keyLength,d=void 0===u?6:u,c=e.basename?Ic(kc(e.basename)):"";function p(e){var t=e||{},n=t.key,r=t.state,a=window.location,i=a.pathname+a.search+a.hash;return c&&(i=Sc(i,c)),Cc(i,r,n)}function h(){return Math.random().toString(36).substr(2,d)}var f=$c();function m(e){fc(T,e),T.length=t.length,f.notifyListeners(T.location,T.action)}function g(e){(function(e){return void 0===e.state&&-1===navigator.userAgent.indexOf("CriOS")})(e)||v(p(e.state))}function b(){v(p(Fc()))}var y=!1;function v(e){y?(y=!1,m()):f.confirmTransitionTo(e,"POP",l,(function(t){t?m({action:"POP",location:e}):function(e){var t=T.location,n=w.indexOf(t.key);-1===n&&(n=0);var r=w.indexOf(e.key);-1===r&&(r=0);var a=n-r;a&&(y=!0,S(a))}(e)}))}var x=p(Fc()),w=[x.key];function k(e){return c+Nc(e)}function S(e){t.go(e)}var I=0;function N(e){1===(I+=e)&&1===e?(window.addEventListener(Ac,g),r&&window.addEventListener(Rc,b)):0===I&&(window.removeEventListener(Ac,g),r&&window.removeEventListener(Rc,b))}var C=!1,T={length:t.length,action:"POP",location:x,createHref:k,push:function(e,r){var a="PUSH",i=Cc(e,r,h(),T.location);f.confirmTransitionTo(i,a,l,(function(e){if(e){var r=k(i),s=i.key,l=i.state;if(n)if(t.pushState({key:s,state:l},null,r),o)window.location.href=r;else{var u=w.indexOf(T.location.key),d=w.slice(0,u+1);d.push(i.key),w=d,m({action:a,location:i})}else window.location.href=r}}))},replace:function(e,r){var a="REPLACE",i=Cc(e,r,h(),T.location);f.confirmTransitionTo(i,a,l,(function(e){if(e){var r=k(i),s=i.key,l=i.state;if(n)if(t.replaceState({key:s,state:l},null,r),o)window.location.replace(r);else{var u=w.indexOf(T.location.key);-1!==u&&(w[u]=i.key),m({action:a,location:i})}else window.location.replace(r)}}))},go:S,goBack:function(){S(-1)},goForward:function(){S(1)},block:function(e){void 0===e&&(e=!1);var t=f.setPrompt(e);return C||(N(1),C=!0),function(){return C&&(C=!1,N(-1)),t()}},listen:function(e){var t=f.appendListener(e);return N(1),function(){N(-1),t()}}};return T}var Mc={exports:{}},Oc=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)};Mc.exports=Gc,Mc.exports.parse=Pc,Mc.exports.compile=function(e,t){return Bc(Pc(e,t),t)},Mc.exports.tokensToFunction=Bc,Mc.exports.tokensToRegExp=Hc;var zc=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Pc(e,t){for(var n,r=[],a=0,i=0,o="",s=t&&t.delimiter||"/";null!=(n=zc.exec(e));){var l=n[0],u=n[1],d=n.index;if(o+=e.slice(i,d),i=d+l.length,u)o+=u[1];else{var c=e[i],p=n[2],h=n[3],f=n[4],m=n[5],g=n[6],b=n[7];o&&(r.push(o),o="");var y=null!=p&&null!=c&&c!==p,v="+"===g||"*"===g,x="?"===g||"*"===g,w=n[2]||s,k=f||m;r.push({name:h||a++,prefix:p||"",delimiter:w,optional:x,repeat:v,partial:y,asterisk:!!b,pattern:k?Vc(k):b?".*":"[^"+Wc(w)+"]+?"})}}return i<e.length&&(o+=e.substr(i)),o&&r.push(o),r}function Lc(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function Bc(e,t){for(var n=new Array(e.length),r=0;r<e.length;r++)"object"==typeof e[r]&&(n[r]=new RegExp("^(?:"+e[r].pattern+")$",jc(t)));return function(t,r){for(var a="",i=t||{},o=(r||{}).pretty?Lc:encodeURIComponent,s=0;s<e.length;s++){var l=e[s];if("string"!=typeof l){var u,d=i[l.name];if(null==d){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(Oc(d)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var c=0;c<d.length;c++){if(u=o(d[c]),!n[s].test(u))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(u)+"`");a+=(0===c?l.prefix:l.delimiter)+u}}else{if(u=l.asterisk?encodeURI(d).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()})):o(d),!n[s].test(u))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+u+'"');a+=l.prefix+u}}else a+=l}return a}}function Wc(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Vc(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function Uc(e,t){return e.keys=t,e}function jc(e){return e&&e.sensitive?"":"i"}function Hc(e,t,n){Oc(t)||(n=t||n,t=[]);for(var r=(n=n||{}).strict,a=!1!==n.end,i="",o=0;o<e.length;o++){var s=e[o];if("string"==typeof s)i+=Wc(s);else{var l=Wc(s.prefix),u="(?:"+s.pattern+")";t.push(s),s.repeat&&(u+="(?:"+l+u+")*"),i+=u=s.optional?s.partial?l+"("+u+")?":"(?:"+l+"("+u+"))?":l+"("+u+")"}}var d=Wc(n.delimiter||"/"),c=i.slice(-d.length)===d;return r||(i=(c?i.slice(0,-d.length):i)+"(?:"+d+"(?=$))?"),i+=a?"$":r&&c?"":"(?="+d+"|$)",Uc(new RegExp("^"+i,jc(n)),t)}function Gc(e,t,n){return Oc(t)||(n=t||n,t=[]),n=n||{},e instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var r=0;r<n.length;r++)t.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Uc(e,t)}(e,t):Oc(e)?function(e,t,n){for(var r=[],a=0;a<e.length;a++)r.push(Gc(e[a],t,n).source);return Uc(new RegExp("(?:"+r.join("|")+")",jc(n)),t)}(e,t,n):function(e,t,n){return Hc(Pc(e,n),t,n)}(e,t,n)}const qc=r(Mc.exports);var Kc={},Xc="function"==typeof Symbol&&Symbol.for,Yc=Xc?Symbol.for("react.element"):60103,Qc=Xc?Symbol.for("react.portal"):60106,Zc=Xc?Symbol.for("react.fragment"):60107,Jc=Xc?Symbol.for("react.strict_mode"):60108,ep=Xc?Symbol.for("react.profiler"):60114,tp=Xc?Symbol.for("react.provider"):60109,np=Xc?Symbol.for("react.context"):60110,rp=Xc?Symbol.for("react.async_mode"):60111,ap=Xc?Symbol.for("react.concurrent_mode"):60111,ip=Xc?Symbol.for("react.forward_ref"):60112,op=Xc?Symbol.for("react.suspense"):60113,sp=Xc?Symbol.for("react.suspense_list"):60120,lp=Xc?Symbol.for("react.memo"):60115,up=Xc?Symbol.for("react.lazy"):60116,dp=Xc?Symbol.for("react.block"):60121,cp=Xc?Symbol.for("react.fundamental"):60117,pp=Xc?Symbol.for("react.responder"):60118,hp=Xc?Symbol.for("react.scope"):60119;
/** @license React v16.13.1
             * react-is.production.min.js
             *
             * Copyright (c) Facebook, Inc. and its affiliates.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE file in the root directory of this source tree.
             */function fp(e){if("object"==typeof e&&null!==e){var t=e.$$typeof;switch(t){case Yc:switch(e=e.type){case rp:case ap:case Zc:case ep:case Jc:case op:return e;default:switch(e=e&&e.$$typeof){case np:case ip:case up:case lp:case tp:return e;default:return t}}case Qc:return t}}}function mp(e){return fp(e)===ap}function gp(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}Kc.AsyncMode=rp,Kc.ConcurrentMode=ap,Kc.ContextConsumer=np,Kc.ContextProvider=tp,Kc.Element=Yc,Kc.ForwardRef=ip,Kc.Fragment=Zc,Kc.Lazy=up,Kc.Memo=lp,Kc.Portal=Qc,Kc.Profiler=ep,Kc.StrictMode=Jc,Kc.Suspense=op,Kc.isAsyncMode=function(e){return mp(e)||fp(e)===rp},Kc.isConcurrentMode=mp,Kc.isContextConsumer=function(e){return fp(e)===np},Kc.isContextProvider=function(e){return fp(e)===tp},Kc.isElement=function(e){return"object"==typeof e&&null!==e&&e.$$typeof===Yc},Kc.isForwardRef=function(e){return fp(e)===ip},Kc.isFragment=function(e){return fp(e)===Zc},Kc.isLazy=function(e){return fp(e)===up},Kc.isMemo=function(e){return fp(e)===lp},Kc.isPortal=function(e){return fp(e)===Qc},Kc.isProfiler=function(e){return fp(e)===ep},Kc.isStrictMode=function(e){return fp(e)===Jc},Kc.isSuspense=function(e){return fp(e)===op},Kc.isValidElementType=function(e){return"string"==typeof e||"function"==typeof e||e===Zc||e===ap||e===ep||e===Jc||e===op||e===sp||"object"==typeof e&&null!==e&&(e.$$typeof===up||e.$$typeof===lp||e.$$typeof===tp||e.$$typeof===np||e.$$typeof===ip||e.$$typeof===cp||e.$$typeof===pp||e.$$typeof===hp||e.$$typeof===dp)},Kc.typeOf=fp;var bp={exports:{}},yp={},vp="function"==typeof Symbol&&Symbol.for,xp=vp?Symbol.for("react.element"):60103,wp=vp?Symbol.for("react.portal"):60106,kp=vp?Symbol.for("react.fragment"):60107,Sp=vp?Symbol.for("react.strict_mode"):60108,Ip=vp?Symbol.for("react.profiler"):60114,Np=vp?Symbol.for("react.provider"):60109,Cp=vp?Symbol.for("react.context"):60110,Tp=vp?Symbol.for("react.async_mode"):60111,$p=vp?Symbol.for("react.concurrent_mode"):60111,Ep=vp?Symbol.for("react.forward_ref"):60112,_p=vp?Symbol.for("react.suspense"):60113,Ap=vp?Symbol.for("react.suspense_list"):60120,Rp=vp?Symbol.for("react.memo"):60115,Fp=vp?Symbol.for("react.lazy"):60116,Dp=vp?Symbol.for("react.block"):60121,Mp=vp?Symbol.for("react.fundamental"):60117,Op=vp?Symbol.for("react.responder"):60118,zp=vp?Symbol.for("react.scope"):60119;function Pp(e){if("object"==typeof e&&null!==e){var t=e.$$typeof;switch(t){case xp:switch(e=e.type){case Tp:case $p:case kp:case Ip:case Sp:case _p:return e;default:switch(e=e&&e.$$typeof){case Cp:case Ep:case Fp:case Rp:case Np:return e;default:return t}}case wp:return t}}}function Lp(e){return Pp(e)===$p}yp.AsyncMode=Tp,yp.ConcurrentMode=$p,yp.ContextConsumer=Cp,yp.ContextProvider=Np,yp.Element=xp,yp.ForwardRef=Ep,yp.Fragment=kp,yp.Lazy=Fp,yp.Memo=Rp,yp.Portal=wp,yp.Profiler=Ip,yp.StrictMode=Sp,yp.Suspense=_p,yp.isAsyncMode=function(e){return Lp(e)||Pp(e)===Tp},yp.isConcurrentMode=Lp,yp.isContextConsumer=function(e){return Pp(e)===Cp},yp.isContextProvider=function(e){return Pp(e)===Np},yp.isElement=function(e){return"object"==typeof e&&null!==e&&e.$$typeof===xp},yp.isForwardRef=function(e){return Pp(e)===Ep},yp.isFragment=function(e){return Pp(e)===kp},yp.isLazy=function(e){return Pp(e)===Fp},yp.isMemo=function(e){return Pp(e)===Rp},yp.isPortal=function(e){return Pp(e)===wp},yp.isProfiler=function(e){return Pp(e)===Ip},yp.isStrictMode=function(e){return Pp(e)===Sp},yp.isSuspense=function(e){return Pp(e)===_p},yp.isValidElementType=function(e){return"string"==typeof e||"function"==typeof e||e===kp||e===$p||e===Ip||e===Sp||e===_p||e===Ap||"object"==typeof e&&null!==e&&(e.$$typeof===Fp||e.$$typeof===Rp||e.$$typeof===Np||e.$$typeof===Cp||e.$$typeof===Ep||e.$$typeof===Mp||e.$$typeof===Op||e.$$typeof===zp||e.$$typeof===Dp)},yp.typeOf=Pp,bp.exports=yp;var Bp=bp.exports,Wp={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},Vp={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},Up={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},jp={};function Hp(e){return Bp.isMemo(e)?Up:jp[e.$$typeof]||Wp}jp[Bp.ForwardRef]={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},jp[Bp.Memo]=Up;var Gp=Object.defineProperty,qp=Object.getOwnPropertyNames,Kp=Object.getOwnPropertySymbols,Xp=Object.getOwnPropertyDescriptor,Yp=Object.getPrototypeOf,Qp=Object.prototype,Zp=function e(t,n,r){if("string"!=typeof n){if(Qp){var a=Yp(n);a&&a!==Qp&&e(t,a,r)}var i=qp(n);Kp&&(i=i.concat(Kp(n)));for(var o=Hp(t),s=Hp(n),l=0;l<i.length;++l){var u=i[l];if(!(Vp[u]||r&&r[u]||s&&s[u]||o&&o[u])){var d=Xp(n,u);try{Gp(t,u,d)}catch(kp){}}}}return t};const Jp=r(Zp);var eh=1073741823,th="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},nh=V.createContext||function(e,t){var n,r,a,i="__create-react-context-"+(th[a="__global_unique_id__"]=(th[a]||0)+1)+"__",o=function(e){function n(){for(var t,n,r,a=arguments.length,i=new Array(a),o=0;o<a;o++)i[o]=arguments[o];return(t=e.call.apply(e,[this].concat(i))||this).emitter=(n=t.props.value,r=[],{on:function(e){r.push(e)},off:function(e){r=r.filter((function(t){return t!==e}))},get:function(){return n},set:function(e,t){n=e,r.forEach((function(e){return e(n,t)}))}}),t}uc(n,e);var r=n.prototype;return r.getChildContext=function(){var e;return(e={})[i]=this.emitter,e},r.componentWillReceiveProps=function(e){if(this.props.value!==e.value){var n,r=this.props.value,a=e.value;!function(e,t){return e===t?0!==e||1/e==1/t:e!=e&&t!=t}(r,a)?(n="function"==typeof t?t(r,a):eh,0!=(n|=0)&&this.emitter.set(e.value,n)):n=0}},r.render=function(){return this.props.children},n}(V.Component);o.childContextTypes=((n={})[i]=hc.object.isRequired,n);var s=function(t){function n(){for(var e,n=arguments.length,r=new Array(n),a=0;a<n;a++)r[a]=arguments[a];return(e=t.call.apply(t,[this].concat(r))||this).observedBits=void 0,e.state={value:e.getValue()},e.onUpdate=function(t,n){0!=((0|e.observedBits)&n)&&e.setState({value:e.getValue()})},e}uc(n,t);var r=n.prototype;return r.componentWillReceiveProps=function(e){var t=e.observedBits;this.observedBits=null==t?eh:t},r.componentDidMount=function(){this.context[i]&&this.context[i].on(this.onUpdate);var e=this.props.observedBits;this.observedBits=null==e?eh:e},r.componentWillUnmount=function(){this.context[i]&&this.context[i].off(this.onUpdate)},r.getValue=function(){return this.context[i]?this.context[i].get():e},r.render=function(){return(e=this.props.children,Array.isArray(e)?e[0]:e)(this.state.value);var e},n}(V.Component);return s.contextTypes=((r={})[i]=hc.object,r),{Provider:o,Consumer:s}},rh=function(e){var t=nh();return t.displayName=e,t},ah=rh("Router-History"),ih=rh("Router"),oh=function(e){function t(t){var n;return(n=e.call(this,t)||this).state={location:t.history.location},n._isMounted=!1,n._pendingLocation=null,t.staticContext||(n.unlisten=t.history.listen((function(e){n._pendingLocation=e}))),n}uc(t,e),t.computeRootMatch=function(e){return{path:"/",url:"/",params:{},isExact:"/"===e}};var n=t.prototype;return n.componentDidMount=function(){var e=this;this._isMounted=!0,this.unlisten&&this.unlisten(),this.props.staticContext||(this.unlisten=this.props.history.listen((function(t){e._isMounted&&e.setState({location:t})}))),this._pendingLocation&&this.setState({location:this._pendingLocation})},n.componentWillUnmount=function(){this.unlisten&&(this.unlisten(),this._isMounted=!1,this._pendingLocation=null)},n.render=function(){return V.createElement(ih.Provider,{value:{history:this.props.history,location:this.state.location,match:t.computeRootMatch(this.state.location.pathname),staticContext:this.props.staticContext}},V.createElement(ah.Provider,{children:this.props.children||null,value:this.props.history}))},t}(V.Component);V.Component;var sh=function(e){function t(){return e.apply(this,arguments)||this}uc(t,e);var n=t.prototype;return n.componentDidMount=function(){this.props.onMount&&this.props.onMount.call(this,this)},n.componentDidUpdate=function(e){this.props.onUpdate&&this.props.onUpdate.call(this,this,e)},n.componentWillUnmount=function(){this.props.onUnmount&&this.props.onUnmount.call(this,this)},n.render=function(){return null},t}(V.Component),lh={},uh=1e4,dh=0;function ch(e,t){return void 0===e&&(e="/"),void 0===t&&(t={}),"/"===e?e:function(e){if(lh[e])return lh[e];var t=qc.compile(e);return dh<uh&&(lh[e]=t,dh++),t}(e)(t,{pretty:!0})}function ph(e){var t=e.computedMatch,n=e.to,r=e.push,a=void 0!==r&&r;return V.createElement(ih.Consumer,null,(function(e){e||wc(!1);var r=e.history,i=e.staticContext,o=a?r.push:r.replace,s=Cc(t?"string"==typeof n?ch(n,t.params):fc({},n,{pathname:ch(n.pathname,t.params)}):n);return i?(o(s),null):V.createElement(sh,{onMount:function(){o(s)},onUpdate:function(e,t){var n=Cc(t.to);Tc(n,fc({},s,{key:n.key}))||o(s)},to:n})}))}var hh={},fh=1e4,mh=0;function gh(e,t){void 0===t&&(t={}),("string"==typeof t||Array.isArray(t))&&(t={path:t});var n=t,r=n.path,a=n.exact,i=void 0!==a&&a,o=n.strict,s=void 0!==o&&o,l=n.sensitive,u=void 0!==l&&l;return[].concat(r).reduce((function(t,n){if(!n&&""!==n)return null;if(t)return t;var r=function(e,t){var n=""+t.end+t.strict+t.sensitive,r=hh[n]||(hh[n]={});if(r[e])return r[e];var a=[],i={regexp:qc(e,a,t),keys:a};return mh<fh&&(r[e]=i,mh++),i}(n,{end:i,strict:s,sensitive:u}),a=r.regexp,o=r.keys,l=a.exec(e);if(!l)return null;var d=l[0],c=l.slice(1),p=e===d;return i&&!p?null:{path:n,url:"/"===n&&""===d?"/":d,isExact:p,params:o.reduce((function(e,t,n){return e[t.name]=c[n],e}),{})}}),null)}var bh=function(e){function t(){return e.apply(this,arguments)||this}return uc(t,e),t.prototype.render=function(){var e=this;return V.createElement(ih.Consumer,null,(function(t){t||wc(!1);var n=e.props.location||t.location,r=fc({},t,{location:n,match:e.props.computedMatch?e.props.computedMatch:e.props.path?gh(n.pathname,e.props):t.match}),a=e.props,i=a.children,o=a.component,s=a.render;return Array.isArray(i)&&function(e){return 0===V.Children.count(e)}(i)&&(i=null),V.createElement(ih.Provider,{value:r},r.match?i?"function"==typeof i?i(r):i:o?V.createElement(o,r):s?s(r):null:"function"==typeof i?i(r):null)}))},t}(V.Component);V.Component,V.Component,V.useContext;const yh=function(e,t,n){return e()},vh=!0,xh=!0,wh=!0,kh=!1,Sh=!1;let Ih,Nh,Ch,Th=!1,$h=!1,Eh=!1,_h=!1,Ah=null,Rh=!1;const Fh=!0,Dh="http://www.w3.org/1999/xlink",Mh={},Oh=e=>"object"==(e=typeof e)||"function"===e,zh=(e,t,...n)=>{let r=null,a=null,i=null,o=!1,s=!1;const l=[],u=t=>{for(let n=0;n<t.length;n++)r=t[n],Array.isArray(r)?u(r):null!=r&&"boolean"!=typeof r&&((o="function"!=typeof e&&!Oh(r))&&(r=String(r)),o&&s?l[l.length-1].$text$+=r:l.push(o?Ph(null,r):r),s=o)};if(u(n),t){t.key&&(a=t.key),t.name&&(i=t.name);{const e=t.className||t.class;e&&(t.class="object"!=typeof e?e:Object.keys(e).filter((t=>e[t])).join(" "))}}if("function"==typeof e)return e(null===t?{}:t,l,Bh);const d=Ph(e,null);return d.$attrs$=t,l.length>0&&(d.$children$=l),d.$key$=a,d.$name$=i,d},Ph=(e,t)=>{const n={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null,$attrs$:null,$key$:null,$name$:null};return n},Lh={},Bh={forEach:(e,t)=>e.map(Wh).forEach(t),map:(e,t)=>e.map(Wh).map(t).map(Vh)},Wh=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),Vh=e=>{if("function"==typeof e.vtag){const t=Object.assign({},e.vattrs);return e.vkey&&(t.key=e.vkey),e.vname&&(t.name=e.vname),zh(e.vtag,t,...e.vchildren||[])}const t=Ph(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},Uh=(e,t,n)=>{const r=e;return{emit:e=>jh(r,t,{bubbles:!!(4&n),composed:!!(2&n),cancelable:!!(1&n),detail:e})}},jh=(e,t,n)=>{const r=Wf.ce(t,n);return e.dispatchEvent(r),r},Hh=new WeakMap,Gh=e=>{const t=e.$cmpMeta$,n=e.$hostElement$,r=t.$flags$,a=(t.$tagName$,()=>{}),i=((e,t,n,r)=>{var a;let i=qh(t,n);const o=Of.get(i);if(e=11===e.nodeType?e:Lf,o)if("string"==typeof o){e=e.head||e;let t,n=Hh.get(e);if(n||Hh.set(e,n=new Set),!n.has(i)){{t=Lf.createElement("style"),t.innerHTML=o;const n=null!==(a=Wf.$nonce$)&&void 0!==a?a:function(e){var t,n,r;return null!==(r=null===(n=null===(t=e.head)||void 0===t?void 0:t.querySelector('meta[name="csp-nonce"]'))||void 0===n?void 0:n.getAttribute("content"))&&void 0!==r?r:void 0}(Lf);null!=n&&t.setAttribute("nonce",n),e.insertBefore(t,e.querySelector("link"))}n&&n.add(i)}}else e.adoptedStyleSheets.includes(o)||(e.adoptedStyleSheets=[...e.adoptedStyleSheets,o]);return i})(n.shadowRoot?n.shadowRoot:n.getRootNode(),t,e.$modeName$);10&r&&(n["s-sc"]=i,n.classList.add(i+"-h"),2&r&&n.classList.add(i+"-s")),a()},qh=(e,t)=>"sc-"+(t&&32&e.$flags$?e.$tagName$+"-"+t:e.$tagName$),Kh=(e,t,n,r,a,i)=>{if(n!==r){let o=Df(e,t),s=t.toLowerCase();if("class"===t){const t=e.classList,a=Yh(n),i=Yh(r);t.remove(...a.filter((e=>e&&!i.includes(e)))),t.add(...i.filter((e=>e&&!a.includes(e))))}else if("style"===t){for(const t in n)r&&null!=r[t]||(t.includes("-")?e.style.removeProperty(t):e.style[t]="");for(const t in r)n&&r[t]===n[t]||(t.includes("-")?e.style.setProperty(t,r[t]):e.style[t]=r[t])}else if("key"===t);else if("ref"===t)r&&r(e);else if(e.__lookupSetter__(t)||"o"!==t[0]||"n"!==t[1]){const l=Oh(r);if((o||l&&null!==r)&&!a)try{if(e.tagName.includes("-"))e[t]=r;else{const a=null==r?"":r;"list"===t?o=!1:null!=n&&e[t]==a||(e[t]=a)}}catch(kp){}let u=!1;s!==(s=s.replace(/^xlink\:?/,""))&&(t=s,u=!0),null==r||!1===r?!1===r&&""!==e.getAttribute(t)||(u?e.removeAttributeNS(Dh,t):e.removeAttribute(t)):(!o||4&i||a)&&!l&&(r=!0===r?"":r,u?e.setAttributeNS(Dh,t,r):e.setAttribute(t,r))}else t="-"===t[2]?t.slice(3):Df(Pf,s)?s.slice(2):s[2]+t.slice(3),n&&Wf.rel(e,t,n,!1),r&&Wf.ael(e,t,r,!1)}},Xh=/\s/,Yh=e=>e?e.split(Xh):[],Qh=(e,t,n,r)=>{const a=11===t.$elm$.nodeType&&t.$elm$.host?t.$elm$.host:t.$elm$,i=e&&e.$attrs$||Mh,o=t.$attrs$||Mh;for(r in i)r in o||Kh(a,r,i[r],void 0,n,t.$flags$);for(r in o)Kh(a,r,i[r],o[r],n,t.$flags$)},Zh=(e,t,n,r)=>{const a=t.$children$[n];let i,o,s,l=0;if(Th||(Eh=!0,"slot"===a.$tag$&&(Ih&&r.classList.add(Ih+"-s"),a.$flags$|=a.$children$?2:1)),null!==a.$text$)i=a.$elm$=Lf.createTextNode(a.$text$);else if(1&a.$flags$)i=a.$elm$=Lf.createTextNode("");else{if(_h||(_h="svg"===a.$tag$),i=a.$elm$=Lf.createElementNS(_h?"http://www.w3.org/2000/svg":"http://www.w3.org/1999/xhtml",2&a.$flags$?"slot-fb":a.$tag$),_h&&"foreignObject"===a.$tag$&&(_h=!1),Qh(null,a,_h),(e=>null!=e)(Ih)&&i["s-si"]!==Ih&&i.classList.add(i["s-si"]=Ih),a.$children$)for(l=0;l<a.$children$.length;++l)o=Zh(e,a,l,i),o&&i.appendChild(o);"svg"===a.$tag$?_h=!1:"foreignObject"===i.tagName&&(_h=!0)}return i["s-hn"]=Ch,3&a.$flags$&&(i["s-sr"]=!0,i["s-cr"]=Nh,i["s-sn"]=a.$name$||"",s=e&&e.$children$&&e.$children$[n],s&&s.$tag$===a.$tag$&&e.$elm$&&Jh(e.$elm$,!1)),i},Jh=(e,t)=>{Wf.$flags$|=1;const n=e.childNodes;for(let r=n.length-1;r>=0;r--){const e=n[r];e["s-hn"]!==Ch&&e["s-ol"]&&(af(e).insertBefore(e,rf(e)),e["s-ol"].remove(),e["s-ol"]=void 0,Eh=!0),t&&Jh(e,t)}Wf.$flags$&=-2},ef=(e,t,n,r,a,i)=>{let o,s=e["s-cr"]&&e["s-cr"].parentNode||e;for(s.shadowRoot&&s.tagName===Ch&&(s=s.shadowRoot);a<=i;++a)r[a]&&(o=Zh(null,n,a,e),o&&(r[a].$elm$=o,s.insertBefore(o,rf(t))))},tf=(e,t,n)=>{for(let r=t;r<=n;++r){const t=e[r];if(t){const e=t.$elm$;cf(t),e&&($h=!0,e["s-ol"]?e["s-ol"].remove():Jh(e,!0),e.remove())}}},nf=(e,t)=>e.$tag$===t.$tag$&&("slot"===e.$tag$?e.$name$===t.$name$:e.$key$===t.$key$),rf=e=>e&&e["s-ol"]||e,af=e=>(e["s-ol"]?e["s-ol"]:e).parentNode,of=(e,t)=>{const n=t.$elm$=e.$elm$,r=e.$children$,a=t.$children$,i=t.$tag$,o=t.$text$;let s;null===o?(_h="svg"===i||"foreignObject"!==i&&_h,"slot"===i||Qh(e,t,_h),null!==r&&null!==a?((e,t,n,r)=>{let a,i,o=0,s=0,l=0,u=0,d=t.length-1,c=t[0],p=t[d],h=r.length-1,f=r[0],m=r[h];for(;o<=d&&s<=h;)if(null==c)c=t[++o];else if(null==p)p=t[--d];else if(null==f)f=r[++s];else if(null==m)m=r[--h];else if(nf(c,f))of(c,f),c=t[++o],f=r[++s];else if(nf(p,m))of(p,m),p=t[--d],m=r[--h];else if(nf(c,m))"slot"!==c.$tag$&&"slot"!==m.$tag$||Jh(c.$elm$.parentNode,!1),of(c,m),e.insertBefore(c.$elm$,p.$elm$.nextSibling),c=t[++o],m=r[--h];else if(nf(p,f))"slot"!==c.$tag$&&"slot"!==m.$tag$||Jh(p.$elm$.parentNode,!1),of(p,f),e.insertBefore(p.$elm$,c.$elm$),p=t[--d],f=r[++s];else{for(l=-1,u=o;u<=d;++u)if(t[u]&&null!==t[u].$key$&&t[u].$key$===f.$key$){l=u;break}l>=0?(i=t[l],i.$tag$!==f.$tag$?a=Zh(t&&t[s],n,l,e):(of(i,f),t[l]=void 0,a=i.$elm$),f=r[++s]):(a=Zh(t&&t[s],n,s,e),f=r[++s]),a&&af(c.$elm$).insertBefore(a,rf(c.$elm$))}o>d?ef(e,null==r[h+1]?null:r[h+1].$elm$,n,r,s,h):s>h&&tf(t,o,d)})(n,r,t,a):null!==a?(null!==e.$text$&&(n.textContent=""),ef(n,null,t,a,0,a.length-1)):null!==r&&tf(r,0,r.length-1),_h&&"svg"===i&&(_h=!1)):(s=n["s-cr"])?s.parentNode.textContent=o:e.$text$!==o&&(n.data=o)},sf=e=>{const t=e.childNodes;let n,r,a,i,o,s;for(r=0,a=t.length;r<a;r++)if(n=t[r],1===n.nodeType){if(n["s-sr"])for(o=n["s-sn"],n.hidden=!1,i=0;i<a;i++)if(s=t[i].nodeType,t[i]["s-hn"]!==n["s-hn"]||""!==o){if(1===s&&o===t[i].getAttribute("slot")){n.hidden=!0;break}}else if(1===s||3===s&&""!==t[i].textContent.trim()){n.hidden=!0;break}sf(n)}},lf=[],uf=e=>{let t,n,r,a,i,o,s=0;const l=e.childNodes,u=l.length;for(;s<u;s++){if(t=l[s],t["s-sr"]&&(n=t["s-cr"])&&n.parentNode)for(r=n.parentNode.childNodes,a=t["s-sn"],o=r.length-1;o>=0;o--)n=r[o],n["s-cn"]||n["s-nr"]||n["s-hn"]===t["s-hn"]||(df(n,a)?(i=lf.find((e=>e.$nodeToRelocate$===n)),$h=!0,n["s-sn"]=n["s-sn"]||a,i?i.$slotRefNode$=t:lf.push({$slotRefNode$:t,$nodeToRelocate$:n}),n["s-sr"]&&lf.map((e=>{df(e.$nodeToRelocate$,n["s-sn"])&&(i=lf.find((e=>e.$nodeToRelocate$===n)),i&&!e.$slotRefNode$&&(e.$slotRefNode$=i.$slotRefNode$))}))):lf.some((e=>e.$nodeToRelocate$===n))||lf.push({$nodeToRelocate$:n}));1===t.nodeType&&uf(t)}},df=(e,t)=>1===e.nodeType?null===e.getAttribute("slot")&&""===t||e.getAttribute("slot")===t:e["s-sn"]===t||""===t,cf=e=>{e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(cf)},pf=(e,t)=>{const n=e.$hostElement$,r=e.$cmpMeta$,a=e.$vnode$||Ph(null,null),i=(o=t)&&o.$tag$===Lh?t:zh(null,null,t);var o;if(Ch=n.tagName,r.$attrsToReflect$&&(i.$attrs$=i.$attrs$||{},r.$attrsToReflect$.map((([e,t])=>i.$attrs$[t]=n[e]))),i.$tag$=null,i.$flags$|=4,e.$vnode$=i,i.$elm$=a.$elm$=n.shadowRoot||n,Ih=n["s-sc"],Nh=n["s-cr"],Th=0!=(1&r.$flags$),$h=!1,of(a,i),Wf.$flags$|=1,Eh){let e,t,n,r,a,o;uf(i.$elm$);let s=0;for(;s<lf.length;s++)e=lf[s],t=e.$nodeToRelocate$,t["s-ol"]||(n=Lf.createTextNode(""),n["s-nr"]=t,t.parentNode.insertBefore(t["s-ol"]=n,t));for(s=0;s<lf.length;s++)if(e=lf[s],t=e.$nodeToRelocate$,e.$slotRefNode$){for(r=e.$slotRefNode$.parentNode,a=e.$slotRefNode$.nextSibling,n=t["s-ol"];n=n.previousSibling;)if(o=n["s-nr"],o&&o["s-sn"]===t["s-sn"]&&r===o.parentNode&&(o=o.nextSibling,!o||!o["s-nr"])){a=o;break}(!a&&r!==t.parentNode||t.nextSibling!==a)&&t!==a&&(!t["s-hn"]&&t["s-ol"]&&(t["s-hn"]=t["s-ol"].parentNode.nodeName),r.insertBefore(t,a))}else 1===t.nodeType&&(t.hidden=!0)}$h&&sf(i.$elm$),Wf.$flags$&=-2,lf.length=0},hf=(e,t)=>(e.$flags$|=16,e.$ancestorComponent$,Qf((()=>ff(e,t)))),ff=(e,t)=>{const n=e.$hostElement$,r=(e.$cmpMeta$.$tagName$,()=>{}),a=n;let i;return i=wf(a,t?"componentWillLoad":"componentWillUpdate"),i=mf(i,(()=>wf(a,"componentWillRender"))),r(),mf(i,(()=>bf(e,a,t)))},mf=(e,t)=>gf(e)?e.then(t):t(),gf=e=>e instanceof Promise||e&&e.then&&"function"==typeof e.then,bf=async(e,t,n)=>{const r=e.$hostElement$,a=(e.$cmpMeta$.$tagName$,()=>{});r["s-rc"],n&&Gh(e);const i=(e.$cmpMeta$.$tagName$,()=>{});yf(e,t,r),i(),a(),vf(e)},yf=(e,t,n)=>{try{Ah=t,t=t.render&&t.render(),e.$flags$&=-17,e.$flags$|=2,(vh||xh)&&(wh||xh)&&(kh||pf(e,t))}catch(kp){Mf(kp,e.$hostElement$)}return Ah=null,null},vf=e=>{e.$cmpMeta$.$tagName$;const t=()=>{},n=e.$hostElement$;e.$ancestorComponent$,wf(n,"componentDidRender"),64&e.$flags$?(wf(n,"componentDidUpdate"),t()):(e.$flags$|=64,wf(n,"componentDidLoad"),t())},xf=e=>{{const t=Rf(e),n=t.$hostElement$.isConnected;return n&&2==(18&t.$flags$)&&hf(t,!1),n}},wf=(e,t,n)=>{if(e&&e[t])try{return e[t](n)}catch(kp){Mf(kp)}},kf=(e,t,n,r)=>{const a=Rf(e),i=e,o=a.$instanceValues$.get(t),s=a.$flags$,l=i;var u,d;u=n,d=r.$members$[t][0],n=null==u||Oh(u)?u:4&d?"false"!==u&&(""===u||!!u):2&d?parseFloat(u):1&d?String(u):u;const c=Number.isNaN(o)&&Number.isNaN(n);if(n!==o&&!c){if(a.$instanceValues$.set(t,n),r.$watchers$&&128&s){const e=r.$watchers$[t];e&&e.map((e=>{try{l[e](n,o,t)}catch(kp){Mf(kp,i)}}))}if(2==(18&s)){if(l.componentShouldUpdate&&!1===l.componentShouldUpdate(n,o,t))return;hf(a,!1)}}},Sf=(e,t,n)=>{if(t.$members$){e.watchers&&(t.$watchers$=e.watchers);const n=Object.entries(t.$members$),r=e.prototype;n.map((([e,[n]])=>{(31&n||32&n)&&Object.defineProperty(r,e,{get(){return t=e,Rf(this).$instanceValues$.get(t);var t},set(n){kf(this,e,n,t)},configurable:!0,enumerable:!0})}));{const a=new Map;r.attributeChangedCallback=function(e,t,n){Wf.jmp((()=>{const t=a.get(e);if(this.hasOwnProperty(t))n=this[t],delete this[t];else if(r.hasOwnProperty(t)&&"number"==typeof this[t]&&this[t]==n)return;this[t]=(null!==n||"boolean"!=typeof this[t])&&n}))},e.observedAttributes=n.filter((([e,t])=>15&t[0])).map((([e,n])=>{const r=n[1]||e;return a.set(r,e),512&n[0]&&t.$attrsToReflect$.push([e,r]),r}))}}return e},If=async(e,t,n,r,a)=>{if(0==(32&t.$flags$)&&(t.$flags$|=32,a=e.constructor,customElements.whenDefined(n.$tagName$).then((()=>t.$flags$|=128)),a.style)){let r=a.style;"string"!=typeof r&&(r=r[t.$modeName$=(e=>zf.map((t=>t(e))).find((e=>!!e)))(e)]);const i=qh(n,t.$modeName$);if(!Of.has(i)){const e=(n.$tagName$,()=>{});((e,t,n)=>{let r=Of.get(e);Uf&&n?(r=r||new CSSStyleSheet,"string"==typeof r?r=t:r.replaceSync(t)):r=t,Of.set(e,r)})(i,r,!!(1&n.$flags$)),e()}}t.$ancestorComponent$,hf(t,!0)},Nf=e=>{const t=e["s-cr"]=Lf.createComment("");t["s-cn"]=!0,e.insertBefore(t,e.firstChild)},Cf=(e,t)=>{const n={$flags$:t[0],$tagName$:t[1]};n.$members$=t[2],n.$listeners$=t[3],n.$watchers$=e.$watchers$,n.$attrsToReflect$=[];const r=e.prototype.connectedCallback,a=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__registerHost(){Ff(this,n)},connectedCallback(){(e=>{if(0==(1&Wf.$flags$)){const t=Rf(e),n=t.$cmpMeta$,r=(n.$tagName$,()=>{});1&t.$flags$?(Tf(e,t,n.$listeners$),t.$lazyInstance$):(t.$flags$|=1,12&n.$flags$&&Nf(e),n.$members$&&Object.entries(n.$members$).map((([t,[n]])=>{if(31&n&&e.hasOwnProperty(t)){const n=e[t];delete e[t],e[t]=n}})),If(e,t,n)),r()}})(this),r&&r.call(this)},disconnectedCallback(){(e=>{if(0==(1&Wf.$flags$)){const t=Rf(e);t.$rmListeners$&&(t.$rmListeners$.map((e=>e())),t.$rmListeners$=void 0)}})(this),a&&a.call(this)},__attachShadow(){this.attachShadow({mode:"open",delegatesFocus:!!(16&n.$flags$)})}}),e.is=n.$tagName$,Sf(e,n)},Tf=(e,t,n,r)=>{n&&n.map((([n,r,a])=>{const i=Ef(e,n),o=$f(t,a),s=_f(n);Wf.ael(i,r,o,s),(t.$rmListeners$=t.$rmListeners$||[]).push((()=>Wf.rel(i,r,o,s)))}))},$f=(e,t)=>n=>{try{Sh||e.$hostElement$[t](n)}catch(kp){Mf(kp)}},Ef=(e,t)=>4&t?Lf:8&t?Pf:16&t?Lf.body:e,_f=e=>Vf?{passive:0!=(1&e),capture:0!=(2&e)}:0!=(2&e),Af=new WeakMap,Rf=e=>Af.get(e),Ff=(e,t)=>{const n={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return Tf(e,n,t.$listeners$),Af.set(e,n)},Df=(e,t)=>t in e,Mf=(e,t)=>(0,console.error)(e,t),Of=new Map,zf=[],Pf="undefined"!=typeof window?window:{},Lf=Pf.document||{head:{}},Bf=Pf.HTMLElement||class{},Wf={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,n,r)=>e.addEventListener(t,n,r),rel:(e,t,n,r)=>e.removeEventListener(t,n,r),ce:(e,t)=>new CustomEvent(e,t)},Vf=(()=>{let e=!1;try{Lf.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch(kp){}return e})(),Uf=(()=>{try{return new CSSStyleSheet,"function"==typeof(new CSSStyleSheet).replaceSync}catch(kp){}return!1})(),jf=[],Hf=[],Gf=(e,t)=>n=>{e.push(n),Rh||(Rh=!0,t&&4&Wf.$flags$?Xf(Kf):Wf.raf(Kf))},qf=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(kp){Mf(kp)}e.length=0},Kf=()=>{qf(jf),qf(Hf),(Rh=jf.length>0)&&Wf.raf(Kf)},Xf=e=>(e=>Promise.resolve(e))().then(e),Yf=e("r",Gf(jf,!1)),Qf=e("w",Gf(Hf,!0)),Zf="undefined"!=typeof window?window:void 0,Jf="undefined"!=typeof document?document:void 0,em=e("a",((e,t)=>{e.componentOnReady?e.componentOnReady().then((e=>t(e))):om((()=>t(e)))})),tm=(e,t=[])=>{const n={};return t.forEach((t=>{e.hasAttribute(t)&&(null!==e.getAttribute(t)&&(n[t]=e.getAttribute(t)),e.removeAttribute(t))})),n},nm=["role","aria-activedescendant","aria-atomic","aria-autocomplete","aria-braillelabel","aria-brailleroledescription","aria-busy","aria-checked","aria-colcount","aria-colindex","aria-colindextext","aria-colspan","aria-controls","aria-current","aria-describedby","aria-description","aria-details","aria-disabled","aria-errormessage","aria-expanded","aria-flowto","aria-haspopup","aria-hidden","aria-invalid","aria-keyshortcuts","aria-label","aria-labelledby","aria-level","aria-live","aria-multiline","aria-multiselectable","aria-orientation","aria-owns","aria-placeholder","aria-posinset","aria-pressed","aria-readonly","aria-relevant","aria-required","aria-roledescription","aria-rowcount","aria-rowindex","aria-rowindextext","aria-rowspan","aria-selected","aria-setsize","aria-sort","aria-valuemax","aria-valuemin","aria-valuenow","aria-valuetext"],rm=(e,t)=>{let n=nm;return t&&t.length>0&&(n=n.filter((e=>!t.includes(e)))),tm(e,n)},am=e("b",((e,t,n,r)=>{var a;if("undefined"!=typeof window){const i=window,o=null===(a=null==i?void 0:i.Ionic)||void 0===a?void 0:a.config;if(o){const a=o.get("_ael");if(a)return a(e,t,n,r);if(o._ael)return o._ael(e,t,n,r)}}return e.addEventListener(t,n,r)})),im=e("d",((e,t,n,r)=>{var a;if("undefined"!=typeof window){const i=window,o=null===(a=null==i?void 0:i.Ionic)||void 0===a?void 0:a.config;if(o){const a=o.get("_rel");if(a)return a(e,t,n,r);if(o._rel)return o._rel(e,t,n,r)}}return e.removeEventListener(t,n,r)})),om=e("g",(e=>"function"==typeof __zone_symbol__requestAnimationFrame?__zone_symbol__requestAnimationFrame(e):"function"==typeof requestAnimationFrame?requestAnimationFrame(e):setTimeout(e))),sm=e("c",((e,t,n)=>Math.max(e,Math.min(t,n)))),lm=(e,t)=>{if(!e){const e="ASSERT: "+t;throw console.error(e),new Error(e)}},um=(e("n",(e=>e.timeStamp||Date.now())),e("p",(e=>{if(e){const t=e.changedTouches;if(t&&t.length>0){const e=t[0];return{x:e.clientX,y:e.clientY}}if(void 0!==e.pageX)return{x:e.pageX,y:e.pageY}}return{x:0,y:0}})),(e,t)=>{if(null!=e||(e={}),null!=t||(t={}),e===t)return!0;const n=Object.keys(e);if(n.length!==Object.keys(t).length)return!1;for(const r of n){if(!(r in t))return!1;if(e[r]!==t[r])return!1}return!0});
/*!
             * (C) Ionic http://ionicframework.com - MIT License
             */
let dm;const cm=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),pm=e=>{if(void 0===dm){const t=void 0!==e.style.animationName,n=void 0!==e.style.webkitAnimationName;dm=!t&&n?"-webkit-":""}return dm},hm=(e,t,n)=>{const r=t.startsWith("animation")?pm(e):"";e.style.setProperty(r+t,n)},fm=(e,t)=>{const n=t.startsWith("animation")?pm(e):"";e.style.removeProperty(n+t)},mm=[],gm=(e=[],t)=>{if(void 0!==t){const n=Array.isArray(t)?t:[t];return[...e,...n]}return e},bm=(e("k",(e=>{let t,n,r,a,i,o,s,l,u,d,c,p,h,f=[],m=[],g=[],b=!1,y={},v=[],x=[],w={},k=0,S=!1,I=!1,N=!0,C=!1,T=!0,$=!1;const E=e,_=[],A=[],R=[],F=[],D=[],M=[],O=[],z=[],P=[],L=[],B="function"==typeof AnimationEffect||void 0!==Zf&&"function"==typeof Zf.AnimationEffect,W="function"==typeof Element&&"function"==typeof Element.prototype.animate&&B,V=()=>L,U=e=>{G(),e&&q()},j=(e,t)=>(((null==t?void 0:t.oneTimeCallback)?A:_).push({c:e,o:t}),h),H=()=>(_.length=0,A.length=0,h),G=()=>{if(W)L.forEach((e=>{e.cancel()})),L.length=0;else{const e=R.slice();om((()=>{e.forEach((e=>{fm(e,"animation-name"),fm(e,"animation-duration"),fm(e,"animation-timing-function"),fm(e,"animation-iteration-count"),fm(e,"animation-delay"),fm(e,"animation-play-state"),fm(e,"animation-fill-mode"),fm(e,"animation-direction")}))}))}},q=()=>{D.forEach((e=>{(null==e?void 0:e.parentNode)&&e.parentNode.removeChild(e)})),D.length=0},K=()=>void 0!==i?i:s?s.getFill():"both",X=()=>void 0!==u?u:void 0!==o?o:s?s.getDirection():"normal",Y=()=>S?"linear":void 0!==r?r:s?s.getEasing():"linear",Q=()=>I?0:void 0!==d?d:void 0!==n?n:s?s.getDuration():0,Z=()=>void 0!==a?a:s?s.getIterations():1,J=()=>void 0!==c?c:void 0!==t?t:s?s.getDelay():0,ee=e=>{W?V().forEach((t=>{if(t.effect.setKeyframes)t.effect.setKeyframes(e);else{const n=new KeyframeEffect(t.effect.target,e,t.effect.getTiming());t.effect=n}})):ne()},te=()=>{0!==k&&(k--,0===k&&((()=>{de(),z.forEach((e=>e())),P.forEach((e=>e()));const e=N?1:0,t=v,n=x,r=w;R.forEach((e=>{const a=e.classList;t.forEach((e=>a.add(e))),n.forEach((e=>a.remove(e)));for(const t in r)r.hasOwnProperty(t)&&hm(e,t,r[t])})),_.forEach((t=>t.c(e,h))),A.forEach((t=>t.c(e,h))),A.length=0,T=!0,N&&(C=!0),N=!0})(),s&&s.animationFinish()))},ne=(t=!0)=>{q();const n=(e=>(e.forEach((e=>{for(const t in e)if(e.hasOwnProperty(t)){const n=e[t];if("easing"===t)e["animation-timing-function"]=n,delete e[t];else{const r=cm(t);r!==t&&(e[r]=n,delete e[t])}}})),e))(f);R.forEach((r=>{if(n.length>0){const a=((e=[])=>e.map((e=>{const t=e.offset,n=[];for(const r in e)e.hasOwnProperty(r)&&"offset"!==r&&n.push(`${r}: ${e[r]};`);return`${100*t}% { ${n.join(" ")} }`})).join(" "))(n);p=void 0!==e?e:(e=>{let t=mm.indexOf(e);return t<0&&(t=mm.push(e)-1),`ion-animation-${t}`})(a);const i=((e,t,n)=>{var r;const a=(e=>{const t=void 0!==e.getRootNode?e.getRootNode():e;return t.head||t})(n),i=pm(n),o=a.querySelector("#"+e);if(o)return o;const s=(null!==(r=n.ownerDocument)&&void 0!==r?r:document).createElement("style");return s.id=e,s.textContent=`@${i}keyframes ${e} { ${t} } @${i}keyframes ${e}-alt { ${t} }`,a.appendChild(s),s})(p,a,r);D.push(i),hm(r,"animation-duration",`${Q()}ms`),hm(r,"animation-timing-function",Y()),hm(r,"animation-delay",`${J()}ms`),hm(r,"animation-fill-mode",K()),hm(r,"animation-direction",X());const o=Z()===1/0?"infinite":Z().toString();hm(r,"animation-iteration-count",o),hm(r,"animation-play-state","paused"),t&&hm(r,"animation-name",`${i.id}-alt`),om((()=>{hm(r,"animation-name",i.id||null)}))}}))},re=(e=!0)=>{(()=>{M.forEach((e=>e())),O.forEach((e=>e()));const e=m,t=g,n=y;R.forEach((r=>{const a=r.classList;e.forEach((e=>a.add(e))),t.forEach((e=>a.remove(e)));for(const e in n)n.hasOwnProperty(e)&&hm(r,e,n[e])}))})(),f.length>0&&(W?(R.forEach((e=>{const t=e.animate(f,{id:E,delay:J(),duration:Q(),easing:Y(),iterations:Z(),fill:K(),direction:X()});t.pause(),L.push(t)})),L.length>0&&(L[0].onfinish=()=>{te()})):ne(e)),b=!0},ae=e=>{if(e=Math.min(Math.max(e,0),.9999),W)L.forEach((t=>{t.currentTime=t.effect.getComputedTiming().delay+Q()*e,t.pause()}));else{const t=`-${Q()*e}ms`;R.forEach((e=>{f.length>0&&(hm(e,"animation-delay",t),hm(e,"animation-play-state","paused"))}))}},ie=e=>{L.forEach((e=>{e.effect.updateTiming({delay:J(),duration:Q(),easing:Y(),iterations:Z(),fill:K(),direction:X()})})),void 0!==e&&ae(e)},oe=(e=!0,t)=>{om((()=>{R.forEach((n=>{hm(n,"animation-name",p||null),hm(n,"animation-duration",`${Q()}ms`),hm(n,"animation-timing-function",Y()),hm(n,"animation-delay",void 0!==t?`-${t*Q()}ms`:`${J()}ms`),hm(n,"animation-fill-mode",K()||null),hm(n,"animation-direction",X()||null);const r=Z()===1/0?"infinite":Z().toString();hm(n,"animation-iteration-count",r),e&&hm(n,"animation-name",`${p}-alt`),om((()=>{hm(n,"animation-name",p||null)}))}))}))},se=(e=!1,t=!0,n)=>(e&&F.forEach((r=>{r.update(e,t,n)})),W?ie(n):oe(t,n),h),le=()=>{b&&(W?L.forEach((e=>{e.pause()})):R.forEach((e=>{hm(e,"animation-play-state","paused")})),$=!0)},ue=()=>{l=void 0,te()},de=()=>{l&&clearTimeout(l)},ce=()=>{R.forEach((e=>{fm(e,"animation-duration"),fm(e,"animation-delay"),fm(e,"animation-play-state")}))},pe=e=>new Promise((t=>{(null==e?void 0:e.sync)&&(I=!0,j((()=>I=!1),{oneTimeCallback:!0})),b||re(),C&&(W?(ae(0),ie()):oe(),C=!1),T&&(k=F.length+1,T=!1),j((()=>t()),{oneTimeCallback:!0}),F.forEach((e=>{e.play()})),W?(L.forEach((e=>{e.play()})),0!==f.length&&0!==R.length||te()):(()=>{if(de(),om((()=>{R.forEach((e=>{f.length>0&&hm(e,"animation-play-state","running")}))})),0===f.length||0===R.length)te();else{const e=J()||0,t=Q()||0,n=Z()||1;isFinite(n)&&(l=setTimeout(ue,e+t*n+100)),((e,t)=>{let n;const r={passive:!0},a=()=>{n&&n()},i=n=>{e===n.target&&(a(),t(n))};e&&(e.addEventListener("webkitAnimationEnd",i,r),e.addEventListener("animationend",i,r),n=()=>{e.removeEventListener("webkitAnimationEnd",i,r),e.removeEventListener("animationend",i,r)})})(R[0],(()=>{de(),om((()=>{ce(),om(te)}))}))}})(),$=!1})),he=(e,t)=>{const n=f[0];return void 0===n||void 0!==n.offset&&0!==n.offset?f=[{offset:0,[e]:t},...f]:n[e]=t,h};return h={parentAnimation:s,elements:R,childAnimations:F,id:E,animationFinish:te,from:he,to:(e,t)=>{const n=f[f.length-1];return void 0===n||void 0!==n.offset&&1!==n.offset?f=[...f,{offset:1,[e]:t}]:n[e]=t,h},fromTo:(e,t,n)=>he(e,t).to(e,n),parent:e=>(s=e,h),play:pe,pause:()=>(F.forEach((e=>{e.pause()})),le(),h),stop:()=>{F.forEach((e=>{e.stop()})),b&&(G(),b=!1),S=!1,I=!1,T=!0,u=void 0,d=void 0,c=void 0,k=0,C=!1,N=!0,$=!1},destroy:e=>(F.forEach((t=>{t.destroy(e)})),U(e),R.length=0,F.length=0,f.length=0,H(),b=!1,T=!0,h),keyframes:e=>{const t=f!==e;return f=e,t&&ee(f),h},addAnimation:e=>{if(null!=e)if(Array.isArray(e))for(const t of e)t.parent(h),F.push(t);else e.parent(h),F.push(e);return h},addElement:e=>{if(null!=e)if(1===e.nodeType)R.push(e);else if(e.length>=0)for(let t=0;t<e.length;t++)R.push(e[t]);else console.error("Invalid addElement value");return h},update:se,fill:e=>(i=e,se(!0),h),direction:e=>(o=e,se(!0),h),iterations:e=>(a=e,se(!0),h),duration:e=>(W||0!==e||(e=1),n=e,se(!0),h),easing:e=>(r=e,se(!0),h),delay:e=>(t=e,se(!0),h),getWebAnimations:V,getKeyframes:()=>f,getFill:K,getDirection:X,getDelay:J,getIterations:Z,getEasing:Y,getDuration:Q,afterAddRead:e=>(z.push(e),h),afterAddWrite:e=>(P.push(e),h),afterClearStyles:(e=[])=>{for(const t of e)w[t]="";return h},afterStyles:(e={})=>(w=e,h),afterRemoveClass:e=>(x=gm(x,e),h),afterAddClass:e=>(v=gm(v,e),h),beforeAddRead:e=>(M.push(e),h),beforeAddWrite:e=>(O.push(e),h),beforeClearStyles:(e=[])=>{for(const t of e)y[t]="";return h},beforeStyles:(e={})=>(y=e,h),beforeRemoveClass:e=>(g=gm(g,e),h),beforeAddClass:e=>(m=gm(m,e),h),onFinish:j,isRunning:()=>0!==k&&!$,progressStart:(e=!1,t)=>(F.forEach((n=>{n.progressStart(e,t)})),le(),S=e,b||re(),se(!1,!0,t),h),progressStep:e=>(F.forEach((t=>{t.progressStep(e)})),ae(e),h),progressEnd:(e,t,n)=>(S=!1,F.forEach((r=>{r.progressEnd(e,t,n)})),void 0!==n&&(d=n),C=!1,N=!0,0===e?(u="reverse"===X()?"normal":"reverse","reverse"===u&&(N=!1),W?(se(),ae(1-t)):(c=(1-t)*Q()*-1,se(!1,!1))):1===e&&(W?(se(),ae(t)):(c=t*Q()*-1,se(!1,!1))),void 0!==e&&(j((()=>{d=void 0,u=void 0,c=void 0}),{oneTimeCallback:!0}),s||pe()),h)}})),"ionViewWillLeave"),ym="ionViewDidLeave",vm="ionViewWillUnload",xm=e=>new Promise(((t,n)=>{Qf((()=>{wm(e),km(e).then((n=>{n.animation&&n.animation.destroy(),Sm(e),t(n)}),(t=>{Sm(e),n(t)}))}))})),wm=e=>{const t=e.enteringEl,n=e.leavingEl;Mm(t,n,e.direction),e.showGoBack?t.classList.add("can-go-back"):t.classList.remove("can-go-back"),Dm(t,!1),t.style.setProperty("pointer-events","none"),n&&(Dm(n,!1),n.style.setProperty("pointer-events","none"))},km=async e=>{const t=await Im(e);return t&&Fh?Nm(t,e):Cm(e)},Sm=e=>{const t=e.enteringEl,n=e.leavingEl;t.classList.remove("ion-page-invisible"),t.style.removeProperty("pointer-events"),void 0!==n&&(n.classList.remove("ion-page-invisible"),n.style.removeProperty("pointer-events"))},Im=async e=>{if(e.leavingEl&&e.animated&&0!==e.duration)return e.animationBuilder?e.animationBuilder:"ios"===e.mode?(await yh((()=>t.import("./ios.transition-legacy-dcfe4352.js")))).iosTransitionAnimation:(await yh((()=>t.import("./md.transition-legacy-b8a4e151.js")))).mdTransitionAnimation},Nm=async(e,t)=>{await Tm(t,!0);const n=e(t.baseEl,t);_m(t.enteringEl,t.leavingEl);const r=await Em(n,t);return t.progressCallback&&t.progressCallback(void 0),r&&Am(t.enteringEl,t.leavingEl),{hasCompleted:r,animation:n}},Cm=async e=>{const t=e.enteringEl,n=e.leavingEl;return await Tm(e,!1),_m(t,n),Am(t,n),{hasCompleted:!0}},Tm=async(e,t)=>{(void 0!==e.deepWait?e.deepWait:t)&&await Promise.all([Fm(e.enteringEl),Fm(e.leavingEl)]),await $m(e.viewIsReady,e.enteringEl)},$m=async(e,t)=>{e&&await e(t)},Em=(e,t)=>{const n=t.progressCallback,r=new Promise((t=>{e.onFinish((e=>t(1===e)))}));return n?(e.progressStart(!0),n(e)):e.play(),r},_m=(e,t)=>{Rm(t,bm),Rm(e,"ionViewWillEnter")},Am=(e,t)=>{Rm(e,"ionViewDidEnter"),Rm(t,ym)},Rm=(e,t)=>{if(e){const n=new CustomEvent(t,{bubbles:!1,cancelable:!1});e.dispatchEvent(n)}},Fm=async e=>{const t=e;if(t){if(null!=t.componentOnReady){if(null!=await t.componentOnReady())return}else if(null!=t.__registerHost){const e=new Promise((e=>om(e)));return void(await e)}await Promise.all(Array.from(t.children).map(Fm))}},Dm=(e,t)=>{t?(e.setAttribute("aria-hidden","true"),e.classList.add("ion-page-hidden")):(e.hidden=!1,e.removeAttribute("aria-hidden"),e.classList.remove("ion-page-hidden"))},Mm=(e,t,n)=>{void 0!==e&&(e.style.zIndex="back"===n?"99":"101"),void 0!==t&&(t.style.zIndex="100")},Om=(e("l",(e=>{if(e.classList.contains("ion-page"))return e;const t=e.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs");return t||e})),(e,t,n,r,a)=>Pm(e[1],t[1],n[1],r[1],a).map((a=>zm(e[0],t[0],n[0],r[0],a)))),zm=(e,t,n,r,a)=>a*(3*t*Math.pow(a-1,2)+a*(-3*n*a+3*n+r*a))-e*Math.pow(a-1,3),Pm=(e,t,n,r,a)=>Lm((r-=a)-3*(n-=a)+3*(t-=a)-(e-=a),3*n-6*t+3*e,3*t-3*e,e).filter((e=>e>=0&&e<=1)),Lm=(e,t,n,r)=>{if(0===e)return((e,t,n)=>{const r=t*t-4*e*n;return r<0?[]:[(-t+Math.sqrt(r))/(2*e),(-t-Math.sqrt(r))/(2*e)]})(t,n,r);const a=(3*(n/=e)-(t/=e)*t)/3,i=(2*t*t*t-9*t*n+27*(r/=e))/27;if(0===a)return[Math.pow(-i,1/3)];if(0===i)return[Math.sqrt(-a),-Math.sqrt(-a)];const o=Math.pow(i/2,2)+Math.pow(a/3,3);if(0===o)return[Math.pow(i/2,.5)-t/3];if(o>0)return[Math.pow(-i/2+Math.sqrt(o),1/3)-Math.pow(i/2+Math.sqrt(o),1/3)-t/3];const s=Math.sqrt(Math.pow(-a/3,3)),l=Math.acos(-i/(2*Math.sqrt(Math.pow(-a/3,3)))),u=2*Math.pow(s,1/3);return[u*Math.cos(l/3)-t/3,u*Math.cos((l+2*Math.PI)/3)-t/3,u*Math.cos((l+4*Math.PI)/3)-t/3]};
/*!
             * (C) Ionic http://ionicframework.com - MIT License
             */
class Bm{constructor(){this.m=new Map}reset(e){this.m=new Map(Object.entries(e))}get(e,t){const n=this.m.get(e);return void 0!==n?n:t}getBoolean(e,t=!1){const n=this.m.get(e);return void 0===n?t:"string"==typeof n?"true"===n:!!n}getNumber(e,t){const n=parseFloat(this.m.get(e));return isNaN(n)?void 0!==t?t:NaN:n}set(e,t){this.m.set(e,t)}}const Wm=new Bm,Vm=(e,t)=>e.substr(0,t.length)===t,Um="ionic:",jm="ionic-persist-config",Hm=(e,t)=>("string"==typeof e&&(t=e,e=void 0),(e=>Gm(e))(e).includes(t)),Gm=(e=window)=>{if(void 0===e)return[];e.Ionic=e.Ionic||{};let t=e.Ionic.platforms;return null==t&&(t=e.Ionic.platforms=qm(e),t.forEach((t=>e.document.documentElement.classList.add(`plt-${t}`)))),t},qm=e=>{const t=Wm.get("platform");return Object.keys(ng).filter((n=>{const r=null==t?void 0:t[n];return"function"==typeof r?r(e):ng[n](e)}))},Km=e=>!!eg(e,/iPad/i)||!(!eg(e,/Macintosh/i)||!Ym(e)),Xm=e=>eg(e,/android|sink/i),Ym=e=>tg(e,"(any-pointer:coarse)"),Qm=e=>Zm(e)||Jm(e),Zm=e=>!!(e.cordova||e.phonegap||e.PhoneGap),Jm=e=>{const t=e.Capacitor;return!!(null==t?void 0:t.isNative)},eg=(e,t)=>t.test(e.navigator.userAgent),tg=(e,t)=>{var n;return null===(n=e.matchMedia)||void 0===n?void 0:n.call(e,t).matches},ng={ipad:Km,iphone:e=>eg(e,/iPhone/i),ios:e=>eg(e,/iPhone|iPod/i)||Km(e),android:Xm,phablet:e=>{const t=e.innerWidth,n=e.innerHeight,r=Math.min(t,n),a=Math.max(t,n);return r>390&&r<520&&a>620&&a<800},tablet:e=>{const t=e.innerWidth,n=e.innerHeight,r=Math.min(t,n),a=Math.max(t,n);return Km(e)||(e=>Xm(e)&&!eg(e,/mobile/i))(e)||r>460&&r<820&&a>780&&a<1400},cordova:Zm,capacitor:Jm,electron:e=>eg(e,/electron/i),pwa:e=>{var t;return!(!(null===(t=e.matchMedia)||void 0===t?void 0:t.call(e,"(display-mode: standalone)").matches)&&!e.navigator.standalone)},mobile:Ym,mobileweb:e=>Ym(e)&&!Qm(e),desktop:e=>!Ym(e),hybrid:Qm};let rg;const ag=e=>e&&(e=>Rf(e).$modeName$)(e)||rg,ig=(e={})=>{if("undefined"==typeof window)return;const t=window.document,n=window,r=n.Ionic=n.Ionic||{},a={};var i;e._ael&&(a.ael=e._ael),e._rel&&(a.rel=e._rel),e._ce&&(a.ce=e._ce),i=a,Object.assign(Wf,i);const o=Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},(e=>{try{const t=e.sessionStorage.getItem(jm);return null!==t?JSON.parse(t):{}}catch(kp){return{}}})(n)),{persistConfig:!1}),r.config),(e=>{const t={};return e.location.search.slice(1).split("&").map((e=>e.split("="))).map((([e,t])=>[decodeURIComponent(e),decodeURIComponent(t)])).filter((([e])=>Vm(e,Um))).map((([e,t])=>[e.slice(Um.length),t])).forEach((([e,n])=>{t[e]=n})),t})(n)),e);Wm.reset(o),Wm.getBoolean("persistConfig")&&((e,t)=>{try{e.sessionStorage.setItem(jm,JSON.stringify(t))}catch(kp){return}})(n,o),Gm(n),r.config=Wm,r.mode=rg=Wm.get("mode",t.documentElement.getAttribute("mode")||(Hm(n,"ios")?"ios":"md")),Wm.set("mode",rg),t.documentElement.setAttribute("mode",rg),t.documentElement.classList.add(rg),Wm.getBoolean("_testing")&&Wm.set("animated",!1);const s=e=>{var t;return null===(t=e.tagName)||void 0===t?void 0:t.startsWith("ION-")},l=e=>["ios","md"].includes(e);var u;u=e=>{for(;e;){const t=e.mode||e.getAttribute("mode");if(t){if(l(t))return t;s(e)&&console.warn('Invalid ionic mode: "'+t+'", expected: "ios" or "md"')}e=e.parentElement}return rg},zf.push(u)},og=async(e,t,n,r,a,i)=>{var o;if(e)return e.attachViewToDom(t,n,a,r);if(!(i||"string"==typeof n||n instanceof HTMLElement))throw new Error("framework delegate is missing");const s="string"==typeof n?null===(o=t.ownerDocument)||void 0===o?void 0:o.createElement(n):n;return r&&r.forEach((e=>s.classList.add(e))),a&&Object.assign(s,a),t.appendChild(s),await new Promise((e=>em(s,e))),s},sg=(e,...t)=>console.warn(`[Ionic Warning]: ${e}`,...t);function lg(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n}
/*!
             * (C) Ionic http://ionicframework.com - MIT License
             */
let ug;"function"==typeof SuppressedError&&SuppressedError;const dg=e=>{const t=(()=>{if("undefined"==typeof window)return new Map;if(!ug){const e=window;e.Ionicons=e.Ionicons||{},ug=e.Ionicons.map=e.Ionicons.map||new Map}return ug})().get(e);return t||(e=>{const t=new URL(e,Wf.$resourcesUrl$);return t.origin!==Pf.location.origin?t.href:t.pathname})(`svg/${e}.svg`)},cg=(e,t,n,r,a)=>(n="ios"===(n&&mg(n))?"ios":"md",r&&"ios"===n?e=mg(r):a&&"md"===n?e=mg(a):(e||!t||hg(t)||(e=t),fg(e)&&(e=mg(e))),fg(e)&&""!==e.trim()?""!==e.replace(/[a-z]|-|\d/gi,"")?null:e:null),pg=e=>fg(e)&&(e=e.trim(),hg(e))?e:null,hg=e=>e.length>0&&/(\/|\.)/.test(e),fg=e=>"string"==typeof e,mg=e=>e.toLowerCase(),gg=e=>{if(1===e.nodeType){if("script"===e.nodeName.toLowerCase())return!1;for(let t=0;t<e.attributes.length;t++){const n=e.attributes[t].name;if(fg(n)&&0===n.toLowerCase().indexOf("on"))return!1}for(let t=0;t<e.childNodes.length;t++)if(!gg(e.childNodes[t]))return!1}return!0},bg=new Map,yg=new Map;let vg;const xg=(e,t)=>{let n=yg.get(e);if(!n){if("undefined"==typeof fetch||"undefined"==typeof document)return bg.set(e,""),Promise.resolve();if((e=>e.startsWith("data:image/svg+xml"))(e)&&(e=>-1!==e.indexOf(";utf8,"))(e)){vg||(vg=new DOMParser);const t=vg.parseFromString(e,"text/html").querySelector("svg");return t&&bg.set(e,t.outerHTML),Promise.resolve()}n=fetch(e).then((n=>{if(n.ok)return n.text().then((n=>{n&&!1!==t&&(n=(e=>{const t=document.createElement("div");t.innerHTML=e;for(let r=t.childNodes.length-1;r>=0;r--)"svg"!==t.childNodes[r].nodeName.toLowerCase()&&t.removeChild(t.childNodes[r]);const n=t.firstElementChild;if(n&&"svg"===n.nodeName.toLowerCase()){const e=n.getAttribute("class")||"";if(n.setAttribute("class",(e+" s-ion-icon").trim()),gg(n))return t.innerHTML}return""})(n)),bg.set(e,n||"")}));bg.set(e,"")})),yg.set(e,n)}return n},wg=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.iconName=null,this.inheritedAttributes={},this.isVisible=!1,this.mode=kg(),this.lazy=!1,this.sanitize=!0}componentWillLoad(){this.inheritedAttributes=((e,t=[])=>{const n={};return t.forEach((t=>{e.hasAttribute(t)&&(null!==e.getAttribute(t)&&(n[t]=e.getAttribute(t)),e.removeAttribute(t))})),n})(this.el,["aria-label"])}connectedCallback(){this.waitUntilVisible(this.el,"50px",(()=>{this.isVisible=!0,this.loadIcon()}))}disconnectedCallback(){this.io&&(this.io.disconnect(),this.io=void 0)}waitUntilVisible(e,t,n){if(this.lazy&&"undefined"!=typeof window&&window.IntersectionObserver){const r=this.io=new window.IntersectionObserver((e=>{e[0].isIntersecting&&(r.disconnect(),this.io=void 0,n())}),{rootMargin:t});r.observe(e)}else n()}loadIcon(){if(this.isVisible){const e=(e=>{let t=pg(e.src);if(t)return t;if(t=cg(e.name,e.icon,e.mode,e.ios,e.md),t)return dg(t);if(e.icon){if(t=pg(e.icon),t)return t;if(t=pg(e.icon[e.mode]),t)return t}return null})(this);e&&(bg.has(e)?this.svgContent=bg.get(e):xg(e,this.sanitize).then((()=>this.svgContent=bg.get(e))))}this.iconName=cg(this.name,this.icon,this.mode,this.ios,this.md)}render(){const{iconName:e,el:t,inheritedAttributes:n}=this,r=this.mode||"md",a=this.flipRtl||e&&(e.indexOf("arrow")>-1||e.indexOf("chevron")>-1)&&!1!==this.flipRtl;return zh(Lh,Object.assign({role:"img",class:Object.assign(Object.assign({[r]:!0},Sg(this.color)),{[`icon-${this.size}`]:!!this.size,"flip-rtl":!!a&&(i=t,i&&""!==i.dir?"rtl"===i.dir.toLowerCase():"rtl"===(null===document||void 0===document?void 0:document.dir.toLowerCase()))})},n),this.svgContent?zh("div",{class:"icon-inner",innerHTML:this.svgContent}):zh("div",{class:"icon-inner"}));var i}static get assetsDirs(){return["svg"]}get el(){return this}static get watchers(){return{name:["loadIcon"],src:["loadIcon"],icon:["loadIcon"],ios:["loadIcon"],md:["loadIcon"]}}static get style(){return":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host .ionicon{stroke:currentColor}.ionicon-fill-none{fill:none}.ionicon-stroke-width{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}.icon-inner,.ionicon,svg{display:block;height:100%;width:100%}:host(.flip-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.icon-small){font-size:18px !important}:host(.icon-large){font-size:32px !important}:host(.ion-color){color:var(--ion-color-base) !important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary, #3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary, #0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary, #f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success, #10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning, #ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger, #f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light, #f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium, #989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark, #222428)}"}},[1,"ion-icon",{mode:[1025],color:[1],ios:[1],md:[1],flipRtl:[4,"flip-rtl"],name:[513],src:[1],icon:[8],size:[1],lazy:[4],sanitize:[4],svgContent:[32],isVisible:[32]}]),kg=()=>"undefined"!=typeof document&&document.documentElement.getAttribute("mode")||"md",Sg=e=>e?{"ion-color":!0,[`ion-color-${e}`]:!0}:null,Ig=(e,t)=>null!==t.closest(e),Ng=(e,t)=>"string"==typeof e&&e.length>0?Object.assign({"ion-color":!0,[`ion-color-${e}`]:!0},t):t,Cg=/^[a-z][a-z0-9+\-.]*:/,Tg=async(e,t,n,r)=>{if(null!=e&&"#"!==e[0]&&!Cg.test(e)){const a=document.querySelector("ion-router");if(a)return null!=t&&t.preventDefault(),a.push(e,n,r)}return!1},$g=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.collapse=!1}render(){const e=ag(this);return zh(Lh,{class:{[e]:!0,"buttons-collapse":this.collapse}})}static get style(){return{ios:".sc-ion-buttons-ios-h{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);z-index:99}.sc-ion-buttons-ios-s ion-button{--padding-top:0;--padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}.sc-ion-buttons-ios-s ion-button{--padding-start:5px;--padding-end:5px;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;height:32px}.sc-ion-buttons-ios-s ion-button:not(.button-round){--border-radius:4px}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button{--color:initial;--border-color:initial;--background-focused:var(--ion-color-contrast)}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button-solid,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button-solid{--background:var(--ion-color-contrast);--background-focused:#000;--background-focused-opacity:.12;--background-activated:#000;--background-activated-opacity:.12;--background-hover:var(--ion-color-base);--background-hover-opacity:0.45;--color:var(--ion-color-base);--color-focused:var(--ion-color-base)}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button-clear,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button-clear{--color-activated:var(--ion-color-contrast);--color-focused:var(--ion-color-contrast)}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button-outline,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button-outline{--color-activated:var(--ion-color-base);--color-focused:var(--ion-color-contrast);--background-activated:var(--ion-color-contrast)}.sc-ion-buttons-ios-s .button-clear,.sc-ion-buttons-ios-s .button-outline{--background-activated:transparent;--background-focused:currentColor;--background-hover:transparent}.sc-ion-buttons-ios-s .button-solid:not(.ion-color){--background-focused:#000;--background-focused-opacity:.12;--background-activated:#000;--background-activated-opacity:.12}.sc-ion-buttons-ios-s ion-icon[slot=start]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-end:0.3em;margin-inline-end:0.3em;font-size:24px;line-height:0.67}.sc-ion-buttons-ios-s ion-icon[slot=end]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-start:0.4em;margin-inline-start:0.4em;font-size:24px;line-height:0.67}.sc-ion-buttons-ios-s ion-icon[slot=icon-only]{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;font-size:28px;line-height:0.67}",md:".sc-ion-buttons-md-h{display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);z-index:99}.sc-ion-buttons-md-s ion-button{--padding-top:0;--padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}.sc-ion-buttons-md-s ion-button{--padding-top:0;--padding-bottom:0;--padding-start:8px;--padding-end:8px;--box-shadow:none;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;height:32px}.sc-ion-buttons-md-s ion-button:not(.button-round){--border-radius:2px}.sc-ion-buttons-md-h.ion-color.sc-ion-buttons-md-s .button,.ion-color .sc-ion-buttons-md-h.sc-ion-buttons-md-s .button{--color:initial;--color-focused:var(--ion-color-contrast);--color-hover:var(--ion-color-contrast);--background-activated:transparent;--background-focused:var(--ion-color-contrast);--background-hover:var(--ion-color-contrast)}.sc-ion-buttons-md-h.ion-color.sc-ion-buttons-md-s .button-solid,.ion-color .sc-ion-buttons-md-h.sc-ion-buttons-md-s .button-solid{--background:var(--ion-color-contrast);--background-activated:transparent;--background-focused:var(--ion-color-shade);--background-hover:var(--ion-color-base);--color:var(--ion-color-base);--color-focused:var(--ion-color-base);--color-hover:var(--ion-color-base)}.sc-ion-buttons-md-h.ion-color.sc-ion-buttons-md-s .button-outline,.ion-color .sc-ion-buttons-md-h.sc-ion-buttons-md-s .button-outline{--border-color:var(--ion-color-contrast)}.sc-ion-buttons-md-s .button-has-icon-only.button-clear{--padding-top:12px;--padding-end:12px;--padding-bottom:12px;--padding-start:12px;--border-radius:50%;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;width:48px;height:48px}.sc-ion-buttons-md-s .button{--background-hover:currentColor}.sc-ion-buttons-md-s .button-solid{--color:var(--ion-toolbar-background, var(--ion-background-color, #fff));--background:var(--ion-toolbar-color, var(--ion-text-color, #424242));--background-activated:transparent;--background-focused:currentColor}.sc-ion-buttons-md-s .button-outline{--color:initial;--background:transparent;--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor;--border-color:currentColor}.sc-ion-buttons-md-s .button-clear{--color:initial;--background:transparent;--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor}.sc-ion-buttons-md-s ion-icon[slot=start]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-end:0.3em;margin-inline-end:0.3em;font-size:1.4em}.sc-ion-buttons-md-s ion-icon[slot=end]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-margin-start:0.4em;margin-inline-start:0.4em;font-size:1.4em}.sc-ion-buttons-md-s ion-icon[slot=icon-only]{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;font-size:1.8em}"}}},[34,"ion-buttons",{collapse:[4]}]),Eg=function(){"undefined"!=typeof customElements&&["ion-buttons"].forEach((e=>{"ion-buttons"===e&&(customElements.get(e)||customElements.define(e,$g))}))}
/*!
             * (C) Ionic http://ionicframework.com - MIT License
             */,_g=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.type="bounded"}async addRipple(e,t){return new Promise((n=>{Yf((()=>{const r=this.el.getBoundingClientRect(),a=r.width,i=r.height,o=Math.sqrt(a*a+i*i),s=Math.max(i,a),l=this.unbounded?s:o+Rg,u=Math.floor(s*Fg),d=l/u;let c=e-r.left,p=t-r.top;this.unbounded&&(c=.5*a,p=.5*i);const h=c-.5*u,f=p-.5*u,m=.5*a-c,g=.5*i-p;Qf((()=>{const e=document.createElement("div");e.classList.add("ripple-effect");const t=e.style;t.top=f+"px",t.left=h+"px",t.width=t.height=u+"px",t.setProperty("--final-scale",`${d}`),t.setProperty("--translate-end",`${m}px, ${g}px`),(this.el.shadowRoot||this.el).appendChild(e),setTimeout((()=>{n((()=>{Ag(e)}))}),325)}))}))}))}get unbounded(){return"unbounded"===this.type}render(){const e=ag(this);return zh(Lh,{role:"presentation",class:{[e]:!0,unbounded:this.unbounded}})}get el(){return this}static get style(){return":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:strict;pointer-events:none}:host(.unbounded){contain:layout size style}.ripple-effect{border-radius:50%;position:absolute;background-color:currentColor;color:inherit;contain:strict;opacity:0;-webkit-animation:225ms rippleAnimation forwards, 75ms fadeInAnimation forwards;animation:225ms rippleAnimation forwards, 75ms fadeInAnimation forwards;will-change:transform, opacity;pointer-events:none}.fade-out{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1));-webkit-animation:150ms fadeOutAnimation forwards;animation:150ms fadeOutAnimation forwards}@-webkit-keyframes rippleAnimation{from{-webkit-animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1))}}@keyframes rippleAnimation{from{-webkit-animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);-webkit-transform:scale(1);transform:scale(1)}to{-webkit-transform:translate(var(--translate-end)) scale(var(--final-scale, 1));transform:translate(var(--translate-end)) scale(var(--final-scale, 1))}}@-webkit-keyframes fadeInAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:0.16}}@keyframes fadeInAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0}to{opacity:0.16}}@-webkit-keyframes fadeOutAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0.16}to{opacity:0}}@keyframes fadeOutAnimation{from{-webkit-animation-timing-function:linear;animation-timing-function:linear;opacity:0.16}to{opacity:0}}"}},[1,"ion-ripple-effect",{type:[1],addRipple:[64]}]),Ag=e=>{e.classList.add("fade-out"),setTimeout((()=>{e.remove()}),200)},Rg=10,Fg=.5;function Dg(){"undefined"!=typeof customElements&&["ion-ripple-effect"].forEach((e=>{"ion-ripple-effect"===e&&(customElements.get(e)||customElements.define(e,_g))}))}
/*!
             * (C) Ionic http://ionicframework.com - MIT License
             */const Mg={xs:"(min-width: 0px)",sm:"(min-width: 576px)",md:"(min-width: 768px)",lg:"(min-width: 992px)",xl:"(min-width: 1200px)"},Og=e=>{if(void 0===e||""===e)return!0;if(window.matchMedia){const t=Mg[e];return window.matchMedia(t).matches}return!1},zg="undefined"!=typeof window?window:void 0,Pg=zg&&!!(zg.CSS&&zg.CSS.supports&&zg.CSS.supports("--a: 0")),Lg=["","xs","sm","md","lg","xl"],Bg=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.offset=void 0,this.offsetXs=void 0,this.offsetSm=void 0,this.offsetMd=void 0,this.offsetLg=void 0,this.offsetXl=void 0,this.pull=void 0,this.pullXs=void 0,this.pullSm=void 0,this.pullMd=void 0,this.pullLg=void 0,this.pullXl=void 0,this.push=void 0,this.pushXs=void 0,this.pushSm=void 0,this.pushMd=void 0,this.pushLg=void 0,this.pushXl=void 0,this.size=void 0,this.sizeXs=void 0,this.sizeSm=void 0,this.sizeMd=void 0,this.sizeLg=void 0,this.sizeXl=void 0}onResize(){xf(this)}getColumns(e){let t;for(const n of Lg){const r=Og(n),a=this[e+n.charAt(0).toUpperCase()+n.slice(1)];r&&void 0!==a&&(t=a)}return t}calculateSize(){const e=this.getColumns("size");if(!e||""===e)return;const t="auto"===e?"auto":Pg?`calc(calc(${e} / var(--ion-grid-columns, 12)) * 100%)`:e/12*100+"%";return{flex:`0 0 ${t}`,width:`${t}`,"max-width":`${t}`}}calculatePosition(e,t){const n=this.getColumns(e);if(n)return{[t]:Pg?`calc(calc(${n} / var(--ion-grid-columns, 12)) * 100%)`:n>0&&n<12?n/12*100+"%":"auto"}}calculateOffset(e){return this.calculatePosition("offset",e?"margin-right":"margin-left")}calculatePull(e){return this.calculatePosition("pull",e?"left":"right")}calculatePush(e){return this.calculatePosition("push",e?"right":"left")}render(){const e="rtl"===document.dir,t=ag(this);return zh(Lh,{class:{[t]:!0},style:Object.assign(Object.assign(Object.assign(Object.assign({},this.calculateOffset(e)),this.calculatePull(e)),this.calculatePush(e)),this.calculateSize())},zh("slot",null))}static get style(){return":host{-webkit-padding-start:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-box-sizing:border-box;box-sizing:border-box;position:relative;-ms-flex-preferred-size:0;flex-basis:0;-ms-flex-positive:1;flex-grow:1;width:100%;max-width:100%;min-height:1px}@media (min-width: 576px){:host{-webkit-padding-start:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px))}}@media (min-width: 768px){:host{-webkit-padding-start:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px))}}@media (min-width: 992px){:host{-webkit-padding-start:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px))}}@media (min-width: 1200px){:host{-webkit-padding-start:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px))}}"}},[1,"ion-col",{offset:[1],offsetXs:[1,"offset-xs"],offsetSm:[1,"offset-sm"],offsetMd:[1,"offset-md"],offsetLg:[1,"offset-lg"],offsetXl:[1,"offset-xl"],pull:[1],pullXs:[1,"pull-xs"],pullSm:[1,"pull-sm"],pullMd:[1,"pull-md"],pullLg:[1,"pull-lg"],pullXl:[1,"pull-xl"],push:[1],pushXs:[1,"push-xs"],pushSm:[1,"push-sm"],pushMd:[1,"push-md"],pushLg:[1,"push-lg"],pushXl:[1,"push-xl"],size:[1],sizeXs:[1,"size-xs"],sizeSm:[1,"size-sm"],sizeMd:[1,"size-md"],sizeLg:[1,"size-lg"],sizeXl:[1,"size-xl"]},[[9,"resize","onResize"]]]),Wg=function(){"undefined"!=typeof customElements&&["ion-col"].forEach((e=>{"ion-col"===e&&(customElements.get(e)||customElements.define(e,Bg))}))},Vg=e("i",(e=>e&&""!==e.dir?"rtl"===e.dir.toLowerCase():"rtl"===(null===document||void 0===document?void 0:document.dir.toLowerCase()))),Ug=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.ionScrollStart=Uh(this,"ionScrollStart",7),this.ionScroll=Uh(this,"ionScroll",7),this.ionScrollEnd=Uh(this,"ionScrollEnd",7),this.watchDog=null,this.isScrolling=!1,this.lastScroll=0,this.queued=!1,this.cTop=-1,this.cBottom=-1,this.isMainContent=!0,this.resizeTimeout=null,this.detail={scrollTop:0,scrollLeft:0,type:"scroll",event:void 0,startX:0,startY:0,startTime:0,currentX:0,currentY:0,velocityX:0,velocityY:0,deltaX:0,deltaY:0,currentTime:0,data:void 0,isScrolling:!0},this.color=void 0,this.fullscreen=!1,this.forceOverscroll=void 0,this.scrollX=!1,this.scrollY=!0,this.scrollEvents=!1}connectedCallback(){this.isMainContent=null===this.el.closest("ion-menu, ion-popover, ion-modal")}disconnectedCallback(){this.onScrollEnd()}onAppLoad(){this.resize()}onResize(){this.resizeTimeout&&(clearTimeout(this.resizeTimeout),this.resizeTimeout=null),this.resizeTimeout=setTimeout((()=>{null!==this.el.offsetParent&&this.resize()}),100)}shouldForceOverscroll(){const{forceOverscroll:e}=this,t=ag(this);return void 0===e?"ios"===t&&Hm("ios"):e}resize(){this.fullscreen?Yf((()=>this.readDimensions())):0===this.cTop&&0===this.cBottom||(this.cTop=this.cBottom=0,xf(this))}readDimensions(){const e=jg(this.el),t=Math.max(this.el.offsetTop,0),n=Math.max(e.offsetHeight-t-this.el.offsetHeight,0);(t!==this.cTop||n!==this.cBottom)&&(this.cTop=t,this.cBottom=n,xf(this))}onScroll(e){const t=Date.now(),n=!this.isScrolling;this.lastScroll=t,n&&this.onScrollStart(),!this.queued&&this.scrollEvents&&(this.queued=!0,Yf((t=>{this.queued=!1,this.detail.event=e,Hg(this.detail,this.scrollEl,t,n),this.ionScroll.emit(this.detail)})))}async getScrollElement(){return this.scrollEl||await new Promise((e=>em(this.el,e))),Promise.resolve(this.scrollEl)}async getBackgroundElement(){return this.backgroundContentEl||await new Promise((e=>em(this.el,e))),Promise.resolve(this.backgroundContentEl)}scrollToTop(e=0){return this.scrollToPoint(void 0,0,e)}async scrollToBottom(e=0){const t=await this.getScrollElement(),n=t.scrollHeight-t.clientHeight;return this.scrollToPoint(void 0,n,e)}async scrollByPoint(e,t,n){const r=await this.getScrollElement();return this.scrollToPoint(e+r.scrollLeft,t+r.scrollTop,n)}async scrollToPoint(e,t,n=0){const r=await this.getScrollElement();if(n<32)return null!=t&&(r.scrollTop=t),void(null!=e&&(r.scrollLeft=e));let a,i=0;const o=new Promise((e=>a=e)),s=r.scrollTop,l=r.scrollLeft,u=null!=t?t-s:0,d=null!=e?e-l:0,c=e=>{const t=Math.min(1,(e-i)/n)-1,o=Math.pow(t,3)+1;0!==u&&(r.scrollTop=Math.floor(o*u+s)),0!==d&&(r.scrollLeft=Math.floor(o*d+l)),o<1?requestAnimationFrame(c):a()};return requestAnimationFrame((e=>{i=e,c(e)})),o}onScrollStart(){this.isScrolling=!0,this.ionScrollStart.emit({isScrolling:!0}),this.watchDog&&clearInterval(this.watchDog),this.watchDog=setInterval((()=>{this.lastScroll<Date.now()-120&&this.onScrollEnd()}),100)}onScrollEnd(){this.watchDog&&clearInterval(this.watchDog),this.watchDog=null,this.isScrolling&&(this.isScrolling=!1,this.ionScrollEnd.emit({isScrolling:!1}))}render(){const{isMainContent:e,scrollX:t,scrollY:n,el:r}=this,a=Vg(r)?"rtl":"ltr",i=ag(this),o=this.shouldForceOverscroll(),s="ios"===i,l=e?"main":"div";return this.resize(),zh(Lh,{class:Ng(this.color,{[i]:!0,"content-sizing":Ig("ion-popover",this.el),overscroll:o,[`content-${a}`]:!0}),style:{"--offset-top":`${this.cTop}px`,"--offset-bottom":`${this.cBottom}px`}},zh("div",{ref:e=>this.backgroundContentEl=e,id:"background-content",part:"background"}),zh(l,{class:{"inner-scroll":!0,"scroll-x":t,"scroll-y":n,overscroll:(t||n)&&o},ref:e=>this.scrollEl=e,onScroll:this.scrollEvents?e=>this.onScroll(e):void 0,part:"scroll"},zh("slot",null)),s?zh("div",{class:"transition-effect"},zh("div",{class:"transition-cover"}),zh("div",{class:"transition-shadow"})):null,zh("slot",{name:"fixed"}))}get el(){return this}static get style(){return':host{--background:var(--ion-background-color, #fff);--color:var(--ion-text-color, #000);--padding-top:0px;--padding-bottom:0px;--padding-start:0px;--padding-end:0px;--keyboard-offset:0px;--offset-top:0px;--offset-bottom:0px;--overflow:auto;display:block;position:relative;-ms-flex:1;flex:1;width:100%;height:100%;margin:0 !important;padding:0 !important;font-family:var(--ion-font-family, inherit);contain:size style}:host(.ion-color) .inner-scroll{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.outer-content){--background:var(--ion-color-step-50, #f2f2f2)}#background-content{left:0px;right:0px;top:calc(var(--offset-top) * -1);bottom:calc(var(--offset-bottom) * -1);position:absolute;background:var(--background)}.inner-scroll{left:0px;right:0px;top:calc(var(--offset-top) * -1);bottom:calc(var(--offset-bottom) * -1);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:calc(var(--padding-top) + var(--offset-top));padding-bottom:calc(var(--padding-bottom) + var(--keyboard-offset) + var(--offset-bottom));position:absolute;color:var(--color);-webkit-box-sizing:border-box;box-sizing:border-box;overflow:hidden;-ms-touch-action:pan-x pan-y pinch-zoom;touch-action:pan-x pan-y pinch-zoom}.scroll-y,.scroll-x{-webkit-overflow-scrolling:touch;z-index:0;will-change:scroll-position}.scroll-y{overflow-y:var(--overflow);overscroll-behavior-y:contain}.scroll-x{overflow-x:var(--overflow);overscroll-behavior-x:contain}.overscroll::before,.overscroll::after{position:absolute;width:1px;height:1px;content:""}.overscroll::before{bottom:-1px}.overscroll::after{top:-1px}:host(.content-sizing){display:-ms-flexbox;display:flex;-ms-flex-direction:column;flex-direction:column;min-height:0;contain:none}:host(.content-sizing) .inner-scroll{position:relative;top:0;bottom:0;margin-top:calc(var(--offset-top) * -1);margin-bottom:calc(var(--offset-bottom) * -1)}.transition-effect{display:none;position:absolute;width:100%;height:100vh;opacity:0;pointer-events:none}:host(.content-ltr) .transition-effect{left:-100%;}:host(.content-rtl) .transition-effect{right:-100%;}.transition-cover{position:absolute;right:0;width:100%;height:100%;background:black;opacity:0.1}.transition-shadow{display:block;position:absolute;width:100%;height:100%;-webkit-box-shadow:inset -9px 0 9px 0 rgba(0, 0, 100, 0.03);box-shadow:inset -9px 0 9px 0 rgba(0, 0, 100, 0.03)}:host(.content-ltr) .transition-shadow{right:0;}:host(.content-rtl) .transition-shadow{left:0;-webkit-transform:scaleX(-1);transform:scaleX(-1)}::slotted([slot=fixed]){position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0)}'}},[1,"ion-content",{color:[513],fullscreen:[4],forceOverscroll:[1028,"force-overscroll"],scrollX:[4,"scroll-x"],scrollY:[4,"scroll-y"],scrollEvents:[4,"scroll-events"],getScrollElement:[64],getBackgroundElement:[64],scrollToTop:[64],scrollToBottom:[64],scrollByPoint:[64],scrollToPoint:[64]},[[8,"appload","onAppLoad"],[9,"resize","onResize"]]]),jg=e=>{const t=e.closest("ion-tabs");if(t)return t;const n=e.closest("ion-app, ion-page, .ion-page, page-inner, .popover-content");return n||(e=>{var t;return e.parentElement?e.parentElement:(null===(t=e.parentNode)||void 0===t?void 0:t.host)?e.parentNode.host:null})(e)},Hg=(e,t,n,r)=>{const a=e.currentX,i=e.currentY,o=e.currentTime,s=t.scrollLeft,l=t.scrollTop,u=n-o;if(r&&(e.startTime=n,e.startX=s,e.startY=l,e.velocityX=e.velocityY=0),e.currentTime=n,e.currentX=e.scrollLeft=s,e.currentY=e.scrollTop=l,e.deltaX=s-e.startX,e.deltaY=l-e.startY,u>0&&u<100){const t=(s-a)/u,n=(l-i)/u;e.velocityX=.7*t+.3*e.velocityX,e.velocityY=.7*n+.3*e.velocityY}},Gg=function(){"undefined"!=typeof customElements&&["ion-content"].forEach((e=>{"ion-content"===e&&(customElements.get(e)||customElements.define(e,Ug))}))},qg=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.ionFocus=Uh(this,"ionFocus",7),this.ionBlur=Uh(this,"ionBlur",7),this.inItem=!1,this.inListHeader=!1,this.inToolbar=!1,this.inheritedAttributes={},this.handleClick=e=>{const{el:t}=this;if("button"===this.type)Tg(this.href,e,this.routerDirection,this.routerAnimation);else if((e=>!!e.shadowRoot&&!!e.attachShadow)(t)){let n=this.findForm();const{form:r}=this;if(!n&&void 0!==r)return void sg("string"==typeof r?`Form with selector: "#${r}" could not be found. Verify that the id is correct and the form is rendered in the DOM.`:'The provided "form" element is invalid. Verify that the form is a HTMLFormElement and rendered in the DOM.',t);if(n||(n=t.closest("form")),n){e.preventDefault();const t=document.createElement("button");t.type=this.type,t.style.display="none",n.appendChild(t),t.click(),t.remove()}}},this.onFocus=()=>{this.ionFocus.emit()},this.onBlur=()=>{this.ionBlur.emit()},this.color=void 0,this.buttonType="button",this.disabled=!1,this.expand=void 0,this.fill=void 0,this.routerDirection="forward",this.routerAnimation=void 0,this.download=void 0,this.href=void 0,this.rel=void 0,this.shape=void 0,this.size=void 0,this.strong=!1,this.target=void 0,this.type="button",this.form=void 0}componentWillLoad(){this.inToolbar=!!this.el.closest("ion-buttons"),this.inListHeader=!!this.el.closest("ion-list-header"),this.inItem=!!this.el.closest("ion-item")||!!this.el.closest("ion-item-divider"),this.inheritedAttributes=rm(this.el)}get hasIconOnly(){return!!this.el.querySelector('[slot="icon-only"]')}get rippleType(){return(void 0===this.fill||"clear"===this.fill)&&this.hasIconOnly&&this.inToolbar?"unbounded":"bounded"}findForm(){const{form:e}=this;if(e instanceof HTMLFormElement)return e;if("string"==typeof e){const t=document.getElementById(e);if(t instanceof HTMLFormElement)return t}return null}render(){const e=ag(this),{buttonType:t,type:n,disabled:r,rel:a,target:i,size:o,href:s,color:l,expand:u,hasIconOnly:d,shape:c,strong:p,inheritedAttributes:h}=this,f=void 0===o&&this.inItem?"small":o,m=void 0===s?"button":"a",g="button"===m?{type:n}:{download:this.download,href:s,rel:a,target:i};let b=this.fill;return null==b&&(b=this.inToolbar||this.inListHeader?"clear":"solid"),zh(Lh,{onClick:this.handleClick,"aria-disabled":r?"true":null,class:Ng(l,{[e]:!0,[t]:!0,[`${t}-${u}`]:void 0!==u,[`${t}-${f}`]:void 0!==f,[`${t}-${c}`]:void 0!==c,[`${t}-${b}`]:!0,[`${t}-strong`]:p,"in-toolbar":Ig("ion-toolbar",this.el),"in-toolbar-color":Ig("ion-toolbar[color]",this.el),"in-buttons":Ig("ion-buttons",this.el),"button-has-icon-only":d,"button-disabled":r,"ion-activatable":!0,"ion-focusable":!0})},zh(m,Object.assign({},g,{class:"button-native",part:"native",disabled:r,onFocus:this.onFocus,onBlur:this.onBlur},h),zh("span",{class:"button-inner"},zh("slot",{name:"icon-only"}),zh("slot",{name:"start"}),zh("slot",null),zh("slot",{name:"end"})),"md"===e&&zh("ion-ripple-effect",{type:this.rippleType})))}get el(){return this}static get style(){return{ios:':host{--overflow:hidden;--ripple-color:currentColor;--border-width:initial;--border-color:initial;--border-style:initial;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--box-shadow:none;display:inline-block;width:auto;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;text-overflow:ellipsis;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:top;vertical-align:-webkit-baseline-middle;-webkit-font-kerning:none;font-kerning:none}:host(.button-disabled){cursor:default;opacity:0.5;pointer-events:none}:host(.button-solid){--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff)}:host(.button-outline){--border-color:var(--ion-color-primary, #3880ff);--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-clear){--border-width:0;--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-block){display:block}:host(.button-block) .button-native{margin-left:0;margin-right:0;display:block;width:100%;clear:both;contain:content}:host(.button-block) .button-native::after{clear:both}:host(.button-full){display:block}:host(.button-full) .button-native{margin-left:0;margin-right:0;display:block;width:100%;contain:content}:host(.button-full:not(.button-round)) .button-native{border-radius:0;border-right-width:0;border-left-width:0}.button-native{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);line-height:1;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);contain:layout style;cursor:pointer;opacity:var(--opacity);overflow:var(--overflow);z-index:0;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}.button-native::-moz-focus-inner{border:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}::slotted(ion-icon){font-size:1.4em;pointer-events:none}::slotted(ion-icon[slot=start]){-webkit-margin-start:-0.3em;margin-inline-start:-0.3em;-webkit-margin-end:0.3em;margin-inline-end:0.3em;margin-top:0;margin-bottom:0}::slotted(ion-icon[slot=end]){-webkit-margin-start:0.3em;margin-inline-start:0.3em;-webkit-margin-end:-0.2em;margin-inline-end:-0.2em;margin-top:0;margin-bottom:0}::slotted(ion-icon[slot=icon-only]){font-size:1.8em}ion-ripple-effect{color:var(--ripple-color)}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}:host(.ion-focused){color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){:host(:hover){color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.ion-activated){color:var(--color-activated)}:host(.ion-activated) .button-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.button-solid.ion-color) .button-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.button-outline.ion-color) .button-native{border-color:var(--ion-color-base);background:transparent;color:var(--ion-color-base)}:host(.button-clear.ion-color) .button-native{background:transparent;color:var(--ion-color-base)}:host(.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{color:var(--ion-toolbar-color, var(--color))}:host(.button-outline.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{border-color:var(--ion-toolbar-color, var(--color, var(--border-color)))}:host(.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--background));color:var(--ion-toolbar-background, var(--color))}:host(.button-outline.ion-activated.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--color));color:var(--ion-toolbar-background, var(--background), var(--ion-color-primary-contrast, #fff))}:host{--border-radius:14px;--padding-top:0;--padding-bottom:0;--padding-start:1em;--padding-end:1em;--transition:background-color, opacity 100ms linear;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;margin-top:4px;margin-bottom:4px;height:3.1em;font-size:16px;font-weight:500;letter-spacing:0}:host(.in-buttons){font-size:17px;font-weight:400}:host(.button-solid){--background-activated:var(--ion-color-primary-shade, #3171e0);--background-focused:var(--ion-color-primary-shade, #3171e0);--background-hover:var(--ion-color-primary-tint, #4c8dff);--background-activated-opacity:1;--background-focused-opacity:1;--background-hover-opacity:1}:host(.button-outline){--border-radius:14px;--border-width:1px;--border-style:solid;--background-activated:var(--ion-color-primary, #3880ff);--background-focused:var(--ion-color-primary, #3880ff);--background-hover:transparent;--background-focused-opacity:.1;--color-activated:var(--ion-color-primary-contrast, #fff)}:host(.button-clear){--background-activated:transparent;--background-activated-opacity:0;--background-focused:var(--ion-color-primary, #3880ff);--background-hover:transparent;--background-focused-opacity:.1;font-size:17px;font-weight:normal}:host(.button-large){--border-radius:16px;--padding-top:0;--padding-start:1em;--padding-end:1em;--padding-bottom:0;height:3.1em;font-size:20px}:host(.button-small){--border-radius:6px;--padding-top:0;--padding-start:0.9em;--padding-end:0.9em;--padding-bottom:0;height:2.1em;font-size:13px}:host(.button-round){--border-radius:64px;--padding-top:0;--padding-start:26px;--padding-end:26px;--padding-bottom:0}:host(.button-strong){font-weight:600}:host(.button-outline.ion-focused.ion-color) .button-native,:host(.button-clear.ion-focused.ion-color) .button-native{color:var(--ion-color-base)}:host(.button-outline.ion-focused.ion-color) .button-native::after,:host(.button-clear.ion-focused.ion-color) .button-native::after{background:var(--ion-color-base)}:host(.button-solid.ion-color.ion-focused) .button-native::after{background:var(--ion-color-shade)}@media (any-hover: hover){:host(.button-clear:not(.ion-activated):hover),:host(.button-outline:not(.ion-activated):hover){opacity:0.6}:host(.button-clear.ion-color:hover) .button-native,:host(.button-outline.ion-color:hover) .button-native{color:var(--ion-color-base)}:host(.button-clear.ion-color:hover) .button-native::after,:host(.button-outline.ion-color:hover) .button-native::after{background:transparent}:host(.button-solid.ion-color:hover) .button-native::after{background:var(--ion-color-tint)}:host(:hover.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color):not(.ion-activated)) .button-native::after{background:#fff;opacity:0.1}}:host(.button-clear.ion-activated){opacity:0.4}:host(.button-outline.ion-activated.ion-color) .button-native{color:var(--ion-color-contrast)}:host(.button-outline.ion-activated.ion-color) .button-native::after{background:var(--ion-color-base)}:host(.button-solid.ion-color.ion-activated) .button-native::after{background:var(--ion-color-shade)}',md:':host{--overflow:hidden;--ripple-color:currentColor;--border-width:initial;--border-color:initial;--border-style:initial;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--box-shadow:none;display:inline-block;width:auto;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;text-overflow:ellipsis;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:top;vertical-align:-webkit-baseline-middle;-webkit-font-kerning:none;font-kerning:none}:host(.button-disabled){cursor:default;opacity:0.5;pointer-events:none}:host(.button-solid){--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff)}:host(.button-outline){--border-color:var(--ion-color-primary, #3880ff);--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-clear){--border-width:0;--background:transparent;--color:var(--ion-color-primary, #3880ff)}:host(.button-block){display:block}:host(.button-block) .button-native{margin-left:0;margin-right:0;display:block;width:100%;clear:both;contain:content}:host(.button-block) .button-native::after{clear:both}:host(.button-full){display:block}:host(.button-full) .button-native{margin-left:0;margin-right:0;display:block;width:100%;contain:content}:host(.button-full:not(.button-round)) .button-native{border-radius:0;border-right-width:0;border-left-width:0}.button-native{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;-webkit-transition:var(--transition);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);line-height:1;-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);contain:layout style;cursor:pointer;opacity:var(--opacity);overflow:var(--overflow);z-index:0;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:none;-moz-appearance:none;appearance:none}.button-native::-moz-focus-inner{border:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}::slotted(ion-icon){font-size:1.4em;pointer-events:none}::slotted(ion-icon[slot=start]){-webkit-margin-start:-0.3em;margin-inline-start:-0.3em;-webkit-margin-end:0.3em;margin-inline-end:0.3em;margin-top:0;margin-bottom:0}::slotted(ion-icon[slot=end]){-webkit-margin-start:0.3em;margin-inline-start:0.3em;-webkit-margin-end:-0.2em;margin-inline-end:-0.2em;margin-top:0;margin-bottom:0}::slotted(ion-icon[slot=icon-only]){font-size:1.8em}ion-ripple-effect{color:var(--ripple-color)}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}:host(.ion-focused){color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){:host(:hover){color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.ion-activated){color:var(--color-activated)}:host(.ion-activated) .button-native::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}:host(.button-solid.ion-color) .button-native{background:var(--ion-color-base);color:var(--ion-color-contrast)}:host(.button-outline.ion-color) .button-native{border-color:var(--ion-color-base);background:transparent;color:var(--ion-color-base)}:host(.button-clear.ion-color) .button-native{background:transparent;color:var(--ion-color-base)}:host(.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{color:var(--ion-toolbar-color, var(--color))}:host(.button-outline.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{border-color:var(--ion-toolbar-color, var(--color, var(--border-color)))}:host(.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--background));color:var(--ion-toolbar-background, var(--color))}:host(.button-outline.ion-activated.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native{background:var(--ion-toolbar-color, var(--color));color:var(--ion-toolbar-background, var(--background), var(--ion-color-primary-contrast, #fff))}:host{--border-radius:4px;--padding-top:0;--padding-bottom:0;--padding-start:1.1em;--padding-end:1.1em;--transition:box-shadow 280ms cubic-bezier(.4, 0, .2, 1),\n                background-color 15ms linear,\n                color 15ms linear;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px;margin-top:4px;margin-bottom:4px;height:36px;font-size:14px;font-weight:500;letter-spacing:0.06em;text-transform:uppercase}:host(.button-solid){--background-activated:transparent;--background-hover:var(--ion-color-primary-contrast, #fff);--background-focused:var(--ion-color-primary-contrast, #fff);--background-activated-opacity:0;--background-focused-opacity:.24;--background-hover-opacity:.08;--box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)}:host(.button-solid.ion-activated){--box-shadow:0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12)}:host(.button-outline){--border-width:2px;--border-style:solid;--box-shadow:none;--background-activated:transparent;--background-focused:var(--ion-color-primary, #3880ff);--background-hover:var(--ion-color-primary, #3880ff);--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04}:host(.button-outline.ion-activated.ion-color) .button-native{background:transparent}:host(.button-clear){--background-activated:transparent;--background-focused:var(--ion-color-primary, #3880ff);--background-hover:var(--ion-color-primary, #3880ff);--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04}:host(.button-round){--border-radius:64px;--padding-top:0;--padding-start:26px;--padding-end:26px;--padding-bottom:0}:host(.button-large){--padding-top:0;--padding-start:1em;--padding-end:1em;--padding-bottom:0;height:2.8em;font-size:20px}:host(.button-small){--padding-top:0;--padding-start:0.9em;--padding-end:0.9em;--padding-bottom:0;height:2.1em;font-size:13px}:host(.button-strong){font-weight:bold}::slotted(ion-icon[slot=icon-only]){padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}:host(.button-solid.ion-color.ion-focused) .button-native::after{background:var(--ion-color-contrast)}:host(.button-clear.ion-color.ion-focused) .button-native::after,:host(.button-outline.ion-color.ion-focused) .button-native::after{background:var(--ion-color-base)}@media (any-hover: hover){:host(.button-solid.ion-color:hover) .button-native::after{background:var(--ion-color-contrast)}:host(.button-clear.ion-color:hover) .button-native::after,:host(.button-outline.ion-color:hover) .button-native::after{background:var(--ion-color-base)}}'}}},[33,"ion-button",{color:[513],buttonType:[1025,"button-type"],disabled:[516],expand:[513],fill:[1537],routerDirection:[1,"router-direction"],routerAnimation:[16],download:[1],href:[1],rel:[1],shape:[513],size:[513],strong:[4],target:[1],type:[1],form:[1]}]),Kg=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.ionColor=Uh(this,"ionColor",7),this.ionStyle=Uh(this,"ionStyle",7),this.inRange=!1,this.color=void 0,this.position=void 0,this.noAnimate=!1}componentWillLoad(){this.inRange=!!this.el.closest("ion-range"),this.noAnimate="floating"===this.position,this.emitStyle(),this.emitColor()}componentDidLoad(){this.noAnimate&&setTimeout((()=>{this.noAnimate=!1}),1e3)}colorChanged(){this.emitColor()}positionChanged(){this.emitStyle()}emitColor(){const{color:e}=this;this.ionColor.emit({"item-label-color":void 0!==e,[`ion-color-${e}`]:void 0!==e})}emitStyle(){const{inRange:e,position:t}=this;e||this.ionStyle.emit({label:!0,[`label-${t}`]:void 0!==t})}render(){const e=this.position,t=ag(this);return zh(Lh,{class:Ng(this.color,{[t]:!0,"in-item-color":Ig("ion-item.ion-color",this.el),[`label-${e}`]:void 0!==e,"label-no-animate":this.noAnimate,"label-rtl":"rtl"===document.dir})})}get el(){return this}static get watchers(){return{color:["colorChanged"],position:["positionChanged"]}}static get style(){return{ios:".item.sc-ion-label-ios-h,.item .sc-ion-label-ios-h{--color:initial;display:block;color:var(--color);font-family:var(--ion-font-family, inherit);font-size:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}.ion-color.sc-ion-label-ios-h{color:var(--ion-color-base)}.ion-text-wrap.sc-ion-label-ios-h,[text-wrap].sc-ion-label-ios-h{white-space:normal}.item-interactive-disabled.sc-ion-label-ios-h:not(.item-multiple-inputs),.item-interactive-disabled:not(.item-multiple-inputs) .sc-ion-label-ios-h{cursor:default;opacity:0.3;pointer-events:none}.item-input.sc-ion-label-ios-h,.item-input .sc-ion-label-ios-h{-ms-flex:initial;flex:initial;max-width:200px;pointer-events:none}.item-textarea.sc-ion-label-ios-h,.item-textarea .sc-ion-label-ios-h{-ms-flex-item-align:baseline;align-self:baseline}.label-fixed.sc-ion-label-ios-h{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.label-stacked.sc-ion-label-ios-h,.label-floating.sc-ion-label-ios-h{margin-bottom:0;-ms-flex-item-align:stretch;align-self:stretch;width:auto;max-width:100%}.label-no-animate.label-floating.sc-ion-label-ios-h{-webkit-transition:none;transition:none}.sc-ion-label-ios-s h1,.sc-ion-label-ios-s h2,.sc-ion-label-ios-s h3,.sc-ion-label-ios-s h4,.sc-ion-label-ios-s h5,.sc-ion-label-ios-s h6{text-overflow:inherit;overflow:inherit}.ion-text-wrap.sc-ion-label-ios-h,[text-wrap].sc-ion-label-ios-h{font-size:14px;line-height:1.5}.label-stacked.sc-ion-label-ios-h{margin-bottom:4px;font-size:14px}.label-floating.sc-ion-label-ios-h{margin-bottom:0;-webkit-transform:translate(0, 29px);transform:translate(0, 29px);-webkit-transform-origin:left top;transform-origin:left top;-webkit-transition:-webkit-transform 150ms ease-in-out;transition:-webkit-transform 150ms ease-in-out;transition:transform 150ms ease-in-out;transition:transform 150ms ease-in-out, -webkit-transform 150ms ease-in-out}[dir=rtl].sc-ion-label-ios-h -no-combinator.label-floating.sc-ion-label-ios-h,[dir=rtl] .sc-ion-label-ios-h -no-combinator.label-floating.sc-ion-label-ios-h,[dir=rtl].label-floating.sc-ion-label-ios-h,[dir=rtl] .label-floating.sc-ion-label-ios-h{-webkit-transform-origin:right top;transform-origin:right top}@supports selector(:dir(rtl)){.label-floating.sc-ion-label-ios-h:dir(rtl){-webkit-transform-origin:right top;transform-origin:right top}}.item-textarea.label-floating.sc-ion-label-ios-h,.item-textarea .label-floating.sc-ion-label-ios-h{-webkit-transform:translate(0, 28px);transform:translate(0, 28px)}.item-has-focus.label-floating.sc-ion-label-ios-h,.item-has-focus .label-floating.sc-ion-label-ios-h,.item-has-placeholder.sc-ion-label-ios-h:not(.item-input).label-floating,.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-ios-h,.item-has-value.label-floating.sc-ion-label-ios-h,.item-has-value .label-floating.sc-ion-label-ios-h{-webkit-transform:scale(0.82);transform:scale(0.82)}.sc-ion-label-ios-s h1{margin-left:0;margin-right:0;margin-top:3px;margin-bottom:2px;font-size:22px;font-weight:normal}.sc-ion-label-ios-s h2{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:17px;font-weight:normal}.sc-ion-label-ios-s h3,.sc-ion-label-ios-s h4,.sc-ion-label-ios-s h5,.sc-ion-label-ios-s h6{margin-left:0;margin-right:0;margin-top:0;margin-bottom:3px;font-size:14px;font-weight:normal;line-height:normal}.sc-ion-label-ios-s p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:14px;line-height:normal;text-overflow:inherit;overflow:inherit}.sc-ion-label-ios-s>p{color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.4)}.sc-ion-label-ios-h.in-item-color.sc-ion-label-ios-s>p{color:inherit}.sc-ion-label-ios-s h2:last-child,.sc-ion-label-ios-s h3:last-child,.sc-ion-label-ios-s h4:last-child,.sc-ion-label-ios-s h5:last-child,.sc-ion-label-ios-s h6:last-child,.sc-ion-label-ios-s p:last-child{margin-bottom:0}",md:'.item.sc-ion-label-md-h,.item .sc-ion-label-md-h{--color:initial;display:block;color:var(--color);font-family:var(--ion-font-family, inherit);font-size:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}.ion-color.sc-ion-label-md-h{color:var(--ion-color-base)}.ion-text-wrap.sc-ion-label-md-h,[text-wrap].sc-ion-label-md-h{white-space:normal}.item-interactive-disabled.sc-ion-label-md-h:not(.item-multiple-inputs),.item-interactive-disabled:not(.item-multiple-inputs) .sc-ion-label-md-h{cursor:default;opacity:0.3;pointer-events:none}.item-input.sc-ion-label-md-h,.item-input .sc-ion-label-md-h{-ms-flex:initial;flex:initial;max-width:200px;pointer-events:none}.item-textarea.sc-ion-label-md-h,.item-textarea .sc-ion-label-md-h{-ms-flex-item-align:baseline;align-self:baseline}.label-fixed.sc-ion-label-md-h{-ms-flex:0 0 100px;flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.label-stacked.sc-ion-label-md-h,.label-floating.sc-ion-label-md-h{margin-bottom:0;-ms-flex-item-align:stretch;align-self:stretch;width:auto;max-width:100%}.label-no-animate.label-floating.sc-ion-label-md-h{-webkit-transition:none;transition:none}.sc-ion-label-md-s h1,.sc-ion-label-md-s h2,.sc-ion-label-md-s h3,.sc-ion-label-md-s h4,.sc-ion-label-md-s h5,.sc-ion-label-md-s h6{text-overflow:inherit;overflow:inherit}.ion-text-wrap.sc-ion-label-md-h,[text-wrap].sc-ion-label-md-h{line-height:1.5}.label-stacked.sc-ion-label-md-h,.label-floating.sc-ion-label-md-h{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-transform-origin:top left;transform-origin:top left}.label-stacked.label-rtl.sc-ion-label-md-h,.label-floating.label-rtl.sc-ion-label-md-h{-webkit-transform-origin:top right;transform-origin:top right}.label-stacked.sc-ion-label-md-h{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75);-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1)}.label-floating.sc-ion-label-md-h{-webkit-transform:translateY(96%);transform:translateY(96%);-webkit-transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1), -webkit-transform 150ms cubic-bezier(0.4, 0, 0.2, 1)}.ion-focused.label-floating.sc-ion-label-md-h,.ion-focused .label-floating.sc-ion-label-md-h,.item-has-focus.label-floating.sc-ion-label-md-h,.item-has-focus .label-floating.sc-ion-label-md-h,.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating,.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h,.item-has-value.label-floating.sc-ion-label-md-h,.item-has-value .label-floating.sc-ion-label-md-h{-webkit-transform:translateY(50%) scale(0.75);transform:translateY(50%) scale(0.75)}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h{-webkit-transform:translateY(-6px) scale(0.75);transform:translateY(-6px) scale(0.75);position:relative;max-width:-webkit-min-content;max-width:-moz-min-content;max-width:min-content;background-color:var(--ion-item-background, var(--ion-background-color, #fff));overflow:visible;z-index:3}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::before,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::before,.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::after,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::before,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::after,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::after{position:absolute;width:4px;height:100%;background-color:var(--ion-item-background, var(--ion-background-color, #fff));content:""}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::before,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::before,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::before,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::before{left:calc(-1 * 4px)}.item-fill-outline.ion-focused.label-floating.sc-ion-label-md-h::after,.item-fill-outline.ion-focused .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-focus .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating::after,.item-fill-outline.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value.label-floating.sc-ion-label-md-h::after,.item-fill-outline.item-has-value .label-floating.sc-ion-label-md-h::after{right:calc(-1 * 4px)}.item-fill-outline.ion-focused.item-has-start-slot.label-floating.sc-ion-label-md-h,.item-fill-outline.ion-focused.item-has-start-slot .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).item-has-start-slot.label-floating,.item-fill-outline.item-has-placeholder:not(.item-input).item-has-start-slot .label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot.label-floating.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot .label-floating.sc-ion-label-md-h{-webkit-transform:translateX(-32px) translateY(-6px) scale(0.75);transform:translateX(-32px) translateY(-6px) scale(0.75)}.item-fill-outline.ion-focused.item-has-start-slot.label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.ion-focused.item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot.label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-focus.item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-placeholder.sc-ion-label-md-h:not(.item-input).item-has-start-slot.label-floating.label-rtl,.item-fill-outline.item-has-placeholder:not(.item-input).item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot.label-floating.label-rtl.sc-ion-label-md-h,.item-fill-outline.item-has-value.item-has-start-slot .label-floating.label-rtl.sc-ion-label-md-h{-webkit-transform:translateX(calc(-1 * -32px)) translateY(-6px) scale(0.75);transform:translateX(calc(-1 * -32px)) translateY(-6px) scale(0.75)}.ion-focused.label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused .label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused.label-floating.sc-ion-label-md-h:not(.ion-color),.ion-focused .label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-primary, #3880ff)}.ion-focused.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-focused.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.ion-focused.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-contrast)}.item-fill-solid.ion-focused.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.ion-focused.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.ion-focused.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.ion-focused.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.ion-focused.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-solid.item-has-focus.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-fill-outline.item-has-focus.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-base)}.ion-invalid.ion-touched.label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-invalid.ion-touched .label-stacked.sc-ion-label-md-h:not(.ion-color),.ion-invalid.ion-touched.label-floating.sc-ion-label-md-h:not(.ion-color),.ion-invalid.ion-touched .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--highlight-color-invalid)}.sc-ion-label-md-s h1{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:24px;font-weight:normal}.sc-ion-label-md-s h2{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:16px;font-weight:normal}.sc-ion-label-md-s h3,.sc-ion-label-md-s h4,.sc-ion-label-md-s h5,.sc-ion-label-md-s h6{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:14px;font-weight:normal;line-height:normal}.sc-ion-label-md-s p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:14px;line-height:20px;text-overflow:inherit;overflow:inherit}.sc-ion-label-md-s>p{color:var(--ion-color-step-600, #666666)}.sc-ion-label-md-h.in-item-color.sc-ion-label-md-s>p{color:inherit}'}}},[34,"ion-label",{color:[513],position:[1],noAnimate:[32]}]),Xg="ion-content",Yg=".ion-content-scroll-host",Qg=`${Xg}, ${Yg}`,Zg=e=>"ION-CONTENT"===e.tagName,Jg=e("h",(async e=>Zg(e)?(await new Promise((t=>em(e,t))),e.getScrollElement()):e)),eb=e=>{const t=e.querySelector(Yg);return t||e.querySelector(Qg)},tb=(e("f",(e=>e.closest(Qg))),e("s",((e,t)=>Zg(e)?e.scrollToTop(t):Promise.resolve(e.scrollTo({top:0,left:0,behavior:t>0?"smooth":"auto"})))),e("j",((e,t,n,r)=>Zg(e)?e.scrollByPoint(t,n,r):Promise.resolve(e.scrollBy({top:n,left:t,behavior:r>0?"smooth":"auto"})))),e=>((e,...t)=>console.error(`<${e.tagName.toLowerCase()}> must be used inside ${t.join(" or ")}.`))(e,Xg));
/*!
             * (C) Ionic http://ionicframework.com - MIT License
             */
var nb;e("e",nb),function(e){e.Body="body",e.Ionic="ionic",e.Native="native",e.None="none"}(nb||e("e",nb={}));const rb=e("K",{getEngine(){var e;return(null===(e=null==Zf?void 0:Zf.Capacitor)||void 0===e?void 0:e.isPluginAvailable("Keyboard"))&&(null==Zf?void 0:Zf.Capacitor.Plugins.Keyboard)},getResizeMode(){const e=this.getEngine();return(null==e?void 0:e.getResizeMode)?e.getResizeMode().catch((e=>{if("UNIMPLEMENTED"!==e.code)throw e})):Promise.resolve(void 0)}}),ab=e=>{if(void 0===Jf||e===nb.None||void 0===e)return null;const t=Jf.querySelector("ion-app");return null!=t?t:Jf.body},ib=e=>{const t=ab(e);return null===t?0:t.clientHeight},ob=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.fixed=!1}render(){const e=ag(this);return zh(Lh,{class:{[e]:!0,"grid-fixed":this.fixed}},zh("slot",null))}static get style(){return":host{-webkit-padding-start:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;display:block;-ms-flex:1;flex:1}@media (min-width: 576px){:host{-webkit-padding-start:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px))}}@media (min-width: 768px){:host{-webkit-padding-start:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px))}}@media (min-width: 992px){:host{-webkit-padding-start:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px))}}@media (min-width: 1200px){:host{-webkit-padding-start:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px))}}:host(.grid-fixed){width:var(--ion-grid-width-xs, var(--ion-grid-width, 100%));max-width:100%}@media (min-width: 576px){:host(.grid-fixed){width:var(--ion-grid-width-sm, var(--ion-grid-width, 540px))}}@media (min-width: 768px){:host(.grid-fixed){width:var(--ion-grid-width-md, var(--ion-grid-width, 720px))}}@media (min-width: 992px){:host(.grid-fixed){width:var(--ion-grid-width-lg, var(--ion-grid-width, 960px))}}@media (min-width: 1200px){:host(.grid-fixed){width:var(--ion-grid-width-xl, var(--ion-grid-width, 1140px))}}:host(.ion-no-padding){--ion-grid-column-padding:0;--ion-grid-column-padding-xs:0;--ion-grid-column-padding-sm:0;--ion-grid-column-padding-md:0;--ion-grid-column-padding-lg:0;--ion-grid-column-padding-xl:0}"}},[1,"ion-grid",{fixed:[4]}]),sb=function(){"undefined"!=typeof customElements&&["ion-grid"].forEach((e=>{"ion-grid"===e&&(customElements.get(e)||customElements.define(e,ob))}))},lb=e=>{const t=document.querySelector(`${e}.ion-cloned-element`);if(null!==t)return t;const n=document.createElement(e);return n.classList.add("ion-cloned-element"),n.style.setProperty("display","none"),document.body.appendChild(n),n},ub=e=>{if(!e)return;const t=e.querySelectorAll("ion-toolbar");return{el:e,toolbars:Array.from(t).map((e=>{const t=e.querySelector("ion-title");return{el:e,background:e.shadowRoot.querySelector(".toolbar-background"),ionTitleEl:t,innerTitleEl:t?t.shadowRoot.querySelector(".toolbar-title"):null,ionButtonsEl:Array.from(e.querySelectorAll("ion-buttons"))}}))}},db=(e,t)=>{"fade"!==e.collapse&&(void 0===t?e.style.removeProperty("--opacity-scale"):e.style.setProperty("--opacity-scale",t.toString()))},cb=(e,t,n,r)=>{Qf((()=>{const a=r.scrollTop;((e,t,n)=>{if(!e[0].isIntersecting)return;const r=e[0].intersectionRatio>.9||n<=0?0:100*(1-e[0].intersectionRatio)/75;db(t.el,1===r?void 0:r)})(e,t,a);const i=e[0],o=i.intersectionRect,s=o.width*o.height,l=i.rootBounds.width*i.rootBounds.height,u=0===s&&0===l,d=Math.abs(o.left-i.boundingClientRect.left),c=Math.abs(o.right-i.boundingClientRect.right);u||s>0&&(d>=5||c>=5)||(i.isIntersecting?(pb(t,!1),pb(n)):(0===o.x&&0===o.y||0!==o.width&&0!==o.height)&&a>0&&(pb(t),pb(n,!1),db(t.el)))}))},pb=(e,t=!0)=>{const n=e.el;t?(n.classList.remove("header-collapse-condense-inactive"),n.removeAttribute("aria-hidden")):(n.classList.add("header-collapse-condense-inactive"),n.setAttribute("aria-hidden","true"))},hb=(e=[],t=1,n=!1)=>{e.forEach((e=>{const r=e.ionTitleEl,a=e.innerTitleEl;r&&"large"===r.size&&(a.style.transition=n?"all 0.2s ease-in-out":"",a.style.transform=`scale3d(${t}, ${t}, 1)`)}))},fb=(e,t,n)=>{Yf((()=>{const r=e.scrollTop,a=t.clientHeight,i=n?n.clientHeight:0;if(null!==n&&r<i)return t.style.setProperty("--opacity-scale","0"),void e.style.setProperty("clip-path",`inset(${a}px 0px 0px 0px)`);const o=sm(0,(r-i)/10,1);Qf((()=>{e.style.removeProperty("clip-path"),t.style.setProperty("--opacity-scale",o.toString())}))}))},mb=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.inheritedAttributes={},this.setupFadeHeader=async(e,t)=>{const n=this.scrollEl=await Jg(e);this.contentScrollCallback=()=>{fb(this.scrollEl,this.el,t)},n.addEventListener("scroll",this.contentScrollCallback),fb(this.scrollEl,this.el,t)},this.collapse=void 0,this.translucent=!1}componentWillLoad(){this.inheritedAttributes=rm(this.el)}componentDidLoad(){this.checkCollapsibleHeader()}componentDidUpdate(){this.checkCollapsibleHeader()}disconnectedCallback(){this.destroyCollapsibleHeader()}async checkCollapsibleHeader(){if("ios"!==ag(this))return;const{collapse:e}=this,t="condense"===e,n="fade"===e;if(this.destroyCollapsibleHeader(),t){const e=this.el.closest("ion-app,ion-page,.ion-page,page-inner"),t=e?eb(e):null;Qf((()=>{lb("ion-title").size="large",lb("ion-back-button")})),await this.setupCondenseHeader(t,e)}else if(n){const e=this.el.closest("ion-app,ion-page,.ion-page,page-inner"),t=e?eb(e):null;if(!t)return void tb(this.el);const n=t.querySelector('ion-header[collapse="condense"]');await this.setupFadeHeader(t,n)}}destroyCollapsibleHeader(){this.intersectionObserver&&(this.intersectionObserver.disconnect(),this.intersectionObserver=void 0),this.scrollEl&&this.contentScrollCallback&&(this.scrollEl.removeEventListener("scroll",this.contentScrollCallback),this.contentScrollCallback=void 0),this.collapsibleMainHeader&&(this.collapsibleMainHeader.classList.remove("header-collapse-main"),this.collapsibleMainHeader=void 0)}async setupCondenseHeader(e,t){if(!e||!t)return void tb(this.el);if("undefined"==typeof IntersectionObserver)return;this.scrollEl=await Jg(e);const n=t.querySelectorAll("ion-header");if(this.collapsibleMainHeader=Array.from(n).find((e=>"condense"!==e.collapse)),!this.collapsibleMainHeader)return;const r=ub(this.collapsibleMainHeader),a=ub(this.el);r&&a&&(pb(r,!1),db(r.el,0),this.intersectionObserver=new IntersectionObserver((e=>{cb(e,r,a,this.scrollEl)}),{root:e,threshold:[.25,.3,.4,.5,.6,.7,.8,.9,1]}),this.intersectionObserver.observe(a.toolbars[a.toolbars.length-1].el),this.contentScrollCallback=()=>{((e,t,n)=>{Yf((()=>{const r=e.scrollTop,a=sm(1,1+-r/500,1.1);null===n.querySelector("ion-refresher.refresher-native")&&Qf((()=>{hb(t.toolbars,a)}))}))})(this.scrollEl,a,e)},this.scrollEl.addEventListener("scroll",this.contentScrollCallback),Qf((()=>{void 0!==this.collapsibleMainHeader&&this.collapsibleMainHeader.classList.add("header-collapse-main")})))}render(){const{translucent:e,inheritedAttributes:t}=this,n=ag(this),r=this.collapse||"none",a=Ig("ion-menu",this.el)?"none":"banner";return zh(Lh,Object.assign({role:a,class:{[n]:!0,[`header-${n}`]:!0,"header-translucent":this.translucent,[`header-collapse-${r}`]:!0,[`header-translucent-${n}`]:this.translucent}},t),"ios"===n&&e&&zh("div",{class:"header-background"}),zh("slot",null))}get el(){return this}static get style(){return{ios:"ion-header{display:block;position:relative;-ms-flex-order:-1;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-ios ion-toolbar:last-of-type{--border-width:0 0 0.55px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){.header-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-backdrop-filter:saturate(180%) blur(20px);backdrop-filter:saturate(180%) blur(20px)}.header-translucent-ios ion-toolbar{--opacity:.8}.header-collapse-condense-inactive .header-background{-webkit-backdrop-filter:blur(20px);backdrop-filter:blur(20px)}}.header-ios.ion-no-border ion-toolbar:last-of-type{--border-width:0}.header-collapse-fade ion-toolbar{--opacity-scale:inherit}.header-collapse-condense{z-index:9}.header-collapse-condense ion-toolbar{position:-webkit-sticky;position:sticky;top:0}.header-collapse-condense ion-toolbar:first-of-type{padding-top:7px;z-index:1}.header-collapse-condense ion-toolbar{--background:var(--ion-background-color, #fff);z-index:0}.header-collapse-condense ion-toolbar:last-of-type{--border-width:0px}.header-collapse-condense ion-toolbar ion-searchbar{height:48px;padding-top:0px;padding-bottom:13px}.header-collapse-main{--opacity-scale:1}.header-collapse-main ion-toolbar{--opacity-scale:inherit}.header-collapse-main ion-toolbar.in-toolbar ion-title,.header-collapse-main ion-toolbar.in-toolbar ion-buttons{-webkit-transition:all 0.2s ease-in-out;transition:all 0.2s ease-in-out}.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-buttons.buttons-collapse{opacity:0;pointer-events:none}.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-buttons.buttons-collapse{visibility:hidden}",md:"ion-header{display:block;position:relative;-ms-flex-order:-1;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-md{-webkit-box-shadow:0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12);box-shadow:0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12)}.header-collapse-condense{display:none}.header-md.ion-no-border{-webkit-box-shadow:none;box-shadow:none}"}}},[36,"ion-header",{collapse:[1],translucent:[4]}]),gb=function(){"undefined"!=typeof customElements&&["ion-header"].forEach((e=>{"ion-header"===e&&(customElements.get(e)||customElements.define(e,mb))}))},bb=function(){"undefined"!=typeof customElements&&["ion-label"].forEach((e=>{"ion-label"===e&&(customElements.get(e)||customElements.define(e,Kg))}))}
/*!
             * (C) Ionic http://ionicframework.com - MIT License
             */;
/*!
             * (C) Ionic http://ionicframework.com - MIT License
             */class yb{constructor(e,t){this.component=e,this.params=t,this.state=1}async init(e){if(this.state=2,!this.element){const t=this.component;this.element=await og(this.delegate,e,t,["ion-page","ion-page-invisible"],this.params)}}_destroy(){lm(3!==this.state,"view state must be ATTACHED");const e=this.element;e&&(this.delegate?this.delegate.removeViewFromDom(e.parentElement,e):e.remove()),this.nav=void 0,this.state=3}}const vb=(e,t,n)=>!!e&&e.component===t&&um(e.params,n),xb=(e,t)=>e?e instanceof yb?e:new yb(e,t):null,wb=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.ionNavWillLoad=Uh(this,"ionNavWillLoad",7),this.ionNavWillChange=Uh(this,"ionNavWillChange",3),this.ionNavDidChange=Uh(this,"ionNavDidChange",3),this.transInstr=[],this.animationEnabled=!0,this.useRouter=!1,this.isTransitioning=!1,this.destroyed=!1,this.views=[],this.didLoad=!1,this.delegate=void 0,this.swipeGesture=void 0,this.animated=!0,this.animation=void 0,this.rootParams=void 0,this.root=void 0}swipeGestureChanged(){this.gesture&&this.gesture.enable(!0===this.swipeGesture)}rootChanged(){void 0!==this.root&&!1!==this.didLoad&&(this.useRouter||void 0!==this.root&&this.setRoot(this.root,this.rootParams))}componentWillLoad(){if(this.useRouter=null!==document.querySelector("ion-router")&&null===this.el.closest("[no-router]"),void 0===this.swipeGesture){const e=ag(this);this.swipeGesture=Wm.getBoolean("swipeBackEnabled","ios"===e)}this.ionNavWillLoad.emit()}async componentDidLoad(){this.didLoad=!0,this.rootChanged(),this.gesture=(await yh((()=>t.import("./swipe-back-legacy-0249fd15.js")))).createSwipeBackGesture(this.el,this.canStart.bind(this),this.onStart.bind(this),this.onMove.bind(this),this.onEnd.bind(this)),this.swipeGestureChanged()}connectedCallback(){this.destroyed=!1}disconnectedCallback(){for(const e of this.views)Rm(e.element,vm),e._destroy();this.gesture&&(this.gesture.destroy(),this.gesture=void 0),this.transInstr.length=0,this.views.length=0,this.destroyed=!0}push(e,t,n,r){return this.insert(-1,e,t,n,r)}insert(e,t,n,r,a){return this.insertPages(e,[{component:t,componentProps:n}],r,a)}insertPages(e,t,n,r){return this.queueTrns({insertStart:e,insertViews:t,opts:n},r)}pop(e,t){return this.removeIndex(-1,1,e,t)}popTo(e,t,n){const r={removeStart:-1,removeCount:-1,opts:t};return"object"==typeof e&&e.component?(r.removeView=e,r.removeStart=1):"number"==typeof e&&(r.removeStart=e+1),this.queueTrns(r,n)}popToRoot(e,t){return this.removeIndex(1,-1,e,t)}removeIndex(e,t=1,n,r){return this.queueTrns({removeStart:e,removeCount:t,opts:n},r)}setRoot(e,t,n,r){return this.setPages([{component:e,componentProps:t}],n,r)}setPages(e,t,n){return null!=t||(t={}),!0!==t.animated&&(t.animated=!1),this.queueTrns({insertStart:0,insertViews:e,removeStart:0,removeCount:-1,opts:t},n)}setRouteId(e,t,n,r){const a=this.getActiveSync();if(vb(a,e,t))return Promise.resolve({changed:!1,element:a.element});let i;const o=new Promise((e=>i=e));let s;const l={updateURL:!1,viewIsReady:e=>{let t;const n=new Promise((e=>t=e));return i({changed:!0,element:e,markVisible:async()=>{t(),await s}}),n}};if("root"===n)s=this.setRoot(e,t,l);else{const a=this.views.find((n=>vb(n,e,t)));a?s=this.popTo(a,Object.assign(Object.assign({},l),{direction:"back",animationBuilder:r})):"forward"===n?s=this.push(e,t,Object.assign(Object.assign({},l),{animationBuilder:r})):"back"===n&&(s=this.setRoot(e,t,Object.assign(Object.assign({},l),{direction:"back",animated:!0,animationBuilder:r})))}return o}async getRouteId(){const e=this.getActiveSync();if(e)return{id:e.element.tagName,params:e.params,element:e.element}}async getActive(){return this.getActiveSync()}async getByIndex(e){return this.views[e]}async canGoBack(e){return this.canGoBackSync(e)}async getPrevious(e){return this.getPreviousSync(e)}getLength(){return this.views.length}getActiveSync(){return this.views[this.views.length-1]}canGoBackSync(e=this.getActiveSync()){return!(!e||!this.getPreviousSync(e))}getPreviousSync(e=this.getActiveSync()){if(!e)return;const t=this.views,n=t.indexOf(e);return n>0?t[n-1]:void 0}async queueTrns(e,t){var n,r;if(this.isTransitioning&&(null===(n=e.opts)||void 0===n?void 0:n.skipIfBusy))return!1;const a=new Promise(((t,n)=>{e.resolve=t,e.reject=n}));if(e.done=t,e.opts&&!1!==e.opts.updateURL&&this.useRouter){const t=document.querySelector("ion-router");if(t){const n=await t.canTransition();if(!1===n)return!1;if("string"==typeof n)return t.push(n,e.opts.direction||"back"),!1}}return 0===(null===(r=e.insertViews)||void 0===r?void 0:r.length)&&(e.insertViews=void 0),this.transInstr.push(e),this.nextTrns(),a}success(e,t){if(this.destroyed)this.fireError("nav controller was destroyed",t);else if(t.done&&t.done(e.hasCompleted,e.requiresTransition,e.enteringView,e.leavingView,e.direction),t.resolve(e.hasCompleted),!1!==t.opts.updateURL&&this.useRouter){const t=document.querySelector("ion-router");if(t){const n="back"===e.direction?"back":"forward";t.navChanged(n)}}}failed(e,t){this.destroyed?this.fireError("nav controller was destroyed",t):(this.transInstr.length=0,this.fireError(e,t))}fireError(e,t){t.done&&t.done(!1,!1,e),t.reject&&!this.destroyed?t.reject(e):t.resolve(!1)}nextTrns(){if(this.isTransitioning)return!1;const e=this.transInstr.shift();return!!e&&(this.runTransition(e),!0)}async runTransition(e){try{this.ionNavWillChange.emit(),this.isTransitioning=!0,this.prepareTI(e);const t=this.getActiveSync(),n=this.getEnteringView(e,t);if(!t&&!n)throw new Error("no views in the stack to be removed");n&&1===n.state&&await n.init(this.el),this.postViewInit(n,t,e);const r=(e.enteringRequiresTransition||e.leavingRequiresTransition)&&n!==t;let a;r&&e.opts&&t&&("back"===e.opts.direction&&(e.opts.animationBuilder=e.opts.animationBuilder||(null==n?void 0:n.animationBuilder)),t.animationBuilder=e.opts.animationBuilder),a=r?await this.transition(n,t,e):{hasCompleted:!0,requiresTransition:!1},this.success(a,e),this.ionNavDidChange.emit()}catch(t){this.failed(t,e)}this.isTransitioning=!1,this.nextTrns()}prepareTI(e){var t,n,r;const a=this.views.length;if(null!==(t=e.opts)&&void 0!==t||(e.opts={}),null!==(n=(r=e.opts).delegate)&&void 0!==n||(r.delegate=this.delegate),void 0!==e.removeView){lm(void 0!==e.removeStart,"removeView needs removeStart"),lm(void 0!==e.removeCount,"removeView needs removeCount");const t=this.views.indexOf(e.removeView);if(t<0)throw new Error("removeView was not found");e.removeStart+=t}void 0!==e.removeStart&&(e.removeStart<0&&(e.removeStart=a-1),e.removeCount<0&&(e.removeCount=a-e.removeStart),e.leavingRequiresTransition=e.removeCount>0&&e.removeStart+e.removeCount===a),e.insertViews&&((e.insertStart<0||e.insertStart>a)&&(e.insertStart=a),e.enteringRequiresTransition=e.insertStart===a);const i=e.insertViews;if(!i)return;lm(i.length>0,"length can not be zero");const o=i.map((e=>e instanceof yb?e:"component"in e?xb(e.component,null===e.componentProps?void 0:e.componentProps):xb(e,void 0))).filter((e=>null!==e));if(0===o.length)throw new Error("invalid views to insert");for(const s of o){s.delegate=e.opts.delegate;const t=s.nav;if(t&&t!==this)throw new Error("inserted view was already inserted");if(3===s.state)throw new Error("inserted view was already destroyed")}e.insertViews=o}getEnteringView(e,t){const n=e.insertViews;if(void 0!==n)return n[n.length-1];const r=e.removeStart;if(void 0!==r){const n=this.views,a=r+e.removeCount;for(let e=n.length-1;e>=0;e--){const i=n[e];if((e<r||e>=a)&&i!==t)return i}}}postViewInit(e,t,n){var r,a,i;lm(t||e,"Both leavingView and enteringView are null"),lm(n.resolve,"resolve must be valid"),lm(n.reject,"reject must be valid");const o=n.opts,{insertViews:s,removeStart:l,removeCount:u}=n;let d;if(void 0!==l&&void 0!==u){lm(l>=0,"removeStart can not be negative"),lm(u>=0,"removeCount can not be negative"),d=[];for(let n=l;n<l+u;n++){const r=this.views[n];void 0!==r&&r!==e&&r!==t&&d.push(r)}null!==(r=o.direction)&&void 0!==r||(o.direction="back")}const c=this.views.length+(null!==(a=null==s?void 0:s.length)&&void 0!==a?a:0)-(null!=u?u:0);if(lm(c>=0,"final balance can not be negative"),0===c)throw console.warn("You can't remove all the pages in the navigation stack. nav.pop() is probably called too many times.",this,this.el),new Error("navigation stack needs at least one root page");if(s){let e=n.insertStart;for(const t of s)this.insertViewAt(t,e),e++;n.enteringRequiresTransition&&(null!==(i=o.direction)&&void 0!==i||(o.direction="forward"))}if(d&&d.length>0){for(const e of d)Rm(e.element,bm),Rm(e.element,ym),Rm(e.element,vm);for(const e of d)this.destroyView(e)}}async transition(e,t,n){const r=n.opts,a=r.progressAnimation?e=>this.sbAni=e:void 0,i=ag(this),o=e.element,s=t&&t.element,l=Object.assign(Object.assign({mode:i,showGoBack:this.canGoBackSync(e),baseEl:this.el,progressCallback:a,animated:this.animated&&Wm.getBoolean("animated",!0),enteringEl:o,leavingEl:s},r),{animationBuilder:r.animationBuilder||this.animation||Wm.get("navAnimation")}),{hasCompleted:u}=await xm(l);return this.transitionFinish(u,e,t,r)}transitionFinish(e,t,n,r){const a=e?t:n;return a&&this.unmountInactiveViews(a),{hasCompleted:e,requiresTransition:!0,enteringView:t,leavingView:n,direction:r.direction}}insertViewAt(e,t){const n=this.views,r=n.indexOf(e);r>-1?(lm(e.nav===this,"view is not part of the nav"),n.splice(r,1),n.splice(t,0,e)):(lm(!e.nav,"nav is used"),e.nav=this,n.splice(t,0,e))}removeView(e){lm(2===e.state||3===e.state,"view state should be loaded or destroyed");const t=this.views,n=t.indexOf(e);lm(n>-1,"view must be part of the stack"),n>=0&&t.splice(n,1)}destroyView(e){e._destroy(),this.removeView(e)}unmountInactiveViews(e){if(this.destroyed)return;const t=this.views,n=t.indexOf(e);for(let r=t.length-1;r>=0;r--){const e=t[r],a=e.element;a&&(r>n?(Rm(a,vm),this.destroyView(e)):r<n&&Dm(a,!0))}}canStart(){return!!this.swipeGesture&&!this.isTransitioning&&0===this.transInstr.length&&this.animationEnabled&&this.canGoBackSync()}onStart(){this.pop({direction:"back",progressAnimation:!0})}onMove(e){this.sbAni&&this.sbAni.progressStep(e)}onEnd(e,t,n){if(this.sbAni){this.animationEnabled=!1,this.sbAni.onFinish((()=>{this.animationEnabled=!0}),{oneTimeCallback:!0});let r=e?-.001:.001;e?r+=Om([0,0],[.32,.72],[0,1],[1,1],t)[0]:(this.sbAni.easing("cubic-bezier(1, 0, 0.68, 0.28)"),r+=Om([0,0],[1,0],[.68,.28],[1,1],t)[0]),this.sbAni.progressEnd(e?1:0,r,n)}}render(){return zh("slot",null)}get el(){return this}static get watchers(){return{swipeGesture:["swipeGestureChanged"],root:["rootChanged"]}}static get style(){return":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}"}},[1,"ion-nav",{delegate:[16],swipeGesture:[1028,"swipe-gesture"],animated:[4],animation:[16],rootParams:[16],root:[1],push:[64],insert:[64],insertPages:[64],pop:[64],popTo:[64],popToRoot:[64],removeIndex:[64],setRoot:[64],setPages:[64],setRouteId:[64],getRouteId:[64],getActive:[64],getByIndex:[64],canGoBack:[64],getPrevious:[64]}]),kb=function(){"undefined"!=typeof customElements&&["ion-nav"].forEach((e=>{"ion-nav"===e&&(customElements.get(e)||customElements.define(e,wb))}))},Sb=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.onClick=()=>((e,t,n,r,a)=>{const i=e.closest("ion-nav");if(i)if("forward"===t){if(void 0!==n)return i.push(n,r,{skipIfBusy:!0,animationBuilder:a})}else if("root"===t){if(void 0!==n)return i.setRoot(n,r,{skipIfBusy:!0,animationBuilder:a})}else if("back"===t)return i.pop({skipIfBusy:!0,animationBuilder:a});return Promise.resolve(!1)})(this.el,this.routerDirection,this.component,this.componentProps,this.routerAnimation),this.component=void 0,this.componentProps=void 0,this.routerDirection="forward",this.routerAnimation=void 0}render(){return zh(Lh,{onClick:this.onClick})}get el(){return this}},[0,"ion-nav-link",{component:[1],componentProps:[16],routerDirection:[1,"router-direction"],routerAnimation:[16]}]),Ib=function(){"undefined"!=typeof customElements&&["ion-nav-link"].forEach((e=>{"ion-nav-link"===e&&(customElements.get(e)||customElements.define(e,Sb))}))},Nb=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow()}render(){return zh(Lh,{class:ag(this)},zh("slot",null))}static get style(){return":host{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}"}},[1,"ion-row"]),Cb=function(){"undefined"!=typeof customElements&&["ion-row"].forEach((e=>{"ion-row"===e&&(customElements.get(e)||customElements.define(e,Nb))}))},Tb=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.ionChange=Uh(this,"ionChange",7),this.ionSelect=Uh(this,"ionSelect",7),this.ionStyle=Uh(this,"ionStyle",7),this.onClick=e=>{const t=e.target,n=this.checked;"ION-SEGMENT"!==t.tagName&&(this.value=t.value,t!==n&&this.emitValueChange(),!this.scrollable&&this.swipeGesture||(n?this.checkButton(n,t):this.setCheckedClasses()))},this.getSegmentButton=e=>{var t,n;const r=this.getButtons().filter((e=>!e.disabled)),a=r.findIndex((e=>e===document.activeElement));switch(e){case"first":return r[0];case"last":return r[r.length-1];case"next":return null!==(t=r[a+1])&&void 0!==t?t:r[0];case"previous":return null!==(n=r[a-1])&&void 0!==n?n:r[r.length-1];default:return null}},this.activated=!1,this.color=void 0,this.disabled=!1,this.scrollable=!1,this.swipeGesture=!0,this.value=void 0,this.selectOnFocus=!1}colorChanged(e,t){(void 0===t&&void 0!==e||void 0!==t&&void 0===e)&&this.emitStyle()}swipeGestureChanged(){this.gestureChanged()}valueChanged(e){if(this.ionSelect.emit({value:e}),this.scrollable){const t=this.getButtons().find((t=>t.value===e));void 0!==t&&t.scrollIntoView({behavior:"smooth",inline:"center",block:"nearest"})}}disabledChanged(){this.gestureChanged();const e=this.getButtons();for(const t of e)t.disabled=this.disabled}gestureChanged(){this.gesture&&this.gesture.enable(!this.scrollable&&!this.disabled&&this.swipeGesture)}connectedCallback(){this.emitStyle()}componentWillLoad(){this.emitStyle()}async componentDidLoad(){this.setCheckedClasses(),this.gesture=(await yh((()=>t.import("./index2-legacy-3b1f112b.js")))).createGesture({el:this.el,gestureName:"segment",gesturePriority:100,threshold:0,passive:!1,onStart:e=>this.onStart(e),onMove:e=>this.onMove(e),onEnd:e=>this.onEnd(e)}),this.gestureChanged(),this.disabled&&this.disabledChanged()}onStart(e){this.valueBeforeGesture=this.value,this.activate(e)}onMove(e){this.setNextIndex(e)}onEnd(e){this.setActivated(!1),this.setNextIndex(e,!0),e.event.stopImmediatePropagation();const t=this.value;void 0!==t&&this.valueBeforeGesture!==t&&this.emitValueChange(),this.valueBeforeGesture=void 0}emitValueChange(){const{value:e}=this;this.ionChange.emit({value:e})}getButtons(){return Array.from(this.el.querySelectorAll("ion-segment-button"))}get checked(){return this.getButtons().find((e=>e.value===this.value))}setActivated(e){this.getButtons().forEach((t=>{e?t.classList.add("segment-button-activated"):t.classList.remove("segment-button-activated")})),this.activated=e}activate(e){const t=e.event.target,n=this.getButtons().find((e=>e.value===this.value));"ION-SEGMENT-BUTTON"===t.tagName&&(n||(this.value=t.value,this.setCheckedClasses()),this.value===t.value&&this.setActivated(!0))}getIndicator(e){return(e.shadowRoot||e).querySelector(".segment-button-indicator")}checkButton(e,t){const n=this.getIndicator(e),r=this.getIndicator(t);if(null===n||null===r)return;const a=n.getBoundingClientRect(),i=r.getBoundingClientRect(),o=a.width/i.width,s=`translate3d(${a.left-i.left}px, 0, 0) scaleX(${o})`;Qf((()=>{r.classList.remove("segment-button-indicator-animated"),r.style.setProperty("transform",s),r.getBoundingClientRect(),r.classList.add("segment-button-indicator-animated"),r.style.setProperty("transform","")})),this.value=t.value,this.setCheckedClasses()}setCheckedClasses(){const e=this.getButtons(),t=e.findIndex((e=>e.value===this.value))+1;for(const n of e)n.classList.remove("segment-button-after-checked");t<e.length&&e[t].classList.add("segment-button-after-checked")}setNextIndex(e,t=!1){const n=Vg(this.el),r=this.activated,a=this.getButtons(),i=a.findIndex((e=>e.value===this.value)),o=a[i];let s,l;if(-1===i)return;const u=o.getBoundingClientRect(),d=u.left,c=u.width,p=e.currentX,h=u.top+u.height/2,f=this.el.getRootNode().elementFromPoint(p,h);if(r&&!t){if(n?p>d+c:p<d){const e=i-1;e>=0&&(l=e)}else if((n?p<d:p>d+c)&&r&&!t){const e=i+1;e<a.length&&(l=e)}void 0===l||a[l].disabled||(s=a[l])}if(!r&&t&&(s=f),null!=s){if("ION-SEGMENT"===s.tagName)return!1;o!==s&&this.checkButton(o,s)}return!0}emitStyle(){this.ionStyle.emit({segment:!0})}onKeyDown(e){const t=Vg(this.el);let n,r=this.selectOnFocus;switch(e.key){case"ArrowRight":e.preventDefault(),n=t?this.getSegmentButton("previous"):this.getSegmentButton("next");break;case"ArrowLeft":e.preventDefault(),n=t?this.getSegmentButton("next"):this.getSegmentButton("previous");break;case"Home":e.preventDefault(),n=this.getSegmentButton("first");break;case"End":e.preventDefault(),n=this.getSegmentButton("last");break;case" ":case"Enter":e.preventDefault(),n=document.activeElement,r=!0}if(n){if(r){const e=this.checked;this.checkButton(e||n,n),n!==e&&this.emitValueChange()}n.setFocus()}}render(){const e=ag(this);return zh(Lh,{role:"tablist",onClick:this.onClick,class:Ng(this.color,{[e]:!0,"in-toolbar":Ig("ion-toolbar",this.el),"in-toolbar-color":Ig("ion-toolbar[color]",this.el),"segment-activated":this.activated,"segment-disabled":this.disabled,"segment-scrollable":this.scrollable})},zh("slot",null))}get el(){return this}static get watchers(){return{color:["colorChanged"],swipeGesture:["swipeGestureChanged"],value:["valueChanged"],disabled:["disabledChanged"]}}static get style(){return{ios:":host{--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:grid;grid-auto-columns:1fr;position:relative;-ms-flex-align:stretch;align-items:stretch;-ms-flex-pack:center;justify-content:center;width:100%;background:var(--background);font-family:var(--ion-font-family, inherit);text-align:center;contain:paint;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host(.segment-scrollable){-ms-flex-pack:start;justify-content:start;width:auto;overflow-x:auto;grid-auto-columns:minmax(-webkit-min-content, 1fr);grid-auto-columns:minmax(min-content, 1fr)}:host(.segment-scrollable::-webkit-scrollbar){display:none}:host{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.065);border-radius:8px;overflow:hidden;z-index:0}:host(.ion-color){background:rgba(var(--ion-color-base-rgb), 0.065)}:host(.in-toolbar){-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto;margin-top:0;margin-bottom:0;width:auto}:host(.in-toolbar:not(.ion-color)){background:var(--ion-toolbar-segment-background, var(--background))}:host(.in-toolbar-color:not(.ion-color)){background:rgba(var(--ion-color-contrast-rgb), 0.11)}",md:":host{--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:grid;grid-auto-columns:1fr;position:relative;-ms-flex-align:stretch;align-items:stretch;-ms-flex-pack:center;justify-content:center;width:100%;background:var(--background);font-family:var(--ion-font-family, inherit);text-align:center;contain:paint;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}:host(.segment-scrollable){-ms-flex-pack:start;justify-content:start;width:auto;overflow-x:auto;grid-auto-columns:minmax(-webkit-min-content, 1fr);grid-auto-columns:minmax(min-content, 1fr)}:host(.segment-scrollable::-webkit-scrollbar){display:none}:host{--background:transparent;grid-auto-columns:minmax(auto, 360px)}:host(.in-toolbar){min-height:var(--min-height)}:host(.segment-scrollable) ::slotted(ion-segment-button){min-width:auto}"}}},[33,"ion-segment",{color:[513],disabled:[4],scrollable:[4],swipeGesture:[4,"swipe-gesture"],value:[1032],selectOnFocus:[4,"select-on-focus"],activated:[32]},[[0,"keydown","onKeyDown"]]]),$b=function(){"undefined"!=typeof customElements&&["ion-segment"].forEach((e=>{"ion-segment"===e&&(customElements.get(e)||customElements.define(e,Tb))}))};let Eb=0;const _b=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.segmentEl=null,this.inheritedAttributes={},this.updateStyle=()=>{xf(this)},this.updateState=()=>{const{segmentEl:e}=this;e&&(this.checked=e.value===this.value,e.disabled&&(this.disabled=!0))},this.checked=!1,this.disabled=!1,this.layout="icon-top",this.type="button",this.value="ion-sb-"+Eb++}valueChanged(){this.updateState()}connectedCallback(){const e=this.segmentEl=this.el.closest("ion-segment");e&&(this.updateState(),am(e,"ionSelect",this.updateState),am(e,"ionStyle",this.updateStyle))}disconnectedCallback(){const e=this.segmentEl;e&&(im(e,"ionSelect",this.updateState),im(e,"ionStyle",this.updateStyle),this.segmentEl=null)}componentWillLoad(){this.inheritedAttributes=Object.assign({},tm(this.el,["aria-label"]))}get hasLabel(){return!!this.el.querySelector("ion-label")}get hasIcon(){return!!this.el.querySelector("ion-icon")}async setFocus(){const{nativeEl:e}=this;void 0!==e&&e.focus()}render(){const{checked:e,type:t,disabled:n,hasIcon:r,hasLabel:a,layout:i,segmentEl:o}=this,s=ag(this);return zh(Lh,{class:{[s]:!0,"in-toolbar":Ig("ion-toolbar",this.el),"in-toolbar-color":Ig("ion-toolbar[color]",this.el),"in-segment":Ig("ion-segment",this.el),"in-segment-color":void 0!==(null==o?void 0:o.color),"segment-button-has-label":a,"segment-button-has-icon":r,"segment-button-has-label-only":a&&!r,"segment-button-has-icon-only":r&&!a,"segment-button-disabled":n,"segment-button-checked":e,[`segment-button-layout-${i}`]:!0,"ion-activatable":!0,"ion-activatable-instant":!0,"ion-focusable":!0}},zh("button",Object.assign({"aria-selected":e?"true":"false",role:"tab",ref:e=>this.nativeEl=e,type:t,class:"button-native",part:"native",disabled:n},this.inheritedAttributes),zh("span",{class:"button-inner"},zh("slot",null)),"md"===s&&zh("ion-ripple-effect",null)),zh("div",{part:"indicator",class:{"segment-button-indicator":!0,"segment-button-indicator-animated":!0}},zh("div",{part:"indicator-background",class:"segment-button-indicator-background"})))}get el(){return this}static get watchers(){return{value:["valueChanged"]}}static get style(){return{ios:':host{--color:initial;--color-hover:var(--color);--color-checked:var(--color);--color-disabled:var(--color);--padding-start:0;--padding-end:0;--padding-top:0;--padding-bottom:0;border-radius:var(--border-radius);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:column;flex-direction:column;height:auto;background:var(--background);color:var(--color);text-decoration:none;text-overflow:ellipsis;white-space:nowrap;cursor:pointer;grid-row:1;-webkit-font-kerning:none;font-kerning:none}.button-native{border-radius:0;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);-webkit-transform:translate3d(0,  0,  0);transform:translate3d(0,  0,  0);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;min-width:inherit;max-width:inherit;height:auto;min-height:inherit;max-height:inherit;-webkit-transition:var(--transition);transition:var(--transition);border:none;outline:none;background:transparent;contain:content;pointer-events:none;overflow:hidden;z-index:2}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}:host(.segment-button-checked){background:var(--background-checked);color:var(--color-checked)}:host(.segment-button-disabled){cursor:default;pointer-events:none}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}:host(:focus){outline:none}@media (any-hover: hover){:host(:hover) .button-native{color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}:host(.segment-button-checked:hover) .button-native{color:var(--color-checked)}}::slotted(ion-icon){-ms-flex-negative:0;flex-shrink:0;-ms-flex-order:-1;order:-1;pointer-events:none}::slotted(ion-label){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;line-height:22px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none}:host(.segment-button-layout-icon-top) .button-native{-ms-flex-direction:column;flex-direction:column}:host(.segment-button-layout-icon-start) .button-native{-ms-flex-direction:row;flex-direction:row}:host(.segment-button-layout-icon-end) .button-native{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.segment-button-layout-icon-bottom) .button-native{-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.segment-button-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.segment-button-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color, var(--color-checked))}.segment-button-indicator{-webkit-transform-origin:left;transform-origin:left;position:absolute;opacity:0;-webkit-box-sizing:border-box;box-sizing:border-box;will-change:transform, opacity;pointer-events:none}.segment-button-indicator-background{width:100%;height:var(--indicator-height);-webkit-transform:var(--indicator-transform);transform:var(--indicator-transform);-webkit-box-shadow:var(--indicator-box-shadow);box-shadow:var(--indicator-box-shadow);pointer-events:none}.segment-button-indicator-animated{-webkit-transition:var(--indicator-transition);transition:var(--indicator-transition)}:host(.segment-button-checked) .segment-button-indicator{opacity:1}@media (prefers-reduced-motion: reduce){.segment-button-indicator-background{-webkit-transform:none;transform:none}.segment-button-indicator-animated{-webkit-transition:none;transition:none}}:host{--background:none;--background-checked:none;--background-hover:none;--background-hover-opacity:0;--background-focused:none;--background-focused-opacity:0;--border-radius:7px;--border-width:1px;--border-color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.12);--border-style:solid;--indicator-box-shadow:0 0 5px rgba(0, 0, 0, 0.16);--indicator-color:var(--ion-color-step-350, var(--ion-background-color, #fff));--indicator-height:100%;--indicator-transition:transform 260ms cubic-bezier(0.4, 0, 0.2, 1);--indicator-transform:none;--transition:100ms all linear;--padding-top:0;--padding-end:13px;--padding-bottom:0;--padding-start:13px;margin-top:2px;margin-bottom:2px;position:relative;-ms-flex-direction:row;flex-direction:row;min-width:70px;min-height:28px;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);font-size:13px;font-weight:450;line-height:37px}:host::before{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:5px;-webkit-transition:160ms opacity ease-in-out;transition:160ms opacity ease-in-out;-webkit-transition-delay:100ms;transition-delay:100ms;border-left:var(--border-width) var(--border-style) var(--border-color);content:"";opacity:1;will-change:opacity}:host(:first-of-type)::before{border-left-color:transparent}:host(.segment-button-disabled){opacity:0.3}::slotted(ion-icon){font-size:24px}:host(.segment-button-layout-icon-start) ::slotted(ion-label){-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:0;margin-inline-end:0}:host(.segment-button-layout-icon-end) ::slotted(ion-label){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:2px;margin-inline-end:2px}.segment-button-indicator{-webkit-padding-start:2px;padding-inline-start:2px;-webkit-padding-end:2px;padding-inline-end:2px;left:0;right:0;top:0;bottom:0}.segment-button-indicator-background{border-radius:var(--border-radius);background:var(--indicator-color)}.segment-button-indicator-background{-webkit-transition:var(--indicator-transition);transition:var(--indicator-transition)}:host(.segment-button-checked)::before,:host(.segment-button-after-checked)::before{opacity:0}:host(.segment-button-checked){z-index:-1}:host(.segment-button-activated){--indicator-transform:scale(0.95)}:host(.ion-focused) .button-native{opacity:0.7}@media (any-hover: hover){:host(:hover) .button-native{opacity:0.5}:host(.segment-button-checked:hover) .button-native{opacity:1}}:host(.in-segment-color){background:none;color:var(--ion-text-color, #000)}:host(.in-segment-color) .segment-button-indicator-background{background:var(--ion-color-step-350, var(--ion-background-color, #fff))}@media (any-hover: hover){:host(.in-segment-color:hover) .button-native,:host(.in-segment-color.segment-button-checked:hover) .button-native{color:var(--ion-text-color, #000)}}:host(.in-toolbar:not(.in-segment-color)){--background-checked:var(--ion-toolbar-segment-background-checked, none);--color:var(--ion-toolbar-segment-color, var(--ion-toolbar-color), initial);--color-checked:var(--ion-toolbar-segment-color-checked, var(--ion-toolbar-color), initial);--indicator-color:var(--ion-toolbar-segment-indicator-color, var(--ion-color-step-350, var(--ion-background-color, #fff)))}:host(.in-toolbar-color) .segment-button-indicator-background{background:var(--ion-color-contrast)}:host(.in-toolbar-color:not(.in-segment-color)) .button-native{color:var(--ion-color-contrast)}:host(.in-toolbar-color.segment-button-checked:not(.in-segment-color)) .button-native{color:var(--ion-color-base)}@media (any-hover: hover){:host(.in-toolbar-color:not(.in-segment-color):hover) .button-native{color:var(--ion-color-contrast)}:host(.in-toolbar-color.segment-button-checked:not(.in-segment-color):hover) .button-native{color:var(--ion-color-base)}}',md:':host{--color:initial;--color-hover:var(--color);--color-checked:var(--color);--color-disabled:var(--color);--padding-start:0;--padding-end:0;--padding-top:0;--padding-bottom:0;border-radius:var(--border-radius);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:column;flex-direction:column;height:auto;background:var(--background);color:var(--color);text-decoration:none;text-overflow:ellipsis;white-space:nowrap;cursor:pointer;grid-row:1;-webkit-font-kerning:none;font-kerning:none}.button-native{border-radius:0;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);-webkit-transform:translate3d(0,  0,  0);transform:translate3d(0,  0,  0);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-positive:1;flex-grow:1;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;min-width:inherit;max-width:inherit;height:auto;min-height:inherit;max-height:inherit;-webkit-transition:var(--transition);transition:var(--transition);border:none;outline:none;background:transparent;contain:content;pointer-events:none;overflow:hidden;z-index:2}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}:host(.segment-button-checked){background:var(--background-checked);color:var(--color-checked)}:host(.segment-button-disabled){cursor:default;pointer-events:none}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}:host(:focus){outline:none}@media (any-hover: hover){:host(:hover) .button-native{color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}:host(.segment-button-checked:hover) .button-native{color:var(--color-checked)}}::slotted(ion-icon){-ms-flex-negative:0;flex-shrink:0;-ms-flex-order:-1;order:-1;pointer-events:none}::slotted(ion-label){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;line-height:22px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none}:host(.segment-button-layout-icon-top) .button-native{-ms-flex-direction:column;flex-direction:column}:host(.segment-button-layout-icon-start) .button-native{-ms-flex-direction:row;flex-direction:row}:host(.segment-button-layout-icon-end) .button-native{-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.segment-button-layout-icon-bottom) .button-native{-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.segment-button-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.segment-button-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color, var(--color-checked))}.segment-button-indicator{-webkit-transform-origin:left;transform-origin:left;position:absolute;opacity:0;-webkit-box-sizing:border-box;box-sizing:border-box;will-change:transform, opacity;pointer-events:none}.segment-button-indicator-background{width:100%;height:var(--indicator-height);-webkit-transform:var(--indicator-transform);transform:var(--indicator-transform);-webkit-box-shadow:var(--indicator-box-shadow);box-shadow:var(--indicator-box-shadow);pointer-events:none}.segment-button-indicator-animated{-webkit-transition:var(--indicator-transition);transition:var(--indicator-transition)}:host(.segment-button-checked) .segment-button-indicator{opacity:1}@media (prefers-reduced-motion: reduce){.segment-button-indicator-background{-webkit-transform:none;transform:none}.segment-button-indicator-animated{-webkit-transition:none;transition:none}}:host{--background:none;--background-checked:none;--background-hover:var(--color-checked);--background-focused:var(--color-checked);--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04;--color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6);--color-checked:var(--ion-color-primary, #3880ff);--indicator-box-shadow:none;--indicator-color:var(--color-checked);--indicator-height:2px;--indicator-transition:transform 250ms cubic-bezier(0.4, 0, 0.2, 1);--indicator-transform:none;--padding-top:0;--padding-end:16px;--padding-bottom:0;--padding-start:16px;--transition:color 0.15s linear 0s, opacity 0.15s linear 0s;min-width:90px;min-height:48px;border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);font-size:14px;font-weight:500;letter-spacing:0.06em;line-height:40px;text-transform:uppercase}:host(.segment-button-disabled){opacity:0.3}:host(.in-segment-color){background:none;color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6)}:host(.in-segment-color) ion-ripple-effect{color:var(--ion-color-base)}:host(.in-segment-color) .segment-button-indicator-background{background:var(--ion-color-base)}:host(.in-segment-color.segment-button-checked) .button-native{color:var(--ion-color-base)}:host(.in-segment-color.ion-focused) .button-native::after{background:var(--ion-color-base)}@media (any-hover: hover){:host(.in-segment-color:hover) .button-native{color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6)}:host(.in-segment-color:hover) .button-native::after{background:var(--ion-color-base)}:host(.in-segment-color.segment-button-checked:hover) .button-native{color:var(--ion-color-base)}}:host(.in-toolbar:not(.in-segment-color)){--background:var(--ion-toolbar-segment-background, none);--background-checked:var(--ion-toolbar-segment-background-checked, none);--color:var(--ion-toolbar-segment-color, rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6));--color-checked:var(--ion-toolbar-segment-color-checked, var(--ion-color-primary, #3880ff));--indicator-color:var(--ion-toolbar-segment-color-checked, var(--color-checked))}:host(.in-toolbar-color:not(.in-segment-color)) .button-native{color:rgba(var(--ion-color-contrast-rgb), 0.6)}:host(.in-toolbar-color.segment-button-checked:not(.in-segment-color)) .button-native{color:var(--ion-color-contrast)}@media (any-hover: hover){:host(.in-toolbar-color:not(.in-segment-color)) .button-native::after{background:var(--ion-color-contrast)}}::slotted(ion-icon){margin-top:12px;margin-bottom:12px;font-size:24px}::slotted(ion-label){margin-top:12px;margin-bottom:12px}:host(.segment-button-layout-icon-top) ::slotted(ion-label),:host(.segment-button-layout-icon-bottom) ::slotted(ion-icon){margin-top:0}:host(.segment-button-layout-icon-top) ::slotted(ion-icon),:host(.segment-button-layout-icon-bottom) ::slotted(ion-label){margin-bottom:0}:host(.segment-button-layout-icon-start) ::slotted(ion-label){-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:0;margin-inline-end:0}:host(.segment-button-layout-icon-end) ::slotted(ion-label){-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px}:host(.segment-button-has-icon-only) ::slotted(ion-icon){margin-top:12px;margin-bottom:12px}:host(.segment-button-has-label-only) ::slotted(ion-label){margin-top:12px;margin-bottom:12px}.segment-button-indicator{left:0;right:0;bottom:0}.segment-button-indicator-background{background:var(--indicator-color)}:host(.in-toolbar:not(.in-segment-color)) .segment-button-indicator-background{background:var(--ion-toolbar-segment-indicator-color, var(--indicator-color))}:host(.in-toolbar-color:not(.in-segment-color)) .segment-button-indicator-background{background:var(--ion-color-contrast)}'}}},[33,"ion-segment-button",{disabled:[1028],layout:[1],type:[1],value:[8],checked:[32],setFocus:[64]}]),Ab=function(){"undefined"!=typeof customElements&&["ion-segment-button","ion-ripple-effect"].forEach((e=>{switch(e){case"ion-segment-button":customElements.get(e)||customElements.define(e,_b);break;case"ion-ripple-effect":customElements.get(e)||Dg()}}))},Rb=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.ionStyle=Uh(this,"ionStyle",7),this.color=void 0,this.size=void 0}sizeChanged(){this.emitStyle()}connectedCallback(){this.emitStyle()}emitStyle(){const e=this.getSize();this.ionStyle.emit({[`title-${e}`]:!0})}getSize(){return void 0!==this.size?this.size:"default"}render(){const e=ag(this),t=this.getSize();return zh(Lh,{class:Ng(this.color,{[e]:!0,[`title-${t}`]:!0,"title-rtl":"rtl"===document.dir})},zh("div",{class:"toolbar-title"},zh("slot",null)))}get el(){return this}static get watchers(){return{size:["sizeChanged"]}}static get style(){return{ios:":host{--color:initial;display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}.toolbar-title{display:block;width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;pointer-events:auto}:host(.title-small) .toolbar-title{white-space:normal}:host{top:0;-webkit-padding-start:90px;padding-inline-start:90px;-webkit-padding-end:90px;padding-inline-end:90px;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);position:absolute;width:100%;height:100%;-webkit-transform:translateZ(0);transform:translateZ(0);font-size:17px;font-weight:600;text-align:center;-webkit-box-sizing:border-box;box-sizing:border-box;pointer-events:none}@supports (inset-inline-start: 0){:host{inset-inline-start:0}}@supports not (inset-inline-start: 0){:host{left:0}:host-context([dir=rtl]){left:unset;right:unset;right:0}@supports selector(:dir(rtl)){:host:dir(rtl){left:unset;right:unset;right:0}}}:host(.title-small){-webkit-padding-start:9px;padding-inline-start:9px;-webkit-padding-end:9px;padding-inline-end:9px;padding-top:6px;padding-bottom:16px;position:relative;font-size:13px;font-weight:normal}:host(.title-large){-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px;padding-top:0;padding-bottom:0;-webkit-transform-origin:left center;transform-origin:left center;bottom:0;-ms-flex-align:end;align-items:flex-end;min-width:100%;padding-bottom:6px;font-size:34px;font-weight:700;text-align:start}:host(.title-large.title-rtl){-webkit-transform-origin:right center;transform-origin:right center}:host(.title-large.ion-cloned-element){--color:var(--ion-text-color, #000)}:host(.title-large) .toolbar-title{-webkit-transform-origin:inherit;transform-origin:inherit}:host-context([dir=rtl]):host(.title-large) .toolbar-title,:host-context([dir=rtl]).title-large .toolbar-title{-webkit-transform-origin:calc(100% - inherit);transform-origin:calc(100% - inherit)}@supports selector(:dir(rtl)){:host(.title-large) .toolbar-title:dir(rtl){-webkit-transform-origin:calc(100% - inherit);transform-origin:calc(100% - inherit)}}",md:":host{--color:initial;display:-ms-flexbox;display:flex;-ms-flex:1;flex:1;-ms-flex-align:center;align-items:center;-webkit-transform:translateZ(0);transform:translateZ(0);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}.toolbar-title{display:block;width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;pointer-events:auto}:host(.title-small) .toolbar-title{white-space:normal}:host{-webkit-padding-start:20px;padding-inline-start:20px;-webkit-padding-end:20px;padding-inline-end:20px;padding-top:0;padding-bottom:0;font-size:20px;font-weight:500;letter-spacing:0.0125em}:host(.title-small){width:100%;height:100%;font-size:15px;font-weight:normal}"}}},[33,"ion-title",{color:[513],size:[1]}]),Fb=function(){"undefined"!=typeof customElements&&["ion-title"].forEach((e=>{"ion-title"===e&&(customElements.get(e)||customElements.define(e,Rb))}))},Db=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.childrenStyles=new Map,this.color=void 0}componentWillLoad(){const e=Array.from(this.el.querySelectorAll("ion-buttons")),t=e.find((e=>"start"===e.slot));t&&t.classList.add("buttons-first-slot");const n=e.reverse(),r=n.find((e=>"end"===e.slot))||n.find((e=>"primary"===e.slot))||n.find((e=>"secondary"===e.slot));r&&r.classList.add("buttons-last-slot")}childrenStyle(e){e.stopPropagation();const t=e.target.tagName,n=e.detail,r={},a=this.childrenStyles.get(t)||{};let i=!1;Object.keys(n).forEach((e=>{const t=`toolbar-${e}`,o=n[e];o!==a[t]&&(i=!0),o&&(r[t]=!0)})),i&&(this.childrenStyles.set(t,r),xf(this))}render(){const e=ag(this),t={};return this.childrenStyles.forEach((e=>{Object.assign(t,e)})),zh(Lh,{class:Object.assign(Object.assign({},t),Ng(this.color,{[e]:!0,"in-toolbar":Ig("ion-toolbar",this.el)}))},zh("div",{class:"toolbar-background"}),zh("div",{class:"toolbar-container"},zh("slot",{name:"start"}),zh("slot",{name:"secondary"}),zh("div",{class:"toolbar-content"},zh("slot",null)),zh("slot",{name:"primary"}),zh("slot",{name:"end"})))}get el(){return this}static get style(){return{ios:":host{--border-width:0;--border-style:solid;--opacity:1;--opacity-scale:1;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right);display:block;position:relative;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);contain:content;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color){color:var(--ion-color-contrast)}:host(.ion-color) .toolbar-background{background:var(--ion-color-base)}.toolbar-container{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:row;flex-direction:row;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:var(--min-height);contain:content;overflow:hidden;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}.toolbar-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;opacity:calc(var(--opacity) * var(--opacity-scale));z-index:-1;pointer-events:none}::slotted(ion-progress-bar){left:0;right:0;bottom:0;position:absolute}:host{--background:var(--ion-toolbar-background, var(--ion-color-step-50, #f7f7f7));--color:var(--ion-toolbar-color, var(--ion-text-color, #000));--border-color:var(--ion-toolbar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.2))));--padding-top:3px;--padding-bottom:3px;--padding-start:4px;--padding-end:4px;--min-height:44px}.toolbar-content{-ms-flex:1;flex:1;-ms-flex-order:4;order:4;min-width:0}:host(.toolbar-segment) .toolbar-content{display:-ms-inline-flexbox;display:inline-flex}:host(.toolbar-searchbar) .toolbar-container{padding-top:0;padding-bottom:0}:host(.toolbar-searchbar) ::slotted(*){-ms-flex-item-align:start;align-self:start}:host(.toolbar-searchbar) ::slotted(ion-chip){margin-top:3px}:host(.toolbar-searchbar) ::slotted(ion-back-button){height:38px}::slotted(ion-buttons){min-height:38px}::slotted([slot=start]){-ms-flex-order:2;order:2}::slotted([slot=secondary]){-ms-flex-order:3;order:3}::slotted([slot=primary]){-ms-flex-order:5;order:5;text-align:end}::slotted([slot=end]){-ms-flex-order:6;order:6;text-align:end}:host(.toolbar-title-large) .toolbar-container{-ms-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-align:start;align-items:flex-start}:host(.toolbar-title-large) .toolbar-content ion-title{-ms-flex:1;flex:1;-ms-flex-order:8;order:8;min-width:100%}",md:":host{--border-width:0;--border-style:solid;--opacity:1;--opacity-scale:1;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right);display:block;position:relative;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);contain:content;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}:host(.ion-color){color:var(--ion-color-contrast)}:host(.ion-color) .toolbar-background{background:var(--ion-color-base)}.toolbar-container{-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:row;flex-direction:row;-ms-flex-align:center;align-items:center;-ms-flex-pack:justify;justify-content:space-between;width:100%;min-height:var(--min-height);contain:content;overflow:hidden;z-index:10;-webkit-box-sizing:border-box;box-sizing:border-box}.toolbar-background{left:0;right:0;top:0;bottom:0;position:absolute;-webkit-transform:translateZ(0);transform:translateZ(0);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;opacity:calc(var(--opacity) * var(--opacity-scale));z-index:-1;pointer-events:none}::slotted(ion-progress-bar){left:0;right:0;bottom:0;position:absolute}:host{--background:var(--ion-toolbar-background, var(--ion-background-color, #fff));--color:var(--ion-toolbar-color, var(--ion-text-color, #424242));--border-color:var(--ion-toolbar-border-color, var(--ion-border-color, var(--ion-color-step-150, #c1c4cd)));--padding-top:0;--padding-bottom:0;--padding-start:0;--padding-end:0;--min-height:56px}.toolbar-content{-ms-flex:1;flex:1;-ms-flex-order:3;order:3;min-width:0;max-width:100%}::slotted(.buttons-first-slot){-webkit-margin-start:4px;margin-inline-start:4px}::slotted(.buttons-last-slot){-webkit-margin-end:4px;margin-inline-end:4px}::slotted([slot=start]){-ms-flex-order:2;order:2}::slotted([slot=secondary]){-ms-flex-order:4;order:4}::slotted([slot=primary]){-ms-flex-order:5;order:5;text-align:end}::slotted([slot=end]){-ms-flex-order:6;order:6;text-align:end}"}}},[33,"ion-toolbar",{color:[513]},[[0,"ionStyle","childrenStyle"]]]),Mb=function(){"undefined"!=typeof customElements&&["ion-toolbar"].forEach((e=>{"ion-toolbar"===e&&(customElements.get(e)||customElements.define(e,Db))}))},Ob=qg;
/*!
             * (C) Ionic http://ionicframework.com - MIT License
             */
var zb;!function(e){e.Dark="DARK",e.Light="LIGHT",e.Default="DEFAULT"}(zb||(zb={}));const Pb=Cf(class extends Bf{constructor(){super(),this.__registerHost()}componentDidLoad(){Bb((async()=>{const e=Hm(window,"hybrid");if(Wm.getBoolean("_testing")||yh((()=>t.import("./index9-legacy-4d7fd10e.js"))).then((e=>e.startTapClick(Wm))),Wm.getBoolean("statusTap",e)&&yh((()=>t.import("./status-tap-legacy-401f719a.js"))).then((e=>e.startStatusTap())),Wm.getBoolean("inputShims",Lb())){const e=Hm(window,"ios")?"ios":"android";yh((()=>t.import("./input-shims-legacy-8edbf82f.js"))).then((t=>t.startInputShims(Wm,e)))}const n=await yh((()=>t.import("./hardware-back-button-legacy-7391e573.js")));Wm.getBoolean("hardwareBackButton",e)?n.startHardwareBackButton():n.blockHardwareBackButton(),"undefined"!=typeof window&&yh((()=>t.import("./keyboard2-legacy-b66672d5.js"))).then((e=>e.startKeyboardAssist(window))),yh((()=>t.import("./focus-visible-legacy-b3e947fe.js"))).then((e=>this.focusVisible=e.startFocusVisible()))}))}async setFocus(e){this.focusVisible&&this.focusVisible.setFocus(e)}render(){const e=ag(this);return zh(Lh,{class:{[e]:!0,"ion-page":!0,"force-statusbar-padding":Wm.getBoolean("_forceStatusbarPadding")}})}get el(){return this}static get style(){return"html.plt-mobile ion-app{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}html.plt-mobile ion-app [contenteditable]{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text}ion-app.force-statusbar-padding{--ion-safe-area-top:20px}"}},[0,"ion-app",{setFocus:[64]}]),Lb=()=>!(!Hm(window,"ios")||!Hm(window,"mobile"))||!(!Hm(window,"android")||!Hm(window,"mobileweb")),Bb=e=>{"requestIdleCallback"in window?window.requestIdleCallback(e):setTimeout(e,32)},Wb=function(){"undefined"!=typeof customElements&&["ion-app"].forEach((e=>{"ion-app"===e&&(customElements.get(e)||customElements.define(e,Pb))}))},Vb=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.inheritedAttributes={},this.onClick=async e=>{const t=this.el.closest("ion-nav");return e.preventDefault(),t&&await t.canGoBack()?t.pop({animationBuilder:this.routerAnimation,skipIfBusy:!0}):Tg(this.defaultHref,e,"back",this.routerAnimation)},this.color=void 0,this.defaultHref=void 0,this.disabled=!1,this.icon=void 0,this.text=void 0,this.type="button",this.routerAnimation=void 0}componentWillLoad(){this.inheritedAttributes=rm(this.el),void 0===this.defaultHref&&(this.defaultHref=Wm.get("backButtonDefaultHref"))}get backButtonIcon(){const e=this.icon;return null!=e?e:"ios"===ag(this)?Wm.get("backButtonIcon","data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='round' stroke-linejoin='round' stroke-width='48' d='M328 112L184 256l144 144' class='ionicon-fill-none'/></svg>"):Wm.get("backButtonIcon","data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' class='ionicon' viewBox='0 0 512 512'><path stroke-linecap='square' stroke-miterlimit='10' stroke-width='48' d='M244 400L100 256l144-144M120 256h292' class='ionicon-fill-none'/></svg>")}get backButtonText(){const e="ios"===ag(this)?"Back":null;return null!=this.text?this.text:Wm.get("backButtonText",e)}get hasIconOnly(){return this.backButtonIcon&&!this.backButtonText}get rippleType(){return this.hasIconOnly?"unbounded":"bounded"}render(){const{color:e,defaultHref:t,disabled:n,type:r,hasIconOnly:a,backButtonIcon:i,backButtonText:o,icon:s,inheritedAttributes:l}=this,u=void 0!==t,d=ag(this),c=l["aria-label"]||o||"back";return zh(Lh,{onClick:this.onClick,class:Ng(e,{[d]:!0,button:!0,"back-button-disabled":n,"back-button-has-icon-only":a,"in-toolbar":Ig("ion-toolbar",this.el),"in-toolbar-color":Ig("ion-toolbar[color]",this.el),"ion-activatable":!0,"ion-focusable":!0,"show-back-button":u})},zh("button",{type:r,disabled:n,class:"button-native",part:"native","aria-label":c},zh("span",{class:"button-inner"},i&&zh("ion-icon",{part:"icon",icon:i,"aria-hidden":"true",lazy:!1,"flip-rtl":void 0===s}),o&&zh("span",{part:"text","aria-hidden":"true",class:"button-text"},o)),"md"===d&&zh("ion-ripple-effect",{type:this.rippleType})))}get el(){return this}static get style(){return{ios:':host{--background:transparent;--color-focused:currentColor;--color-hover:currentColor;--icon-margin-top:0;--icon-margin-bottom:0;--icon-padding-top:0;--icon-padding-end:0;--icon-padding-bottom:0;--icon-padding-start:0;--margin-top:0;--margin-end:0;--margin-bottom:0;--margin-start:0;--min-width:auto;--min-height:auto;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;--opacity:1;--ripple-color:currentColor;--transition:background-color, opacity 100ms linear;display:none;min-width:var(--min-width);min-height:var(--min-height);color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;text-overflow:ellipsis;text-transform:none;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-font-kerning:none;font-kerning:none}ion-ripple-effect{color:var(--ripple-color)}:host(.ion-color) .button-native{color:var(--ion-color-base)}:host(.show-back-button){display:block}:host(.back-button-disabled){cursor:default;opacity:0.5;pointer-events:none}.button-native{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;min-height:inherit;-webkit-transition:var(--transition);transition:var(--transition);border:0;outline:none;background:var(--background);line-height:1;cursor:pointer;opacity:var(--opacity);overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:0;-webkit-appearance:none;-moz-appearance:none;appearance:none}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}ion-icon{-webkit-padding-start:var(--icon-padding-start);padding-inline-start:var(--icon-padding-start);-webkit-padding-end:var(--icon-padding-end);padding-inline-end:var(--icon-padding-end);padding-top:var(--icon-padding-top);padding-bottom:var(--icon-padding-bottom);-webkit-margin-start:var(--icon-margin-start);margin-inline-start:var(--icon-margin-start);-webkit-margin-end:var(--icon-margin-end);margin-inline-end:var(--icon-margin-end);margin-top:var(--icon-margin-top);margin-bottom:var(--icon-margin-bottom);display:inherit;font-size:var(--icon-font-size);font-weight:var(--icon-font-weight);pointer-events:none}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}@media (any-hover: hover){:host(:hover) .button-native{color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.ion-color.ion-focused) .button-native{color:var(--ion-color-base)}@media (any-hover: hover){:host(.ion-color:hover) .button-native{color:var(--ion-color-base)}}:host(.in-toolbar:not(.in-toolbar-color)){color:var(--ion-toolbar-color, var(--color))}:host{--background-hover:transparent;--background-hover-opacity:1;--background-focused:currentColor;--background-focused-opacity:.1;--border-radius:4px;--color:var(--ion-color-primary, #3880ff);--icon-margin-end:1px;--icon-margin-start:-4px;--icon-font-size:1.6em;--min-height:32px;font-size:17px}.button-native{-webkit-transform:translateZ(0);transform:translateZ(0);overflow:visible;z-index:99}:host(.ion-activated) .button-native{opacity:0.4}@media (any-hover: hover){:host(:hover){opacity:0.6}}',md:':host{--background:transparent;--color-focused:currentColor;--color-hover:currentColor;--icon-margin-top:0;--icon-margin-bottom:0;--icon-padding-top:0;--icon-padding-end:0;--icon-padding-bottom:0;--icon-padding-start:0;--margin-top:0;--margin-end:0;--margin-bottom:0;--margin-start:0;--min-width:auto;--min-height:auto;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;--opacity:1;--ripple-color:currentColor;--transition:background-color, opacity 100ms linear;display:none;min-width:var(--min-width);min-height:var(--min-height);color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;text-overflow:ellipsis;text-transform:none;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-font-kerning:none;font-kerning:none}ion-ripple-effect{color:var(--ripple-color)}:host(.ion-color) .button-native{color:var(--ion-color-base)}:host(.show-back-button){display:block}:host(.back-button-disabled){cursor:default;opacity:0.5;pointer-events:none}.button-native{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;min-height:inherit;-webkit-transition:var(--transition);transition:var(--transition);border:0;outline:none;background:var(--background);line-height:1;cursor:pointer;opacity:var(--opacity);overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:0;-webkit-appearance:none;-moz-appearance:none;appearance:none}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:row nowrap;flex-flow:row nowrap;-ms-flex-negative:0;flex-shrink:0;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:100%;height:100%;z-index:1}ion-icon{-webkit-padding-start:var(--icon-padding-start);padding-inline-start:var(--icon-padding-start);-webkit-padding-end:var(--icon-padding-end);padding-inline-end:var(--icon-padding-end);padding-top:var(--icon-padding-top);padding-bottom:var(--icon-padding-bottom);-webkit-margin-start:var(--icon-margin-start);margin-inline-start:var(--icon-margin-start);-webkit-margin-end:var(--icon-margin-end);margin-inline-end:var(--icon-margin-end);margin-top:var(--icon-margin-top);margin-bottom:var(--icon-margin-bottom);display:inherit;font-size:var(--icon-font-size);font-weight:var(--icon-font-weight);pointer-events:none}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}@media (any-hover: hover){:host(:hover) .button-native{color:var(--color-hover)}:host(:hover) .button-native::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}:host(.ion-color.ion-focused) .button-native{color:var(--ion-color-base)}@media (any-hover: hover){:host(.ion-color:hover) .button-native{color:var(--ion-color-base)}}:host(.in-toolbar:not(.in-toolbar-color)){color:var(--ion-toolbar-color, var(--color))}:host{--border-radius:4px;--background-focused:currentColor;--background-focused-opacity:.12;--background-hover:currentColor;--background-hover-opacity:0.04;--color:currentColor;--icon-margin-end:0;--icon-margin-start:0;--icon-font-size:24px;--icon-font-weight:normal;--min-height:32px;--min-width:44px;--padding-start:12px;--padding-end:12px;font-size:14px;font-weight:500;text-transform:uppercase}:host(.back-button-has-icon-only){--border-radius:50%;min-width:48px;height:48px}.button-native{-webkit-box-shadow:none;box-shadow:none}.button-text{-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px;padding-top:0;padding-bottom:0}ion-icon{line-height:0.67;text-align:start}@media (any-hover: hover){:host(.ion-color:hover) .button-native::after{background:var(--ion-color-base)}}:host(.ion-color.ion-focused) .button-native::after{background:var(--ion-color-base)}'}}},[33,"ion-back-button",{color:[513],defaultHref:[1025,"default-href"],disabled:[516],icon:[1],text:[1],type:[1],routerAnimation:[16]}]),Ub=function(){"undefined"!=typeof customElements&&["ion-back-button","ion-icon","ion-ripple-effect"].forEach((e=>{switch(e){case"ion-back-button":customElements.get(e)||customElements.define(e,Vb);break;case"ion-icon":customElements.get(e)||"undefined"!=typeof customElements&&["ion-icon"].forEach((e=>{"ion-icon"===e&&(customElements.get(e)||customElements.define(e,wg))}));break;case"ion-ripple-effect":customElements.get(e)||Dg()}}))},jb=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.ionNavWillLoad=Uh(this,"ionNavWillLoad",7),this.ionNavWillChange=Uh(this,"ionNavWillChange",3),this.ionNavDidChange=Uh(this,"ionNavDidChange",3),this.gestureOrAnimationInProgress=!1,this.mode=ag(this),this.delegate=void 0,this.animated=!0,this.animation=void 0,this.swipeHandler=void 0}swipeHandlerChanged(){this.gesture&&this.gesture.enable(void 0!==this.swipeHandler)}async connectedCallback(){const e=()=>{this.gestureOrAnimationInProgress=!0,this.swipeHandler&&this.swipeHandler.onStart()};this.gesture=(await yh((()=>t.import("./swipe-back-legacy-0249fd15.js")))).createSwipeBackGesture(this.el,(()=>!this.gestureOrAnimationInProgress&&!!this.swipeHandler&&this.swipeHandler.canStart()),(()=>e()),(e=>{var t;return null===(t=this.ani)||void 0===t?void 0:t.progressStep(e)}),((e,t,n)=>{if(this.ani){this.ani.onFinish((()=>{this.gestureOrAnimationInProgress=!1,this.swipeHandler&&this.swipeHandler.onEnd(e)}),{oneTimeCallback:!0});let r=e?-.001:.001;e?r+=Om([0,0],[.32,.72],[0,1],[1,1],t)[0]:(this.ani.easing("cubic-bezier(1, 0, 0.68, 0.28)"),r+=Om([0,0],[1,0],[.68,.28],[1,1],t)[0]),this.ani.progressEnd(e?1:0,r,n)}else this.gestureOrAnimationInProgress=!1})),this.swipeHandlerChanged()}componentWillLoad(){this.ionNavWillLoad.emit()}disconnectedCallback(){this.gesture&&(this.gesture.destroy(),this.gesture=void 0)}async commit(e,t,n){const r=await this.lock();let a=!1;try{a=await this.transition(e,t,n)}catch(kp){console.error(kp)}return r(),a}async setRouteId(e,t,n,r){return{changed:await this.setRoot(e,t,{duration:"root"===n?0:void 0,direction:"back"===n?"back":"forward",animationBuilder:r}),element:this.activeEl}}async getRouteId(){const e=this.activeEl;return e?{id:e.tagName,element:e,params:this.activeParams}:void 0}async setRoot(e,t,n){if(this.activeComponent===e&&um(t,this.activeParams))return!1;const r=this.activeEl,a=await og(this.delegate,this.el,e,["ion-page","ion-page-invisible"],t);return this.activeComponent=e,this.activeEl=a,this.activeParams=t,await this.commit(a,r,n),await((e,t)=>{if(t){if(e){const n=t.parentElement;return e.removeViewFromDom(n,t)}t.remove()}return Promise.resolve()})(this.delegate,r),!0}async transition(e,t,n={}){if(t===e)return!1;this.ionNavWillChange.emit();const{el:r,mode:a}=this,i=this.animated&&Wm.getBoolean("animated",!0),o=n.animationBuilder||this.animation||Wm.get("navAnimation");var s;return await xm(Object.assign(Object.assign({mode:a,animated:i,enteringEl:e,leavingEl:t,baseEl:r,deepWait:(s=r,void 0!==s.componentOnReady),progressCallback:n.progressAnimation?e=>{void 0===e||this.gestureOrAnimationInProgress?this.ani=e:(this.gestureOrAnimationInProgress=!0,e.onFinish((()=>{this.gestureOrAnimationInProgress=!1,this.swipeHandler&&this.swipeHandler.onEnd(!1)}),{oneTimeCallback:!0}),e.progressEnd(0,0,0))}:void 0},n),{animationBuilder:o})),this.ionNavDidChange.emit(),!0}async lock(){const e=this.waitPromise;let t;return this.waitPromise=new Promise((e=>t=e)),void 0!==e&&await e,t}render(){return zh("slot",null)}get el(){return this}static get watchers(){return{swipeHandler:["swipeHandlerChanged"]}}static get style(){return":host{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}"}},[1,"ion-router-outlet",{mode:[1025],delegate:[16],animated:[4],animation:[16],swipeHandler:[16],commit:[64],setRouteId:[64],getRouteId:[64]}]),Hb=function(){"undefined"!=typeof customElements&&["ion-router-outlet"].forEach((e=>{"ion-router-outlet"===e&&(customElements.get(e)||customElements.define(e,jb))}))},Gb=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.ionTabBarChanged=Uh(this,"ionTabBarChanged",7),this.keyboardCtrl=null,this.keyboardVisible=!1,this.color=void 0,this.selectedTab=void 0,this.translucent=!1}selectedTabChanged(){void 0!==this.selectedTab&&this.ionTabBarChanged.emit({tab:this.selectedTab})}componentWillLoad(){this.selectedTabChanged()}async connectedCallback(){this.keyboardCtrl=await(async e=>{let t,n,r,a;const i=async()=>{const e=await rb.getResizeMode(),i=void 0===e?void 0:e.mode;t=()=>{void 0===a&&(a=ib(i)),r=!0,o(r,i)},n=()=>{r=!1,o(r,i)},null==Zf||Zf.addEventListener("keyboardWillShow",t),null==Zf||Zf.addEventListener("keyboardWillHide",n)},o=(t,n)=>{e&&e(t,s(n))},s=e=>{if(0===a||a===ib(e))return;const t=ab(e);return null!==t?new Promise((e=>{const n=new ResizeObserver((()=>{t.clientHeight===a&&(n.disconnect(),e())}));n.observe(t)})):void 0};return await i(),{init:i,destroy:()=>{null==Zf||Zf.removeEventListener("keyboardWillShow",t),null==Zf||Zf.removeEventListener("keyboardWillHide",n),t=n=void 0},isKeyboardVisible:()=>r}})((async(e,t)=>{!1===e&&void 0!==t&&await t,this.keyboardVisible=e}))}disconnectedCallback(){this.keyboardCtrl&&this.keyboardCtrl.destroy()}render(){const{color:e,translucent:t,keyboardVisible:n}=this,r=ag(this),a=n&&"top"!==this.el.getAttribute("slot");return zh(Lh,{role:"tablist","aria-hidden":a?"true":null,class:Ng(e,{[r]:!0,"tab-bar-translucent":t,"tab-bar-hidden":a})},zh("slot",null))}get el(){return this}static get watchers(){return{selectedTab:["selectedTabChanged"]}}static get style(){return{ios:":host{-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-bottom:var(--ion-safe-area-bottom, 0);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:10;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host(.ion-color) ::slotted(ion-tab-button){--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}:host(.ion-color) ::slotted(.tab-selected){color:var(--ion-color-contrast)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){color:rgba(var(--ion-color-contrast-rgb), 0.7)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){background:var(--ion-color-base)}:host(.ion-color) ::slotted(ion-tab-button.ion-focused),:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:var(--background-focused)}:host(.tab-bar-translucent) ::slotted(ion-tab-button){background:transparent}:host([slot=top]){padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}:host(.tab-bar-hidden){display:none !important}:host{--background:var(--ion-tab-bar-background, var(--ion-color-step-50, #f7f7f7));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:0.55px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.2))));--color:var(--ion-tab-bar-color, var(--ion-color-step-600, #666666));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #3880ff));height:50px}@supports ((-webkit-backdrop-filter: blur(0)) or (backdrop-filter: blur(0))){:host(.tab-bar-translucent){--background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);-webkit-backdrop-filter:saturate(210%) blur(20px);backdrop-filter:saturate(210%) blur(20px)}:host(.ion-color.tab-bar-translucent){background:rgba(var(--ion-color-base-rgb), 0.8)}:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.6)}}",md:":host{-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right);display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;width:auto;padding-bottom:var(--ion-safe-area-bottom, 0);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;z-index:10;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host(.ion-color) ::slotted(ion-tab-button){--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}:host(.ion-color) ::slotted(.tab-selected){color:var(--ion-color-contrast)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){color:rgba(var(--ion-color-contrast-rgb), 0.7)}:host(.ion-color),:host(.ion-color) ::slotted(ion-tab-button){background:var(--ion-color-base)}:host(.ion-color) ::slotted(ion-tab-button.ion-focused),:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused){background:var(--background-focused)}:host(.tab-bar-translucent) ::slotted(ion-tab-button){background:transparent}:host([slot=top]){padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}:host(.tab-bar-hidden){display:none !important}:host{--background:var(--ion-tab-bar-background, var(--ion-background-color, #fff));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:1px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.07))));--color:var(--ion-tab-bar-color, var(--ion-color-step-650, #595959));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #3880ff));height:56px}"}}},[33,"ion-tab-bar",{color:[513],selectedTab:[1,"selected-tab"],translucent:[4],keyboardVisible:[32]}]),qb=function(){"undefined"!=typeof customElements&&["ion-tab-bar"].forEach((e=>{"ion-tab-bar"===e&&(customElements.get(e)||customElements.define(e,Gb))}))},Kb=Cf(class extends Bf{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.ionTabButtonClick=Uh(this,"ionTabButtonClick",7),this.inheritedAttributes={},this.onKeyUp=e=>{"Enter"!==e.key&&" "!==e.key||this.selectTab(e)},this.onClick=e=>{this.selectTab(e)},this.disabled=!1,this.download=void 0,this.href=void 0,this.rel=void 0,this.layout=void 0,this.selected=!1,this.tab=void 0,this.target=void 0}onTabBarChanged(e){const t=e.target,n=this.el.parentElement;(e.composedPath().includes(n)||(null==t?void 0:t.contains(this.el)))&&(this.selected=this.tab===e.detail.tab)}componentWillLoad(){this.inheritedAttributes=Object.assign({},tm(this.el,["aria-label"])),void 0===this.layout&&(this.layout=Wm.get("tabButtonLayout","icon-top"))}selectTab(e){void 0!==this.tab&&(this.disabled||this.ionTabButtonClick.emit({tab:this.tab,href:this.href,selected:this.selected}),e.preventDefault())}get hasLabel(){return!!this.el.querySelector("ion-label")}get hasIcon(){return!!this.el.querySelector("ion-icon")}render(){const{disabled:e,hasIcon:t,hasLabel:n,href:r,rel:a,target:i,layout:o,selected:s,tab:l,inheritedAttributes:u}=this,d=ag(this),c={download:this.download,href:r,rel:a,target:i};return zh(Lh,{onClick:this.onClick,onKeyup:this.onKeyUp,id:void 0!==l?`tab-button-${l}`:null,class:{[d]:!0,"tab-selected":s,"tab-disabled":e,"tab-has-label":n,"tab-has-icon":t,"tab-has-label-only":n&&!t,"tab-has-icon-only":t&&!n,[`tab-layout-${o}`]:!0,"ion-activatable":!0,"ion-selectable":!0,"ion-focusable":!0}},zh("a",Object.assign({},c,{class:"button-native",part:"native",role:"tab","aria-selected":s?"true":null,"aria-disabled":e?"true":null,tabindex:e?"-1":void 0},u),zh("span",{class:"button-inner"},zh("slot",null)),"md"===d&&zh("ion-ripple-effect",{type:"unbounded"})))}get el(){return this}static get style(){return{ios:':host{--ripple-color:var(--color-selected);--background-focused-opacity:1;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}.button-native{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-drag:none}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){a:hover{color:var(--color-selected)}}:host(.tab-selected){color:var(--color-selected)}:host(.tab-hidden){display:none !important}:host(.tab-disabled){pointer-events:none;opacity:0.4}::slotted(ion-label),::slotted(ion-icon){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex-order:0;order:0}::slotted(ion-icon){-ms-flex-order:-1;order:-1;height:1em}:host(.tab-has-label-only) ::slotted(ion-label){white-space:normal}::slotted(ion-badge){-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1}:host(.tab-layout-icon-start){-ms-flex-direction:row;flex-direction:row}:host(.tab-layout-icon-end){-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.tab-layout-icon-bottom){-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.tab-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.tab-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color)}:host{--padding-top:0;--padding-end:2px;--padding-bottom:0;--padding-start:2px;max-width:240px;font-size:10px}::slotted(ion-badge){-webkit-padding-start:6px;padding-inline-start:6px;-webkit-padding-end:6px;padding-inline-end:6px;padding-top:1px;padding-bottom:1px;top:4px;height:auto;font-size:12px;line-height:16px}@supports (inset-inline-start: 0){::slotted(ion-badge){inset-inline-start:calc(50% + 6px)}}@supports not (inset-inline-start: 0){::slotted(ion-badge){left:calc(50% + 6px)}:host-context([dir=rtl]) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}[dir=rtl] ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}@supports selector(:dir(rtl)){::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:calc(50% + 6px)}}}::slotted(ion-icon){margin-top:2px;margin-bottom:2px;font-size:30px}::slotted(ion-icon::before){vertical-align:top}::slotted(ion-label){margin-top:0;margin-bottom:1px;min-height:11px;font-weight:500}:host(.tab-has-label-only) ::slotted(ion-label){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:12px;font-size:14px;line-height:1.1}:host(.tab-layout-icon-end) ::slotted(ion-label),:host(.tab-layout-icon-start) ::slotted(ion-label),:host(.tab-layout-icon-hide) ::slotted(ion-label){margin-top:2px;margin-bottom:2px;font-size:14px;line-height:1.1}:host(.tab-layout-icon-end) ::slotted(ion-icon),:host(.tab-layout-icon-start) ::slotted(ion-icon){min-width:24px;height:26px;margin-top:2px;margin-bottom:1px;font-size:24px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-bottom) ::slotted(ion-badge){inset-inline-start:calc(50% + 12px)}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-bottom) ::slotted(ion-badge){left:calc(50% + 12px)}:host-context([dir=rtl]):host(.tab-layout-icon-bottom) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-bottom ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 12px)}@supports selector(:dir(rtl)){:host(.tab-layout-icon-bottom) ::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:calc(50% + 12px)}}}:host(.tab-layout-icon-bottom) ::slotted(ion-icon){margin-top:0;margin-bottom:1px}:host(.tab-layout-icon-bottom) ::slotted(ion-label){margin-top:4px}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){top:10px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){inset-inline-start:calc(50% + 35px)}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){left:calc(50% + 35px)}:host-context([dir=rtl]):host(.tab-layout-icon-start) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-start ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-end) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-end ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 35px)}@supports selector(:dir(rtl)){:host(.tab-layout-icon-start) ::slotted(ion-badge):dir(rtl),:host(.tab-layout-icon-end) ::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:calc(50% + 35px)}}}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){top:10px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){inset-inline-start:calc(50% + 30px)}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){left:calc(50% + 30px)}:host-context([dir=rtl]):host(.tab-layout-icon-hide) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-hide ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-has-label-only) ::slotted(ion-badge),:host-context([dir=rtl]).tab-has-label-only ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 30px)}@supports selector(:dir(rtl)){:host(.tab-layout-icon-hide) ::slotted(ion-badge):dir(rtl),:host(.tab-has-label-only) ::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:calc(50% + 30px)}}}:host(.tab-layout-label-hide) ::slotted(ion-badge),:host(.tab-has-icon-only) ::slotted(ion-badge){top:10px}:host(.tab-layout-label-hide) ::slotted(ion-icon){margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}',md:':host{--ripple-color:var(--color-selected);--background-focused-opacity:1;-ms-flex:1;flex:1;-ms-flex-direction:column;flex-direction:column;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}.button-native{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:-ms-flexbox;display:flex;position:relative;-ms-flex-direction:inherit;flex-direction:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-user-drag:none}.button-native::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.button-inner{display:-ms-flexbox;display:flex;position:relative;-ms-flex-flow:inherit;flex-flow:inherit;-ms-flex-align:inherit;align-items:inherit;-ms-flex-pack:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}:host(.ion-focused) .button-native{color:var(--color-focused)}:host(.ion-focused) .button-native::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){a:hover{color:var(--color-selected)}}:host(.tab-selected){color:var(--color-selected)}:host(.tab-hidden){display:none !important}:host(.tab-disabled){pointer-events:none;opacity:0.4}::slotted(ion-label),::slotted(ion-icon){display:block;-ms-flex-item-align:center;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box}::slotted(ion-label){-ms-flex-order:0;order:0}::slotted(ion-icon){-ms-flex-order:-1;order:-1;height:1em}:host(.tab-has-label-only) ::slotted(ion-label){white-space:normal}::slotted(ion-badge){-webkit-box-sizing:border-box;box-sizing:border-box;position:absolute;z-index:1}:host(.tab-layout-icon-start){-ms-flex-direction:row;flex-direction:row}:host(.tab-layout-icon-end){-ms-flex-direction:row-reverse;flex-direction:row-reverse}:host(.tab-layout-icon-bottom){-ms-flex-direction:column-reverse;flex-direction:column-reverse}:host(.tab-layout-icon-hide) ::slotted(ion-icon){display:none}:host(.tab-layout-label-hide) ::slotted(ion-label){display:none}ion-ripple-effect{color:var(--ripple-color)}:host{--padding-top:0;--padding-end:12px;--padding-bottom:0;--padding-start:12px;max-width:168px;font-size:12px;font-weight:normal;letter-spacing:0.03em}::slotted(ion-label){margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;text-transform:none}::slotted(ion-icon){margin-left:0;margin-right:0;margin-top:16px;margin-bottom:16px;-webkit-transform-origin:center center;transform-origin:center center;font-size:22px}:host-context([dir=rtl]) ::slotted(ion-icon){-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}[dir=rtl] ::slotted(ion-icon){-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}@supports selector(:dir(rtl)){::slotted(ion-icon):dir(rtl){-webkit-transform-origin:calc(100% - center) center;transform-origin:calc(100% - center) center}}::slotted(ion-badge){border-radius:8px;-webkit-padding-start:2px;padding-inline-start:2px;-webkit-padding-end:2px;padding-inline-end:2px;padding-top:3px;padding-bottom:2px;top:8px;min-width:12px;font-size:8px;font-weight:normal}@supports (inset-inline-start: 0){::slotted(ion-badge){inset-inline-start:calc(50% + 6px)}}@supports not (inset-inline-start: 0){::slotted(ion-badge){left:calc(50% + 6px)}:host-context([dir=rtl]) ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}[dir=rtl] ::slotted(ion-badge){left:unset;right:unset;right:calc(50% + 6px)}@supports selector(:dir(rtl)){::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:calc(50% + 6px)}}}::slotted(ion-badge:empty){display:block;min-width:8px;height:8px}:host(.tab-layout-icon-top) ::slotted(ion-icon){margin-top:6px;margin-bottom:2px}:host(.tab-layout-icon-top) ::slotted(ion-label){margin-top:0;margin-bottom:6px}:host(.tab-layout-icon-bottom) ::slotted(ion-badge){top:8px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-bottom) ::slotted(ion-badge){inset-inline-start:70%}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-bottom) ::slotted(ion-badge){left:70%}:host-context([dir=rtl]):host(.tab-layout-icon-bottom) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-bottom ::slotted(ion-badge){left:unset;right:unset;right:70%}@supports selector(:dir(rtl)){:host(.tab-layout-icon-bottom) ::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:70%}}}:host(.tab-layout-icon-bottom) ::slotted(ion-icon){margin-top:0;margin-bottom:6px}:host(.tab-layout-icon-bottom) ::slotted(ion-label){margin-top:6px;margin-bottom:0}:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){top:16px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){inset-inline-start:80%}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-start) ::slotted(ion-badge),:host(.tab-layout-icon-end) ::slotted(ion-badge){left:80%}:host-context([dir=rtl]):host(.tab-layout-icon-start) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-start ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-layout-icon-end) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-end ::slotted(ion-badge){left:unset;right:unset;right:80%}@supports selector(:dir(rtl)){:host(.tab-layout-icon-start) ::slotted(ion-badge):dir(rtl),:host(.tab-layout-icon-end) ::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:80%}}}:host(.tab-layout-icon-start) ::slotted(ion-icon){-webkit-margin-end:6px;margin-inline-end:6px}:host(.tab-layout-icon-end) ::slotted(ion-icon){-webkit-margin-start:6px;margin-inline-start:6px}:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){top:16px}@supports (inset-inline-start: 0){:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){inset-inline-start:70%}}@supports not (inset-inline-start: 0){:host(.tab-layout-icon-hide) ::slotted(ion-badge),:host(.tab-has-label-only) ::slotted(ion-badge){left:70%}:host-context([dir=rtl]):host(.tab-layout-icon-hide) ::slotted(ion-badge),:host-context([dir=rtl]).tab-layout-icon-hide ::slotted(ion-badge),:host-context([dir=rtl]):host(.tab-has-label-only) ::slotted(ion-badge),:host-context([dir=rtl]).tab-has-label-only ::slotted(ion-badge){left:unset;right:unset;right:70%}@supports selector(:dir(rtl)){:host(.tab-layout-icon-hide) ::slotted(ion-badge):dir(rtl),:host(.tab-has-label-only) ::slotted(ion-badge):dir(rtl){left:unset;right:unset;right:70%}}}:host(.tab-layout-icon-hide) ::slotted(ion-label),:host(.tab-has-label-only) ::slotted(ion-label){margin-top:0;margin-bottom:0}:host(.tab-layout-label-hide) ::slotted(ion-badge),:host(.tab-has-icon-only) ::slotted(ion-badge){top:16px}:host(.tab-layout-label-hide) ::slotted(ion-icon),:host(.tab-has-icon-only) ::slotted(ion-icon){margin-top:0;margin-bottom:0;font-size:24px}'}}},[33,"ion-tab-button",{disabled:[4],download:[1],href:[1],rel:[1],layout:[1025],selected:[1028],tab:[1],target:[1]},[[8,"ionTabBarChanged","onTabBarChanged"]]]),Xb=function(){"undefined"!=typeof customElements&&["ion-tab-button","ion-ripple-effect"].forEach((e=>{switch(e){case"ion-tab-button":customElements.get(e)||customElements.define(e,Kb);break;case"ion-ripple-effect":customElements.get(e)||Dg()}}))},Yb=!0,Qb=!0,Zb=!0,Jb=!1,ey=!1;let ty,ny,ry,ay=!1,iy=!1,oy=!1,sy=!1,ly=null,uy=!1;const dy="http://www.w3.org/1999/xlink",cy={},py=e=>"object"==(e=typeof e)||"function"===e,hy=(e,t,...n)=>{let r=null,a=null,i=null,o=!1,s=!1;const l=[],u=t=>{for(let n=0;n<t.length;n++)r=t[n],Array.isArray(r)?u(r):null!=r&&"boolean"!=typeof r&&((o="function"!=typeof e&&!py(r))&&(r=String(r)),o&&s?l[l.length-1].$text$+=r:l.push(o?fy(null,r):r),s=o)};if(u(n),t){t.key&&(a=t.key),t.name&&(i=t.name);{const e=t.className||t.class;e&&(t.class="object"!=typeof e?e:Object.keys(e).filter((t=>e[t])).join(" "))}}if("function"==typeof e)return e(null===t?{}:t,l,gy);const d=fy(e,null);return d.$attrs$=t,l.length>0&&(d.$children$=l),d.$key$=a,d.$name$=i,d},fy=(e,t)=>{const n={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null,$attrs$:null,$key$:null,$name$:null};return n},my={},gy={forEach:(e,t)=>e.map(by).forEach(t),map:(e,t)=>e.map(by).map(t).map(yy)},by=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),yy=e=>{if("function"==typeof e.vtag){const t=Object.assign({},e.vattrs);return e.vkey&&(t.key=e.vkey),e.vname&&(t.name=e.vname),hy(e.vtag,t,...e.vchildren||[])}const t=fy(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},vy=new WeakMap,xy=e=>{const t=e.$cmpMeta$,n=e.$hostElement$,r=t.$flags$,a=(t.$tagName$,()=>{}),i=((e,t,n,r)=>{var a;let i=wy(t,n);const o=sv.get(i);if(e=11===e.nodeType?e:dv,o)if("string"==typeof o){e=e.head||e;let t,n=vy.get(e);if(n||vy.set(e,n=new Set),!n.has(i)){{t=dv.createElement("style"),t.innerHTML=o;const n=null!==(a=pv.$nonce$)&&void 0!==a?a:function(e){var t,n,r;return null!==(r=null===(n=null===(t=e.head)||void 0===t?void 0:t.querySelector('meta[name="csp-nonce"]'))||void 0===n?void 0:n.getAttribute("content"))&&void 0!==r?r:void 0}(dv);null!=n&&t.setAttribute("nonce",n),e.insertBefore(t,e.querySelector("link"))}n&&n.add(i)}}else e.adoptedStyleSheets.includes(o)||(e.adoptedStyleSheets=[...e.adoptedStyleSheets,o]);return i})(n.shadowRoot?n.shadowRoot:n.getRootNode(),t,e.$modeName$);10&r&&(n["s-sc"]=i,n.classList.add(i+"-h"),2&r&&n.classList.add(i+"-s")),a()},wy=(e,t)=>"sc-"+(t&&32&e.$flags$?e.$tagName$+"-"+t:e.$tagName$),ky=(e,t,n,r,a,i)=>{if(n!==r){let o=iv(e,t),s=t.toLowerCase();if("class"===t){const t=e.classList,a=Iy(n),i=Iy(r);t.remove(...a.filter((e=>e&&!i.includes(e)))),t.add(...i.filter((e=>e&&!a.includes(e))))}else if("style"===t){for(const t in n)r&&null!=r[t]||(t.includes("-")?e.style.removeProperty(t):e.style[t]="");for(const t in r)n&&r[t]===n[t]||(t.includes("-")?e.style.setProperty(t,r[t]):e.style[t]=r[t])}else if("key"===t);else if("ref"===t)r&&r(e);else if(e.__lookupSetter__(t)||"o"!==t[0]||"n"!==t[1]){const l=py(r);if((o||l&&null!==r)&&!a)try{if(e.tagName.includes("-"))e[t]=r;else{const a=null==r?"":r;"list"===t?o=!1:null!=n&&e[t]==a||(e[t]=a)}}catch(kp){}let u=!1;s!==(s=s.replace(/^xlink\:?/,""))&&(t=s,u=!0),null==r||!1===r?!1===r&&""!==e.getAttribute(t)||(u?e.removeAttributeNS(dy,t):e.removeAttribute(t)):(!o||4&i||a)&&!l&&(r=!0===r?"":r,u?e.setAttributeNS(dy,t,r):e.setAttribute(t,r))}else t="-"===t[2]?t.slice(3):iv(uv,s)?s.slice(2):s[2]+t.slice(3),n&&pv.rel(e,t,n,!1),r&&pv.ael(e,t,r,!1)}},Sy=/\s/,Iy=e=>e?e.split(Sy):[],Ny=(e,t,n,r)=>{const a=11===t.$elm$.nodeType&&t.$elm$.host?t.$elm$.host:t.$elm$,i=e&&e.$attrs$||cy,o=t.$attrs$||cy;for(r in i)r in o||ky(a,r,i[r],void 0,n,t.$flags$);for(r in o)ky(a,r,i[r],o[r],n,t.$flags$)},Cy=(e,t,n,r)=>{const a=t.$children$[n];let i,o,s,l=0;if(ay||(oy=!0,"slot"===a.$tag$&&(ty&&r.classList.add(ty+"-s"),a.$flags$|=a.$children$?2:1)),null!==a.$text$)i=a.$elm$=dv.createTextNode(a.$text$);else if(1&a.$flags$)i=a.$elm$=dv.createTextNode("");else{if(sy||(sy="svg"===a.$tag$),i=a.$elm$=dv.createElementNS(sy?"http://www.w3.org/2000/svg":"http://www.w3.org/1999/xhtml",2&a.$flags$?"slot-fb":a.$tag$),sy&&"foreignObject"===a.$tag$&&(sy=!1),Ny(null,a,sy),(e=>null!=e)(ty)&&i["s-si"]!==ty&&i.classList.add(i["s-si"]=ty),a.$children$)for(l=0;l<a.$children$.length;++l)o=Cy(e,a,l,i),o&&i.appendChild(o);"svg"===a.$tag$?sy=!1:"foreignObject"===i.tagName&&(sy=!0)}return i["s-hn"]=ry,3&a.$flags$&&(i["s-sr"]=!0,i["s-cr"]=ny,i["s-sn"]=a.$name$||"",s=e&&e.$children$&&e.$children$[n],s&&s.$tag$===a.$tag$&&e.$elm$&&Ty(e.$elm$,!1)),i},Ty=(e,t)=>{pv.$flags$|=1;const n=e.childNodes;for(let r=n.length-1;r>=0;r--){const e=n[r];e["s-hn"]!==ry&&e["s-ol"]&&(Ry(e).insertBefore(e,Ay(e)),e["s-ol"].remove(),e["s-ol"]=void 0,oy=!0),t&&Ty(e,t)}pv.$flags$&=-2},$y=(e,t,n,r,a,i)=>{let o,s=e["s-cr"]&&e["s-cr"].parentNode||e;for(s.shadowRoot&&s.tagName===ry&&(s=s.shadowRoot);a<=i;++a)r[a]&&(o=Cy(null,n,a,e),o&&(r[a].$elm$=o,s.insertBefore(o,Ay(t))))},Ey=(e,t,n,r,a)=>{for(;t<=n;++t)(r=e[t])&&(a=r.$elm$,Py(r),iy=!0,a["s-ol"]?a["s-ol"].remove():Ty(a,!0),a.remove())},_y=(e,t)=>e.$tag$===t.$tag$&&("slot"===e.$tag$?e.$name$===t.$name$:e.$key$===t.$key$),Ay=e=>e&&e["s-ol"]||e,Ry=e=>(e["s-ol"]?e["s-ol"]:e).parentNode,Fy=(e,t)=>{const n=t.$elm$=e.$elm$,r=e.$children$,a=t.$children$,i=t.$tag$,o=t.$text$;let s;null===o?(sy="svg"===i||"foreignObject"!==i&&sy,"slot"===i||Ny(e,t,sy),null!==r&&null!==a?((e,t,n,r)=>{let a,i,o=0,s=0,l=0,u=0,d=t.length-1,c=t[0],p=t[d],h=r.length-1,f=r[0],m=r[h];for(;o<=d&&s<=h;)if(null==c)c=t[++o];else if(null==p)p=t[--d];else if(null==f)f=r[++s];else if(null==m)m=r[--h];else if(_y(c,f))Fy(c,f),c=t[++o],f=r[++s];else if(_y(p,m))Fy(p,m),p=t[--d],m=r[--h];else if(_y(c,m))"slot"!==c.$tag$&&"slot"!==m.$tag$||Ty(c.$elm$.parentNode,!1),Fy(c,m),e.insertBefore(c.$elm$,p.$elm$.nextSibling),c=t[++o],m=r[--h];else if(_y(p,f))"slot"!==c.$tag$&&"slot"!==m.$tag$||Ty(p.$elm$.parentNode,!1),Fy(p,f),e.insertBefore(p.$elm$,c.$elm$),p=t[--d],f=r[++s];else{for(l=-1,u=o;u<=d;++u)if(t[u]&&null!==t[u].$key$&&t[u].$key$===f.$key$){l=u;break}l>=0?(i=t[l],i.$tag$!==f.$tag$?a=Cy(t&&t[s],n,l,e):(Fy(i,f),t[l]=void 0,a=i.$elm$),f=r[++s]):(a=Cy(t&&t[s],n,s,e),f=r[++s]),a&&Ry(c.$elm$).insertBefore(a,Ay(c.$elm$))}o>d?$y(e,null==r[h+1]?null:r[h+1].$elm$,n,r,s,h):s>h&&Ey(t,o,d)})(n,r,t,a):null!==a?(null!==e.$text$&&(n.textContent=""),$y(n,null,t,a,0,a.length-1)):null!==r&&Ey(r,0,r.length-1),sy&&"svg"===i&&(sy=!1)):(s=n["s-cr"])?s.parentNode.textContent=o:e.$text$!==o&&(n.data=o)},Dy=e=>{const t=e.childNodes;let n,r,a,i,o,s;for(r=0,a=t.length;r<a;r++)if(n=t[r],1===n.nodeType){if(n["s-sr"])for(o=n["s-sn"],n.hidden=!1,i=0;i<a;i++)if(s=t[i].nodeType,t[i]["s-hn"]!==n["s-hn"]||""!==o){if(1===s&&o===t[i].getAttribute("slot")){n.hidden=!0;break}}else if(1===s||3===s&&""!==t[i].textContent.trim()){n.hidden=!0;break}Dy(n)}},My=[],Oy=e=>{let t,n,r,a,i,o,s=0;const l=e.childNodes,u=l.length;for(;s<u;s++){if(t=l[s],t["s-sr"]&&(n=t["s-cr"])&&n.parentNode)for(r=n.parentNode.childNodes,a=t["s-sn"],o=r.length-1;o>=0;o--)n=r[o],n["s-cn"]||n["s-nr"]||n["s-hn"]===t["s-hn"]||(zy(n,a)?(i=My.find((e=>e.$nodeToRelocate$===n)),iy=!0,n["s-sn"]=n["s-sn"]||a,i?i.$slotRefNode$=t:My.push({$slotRefNode$:t,$nodeToRelocate$:n}),n["s-sr"]&&My.map((e=>{zy(e.$nodeToRelocate$,n["s-sn"])&&(i=My.find((e=>e.$nodeToRelocate$===n)),i&&!e.$slotRefNode$&&(e.$slotRefNode$=i.$slotRefNode$))}))):My.some((e=>e.$nodeToRelocate$===n))||My.push({$nodeToRelocate$:n}));1===t.nodeType&&Oy(t)}},zy=(e,t)=>1===e.nodeType?null===e.getAttribute("slot")&&""===t||e.getAttribute("slot")===t:e["s-sn"]===t||""===t,Py=e=>{e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(Py)},Ly=(e,t)=>{const n=e.$hostElement$,r=e.$cmpMeta$,a=e.$vnode$||fy(null,null),i=(o=t)&&o.$tag$===my?t:hy(null,null,t);var o;if(ry=n.tagName,r.$attrsToReflect$&&(i.$attrs$=i.$attrs$||{},r.$attrsToReflect$.map((([e,t])=>i.$attrs$[t]=n[e]))),i.$tag$=null,i.$flags$|=4,e.$vnode$=i,i.$elm$=a.$elm$=n.shadowRoot||n,ty=n["s-sc"],ny=n["s-cr"],ay=0!=(1&r.$flags$),iy=!1,Fy(a,i),pv.$flags$|=1,oy){let e,t,n,r,a,o;Oy(i.$elm$);let s=0;for(;s<My.length;s++)e=My[s],t=e.$nodeToRelocate$,t["s-ol"]||(n=dv.createTextNode(""),n["s-nr"]=t,t.parentNode.insertBefore(t["s-ol"]=n,t));for(s=0;s<My.length;s++)if(e=My[s],t=e.$nodeToRelocate$,e.$slotRefNode$){for(r=e.$slotRefNode$.parentNode,a=e.$slotRefNode$.nextSibling,n=t["s-ol"];n=n.previousSibling;)if(o=n["s-nr"],o&&o["s-sn"]===t["s-sn"]&&r===o.parentNode&&(o=o.nextSibling,!o||!o["s-nr"])){a=o;break}(!a&&r!==t.parentNode||t.nextSibling!==a)&&t!==a&&(!t["s-hn"]&&t["s-ol"]&&(t["s-hn"]=t["s-ol"].parentNode.nodeName),r.insertBefore(t,a))}else 1===t.nodeType&&(t.hidden=!0)}iy&&Dy(i.$elm$),pv.$flags$&=-2,My.length=0},By=(e,t)=>(e.$flags$|=16,e.$ancestorComponent$,wv((()=>Wy(e,t)))),Wy=(e,t)=>{const n=e.$hostElement$,r=(e.$cmpMeta$.$tagName$,()=>{}),a=n;let i;return i=Hy(a,t?"componentWillLoad":"componentWillUpdate"),i=Gy(i,(()=>Hy(a,"componentWillRender"))),r(),Gy(i,(()=>Vy(e,a,t)))},Vy=async(e,t,n)=>{const r=e.$hostElement$,a=(e.$cmpMeta$.$tagName$,()=>{});r["s-rc"],n&&xy(e);const i=(e.$cmpMeta$.$tagName$,()=>{});Uy(e,t,r),i(),a(),jy(e)},Uy=(e,t,n)=>{try{ly=t,t=t.render&&t.render(),e.$flags$&=-17,e.$flags$|=2,(Yb||Qb)&&(Zb||Qb)&&(Jb||Ly(e,t))}catch(kp){ov(kp,e.$hostElement$)}return ly=null,null},jy=e=>{e.$cmpMeta$.$tagName$;const t=()=>{},n=e.$hostElement$;e.$ancestorComponent$,Hy(n,"componentDidRender"),64&e.$flags$?(Hy(n,"componentDidUpdate"),t()):(e.$flags$|=64,Hy(n,"componentDidLoad"),t())},Hy=(e,t,n)=>{if(e&&e[t])try{return e[t](n)}catch(kp){ov(kp)}},Gy=(e,t)=>e&&e.then?e.then(t):t(),qy=(e,t,n,r)=>{const a=rv(e),i=e,o=a.$instanceValues$.get(t),s=a.$flags$,l=i;var u,d;u=n,d=r.$members$[t][0],n=null==u||py(u)?u:4&d?"false"!==u&&(""===u||!!u):2&d?parseFloat(u):1&d?String(u):u;const c=Number.isNaN(o)&&Number.isNaN(n);if(n!==o&&!c){if(a.$instanceValues$.set(t,n),r.$watchers$&&128&s){const e=r.$watchers$[t];e&&e.map((e=>{try{l[e](n,o,t)}catch(kp){ov(kp,i)}}))}if(2==(18&s)){if(l.componentShouldUpdate&&!1===l.componentShouldUpdate(n,o,t))return;By(a,!1)}}},Ky=(e,t,n)=>{if(t.$members$){e.watchers&&(t.$watchers$=e.watchers);const n=Object.entries(t.$members$),r=e.prototype;n.map((([e,[n]])=>{(31&n||32&n)&&Object.defineProperty(r,e,{get(){return t=e,rv(this).$instanceValues$.get(t);var t},set(n){qy(this,e,n,t)},configurable:!0,enumerable:!0})}));{const a=new Map;r.attributeChangedCallback=function(e,t,n){pv.jmp((()=>{const t=a.get(e);if(this.hasOwnProperty(t))n=this[t],delete this[t];else if(r.hasOwnProperty(t)&&"number"==typeof this[t]&&this[t]==n)return;this[t]=(null!==n||"boolean"!=typeof this[t])&&n}))},e.observedAttributes=n.filter((([e,t])=>15&t[0])).map((([e,n])=>{const r=n[1]||e;return a.set(r,e),512&n[0]&&t.$attrsToReflect$.push([e,r]),r}))}}return e},Xy=async(e,t,n,r,a)=>{if(0==(32&t.$flags$)&&(a=e.constructor,t.$flags$|=32,customElements.whenDefined(n.$tagName$).then((()=>t.$flags$|=128)),a.style)){let r=a.style;"string"!=typeof r&&(r=r[t.$modeName$=(e=>lv.map((t=>t(e))).find((e=>!!e)))(e)]);const i=wy(n,t.$modeName$);if(!sv.has(i)){const e=(n.$tagName$,()=>{});((e,t,n)=>{let r=sv.get(e);fv&&n?(r=r||new CSSStyleSheet,"string"==typeof r?r=t:r.replaceSync(t)):r=t,sv.set(e,r)})(i,r,!!(1&n.$flags$)),e()}}t.$ancestorComponent$,By(t,!0)},Yy=e=>{const t=e["s-cr"]=dv.createComment("");t["s-cn"]=!0,e.insertBefore(t,e.firstChild)},Qy=(e,t)=>{const n={$flags$:t[0],$tagName$:t[1]};n.$members$=t[2],n.$listeners$=t[3],n.$watchers$=e.$watchers$,n.$attrsToReflect$=[];const r=e.prototype.connectedCallback,a=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__registerHost(){av(this,n)},connectedCallback(){(e=>{if(0==(1&pv.$flags$)){const t=rv(e),n=t.$cmpMeta$,r=(n.$tagName$,()=>{});1&t.$flags$?(Zy(e,t,n.$listeners$),t.$lazyInstance$):(t.$flags$|=1,12&n.$flags$&&Yy(e),n.$members$&&Object.entries(n.$members$).map((([t,[n]])=>{if(31&n&&e.hasOwnProperty(t)){const n=e[t];delete e[t],e[t]=n}})),Xy(e,t,n)),r()}})(this),r&&r.call(this)},disconnectedCallback(){(e=>{if(0==(1&pv.$flags$)){const t=rv(e);t.$rmListeners$&&(t.$rmListeners$.map((e=>e())),t.$rmListeners$=void 0)}})(this),a&&a.call(this)},__attachShadow(){this.attachShadow({mode:"open",delegatesFocus:!!(16&n.$flags$)})}}),e.is=n.$tagName$,Ky(e,n)},Zy=(e,t,n,r)=>{n&&n.map((([n,r,a])=>{const i=ev(e,n),o=Jy(t,a),s=tv(n);pv.ael(i,r,o,s),(t.$rmListeners$=t.$rmListeners$||[]).push((()=>pv.rel(i,r,o,s)))}))},Jy=(e,t)=>n=>{try{ey||e.$hostElement$[t](n)}catch(kp){ov(kp)}},ev=(e,t)=>4&t?dv:8&t?uv:16&t?dv.body:e,tv=e=>hv?{passive:0!=(1&e),capture:0!=(2&e)}:0!=(2&e),nv=new WeakMap,rv=e=>nv.get(e),av=(e,t)=>{const n={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return Zy(e,n,t.$listeners$),nv.set(e,n)},iv=(e,t)=>t in e,ov=(e,t)=>(0,console.error)(e,t),sv=new Map,lv=[],uv="undefined"!=typeof window?window:{},dv=uv.document||{head:{}},cv=uv.HTMLElement||class{},pv={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,n,r)=>e.addEventListener(t,n,r),rel:(e,t,n,r)=>e.removeEventListener(t,n,r),ce:(e,t)=>new CustomEvent(e,t)},hv=(()=>{let e=!1;try{dv.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch(kp){}return e})(),fv=(()=>{try{return new CSSStyleSheet,"function"==typeof(new CSSStyleSheet).replaceSync}catch(kp){}return!1})(),mv=[],gv=[],bv=(e,t)=>n=>{e.push(n),uy||(uy=!0,t&&4&pv.$flags$?xv(vv):pv.raf(vv))},yv=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(kp){ov(kp)}e.length=0},vv=()=>{yv(mv),yv(gv),(uy=mv.length>0)&&pv.raf(vv)},xv=e=>(e=>Promise.resolve(e))().then(e),wv=bv(gv,!0);let kv;const Sv=e=>{const t=(()=>{if("undefined"==typeof window)return new Map;if(!kv){const e=window;e.Ionicons=e.Ionicons||{},kv=e.Ionicons.map=e.Ionicons.map||new Map}return kv})().get(e);return t||(e=>{const t=new URL(e,pv.$resourcesUrl$);return t.origin!==uv.location.origin?t.href:t.pathname})(`svg/${e}.svg`)},Iv=(e,t,n,r,a)=>(n="ios"===(n&&$v(n))?"ios":"md",r&&"ios"===n?e=$v(r):a&&"md"===n?e=$v(a):(e||!t||Cv(t)||(e=t),Tv(e)&&(e=$v(e))),Tv(e)&&""!==e.trim()?""!==e.replace(/[a-z]|-|\d/gi,"")?null:e:null),Nv=e=>Tv(e)&&(e=e.trim(),Cv(e))?e:null,Cv=e=>e.length>0&&/(\/|\.)/.test(e),Tv=e=>"string"==typeof e,$v=e=>e.toLowerCase(),Ev=e=>{if(1===e.nodeType){if("script"===e.nodeName.toLowerCase())return!1;for(let t=0;t<e.attributes.length;t++){const n=e.attributes[t].name;if(Tv(n)&&0===n.toLowerCase().indexOf("on"))return!1}for(let t=0;t<e.childNodes.length;t++)if(!Ev(e.childNodes[t]))return!1}return!0},_v=new Map,Av=new Map;let Rv;const Fv=(e,t)=>{let n=Av.get(e);if(!n){if("undefined"==typeof fetch||"undefined"==typeof document)return _v.set(e,""),Promise.resolve();if((e=>e.startsWith("data:image/svg+xml"))(e)&&(e=>-1!==e.indexOf(";utf8,"))(e)){Rv||(Rv=new DOMParser);const t=Rv.parseFromString(e,"text/html").querySelector("svg");return t&&_v.set(e,t.outerHTML),Promise.resolve()}n=fetch(e).then((n=>{if(n.ok)return n.text().then((n=>{n&&!1!==t&&(n=(e=>{const t=document.createElement("div");t.innerHTML=e;for(let r=t.childNodes.length-1;r>=0;r--)"svg"!==t.childNodes[r].nodeName.toLowerCase()&&t.removeChild(t.childNodes[r]);const n=t.firstElementChild;if(n&&"svg"===n.nodeName.toLowerCase()){const e=n.getAttribute("class")||"";if(n.setAttribute("class",(e+" s-ion-icon").trim()),Ev(n))return t.innerHTML}return""})(n)),_v.set(e,n||"")}));_v.set(e,"")})),Av.set(e,n)}return n},Dv=Qy(class extends cv{constructor(){super(),this.__registerHost(),this.__attachShadow(),this.iconName=null,this.inheritedAttributes={},this.isVisible=!1,this.mode=Mv(),this.lazy=!1,this.sanitize=!0}componentWillLoad(){this.inheritedAttributes=((e,t=[])=>{const n={};return t.forEach((t=>{e.hasAttribute(t)&&(null!==e.getAttribute(t)&&(n[t]=e.getAttribute(t)),e.removeAttribute(t))})),n})(this.el,["aria-label"])}connectedCallback(){this.waitUntilVisible(this.el,"50px",(()=>{this.isVisible=!0,this.loadIcon()}))}disconnectedCallback(){this.io&&(this.io.disconnect(),this.io=void 0)}waitUntilVisible(e,t,n){if(this.lazy&&"undefined"!=typeof window&&window.IntersectionObserver){const r=this.io=new window.IntersectionObserver((e=>{e[0].isIntersecting&&(r.disconnect(),this.io=void 0,n())}),{rootMargin:t});r.observe(e)}else n()}loadIcon(){if(this.isVisible){const e=(e=>{let t=Nv(e.src);if(t)return t;if(t=Iv(e.name,e.icon,e.mode,e.ios,e.md),t)return Sv(t);if(e.icon){if(t=Nv(e.icon),t)return t;if(t=Nv(e.icon[e.mode]),t)return t}return null})(this);e&&(_v.has(e)?this.svgContent=_v.get(e):Fv(e,this.sanitize).then((()=>this.svgContent=_v.get(e))))}this.iconName=Iv(this.name,this.icon,this.mode,this.ios,this.md)}render(){const{flipRtl:e,iconName:t,inheritedAttributes:n,el:r}=this,a=this.mode||"md",i=!!t&&(t.includes("arrow")||t.includes("chevron"))&&!1!==e,o=e||i;return hy(my,Object.assign({role:"img",class:Object.assign(Object.assign({[a]:!0},Ov(this.color)),{[`icon-${this.size}`]:!!this.size,"flip-rtl":o,"icon-rtl":o&&(s=r,s&&""!==s.dir?"rtl"===s.dir.toLowerCase():"rtl"===(null===document||void 0===document?void 0:document.dir.toLowerCase()))})},n),this.svgContent?hy("div",{class:"icon-inner",innerHTML:this.svgContent}):hy("div",{class:"icon-inner"}));var s}static get assetsDirs(){return["svg"]}get el(){return this}static get watchers(){return{name:["loadIcon"],src:["loadIcon"],icon:["loadIcon"],ios:["loadIcon"],md:["loadIcon"]}}static get style(){return":host{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;-webkit-box-sizing:content-box !important;box-sizing:content-box !important}:host .ionicon{stroke:currentColor}.ionicon-fill-none{fill:none}.ionicon-stroke-width{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}.icon-inner,.ionicon,svg{display:block;height:100%;width:100%}@supports (background: -webkit-named-image(i)){:host(.icon-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}}@supports not selector(:dir(rtl)) and selector(:host-context([dir='rtl'])){:host(.icon-rtl) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}}:host(.flip-rtl):host-context([dir='rtl']) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}@supports selector(:dir(rtl)){:host(.flip-rtl:dir(rtl)) .icon-inner{-webkit-transform:scaleX(-1);transform:scaleX(-1)}:host(.flip-rtl:dir(ltr)) .icon-inner{-webkit-transform:scaleX(1);transform:scaleX(1)}}:host(.icon-small){font-size:18px !important}:host(.icon-large){font-size:32px !important}:host(.ion-color){color:var(--ion-color-base) !important}:host(.ion-color-primary){--ion-color-base:var(--ion-color-primary, #3880ff)}:host(.ion-color-secondary){--ion-color-base:var(--ion-color-secondary, #0cd1e8)}:host(.ion-color-tertiary){--ion-color-base:var(--ion-color-tertiary, #f4a942)}:host(.ion-color-success){--ion-color-base:var(--ion-color-success, #10dc60)}:host(.ion-color-warning){--ion-color-base:var(--ion-color-warning, #ffce00)}:host(.ion-color-danger){--ion-color-base:var(--ion-color-danger, #f14141)}:host(.ion-color-light){--ion-color-base:var(--ion-color-light, #f4f5f8)}:host(.ion-color-medium){--ion-color-base:var(--ion-color-medium, #989aa2)}:host(.ion-color-dark){--ion-color-base:var(--ion-color-dark, #222428)}"}},[1,"ion-icon",{mode:[1025],color:[1],ios:[1],md:[1],flipRtl:[4,"flip-rtl"],name:[513],src:[1],icon:[8],size:[1],lazy:[4],sanitize:[4],svgContent:[32],isVisible:[32]}]),Mv=()=>"undefined"!=typeof document&&document.documentElement.getAttribute("mode")||"md",Ov=e=>e?{"ion-color":!0,[`ion-color-${e}`]:!0}:null,zv=function(){"undefined"!=typeof customElements&&["ion-icon"].forEach((e=>{"ion-icon"===e&&(customElements.get(e)||customElements.define(e,Dv))}))},Pv=V.createContext({onIonViewWillEnter:()=>{},ionViewWillEnter:()=>{},onIonViewDidEnter:()=>{},ionViewDidEnter:()=>{},onIonViewWillLeave:()=>{},ionViewWillLeave:()=>{},onIonViewDidLeave:()=>{},ionViewDidLeave:()=>{}}),Lv=V.createContext({getIonRedirect:()=>{},getIonRoute:()=>{},getPageManager:()=>{},getStackManager:()=>{},goBack:e=>{"undefined"!=typeof window&&("string"==typeof e?window.location.pathname=e:window.history.back())},navigate:e=>{"undefined"!=typeof window&&(window.location.pathname=e)},hasIonicRouter:()=>!1,routeInfo:void 0,setCurrentTab:()=>{},changeTab:(e,t)=>{"undefined"!=typeof window&&(window.location.pathname=t)},resetTab:(e,t)=>{"undefined"!=typeof window&&(window.location.pathname=t)}}),Bv=e=>e.toLowerCase().split("-").map((e=>e.charAt(0).toUpperCase()+e.slice(1))).join(""),Wv=e=>e.replace(/([A-Z])/g,(e=>`-${e[0].toLowerCase()}`)),Vv=(e,t,n={})=>{if(e instanceof Element){const r=Uv(e.classList,t,n);""!==r&&(e.className=r),Object.keys(t).forEach((n=>{if("children"!==n&&"style"!==n&&"ref"!==n&&"class"!==n&&"className"!==n&&"forwardedRef"!==n)if(0===n.indexOf("on")&&n[2]===n[2].toUpperCase()){const r=n.substring(2),a=r[0].toLowerCase()+r.substring(1);jv(a)||Hv(e,a,t[n])}else e[n]=t[n],"string"==typeof t[n]&&e.setAttribute(Wv(n),t[n])}))}},Uv=(e,t,n)=>{const r=t.className||t.class,a=n.className||n.class,i=Gv(e),o=Gv(r?r.split(" "):[]),s=Gv(a?a.split(" "):[]),l=[];return i.forEach((e=>{o.has(e)?(l.push(e),o.delete(e)):s.has(e)||l.push(e)})),o.forEach((e=>l.push(e))),l.join(" ")},jv=e=>{if("undefined"==typeof document)return!0;{const t="on"+(e=>"doubleclick"===e?"dblclick":e)(e);let n=t in document;if(!n){const e=document.createElement("div");e.setAttribute(t,"return;"),n="function"==typeof e[t]}return n}},Hv=(e,t,n)=>{const r=e.__events||(e.__events={}),a=r[t];a&&e.removeEventListener(t,a),e.addEventListener(t,r[t]=function(e){n&&n.call(this,e)})},Gv=e=>{const t=new Map;return e.forEach((e=>t.set(e,e))),t},qv=(...e)=>t=>{e.forEach((e=>{((e,t)=>{"function"==typeof e?e(t):null!=e&&(e.current=t)})(e,t)}))},Kv=(e,t,n,r)=>{void 0!==r&&r();const a=Bv(e),i=class extends V.Component{constructor(e){super(e),this.setComponentElRef=e=>{this.componentEl=e}}componentDidMount(){this.componentDidUpdate(this.props)}componentDidUpdate(e){Vv(this.componentEl,this.props,e)}render(){const t=this.props,{children:r,forwardedRef:a,style:i,className:o,ref:s}=t,l=lg(t,["children","forwardedRef","style","className","ref"]);let u=Object.keys(l).reduce(((e,t)=>{const n=l[t];if(0===t.indexOf("on")&&t[2]===t[2].toUpperCase()){const r=t.substring(2).toLowerCase();"undefined"!=typeof document&&jv(r)&&(e[t]=n)}else{const r=typeof n;"string"!==r&&"boolean"!==r&&"number"!==r||(e[Wv(t)]=n)}return e}),{});n&&(u=n(this.props,u));const d=Object.assign(Object.assign({},u),{ref:qv(a,this.setComponentElRef),style:i});return W.createElement(e,d,r)}static get displayName(){return a}};return t&&(i.contextType=t),((e,t)=>{const n=(t,n)=>V.createElement(e,Object.assign({},t,{forwardedRef:n}));return n.displayName=t,V.forwardRef(n)})(i,a)},Xv=Kv("ion-buttons",void 0,void 0,Eg),Yv=Kv("ion-col",void 0,void 0,Wg),Qv=Kv("ion-content",void 0,void 0,Gg),Zv=Kv("ion-grid",void 0,void 0,sb),Jv=Kv("ion-header",void 0,void 0,gb),ex=Kv("ion-label",void 0,void 0,bb),tx=Kv("ion-nav-link",void 0,void 0,Ib),nx=Kv("ion-row",void 0,void 0,Cb),rx=Kv("ion-segment",void 0,void 0,$b),ax=Kv("ion-segment-button",void 0,void 0,Ab),ix=Kv("ion-title",void 0,void 0,Fb),ox=Kv("ion-toolbar",void 0,void 0,Mb),sx=(e,t)=>{const n=(t,n)=>V.createElement(e,Object.assign({},t,{forwardedRef:n}));return n.displayName=t,V.forwardRef(n)},lx=()=>{if("undefined"!=typeof window){const e=window.Ionic;if(e&&e.config)return e.config}return null},ux=(e,t)=>{((e,t)=>{void 0===t||"undefined"==typeof customElements||customElements.get(e)||customElements.define(e,t)})(e,t);const n=Bv(e),r=class extends V.Component{constructor(e){super(e),this.handleClick=e=>{const{routerLink:t,routerDirection:n,routerOptions:r,routerAnimation:a}=this.props;void 0!==t&&(e.preventDefault(),this.context.navigate(t,n,void 0,a,r))},this.ref=V.createRef(),this.stableMergedRefs=qv(this.ref,this.props.forwardedRef)}componentDidMount(){this.componentDidUpdate(this.props)}componentDidUpdate(e){const t=this.ref.current;Vv(t,this.props,e)}render(){const t=this.props,{children:n,forwardedRef:r,style:a,className:i,ref:o}=t,s=lg(t,["children","forwardedRef","style","className","ref"]),l=Object.keys(s).reduce(((e,t)=>{if(0===t.indexOf("on")&&t[2]===t[2].toUpperCase()){const n=t.substring(2).toLowerCase();jv(n)&&(e[t]=s[t])}else["string","boolean","number"].includes(typeof s[t])&&(e[Wv(t)]=s[t]);return e}),{}),u=Object.assign(Object.assign({},l),{ref:this.stableMergedRefs,style:a});if(this.props.routerLink&&!this.props.href&&(u.href=this.props.routerLink),u.onClick){const e=u.onClick;u.onClick=t=>{e(t),t.defaultPrevented||this.handleClick(t)}}else u.onClick=this.handleClick;return W.createElement(e,u,n)}static get displayName(){return n}static get contextType(){return Lv}};return sx(r,n)},dx=ux("ion-button",Ob),cx=V.createContext({addOverlay:()=>{},removeOverlay:()=>{}}),px=({onAddOverlay:e,onRemoveOverlay:t})=>{const[n,r]=W.useState({}),a=W.useRef({});a.current=n,W.useEffect((()=>{e(i),t(o)}),[]);const i=(e,t,n)=>{const i=Object.assign({},a.current);i[e]={component:t,containerElement:n},r(i)},o=e=>{const t=Object.assign({},a.current);delete t[e],r(t)},s=Object.keys(n);return V.createElement(V.Fragment,null,s.map((e=>{const t=n[e];return ic.createPortal(t.component,t.containerElement,`overlay-${e}`)})))},hx=Kv("ion-tab-button",void 0,void 0,Xb),fx=Kv("ion-tab-bar",void 0,void 0,qb),mx=Kv("ion-back-button",void 0,void 0,Ub),gx=Kv("ion-router-outlet",void 0,void 0,Hb),bx=Kv("ion-app",void 0,void 0,Wb),yx=Kv("ion-icon",void 0,void 0,zv),vx=(()=>class extends V.Component{constructor(e){super(e),this.ionContext={addOverlay:(e,t,n)=>{this.addOverlayCallback&&this.addOverlayCallback(e,t,n)},removeOverlay:e=>{this.removeOverlayCallback&&this.removeOverlayCallback(e)}}}render(){return V.createElement(cx.Provider,{value:this.ionContext},V.createElement(bx,Object.assign({},this.props),this.props.children),V.createElement(px,{onAddOverlay:e=>{this.addOverlayCallback=e},onRemoveOverlay:e=>{this.removeOverlayCallback=e}}))}static get displayName(){return"IonApp"}})(),xx=V.createContext({registerIonPage:()=>{},isInOutlet:()=>!1});class wx extends V.PureComponent{constructor(e){super(e),this.ionPageElementRef=V.createRef(),this.stableMergedRefs=qv(this.ionPageElementRef,this.props.forwardedRef)}componentDidMount(){this.ionPageElementRef.current&&(this.context.isInOutlet()&&this.ionPageElementRef.current.classList.add("ion-page-invisible"),this.context.registerIonPage(this.ionPageElementRef.current,this.props.routeInfo),this.ionPageElementRef.current.addEventListener("ionViewWillEnter",this.ionViewWillEnterHandler.bind(this)),this.ionPageElementRef.current.addEventListener("ionViewDidEnter",this.ionViewDidEnterHandler.bind(this)),this.ionPageElementRef.current.addEventListener("ionViewWillLeave",this.ionViewWillLeaveHandler.bind(this)),this.ionPageElementRef.current.addEventListener("ionViewDidLeave",this.ionViewDidLeaveHandler.bind(this)))}componentWillUnmount(){this.ionPageElementRef.current&&(this.ionPageElementRef.current.removeEventListener("ionViewWillEnter",this.ionViewWillEnterHandler.bind(this)),this.ionPageElementRef.current.removeEventListener("ionViewDidEnter",this.ionViewDidEnterHandler.bind(this)),this.ionPageElementRef.current.removeEventListener("ionViewWillLeave",this.ionViewWillLeaveHandler.bind(this)),this.ionPageElementRef.current.removeEventListener("ionViewDidLeave",this.ionViewDidLeaveHandler.bind(this)))}ionViewWillEnterHandler(){this.ionLifeCycleContext.ionViewWillEnter()}ionViewDidEnterHandler(){this.ionLifeCycleContext.ionViewDidEnter()}ionViewWillLeaveHandler(){this.ionLifeCycleContext.ionViewWillLeave()}ionViewDidLeaveHandler(){this.ionLifeCycleContext.ionViewDidLeave()}render(){const e=this.props,{className:t,children:n,routeInfo:r,forwardedRef:a}=e,i=lg(e,["className","children","routeInfo","forwardedRef"]);return V.createElement(Pv.Consumer,null,(e=>(this.ionLifeCycleContext=e,V.createElement("div",Object.assign({className:t?`${t} ion-page`:"ion-page",ref:this.stableMergedRefs},i),n))))}static get contextType(){return xx}}class kx extends V.Component{constructor(e){super(e)}render(){const e=this.props,{className:t,children:n,forwardedRef:r}=e,a=lg(e,["className","children","forwardedRef"]);return this.context.hasIonicRouter()?V.createElement(wx,Object.assign({className:t?`${t}`:"",routeInfo:this.context.routeInfo,forwardedRef:r},a),n):V.createElement("div",Object.assign({className:t?`ion-page ${t}`:"ion-page",ref:r},a),n)}static get displayName(){return"IonPage"}static get contextType(){return Lv}}sx(kx,"IonPage");const Sx=Kv("ion-nav",void 0,void 0,kb),Ix=sx((e=>{var{children:t,forwardedRef:n}=e,r=lg(e,["children","forwardedRef"]);const[a,i]=W.useState([]),o=e=>i((t=>[...t,e])),s=e=>i((t=>t.filter((t=>t!==e)))),l=W.useMemo((()=>((e,t)=>{const n=new WeakMap;return{attachViewToDom:async(t,r,a,i)=>{const o=document.createElement("div");i&&o.classList.add(...i),t.appendChild(o);const s=r(a),l=ac.createPortal(s,o);return n.set(o,l),e(l),Promise.resolve(o)},removeViewFromDom:(e,r)=>{const a=n.get(r);return a&&t(a),r.remove(),Promise.resolve()}}})(o,s)),[]);return V.createElement(Sx,Object.assign({delegate:l,ref:n},r),a)}),"IonNav");V.createContext({activeTab:void 0,selectTab:()=>!1});const Nx="undefined"!=typeof HTMLElement?HTMLElement:class{};class Cx extends V.Component{constructor(e){super(e),this.outletIsReady=!1}componentDidMount(){this.ionRouterOutlet&&(this.outletIsReady||em(this.ionRouterOutlet,(()=>{this.outletIsReady=!0,this.context.registerIonPage(this.ionRouterOutlet,this.props.routeInfo)})),this.ionRouterOutlet.addEventListener("ionViewWillEnter",this.ionViewWillEnterHandler.bind(this)),this.ionRouterOutlet.addEventListener("ionViewDidEnter",this.ionViewDidEnterHandler.bind(this)),this.ionRouterOutlet.addEventListener("ionViewWillLeave",this.ionViewWillLeaveHandler.bind(this)),this.ionRouterOutlet.addEventListener("ionViewDidLeave",this.ionViewDidLeaveHandler.bind(this)))}componentWillUnmount(){this.ionRouterOutlet&&(this.ionRouterOutlet.removeEventListener("ionViewWillEnter",this.ionViewWillEnterHandler.bind(this)),this.ionRouterOutlet.removeEventListener("ionViewDidEnter",this.ionViewDidEnterHandler.bind(this)),this.ionRouterOutlet.removeEventListener("ionViewWillLeave",this.ionViewWillLeaveHandler.bind(this)),this.ionRouterOutlet.removeEventListener("ionViewDidLeave",this.ionViewDidLeaveHandler.bind(this)))}ionViewWillEnterHandler(){this.ionLifeCycleContext.ionViewWillEnter()}ionViewDidEnterHandler(){this.ionLifeCycleContext.ionViewDidEnter()}ionViewWillLeaveHandler(){this.ionLifeCycleContext.ionViewWillLeave()}ionViewDidLeaveHandler(){this.ionLifeCycleContext.ionViewDidLeave()}render(){const e=this.props,{StackManager:t,children:n,routeInfo:r}=e,a=lg(e,["StackManager","children","routeInfo"]);return V.createElement(Pv.Consumer,null,(e=>(this.ionLifeCycleContext=e,V.createElement(t,{routeInfo:r},V.createElement(gx,Object.assign({setRef:e=>this.ionRouterOutlet=e},a),n)))))}static get contextType(){return xx}}class Tx extends V.Component{constructor(e){super(e)}render(){const e=this.context.getStackManager(),t=this.props,{children:n,forwardedRef:r}=t,a=lg(t,["children","forwardedRef"]);return this.context.hasIonicRouter()?a.ionPage?V.createElement(Cx,Object.assign({StackManager:e,routeInfo:this.context.routeInfo},a),n):V.createElement(e,{routeInfo:this.context.routeInfo},V.createElement(gx,Object.assign({},a,{forwardedRef:r}),n)):V.createElement(gx,Object.assign({ref:r},this.props),this.props.children)}static get contextType(){return Lv}}const $x=sx(Tx,"IonRouterOutlet"),Ex=(()=>class extends V.Component{constructor(e){super(e),this.handleIonTabButtonClick=this.handleIonTabButtonClick.bind(this)}handleIonTabButtonClick(){this.props.onClick&&this.props.onClick(new CustomEvent("ionTabButtonClick",{detail:{tab:this.props.tab,href:this.props.href,routeOptions:this.props.routerOptions}}))}render(){const e=lg(this.props,["onClick"]);return V.createElement(hx,Object.assign({onIonTabButtonClick:this.handleIonTabButtonClick},e))}static get displayName(){return"IonTabButton"}})();class _x extends V.PureComponent{constructor(e){super(e),this.setActiveTabOnContext=e=>{};const t={};V.Children.forEach(e.children,(n=>{var r,a,i,o;null!=n&&"object"==typeof n&&n.props&&(n.type===Ex||n.type.isTabButton)&&(t[n.props.tab]={originalHref:n.props.href,currentHref:n.props.href,originalRouteOptions:n.props.href===(null===(r=e.routeInfo)||void 0===r?void 0:r.pathname)?null===(a=e.routeInfo)||void 0===a?void 0:a.routeOptions:void 0,currentRouteOptions:n.props.href===(null===(i=e.routeInfo)||void 0===i?void 0:i.pathname)?null===(o=e.routeInfo)||void 0===o?void 0:o.routeOptions:void 0})})),this.state={tabs:t},this.onTabButtonClick=this.onTabButtonClick.bind(this),this.renderTabButton=this.renderTabButton.bind(this),this.setActiveTabOnContext=this.setActiveTabOnContext.bind(this),this.selectTab=this.selectTab.bind(this)}componentDidMount(){const e=this.state.tabs,t=Object.keys(e).find((t=>{const n=e[t].originalHref;return this.props.routeInfo.pathname.startsWith(n)}));t&&this.setState({activeTab:t})}componentDidUpdate(){this.state.activeTab&&this.setActiveTabOnContext(this.state.activeTab)}selectTab(e){const t=this.state.tabs[e];return!!t&&(this.onTabButtonClick(new CustomEvent("ionTabButtonClick",{detail:{href:t.currentHref,tab:e,selected:e===this.state.activeTab,routeOptions:void 0}})),!0)}static getDerivedStateFromProps(e,t){var n,r,a;const i=Object.assign({},t.tabs),o=Object.keys(t.tabs).find((n=>{const r=t.tabs[n].originalHref;return e.routeInfo.pathname.startsWith(r)}));V.Children.forEach(e.children,(e=>{if(null!=e&&"object"==typeof e&&e.props&&(e.type===Ex||e.type.isTabButton)){const t=i[e.props.tab];t&&t.originalHref===e.props.href||(i[e.props.tab]={originalHref:e.props.href,currentHref:e.props.href,originalRouteOptions:e.props.routeOptions,currentRouteOptions:e.props.routeOptions})}}));const{activeTab:s}=t;if(o&&s){const l=t.tabs[s].currentHref,u=t.tabs[s].currentRouteOptions;o===s&&l===(null===(n=e.routeInfo)||void 0===n?void 0:n.pathname)&&u===(null===(r=e.routeInfo)||void 0===r?void 0:r.routeOptions)||(i[o]={originalHref:i[o].originalHref,currentHref:e.routeInfo.pathname+(e.routeInfo.search||""),originalRouteOptions:i[o].originalRouteOptions,currentRouteOptions:null===(a=e.routeInfo)||void 0===a?void 0:a.routeOptions},"pop"===e.routeInfo.routeAction&&o!==s&&(i[s]={originalHref:i[s].originalHref,currentHref:i[s].originalHref,originalRouteOptions:i[s].originalRouteOptions,currentRouteOptions:i[s].currentRouteOptions}))}return o&&e.onSetCurrentTab(o,e.routeInfo),{activeTab:o,tabs:i}}onTabButtonClick(e,t){const n=this.state.tabs[e.detail.tab],r=n.originalHref,a=e.detail.href,{activeTab:i}=this.state;t&&t(e),i===e.detail.tab?r!==a&&this.context.resetTab(e.detail.tab,r,n.originalRouteOptions):(this.props.onIonTabsWillChange&&this.props.onIonTabsWillChange(new CustomEvent("ionTabWillChange",{detail:{tab:e.detail.tab}})),this.props.onIonTabsDidChange&&this.props.onIonTabsDidChange(new CustomEvent("ionTabDidChange",{detail:{tab:e.detail.tab}})),this.setActiveTabOnContext(e.detail.tab),this.context.changeTab(e.detail.tab,a,e.detail.routeOptions))}renderTabButton(e){return t=>{var n,r;if(null!=t&&t.props&&(t.type===Ex||t.type.isTabButton)){const a=t.props.tab===e?null===(n=this.props.routeInfo)||void 0===n?void 0:n.pathname:this.state.tabs[t.props.tab].currentHref,i=t.props.tab===e?null===(r=this.props.routeInfo)||void 0===r?void 0:r.routeOptions:this.state.tabs[t.props.tab].currentRouteOptions;return V.cloneElement(t,{href:a,routeOptions:i,onClick:e=>this.onTabButtonClick(e,t.props.onClick)})}return null}}render(){const{activeTab:e}=this.state;return V.createElement(fx,Object.assign({},this.props,{selectedTab:e}),V.Children.map(this.props.children,this.renderTabButton(e)))}static get contextType(){return Lv}}const Ax=V.memo((e=>{var{forwardedRef:t}=e,n=lg(e,["forwardedRef"]);const r=W.useContext(Lv);return V.createElement(_x,Object.assign({ref:t},n,{routeInfo:n.routeInfo||r.routeInfo||{pathname:window.location.pathname},onSetCurrentTab:r.setCurrentTab}),n.children)}));sx(Ax,"IonTabBar");class Rx extends Nx{constructor(){super()}}"undefined"!=typeof window&&window.customElements&&(window.customElements.get("ion-tabs")||window.customElements.define("ion-tabs",Rx));const Fx=(()=>class extends V.Component{constructor(){super(...arguments),this.clickButton=e=>{if(e.target&&null!==e.target.closest("ion-nav"))return;const{defaultHref:t,routerAnimation:n}=this.props;this.context.hasIonicRouter()?(e.stopPropagation(),this.context.goBack(t,n)):void 0!==t&&(window.location.href=t)}}render(){return V.createElement(mx,Object.assign({onClick:this.clickButton},this.props))}static get displayName(){return"IonBackButton"}static get contextType(){return Lv}})();class Dx extends V.PureComponent{constructor(e){super(e),this.props.name&&console.warn('In Ionic React, you import icons from "ionicons/icons" and set the icon you imported to the "icon" property. Setting the "name" property has no effect.')}render(){var e,t;const n=this.props,{icon:r,ios:a,md:i,mode:o}=n,s=lg(n,["icon","ios","md","mode"]);let l;const u=lx(),d=o||(null==u?void 0:u.get("mode"));return l=a||i?"ios"===d?null!==(e=null!=a?a:i)&&void 0!==e?e:r:null!==(t=null!=i?i:a)&&void 0!==t?t:r:r,V.createElement(yx,Object.assign({ref:this.props.forwardedRef,icon:l},s),this.props.children)}static get contextType(){return Lv}}sx(Dx,"IonIcon");class Mx extends V.PureComponent{render(){const e=this.context.getIonRoute();return this.context.hasIonicRouter()&&Mx?V.createElement(e,Object.assign({},this.props)):(console.error("You either do not have an Ionic Router package, or your router does not support using <IonRoute>"),null)}static get contextType(){return Lv}}V.PureComponent;const Ox=V.createContext({routeInfo:void 0,push:()=>{throw new Error("An Ionic Router is required for IonRouterContext")},back:()=>{throw new Error("An Ionic Router is required for IonRouterContext")},canGoBack:()=>{throw new Error("An Ionic Router is required for IonRouterContext")},nativeBack:()=>{throw new Error("An Ionic Router is required for IonRouterContext")}});V.PureComponent;const zx={main:0},Px=(e="main")=>{var t;const n=(null!==(t=zx[e])&&void 0!==t?t:0)+1;return zx[e]=n,n.toString()},Lx=(e={})=>{"undefined"!=typeof document&&document.documentElement.classList.add("ion-ce"),ig(Object.assign({},e))},Bx=V.createContext({addViewItem:()=>{},canGoBack:()=>{},clearOutlet:()=>{},createViewItem:()=>{},findViewItemByPathname:()=>{},findLeavingViewItemByRouteInfo:()=>{},findViewItemByRouteInfo:()=>{},getChildrenToRender:()=>{},goBack:()=>{},unMountViewItem:()=>{}});class Wx extends V.Component{constructor(e){super(e),this.ionLifeCycleContext=new class{constructor(){this.ionViewWillEnterCallbacks=[],this.ionViewDidEnterCallbacks=[],this.ionViewWillLeaveCallbacks=[],this.ionViewDidLeaveCallbacks=[]}onIonViewWillEnter(e){if(e.id){const t=this.ionViewWillEnterCallbacks.findIndex((t=>t.id===e.id));t>-1?this.ionViewWillEnterCallbacks[t]=e:this.ionViewWillEnterCallbacks.push(e)}else this.ionViewWillEnterCallbacks.push(e)}ionViewWillEnter(){this.ionViewWillEnterCallbacks.forEach((e=>e()))}onIonViewDidEnter(e){if(e.id){const t=this.ionViewDidEnterCallbacks.findIndex((t=>t.id===e.id));t>-1?this.ionViewDidEnterCallbacks[t]=e:this.ionViewDidEnterCallbacks.push(e)}else this.ionViewDidEnterCallbacks.push(e)}ionViewDidEnter(){this.ionViewDidEnterCallbacks.forEach((e=>e()))}onIonViewWillLeave(e){if(e.id){const t=this.ionViewWillLeaveCallbacks.findIndex((t=>t.id===e.id));t>-1?this.ionViewWillLeaveCallbacks[t]=e:this.ionViewWillLeaveCallbacks.push(e)}else this.ionViewWillLeaveCallbacks.push(e)}ionViewWillLeave(){this.ionViewWillLeaveCallbacks.forEach((e=>e()))}onIonViewDidLeave(e){if(e.id){const t=this.ionViewDidLeaveCallbacks.findIndex((t=>t.id===e.id));t>-1?this.ionViewDidLeaveCallbacks[t]=e:this.ionViewDidLeaveCallbacks.push(e)}else this.ionViewDidLeaveCallbacks.push(e)}ionViewDidLeave(){this.ionViewDidLeaveCallbacks.forEach((e=>e())),this.componentCanBeDestroyed()}onComponentCanBeDestroyed(e){this.componentCanBeDestroyedCallback=e}componentCanBeDestroyed(){this.componentCanBeDestroyedCallback&&this.componentCanBeDestroyedCallback()}},this._isMounted=!1,this.ionLifeCycleContext.onComponentCanBeDestroyed((()=>{this.props.mount||this._isMounted&&this.setState({show:!1},(()=>this.props.removeView()))})),this.state={show:!0}}componentDidMount(){this._isMounted=!0}componentWillUnmount(){this._isMounted=!1}render(){const{show:e}=this.state;return V.createElement(Pv.Provider,{value:this.ionLifeCycleContext},e&&this.props.children)}}class Vx{constructor(){this.locationHistory=[],this.tabHistory={}}add(e){"push"===e.routeAction||null==e.routeAction?this._add(e):"pop"===e.routeAction?this._pop(e):"replace"===e.routeAction&&this._replace(e),"root"===e.routeDirection&&(this._clear(),this._add(e))}clearTabStack(e){const t=this._getRouteInfosByKey(e);t&&(t.forEach((e=>{this.locationHistory=this.locationHistory.filter((t=>t.id!==e.id))})),this.tabHistory[e]=[])}update(e){const t=this.locationHistory.findIndex((t=>t.id===e.id));t>-1&&this.locationHistory.splice(t,1,e);const n=this.tabHistory[e.tab||""];if(n){const t=n.findIndex((t=>t.id===e.id));t>-1?n.splice(t,1,e):n.push(e)}else e.tab&&(this.tabHistory[e.tab]=[e])}_add(e){const t=this._getRouteInfosByKey(e.tab);t&&(this._areRoutesEqual(t[t.length-1],e)&&t.pop(),t.push(e)),this.locationHistory.push(e)}_areRoutesEqual(e,t){return!(!e||!t)&&e.pathname===t.pathname&&e.search===t.search}_pop(e){const t=this._getRouteInfosByKey(e.tab);t&&(t.pop(),t.pop(),t.push(e)),this.locationHistory.pop(),this.locationHistory.pop(),this.locationHistory.push(e)}_replace(e){const t=this._getRouteInfosByKey(e.tab);t&&t.pop(),this.locationHistory.pop(),this._add(e)}_clear(){Object.keys(this.tabHistory).forEach((e=>this.tabHistory[e]=[])),this.locationHistory=[]}_getRouteInfosByKey(e){let t;return e&&(t=this.tabHistory[e],t||(t=this.tabHistory[e]=[])),t}getFirstRouteInfoForTab(e){const t=this._getRouteInfosByKey(e);if(t)return t[0]}getCurrentRouteInfoForTab(e){const t=this._getRouteInfosByKey(e);if(t)return t[t.length-1]}findLastLocation(e){const t=this._getRouteInfosByKey(e.tab);if(t)for(let n=t.length-2;n>=0;n--){const r=t[n];if(r&&r.pathname===e.pushedByRoute)return r}for(let n=this.locationHistory.length-2;n>=0;n--){const t=this.locationHistory[n];if(t&&t.pathname===e.pushedByRoute)return t}}previous(){return this.locationHistory[this.locationHistory.length-2]||this.locationHistory[this.locationHistory.length-1]}current(){return this.locationHistory[this.locationHistory.length-1]}canGoBack(){return this.locationHistory.length>1}}class Ux extends V.PureComponent{constructor(e){super(e),this.ionRouterContextValue={push:(e,t,n,r,a)=>{this.navigate(e,t,n,a,r)},back:e=>{this.goBack(void 0,e)},canGoBack:()=>this.props.locationHistory.canGoBack(),nativeBack:()=>this.props.onNativeBack(),routeInfo:this.props.routeInfo},this.state={goBack:this.goBack.bind(this),hasIonicRouter:()=>!0,navigate:this.navigate.bind(this),getIonRedirect:this.getIonRedirect.bind(this),getIonRoute:this.getIonRoute.bind(this),getStackManager:this.getStackManager.bind(this),getPageManager:this.getPageManager.bind(this),routeInfo:this.props.routeInfo,setCurrentTab:this.props.onSetCurrentTab,changeTab:this.props.onChangeTab,resetTab:this.props.onResetTab}}componentDidMount(){"undefined"!=typeof document&&(this.handleHardwareBackButton=this.handleHardwareBackButton.bind(this),document.addEventListener("ionBackButton",this.handleHardwareBackButton))}componentWillUnmount(){"undefined"!=typeof document&&document.removeEventListener("ionBackButton",this.handleHardwareBackButton)}handleHardwareBackButton(e){e.detail.register(0,(e=>{this.nativeGoBack(),e()}))}goBack(e,t){this.props.onNavigateBack(e,t)}nativeGoBack(){this.props.onNativeBack()}navigate(e,t="forward",n="push",r,a,i){this.props.onNavigate(e,n,t,r,a,i)}getPageManager(){return wx}getIonRedirect(){return this.props.ionRedirect}getIonRoute(){return this.props.ionRoute}getStackManager(){return this.props.stackManager}render(){return V.createElement(Lv.Provider,{value:Object.assign(Object.assign({},this.state),{routeInfo:this.props.routeInfo})},V.createElement(Ox.Provider,{value:Object.assign(Object.assign({},this.ionRouterContextValue),{routeInfo:this.props.routeInfo})},this.props.children))}}class jx{constructor(){this.viewStacks={},this.add=this.add.bind(this),this.clear=this.clear.bind(this),this.getViewItemsForOutlet=this.getViewItemsForOutlet.bind(this),this.remove=this.remove.bind(this)}add(e){const{outletId:t}=e;this.viewStacks[t]?this.viewStacks[t].push(e):this.viewStacks[t]=[e]}clear(e){return setTimeout((()=>{delete this.viewStacks[e]}),500)}getViewItemsForOutlet(e){return this.viewStacks[e]||[]}remove(e){const{outletId:t}=e,n=this.viewStacks[t];if(n){const r=n.find((t=>t.id===e.id));r&&(r.mount=!1,this.viewStacks[t]=n.filter((e=>e.id!==r.id)))}}getStackIds(){return Object.keys(this.viewStacks)}getAllViewItems(){const e=this.getStackIds(),t=[];return e.forEach((e=>{t.push(...this.viewStacks[e])})),t}}class Hx extends V.PureComponent{render(){return V.createElement(bh,Object.assign({path:this.props.path,exact:this.props.exact,render:this.props.render},void 0!==this.props.computedMatch?{computedMatch:this.props.computedMatch}:{}))}}class Gx extends jx{constructor(){super(),this.createViewItem=this.createViewItem.bind(this),this.findViewItemByRouteInfo=this.findViewItemByRouteInfo.bind(this),this.findLeavingViewItemByRouteInfo=this.findLeavingViewItemByRouteInfo.bind(this),this.getChildrenToRender=this.getChildrenToRender.bind(this),this.findViewItemByPathname=this.findViewItemByPathname.bind(this)}createViewItem(e,t,n,r){const a={id:Px("viewItem"),outletId:e,ionPageElement:r,reactElement:t,mount:!0,ionRoute:!1},i={exact:t.props.exact,path:t.props.path||t.props.from,component:t.props.component},o=gh(n.pathname,i);return t.type===Mx&&(a.ionRoute=!0,a.disableIonPageManagement=t.props.disableIonPageManagement),a.routeData={match:o,childProps:t.props},a}getChildrenToRender(e,t,n){const r=this.getViewItemsForOutlet(e);return V.Children.forEach(t.props.children,(e=>{const t=r.find((t=>qx(e,t.routeData.childProps.path||t.routeData.childProps.from)));t&&(t.reactElement=e)})),r.map((e=>{let t;if(e.ionRoute&&!e.disableIonPageManagement)t=V.createElement(Wx,{key:`view-${e.id}`,mount:e.mount,removeView:()=>this.remove(e)},V.cloneElement(e.reactElement,{computedMatch:e.routeData.match}));else{const r=qx(e.reactElement,n.pathname);t=V.createElement(Wx,{key:`view-${e.id}`,mount:e.mount,removeView:()=>this.remove(e)},V.cloneElement(e.reactElement,{computedMatch:e.routeData.match})),!r&&e.routeData.match&&(e.routeData.match=void 0,e.mount=!1)}return t}))}findViewItemByRouteInfo(e,t,n){const{viewItem:r,match:a}=this.findViewItemByPath(e.pathname,t);return(void 0===n||!0===n)&&r&&a&&(r.routeData.match=a),r}findLeavingViewItemByRouteInfo(e,t,n=!0){const{viewItem:r}=this.findViewItemByPath(e.lastPathname,t,!1,n);return r}findViewItemByPathname(e,t){const{viewItem:n}=this.findViewItemByPath(e,t);return n}findViewItemByPath(e,t,n,r){let a,i,o;if(t)o=this.getViewItemsForOutlet(t),o.some(s),a||o.some(l);else{const e=this.getAllViewItems();e.some(s),a||e.some(l)}return{viewItem:a,match:i};function s(t){if(r&&!t.ionRoute)return!1;const o={exact:!!n||t.routeData.childProps.exact,path:t.routeData.childProps.path||t.routeData.childProps.from,component:t.routeData.childProps.component},s=gh(e,o);return!!s&&(a=t,i=s,!0)}function l(t){return!t.routeData.childProps.path&&!t.routeData.childProps.from&&(i={path:e,url:e,isExact:!0,params:{}},a=t,!0)}}}function qx(e,t,n){return gh(t,{exact:!!n||e.props.exact,path:e.props.path||e.props.from,component:e.props.component})}const Kx=e=>!e.classList.contains("ion-page-invisible")&&!e.classList.contains("ion-page-hidden");class Xx extends V.PureComponent{constructor(e){super(e),this.stackContextValue={registerIonPage:this.registerIonPage.bind(this),isInOutlet:()=>!0},this.pendingPageTransition=!1,this.registerIonPage=this.registerIonPage.bind(this),this.transitionPage=this.transitionPage.bind(this),this.handlePageTransition=this.handlePageTransition.bind(this),this.id=Px("routerOutlet"),this.prevProps=void 0,this.skipTransition=!1}componentDidMount(){this.clearOutletTimeout&&clearTimeout(this.clearOutletTimeout),this.routerOutletElement&&(this.setupRouterOutlet(this.routerOutletElement),this.handlePageTransition(this.props.routeInfo))}componentDidUpdate(e){const{pathname:t}=this.props.routeInfo,{pathname:n}=e.routeInfo;t!==n?(this.prevProps=e,this.handlePageTransition(this.props.routeInfo)):this.pendingPageTransition&&(this.handlePageTransition(this.props.routeInfo),this.pendingPageTransition=!1)}componentWillUnmount(){this.clearOutletTimeout=this.context.clearOutlet(this.id)}async handlePageTransition(e){var t,n;if(this.routerOutletElement&&this.routerOutletElement.commit){let r=this.context.findViewItemByRouteInfo(e,this.id),a=this.context.findLeavingViewItemByRouteInfo(e,this.id);!a&&e.prevRouteLastPathname&&(a=this.context.findViewItemByPathname(e.prevRouteLastPathname,this.id)),a&&("replace"===e.routeAction?a.mount=!1:"push"!==e.routeAction||"forward"!==e.routeDirection?"none"!==e.routeDirection&&r!==a&&(a.mount=!1):(null===(t=e.routeOptions)||void 0===t?void 0:t.unmount)&&(a.mount=!1));const i=function(e,t){let n;return V.Children.forEach(e,(e=>{const r={exact:e.props.exact,path:e.props.path||e.props.from,component:e.props.component};gh(t.pathname,r)&&(n=e)})),n||(V.Children.forEach(e,(e=>{e.props.path||e.props.from||(n=e)})),n)}(null===(n=this.ionRouterOutlet)||void 0===n?void 0:n.props.children,e);if(r?r.reactElement=i:i&&(r=this.context.createViewItem(this.id,i,e),this.context.addViewItem(r)),r&&r.ionPageElement){if(r===a&&r.routeData.match.url!==e.pathname)return;if(!a&&this.props.routeInfo.prevRouteLastPathname&&(a=this.context.findViewItemByPathname(this.props.routeInfo.prevRouteLastPathname,this.id)),Kx(r.ionPageElement)&&void 0!==a&&!Kx(a.ionPageElement))return;this.transitionPage(e,r,a)}else!a||i||r||a.ionPageElement&&(a.ionPageElement.classList.add("ion-page-hidden"),a.ionPageElement.setAttribute("aria-hidden","true"));this.forceUpdate()}else this.pendingPageTransition=!0}registerIonPage(e,t){const n=this.context.findViewItemByRouteInfo(t,this.id);if(n){const t=n.ionPageElement;if(n.ionPageElement=e,n.ionRoute=!0,t===e)return}this.handlePageTransition(t)}async setupRouterOutlet(e){e.swipeHandler={canStart:()=>{const t=lx();if(!t||!t.get("swipeBackEnabled","ios"===e.mode))return!1;const{routeInfo:n}=this.props,r=this.prevProps&&this.prevProps.routeInfo.pathname===n.pushedByRoute?this.prevProps.routeInfo:{pathname:n.pushedByRoute||""},a=this.context.findViewItemByRouteInfo(r,this.id,!1);return!!a&&a.mount&&a.routeData.match.path!==n.pathname},onStart:async()=>{const{routeInfo:e}=this.props,t=this.prevProps&&this.prevProps.routeInfo.pathname===e.pushedByRoute?this.prevProps.routeInfo:{pathname:e.pushedByRoute||""},n=this.context.findViewItemByRouteInfo(t,this.id,!1),r=this.context.findViewItemByRouteInfo(e,this.id,!1);return n&&r&&await this.transitionPage(e,n,r,"back",!0),Promise.resolve()},onEnd:e=>{if(e)this.skipTransition=!0,this.context.goBack();else{const{routeInfo:e}=this.props,t=this.prevProps&&this.prevProps.routeInfo.pathname===e.pushedByRoute?this.prevProps.routeInfo:{pathname:e.pushedByRoute||""},n=this.context.findViewItemByRouteInfo(t,this.id,!1);if(n!==this.context.findViewItemByRouteInfo(e,this.id,!1)&&void 0!==(null==n?void 0:n.ionPageElement)){const{ionPageElement:e}=n;e.setAttribute("aria-hidden","true"),e.classList.add("ion-page-hidden")}}}}}async transitionPage(e,t,n,r,a=!1){const i=async(t,n)=>{const r=this.skipTransition;r?this.skipTransition=!1:(t.classList.add("ion-page"),t.classList.add("ion-page-invisible")),await o.commit(t,n,{duration:r||void 0===l?0:void 0,direction:l,showGoBack:!!e.pushedByRoute,progressAnimation:a,animationBuilder:e.routeAnimation})},o=this.routerOutletElement,s="none"===e.routeDirection||"root"===e.routeDirection?void 0:e.routeDirection,l=null!=r?r:s;if(t&&t.ionPageElement&&this.routerOutletElement)if(n&&n.ionPageElement&&t===n)if(function(e,t,n){const r={exact:!!n||e.props.exact,path:e.props.path||e.props.from,component:e.props.component},a=gh(t,r);return a}(n.reactElement,e.pathname,!0)){const e=function(e){let t;if(t="string"==typeof e?e:e.outerHTML,document){const e=document.createElement("div");e.innerHTML=t,e.style.zIndex="";const n=e.getElementsByTagName("ion-back-button");return n[0]&&n[0].remove(),e.firstChild}}(n.ionPageElement.outerHTML);e&&(this.routerOutletElement.appendChild(e),await i(t.ionPageElement,e),this.routerOutletElement.removeChild(e))}else await i(t.ionPageElement,void 0);else await i(t.ionPageElement,null==n?void 0:n.ionPageElement),n&&n.ionPageElement&&!a&&(n.ionPageElement.classList.add("ion-page-hidden"),n.ionPageElement.setAttribute("aria-hidden","true"))}render(){const{children:e}=this.props,t=V.Children.only(e);this.ionRouterOutlet=t;const n=this.context.getChildrenToRender(this.id,this.ionRouterOutlet,this.props.routeInfo,(()=>{this.forceUpdate()}));return V.createElement(xx.Provider,{value:this.stackContextValue},V.cloneElement(t,{ref:e=>{t.props.setRef&&t.props.setRef(e),t.props.forwardedRef&&(t.props.forwardedRef.current=e),this.routerOutletElement=e;const{ref:n}=t;"function"==typeof n&&n(e)}},n))}static get contextType(){return Bx}}class Yx extends V.PureComponent{constructor(e){super(e),this.exitViewFromOtherOutletHandlers=[],this.locationHistory=new Vx,this.viewStack=new Gx,this.routeMangerContextState={canGoBack:()=>this.locationHistory.canGoBack(),clearOutlet:this.viewStack.clear,findViewItemByPathname:this.viewStack.findViewItemByPathname,getChildrenToRender:this.viewStack.getChildrenToRender,goBack:()=>this.handleNavigateBack(),createViewItem:this.viewStack.createViewItem,findViewItemByRouteInfo:this.viewStack.findViewItemByRouteInfo,findLeavingViewItemByRouteInfo:this.viewStack.findLeavingViewItemByRouteInfo,addViewItem:this.viewStack.add,unMountViewItem:this.viewStack.remove};const t={id:Px("routeInfo"),pathname:this.props.location.pathname,search:this.props.location.search};this.locationHistory.add(t),this.handleChangeTab=this.handleChangeTab.bind(this),this.handleResetTab=this.handleResetTab.bind(this),this.handleNativeBack=this.handleNativeBack.bind(this),this.handleNavigate=this.handleNavigate.bind(this),this.handleNavigateBack=this.handleNavigateBack.bind(this),this.props.registerHistoryListener(this.handleHistoryChange.bind(this)),this.handleSetCurrentTab=this.handleSetCurrentTab.bind(this),this.state={routeInfo:t}}handleChangeTab(e,t,n){if(!t)return;const r=this.locationHistory.getCurrentRouteInfoForTab(e),[a,i]=t.split("?");r?(this.incomingRouteParams=Object.assign(Object.assign({},r),{routeAction:"push",routeDirection:"none"}),r.pathname===a?(this.incomingRouteParams.routeOptions=n,this.props.history.push(r.pathname+(r.search||""))):(this.incomingRouteParams.pathname=a,this.incomingRouteParams.search=i?"?"+i:void 0,this.incomingRouteParams.routeOptions=n,this.props.history.push(a+(i?"?"+i:"")))):this.handleNavigate(a,"push","none",void 0,n,e)}handleHistoryChange(e,t){var n,r,a;let i;if(i=this.incomingRouteParams&&"replace"===this.incomingRouteParams.routeAction?this.locationHistory.previous():this.locationHistory.current(),i.pathname+i.search!==e.pathname){if(!this.incomingRouteParams){if("REPLACE"===t&&(this.incomingRouteParams={routeAction:"replace",routeDirection:"none",tab:this.currentTab}),"POP"===t){const e=this.locationHistory.current();if(e&&e.pushedByRoute){const t=this.locationHistory.findLastLocation(e);this.incomingRouteParams=Object.assign(Object.assign({},t),{routeAction:"pop",routeDirection:"back"})}else this.incomingRouteParams={routeAction:"pop",routeDirection:"none",tab:this.currentTab}}this.incomingRouteParams||(this.incomingRouteParams={routeAction:"push",routeDirection:(null===(n=e.state)||void 0===n?void 0:n.direction)||"forward",routeOptions:null===(r=e.state)||void 0===r?void 0:r.routerOptions,tab:this.currentTab})}let o;if(null===(a=this.incomingRouteParams)||void 0===a?void 0:a.id)o=Object.assign(Object.assign({},this.incomingRouteParams),{lastPathname:i.pathname}),this.locationHistory.add(o);else{const t="push"===this.incomingRouteParams.routeAction&&"forward"===this.incomingRouteParams.routeDirection;if(o=Object.assign(Object.assign({id:Px("routeInfo")},this.incomingRouteParams),{lastPathname:i.pathname,pathname:e.pathname,search:e.search,params:this.props.match.params,prevRouteLastPathname:i.lastPathname}),t)o.tab=i.tab,o.pushedByRoute=i.pathname;else if("pop"===o.routeAction){const e=this.locationHistory.findLastLocation(o);o.pushedByRoute=null==e?void 0:e.pushedByRoute}else if("push"===o.routeAction&&o.tab!==i.tab){const e=this.locationHistory.getCurrentRouteInfoForTab(o.tab);o.pushedByRoute=null==e?void 0:e.pushedByRoute}else if("replace"===o.routeAction){const e=this.locationHistory.current(),t=null==e?void 0:e.pushedByRoute,n=void 0!==t&&t!==o.pathname?t:o.pushedByRoute;o.lastPathname=(null==e?void 0:e.pathname)||o.lastPathname,o.prevRouteLastPathname=null==e?void 0:e.lastPathname,o.pushedByRoute=n,o.routeDirection=(null==e?void 0:e.routeDirection)||o.routeDirection,o.routeAnimation=(null==e?void 0:e.routeAnimation)||o.routeAnimation}this.locationHistory.add(o)}this.setState({routeInfo:o})}this.incomingRouteParams=void 0}handleNativeBack(){const e=this.props.history;(e.goBack||e.back)()}handleNavigate(e,t,n,r,a,i){this.incomingRouteParams=Object.assign(this.incomingRouteParams||{},{routeAction:t,routeDirection:n,routeOptions:a,routeAnimation:r,tab:i}),"push"===t?this.props.history.push(e):this.props.history.replace(e)}handleNavigateBack(e="/",t){const n=lx();e=e||n&&n.get("backButtonDefaultHref");const r=this.locationHistory.current();if(r&&r.pushedByRoute){const n=this.locationHistory.findLastLocation(r);if(n)if(this.incomingRouteParams=Object.assign(Object.assign({},n),{routeAction:"pop",routeDirection:"back",routeAnimation:t||r.routeAnimation}),r.lastPathname===r.pushedByRoute||n.pathname===r.pushedByRoute&&""===r.tab&&""===n.tab){const e=this.props.history;(e.goBack||e.back)()}else this.handleNavigate(n.pathname+(n.search||""),"pop","back");else this.handleNavigate(e,"pop","back")}else this.handleNavigate(e,"pop","back")}handleResetTab(e,t,n){const r=this.locationHistory.getFirstRouteInfoForTab(e);if(r){const e=Object.assign({},r);e.pathname=t,e.routeOptions=n,this.incomingRouteParams=Object.assign(Object.assign({},e),{routeAction:"pop",routeDirection:"back"}),this.props.history.push(e.pathname+(e.search||""))}}handleSetCurrentTab(e){this.currentTab=e;const t=Object.assign({},this.locationHistory.current());t.tab!==e&&(t.tab=e,this.locationHistory.update(t))}render(){return V.createElement(Bx.Provider,{value:this.routeMangerContextState},V.createElement(Ux,{ionRoute:Hx,ionRedirect:{},stackManager:Xx,routeInfo:this.state.routeInfo,onNativeBack:this.handleNativeBack,onNavigateBack:this.handleNavigateBack,onNavigate:this.handleNavigate,onSetCurrentTab:this.handleSetCurrentTab,onChangeTab:this.handleChangeTab,onResetTab:this.handleResetTab,locationHistory:this.locationHistory},this.props.children))}}const Qx=function(e){var t="withRouter("+(e.displayName||e.name)+")",n=function(t){var n=t.wrappedComponentRef,r=gp(t,["wrappedComponentRef"]);return V.createElement(ih.Consumer,null,(function(t){return t||wc(!1),V.createElement(e,fc({},r,t,{ref:n}))}))};return n.displayName=t,n.WrappedComponent=e,Jp(n,e)}(Yx);Qx.displayName="IonRouter";class Zx extends V.Component{constructor(e){super(e);const{history:t}=e,n=lg(e,["history"]);this.history=t||Dc(n),this.history.listen(this.handleHistoryChange.bind(this)),this.registerHistoryListener=this.registerHistoryListener.bind(this)}handleHistoryChange(e,t){const n=e.location||e,r=e.action||t;this.historyListenHandler&&this.historyListenHandler(n,r)}registerHistoryListener(e){this.historyListenHandler=e}render(){const e=this.props,{children:t}=e,n=lg(e,["children"]);return V.createElement(oh,Object.assign({history:this.history},n),V.createElement(Qx,{registerHistoryListener:this.registerHistoryListener},t))}}V.Component,V.Component;var Jx=Object.defineProperty,ew=(e=>"undefined"!=typeof require?require:"undefined"!=typeof Proxy?new Proxy(e,{get:(e,t)=>("undefined"!=typeof require?require:e)[t]}):e)((function(e){if("undefined"!=typeof require)return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')})),tw=(e,t)=>{for(var n in t)Jx(e,n,{get:t[n],enumerable:!0})};tw({},{Abs:()=>zk,Acos:()=>Pk,Acosh:()=>Lk,AdadeltaOptimizer:()=>gM,AdagradOptimizer:()=>bM,AdamOptimizer:()=>yM,AdamaxOptimizer:()=>vM,Add:()=>Bk,AddN:()=>Wk,All:()=>Vk,Any:()=>Uk,ArgMax:()=>jk,ArgMin:()=>Hk,Asin:()=>Gk,Asinh:()=>qk,Atan:()=>Kk,Atan2:()=>Yk,Atanh:()=>Xk,AvgPool:()=>Qk,AvgPool3D:()=>Jk,AvgPool3DGrad:()=>eS,AvgPoolGrad:()=>Zk,BackendWasm:()=>Yse,BatchMatMul:()=>tS,BatchToSpaceND:()=>nS,Bincount:()=>rS,BitwiseAnd:()=>aS,BroadcastArgs:()=>oS,BroadcastTo:()=>iS,Callback:()=>qq,CallbackList:()=>AV,Cast:()=>sS,Ceil:()=>lS,ClipByValue:()=>uS,Complex:()=>dS,ComplexAbs:()=>cS,Concat:()=>pS,Conv2D:()=>hS,Conv2DBackpropFilter:()=>fS,Conv2DBackpropInput:()=>mS,Conv3D:()=>gS,Conv3DBackpropFilterV2:()=>bS,Conv3DBackpropInputV2:()=>yS,Cos:()=>vS,Cosh:()=>xS,CropAndResize:()=>SS,Cumprod:()=>wS,Cumsum:()=>kS,CustomCallback:()=>DV,DataStorage:()=>Rw,DenseBincount:()=>IS,DepthToSpace:()=>NS,DepthwiseConv2dNative:()=>CS,DepthwiseConv2dNativeBackpropFilter:()=>TS,DepthwiseConv2dNativeBackpropInput:()=>$S,Diag:()=>ES,Dilation2D:()=>_S,Dilation2DBackpropFilter:()=>RS,Dilation2DBackpropInput:()=>AS,Draw:()=>FS,ENV:()=>Dk,EarlyStopping:()=>Zq,Einsum:()=>MS,Elu:()=>OS,EluGrad:()=>zS,Environment:()=>_k,Equal:()=>LS,Erf:()=>PS,Exp:()=>BS,ExpandDims:()=>WS,Expm1:()=>VS,FFT:()=>US,Fill:()=>jS,FlipLeftRight:()=>HS,Floor:()=>GS,FloorDiv:()=>qS,FromPixels:()=>YN,FusedBatchNorm:()=>KS,FusedConv2D:()=>JN,FusedDepthwiseConv2D:()=>eC,GPGPUContext:()=>B5,GatherNd:()=>YS,GatherV2:()=>XS,GraphModel:()=>MX,Greater:()=>QS,GreaterEqual:()=>ZS,History:()=>FV,IFFT:()=>eI,Identity:()=>JS,Imag:()=>tI,InputSpec:()=>FW,IsFinite:()=>nI,IsInf:()=>rI,IsNan:()=>aI,KernelBackend:()=>Fw,LRN:()=>bI,LRNGrad:()=>yI,LayerVariable:()=>_W,LayersModel:()=>MU,LeakyRelu:()=>iI,Less:()=>oI,LessEqual:()=>sI,LinSpace:()=>lI,Log:()=>uI,Log1p:()=>dI,LogSoftmax:()=>mI,LogicalAnd:()=>cI,LogicalNot:()=>pI,LogicalOr:()=>hI,LogicalXor:()=>fI,LowerBound:()=>gI,MathBackendCPU:()=>eQ,MathBackendWebGL:()=>o8,MatrixBandPart:()=>vI,Max:()=>xI,MaxPool:()=>kI,MaxPool3D:()=>II,MaxPool3DGrad:()=>NI,MaxPoolGrad:()=>SI,MaxPoolWithArgmax:()=>CI,Maximum:()=>wI,Mean:()=>TI,Min:()=>$I,Minimum:()=>EI,MirrorPad:()=>_I,Mod:()=>AI,MomentumOptimizer:()=>wM,Multinomial:()=>RI,Multiply:()=>FI,Neg:()=>DI,NonMaxSuppressionV3:()=>OI,NonMaxSuppressionV4:()=>zI,NonMaxSuppressionV5:()=>PI,NotEqual:()=>MI,OP_SCOPE_SUFFIX:()=>FT,OneHot:()=>BI,OnesLike:()=>LI,Optimizer:()=>mM,OptimizerConstructors:()=>CO,Pack:()=>WI,PadV2:()=>VI,Pool:()=>UI,Pow:()=>jI,Prelu:()=>HI,Prod:()=>GI,RMSPropOptimizer:()=>kM,RNN:()=>Wj,RaggedGather:()=>qI,RaggedRange:()=>KI,RaggedTensorToTensor:()=>XI,Range:()=>YI,Rank:()=>eT,Real:()=>QI,RealDiv:()=>DS,Reciprocal:()=>ZI,Reduction:()=>LD,Relu:()=>JI,Relu6:()=>iN,Reshape:()=>eN,ResizeBilinear:()=>rN,ResizeBilinearGrad:()=>aN,ResizeNearestNeighbor:()=>tN,ResizeNearestNeighborGrad:()=>nN,Reverse:()=>oN,RotateWithOffset:()=>QN,Round:()=>sN,Rsqrt:()=>lN,SGDOptimizer:()=>xM,ScatterNd:()=>uN,SearchSorted:()=>cN,Select:()=>pN,Selu:()=>hN,Sequential:()=>LU,Sigmoid:()=>yN,Sign:()=>bN,Sin:()=>mN,Sinh:()=>gN,Slice:()=>fN,Softmax:()=>IN,Softplus:()=>vN,SpaceToBatchND:()=>kN,SparseFillEmptyRows:()=>NN,SparseReshape:()=>CN,SparseSegmentMean:()=>TN,SparseSegmentSum:()=>$N,SparseToDense:()=>EN,SplitV:()=>SN,Sqrt:()=>xN,Square:()=>AN,SquaredDifference:()=>_N,StaticRegexReplace:()=>RN,Step:()=>XN,StridedSlice:()=>FN,StringNGrams:()=>DN,StringSplit:()=>MN,StringToHashBucketFast:()=>ON,Sub:()=>zN,Sum:()=>wN,SymbolicTensor:()=>DW,Tan:()=>PN,Tanh:()=>LN,Tensor:()=>QC,TensorBuffer:()=>KC,TensorScatterUpdate:()=>dN,Tile:()=>BN,TopK:()=>WN,Transform:()=>VN,Transpose:()=>UN,Unique:()=>jN,Unpack:()=>HN,UnsortedSegmentSum:()=>GN,UpperBound:()=>qN,Variable:()=>JC,ZerosLike:()=>KN,_FusedMatMul:()=>ZN,abs:()=>uE,acos:()=>dE,acosh:()=>cE,add:()=>iE,addN:()=>pE,all:()=>hE,any:()=>fE,argMax:()=>mE,argMin:()=>gE,asin:()=>bE,asinh:()=>yE,atan:()=>vE,atan2:()=>xE,atanh:()=>wE,avgPool:()=>PE,avgPool3d:()=>LE,backend:()=>rE,backend_util:()=>AO,basicLSTMCell:()=>HE,batchNorm:()=>KE,batchNorm2d:()=>XE,batchNorm3d:()=>YE,batchNorm4d:()=>QE,batchToSpaceND:()=>GE,bincount:()=>ZE,bitwiseAnd:()=>JE,booleanMaskAsync:()=>WF,broadcastArgs:()=>e_,broadcastTo:()=>t_,broadcast_util:()=>N_,browser:()=>qM,buffer:()=>D$,callbacks:()=>Jq,cast:()=>M$,ceil:()=>n_,clipByValue:()=>a_,clone:()=>O$,complex:()=>MT,concat:()=>BE,concat1d:()=>i_,concat2d:()=>o_,concat3d:()=>s_,concat4d:()=>l_,constraints:()=>XW,conv1d:()=>d_,conv2d:()=>u_,conv2dTranspose:()=>p_,conv3d:()=>h_,conv3dTranspose:()=>m_,copyRegisteredKernels:()=>pC,cos:()=>g_,cosh:()=>b_,cosineWindow:()=>XF,cumprod:()=>y_,cumsum:()=>v_,customGrad:()=>TA,data:()=>LX,denseBincount:()=>x_,deprecationWarn:()=>W$,depthToSpace:()=>w_,depthwiseConv2d:()=>k_,deregisterOp:()=>rK,device_util:()=>ST,diag:()=>S_,dilation2d:()=>I_,disableDeprecationWarnings:()=>B$,dispose:()=>q$,disposeVariables:()=>V$,div:()=>sE,divNoNan:()=>R_,dot:()=>F_,dropout:()=>qF,einsum:()=>D_,elu:()=>M_,enableDebugMode:()=>L$,enableProdMode:()=>P$,enclosingPowerOfTwo:()=>KF,engine:()=>U$,ensureShape:()=>O_,env:()=>Rk,equal:()=>E_,erf:()=>z_,euclideanNorm:()=>tA,exp:()=>nA,expandDims:()=>rA,expm1:()=>aA,eye:()=>oA,fft:()=>dF,fill:()=>r_,findBackend:()=>eE,findBackendFactory:()=>tE,floor:()=>sA,floorDiv:()=>oE,forceHalfFloat:()=>l8,fused:()=>QF,gather:()=>lA,gatherND:()=>GF,gather_util:()=>rO,getBackend:()=>Z$,getGradient:()=>oC,getKernel:()=>iC,getKernelsForBackend:()=>sC,getThreadsCount:()=>dle,gpgpu_util:()=>b5,grad:()=>kA,grads:()=>SA,greater:()=>uA,greaterEqual:()=>dA,ifft:()=>cF,imag:()=>cA,image:()=>oM,inTopKAsync:()=>YF,initializers:()=>dV,input:()=>VU,io:()=>IM,irfft:()=>pF,isFinite:()=>pA,isInf:()=>hA,isNaN:()=>fA,keep:()=>K$,kernel_impls:()=>zz,layers:()=>TV,leakyRelu:()=>mA,less:()=>gA,lessEqual:()=>bA,linalg:()=>sM,linspace:()=>yA,loadGraphModel:()=>OX,loadGraphModelSync:()=>zX,loadLayersModel:()=>PU,localResponseNormalization:()=>vA,log:()=>xA,log1p:()=>wA,logSigmoid:()=>AA,logSoftmax:()=>FA,logSumExp:()=>DA,logicalAnd:()=>MA,logicalNot:()=>OA,logicalOr:()=>zA,logicalXor:()=>PA,losses:()=>lM,lowerBound:()=>WA,matMul:()=>WE,math:()=>HM,max:()=>G_,maxPool:()=>VA,maxPool3d:()=>UA,maxPoolWithArgmax:()=>jA,maximum:()=>HA,mean:()=>GA,memory:()=>j$,meshgrid:()=>XA,metrics:()=>Cq,min:()=>q_,minimum:()=>YA,mirrorPad:()=>QA,mod:()=>ZA,model:()=>BU,models:()=>Vq,moments:()=>JA,movingAverage:()=>UF,mul:()=>lE,multiRNNCell:()=>eR,multinomial:()=>tR,neg:()=>EA,nextFrame:()=>EO,norm:()=>eA,notEqual:()=>nR,oneHot:()=>rR,ones:()=>KA,onesLike:()=>aR,op:()=>DT,outerProduct:()=>iR,pad:()=>oR,pad1d:()=>sR,pad2d:()=>lR,pad3d:()=>uR,pad4d:()=>dR,pool:()=>pR,pow:()=>K_,prelu:()=>hR,print:()=>z$,prod:()=>fR,profile:()=>H$,raggedGather:()=>mR,raggedRange:()=>gR,raggedTensorToTensor:()=>bR,rand:()=>yR,randomGamma:()=>OR,randomNormal:()=>zR,randomStandardNormal:()=>PR,randomUniform:()=>LR,randomUniformInt:()=>BR,range:()=>WR,ready:()=>Q$,real:()=>VR,reciprocal:()=>UR,registerBackend:()=>nE,registerCallbackConstructor:()=>UU,registerGradient:()=>uC,registerKernel:()=>lC,registerOp:()=>tK,regularizers:()=>Uq,relu:()=>jR,relu6:()=>HR,removeBackend:()=>J$,reshape:()=>zE,reverse:()=>GR,reverse1d:()=>qR,reverse2d:()=>KR,reverse3d:()=>XR,reverse4d:()=>YR,rfft:()=>fF,round:()=>QR,rsqrt:()=>ZR,scalar:()=>X_,scatterND:()=>jF,scatter_util:()=>TF,searchSorted:()=>BA,selu:()=>JR,separableConv2d:()=>eF,sequential:()=>WU,serialization:()=>cM,setBackend:()=>Y$,setPlatform:()=>aE,setThreadsCount:()=>ule,setWasmPath:()=>ile,setWasmPaths:()=>ole,setWebGLContext:()=>W3,setdiff1dAsync:()=>tF,shared:()=>tQ,sigmoid:()=>VE,sign:()=>nF,signal:()=>iM,sin:()=>rF,sinh:()=>aF,slice:()=>UE,slice1d:()=>iF,slice2d:()=>oF,slice3d:()=>sF,slice4d:()=>lF,slice_util:()=>iO,softmax:()=>uF,softplus:()=>_A,spaceToBatchND:()=>cR,sparse:()=>uM,sparseToDense:()=>HF,spectral:()=>aM,split:()=>hF,sqrt:()=>Y_,square:()=>Q_,squaredDifference:()=>mF,squeeze:()=>gF,stack:()=>bF,step:()=>yF,stridedSlice:()=>vF,string:()=>dM,sub:()=>RA,sum:()=>Z_,sumOutType:()=>lT,tan:()=>xF,tanh:()=>jE,tensor:()=>zT,tensor1d:()=>wF,tensor2d:()=>kF,tensor3d:()=>SF,tensor4d:()=>IF,tensor5d:()=>NF,tensor6d:()=>CF,tensorScatterUpdate:()=>AF,tensor_util:()=>iT,test_util:()=>xR,tidy:()=>G$,tile:()=>iA,time:()=>X$,topk:()=>RF,train:()=>TO,transpose:()=>VF,truncatedNormal:()=>FF,unique:()=>DF,unregisterGradient:()=>cC,unregisterKernel:()=>dC,unsortedSegmentSum:()=>MF,unstack:()=>OF,upcastType:()=>sT,upperBound:()=>zF,util:()=>fC,valueAndGrad:()=>IA,valueAndGrads:()=>NA,variable:()=>PF,variableGrads:()=>CA,version:()=>hle,version_converter:()=>PX,version_core:()=>NO,version_cpu:()=>$J,version_layers:()=>gU,version_wasm:()=>cle,version_webgl:()=>s8,webgl:()=>u8,webgl_util:()=>M3,where:()=>__,whereAsync:()=>BF,zeros:()=>qA,zerosLike:()=>A_});var nw=Object.create,rw=Object.defineProperty,aw=Object.getOwnPropertyDescriptor,iw=Object.getOwnPropertyNames,ow=Object.getPrototypeOf,sw=Object.prototype.hasOwnProperty,lw=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),uw=(e,t)=>{for(var n in t)rw(e,n,{get:t[n],enumerable:!0})},dw=(e,t,n)=>(n=null!=e?nw(ow(e)):{},((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let a of iw(t))!sw.call(e,a)&&a!==n&&rw(e,a,{get:()=>t[a],enumerable:!(r=aw(t,a))||r.enumerable});return e})(!t&&e&&e.__esModule?n:rw(n,"default",{value:e,enumerable:!0}),e)),cw=lw(((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(Gl){}function r(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0}),r.isLong=a;var i={},o={};function s(e,t){var n,r,a;return t?(a=0<=(e>>>=0)&&e<256)&&(r=o[e])?r:(n=u(e,(0|e)<0?-1:0,!0),a&&(o[e]=n),n):(a=-128<=(e|=0)&&e<128)&&(r=i[e])?r:(n=u(e,e<0?-1:0,!1),a&&(i[e]=n),n)}function l(e,t){if(isNaN(e))return t?y:b;if(t){if(e<0)return y;if(e>=f)return S}else{if(e<=-m)return I;if(e+1>=m)return k}return e<0?l(-e,t).neg():u(e%h|0,e/h|0,t)}function u(e,t,n){return new r(e,t,n)}r.fromInt=s,r.fromNumber=l,r.fromBits=u;var d=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return b;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var a=l(d(n,8)),i=b,o=0;o<e.length;o+=8){var s=Math.min(8,e.length-o),u=parseInt(e.substring(o,o+s),n);if(s<8){var p=l(d(n,s));i=i.mul(p).add(l(u))}else i=(i=i.mul(a)).add(l(u))}return i.unsigned=t,i}function p(e,t){return"number"==typeof e?l(e,t):"string"==typeof e?c(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}r.fromString=c,r.fromValue=p;var h=4294967296,f=h*h,m=f/2,g=s(1<<24),b=s(0);r.ZERO=b;var y=s(0,!0);r.UZERO=y;var v=s(1);r.ONE=v;var x=s(1,!0);r.UONE=x;var w=s(-1);r.NEG_ONE=w;var k=u(-1,2147483647,!1);r.MAX_VALUE=k;var S=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=S;var I=u(0,-2147483648,!1);r.MIN_VALUE=I;var N=r.prototype;N.toInt=function(){return this.unsigned?this.low>>>0:this.low},N.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},N.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(I)){var t=l(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=l(d(e,6),this.unsigned),i=this,o="";;){var s=i.div(a),u=(i.sub(s.mul(a)).toInt()>>>0).toString(e);if((i=s).isZero())return u+o;for(;u.length<6;)u="0"+u;o=""+u+o}},N.getHighBits=function(){return this.high},N.getHighBitsUnsigned=function(){return this.high>>>0},N.getLowBits=function(){return this.low},N.getLowBitsUnsigned=function(){return this.low>>>0},N.getNumBitsAbs=function(){if(this.isNegative())return this.eq(I)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},N.isZero=function(){return 0===this.high&&0===this.low},N.eqz=N.isZero,N.isNegative=function(){return!this.unsigned&&this.high<0},N.isPositive=function(){return this.unsigned||this.high>=0},N.isOdd=function(){return 1==(1&this.low)},N.isEven=function(){return 0==(1&this.low)},N.equals=function(e){return a(e)||(e=p(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},N.eq=N.equals,N.notEquals=function(e){return!this.eq(e)},N.neq=N.notEquals,N.ne=N.notEquals,N.lessThan=function(e){return this.comp(e)<0},N.lt=N.lessThan,N.lessThanOrEqual=function(e){return this.comp(e)<=0},N.lte=N.lessThanOrEqual,N.le=N.lessThanOrEqual,N.greaterThan=function(e){return this.comp(e)>0},N.gt=N.greaterThan,N.greaterThanOrEqual=function(e){return this.comp(e)>=0},N.gte=N.greaterThanOrEqual,N.ge=N.greaterThanOrEqual,N.compare=function(e){if(a(e)||(e=p(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},N.comp=N.compare,N.negate=function(){return!this.unsigned&&this.eq(I)?I:this.not().add(v)},N.neg=N.negate,N.add=function(e){a(e)||(e=p(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,i=65535&this.low,o=e.high>>>16,s=65535&e.high,l=e.low>>>16,d=0,c=0,h=0,f=0;return h+=(f+=i+(65535&e.low))>>>16,c+=(h+=r+l)>>>16,d+=(c+=n+s)>>>16,d+=t+o,u((h&=65535)<<16|(f&=65535),(d&=65535)<<16|(c&=65535),this.unsigned)},N.subtract=function(e){return a(e)||(e=p(e)),this.add(e.neg())},N.sub=N.subtract,N.multiply=function(e){if(this.isZero())return b;if(a(e)||(e=p(e)),n)return u(n.mul(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned);if(e.isZero())return b;if(this.eq(I))return e.isOdd()?I:b;if(e.eq(I))return this.isOdd()?I:b;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return l(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,r=65535&this.high,i=this.low>>>16,o=65535&this.low,s=e.high>>>16,d=65535&e.high,c=e.low>>>16,h=65535&e.low,f=0,m=0,y=0,v=0;return y+=(v+=o*h)>>>16,m+=(y+=i*h)>>>16,y&=65535,m+=(y+=o*c)>>>16,f+=(m+=r*h)>>>16,m&=65535,f+=(m+=i*c)>>>16,m&=65535,f+=(m+=o*d)>>>16,f+=t*h+r*c+i*d+o*s,u((y&=65535)<<16|(v&=65535),(f&=65535)<<16|(m&=65535),this.unsigned)},N.mul=N.multiply,N.divide=function(e){if(a(e)||(e=p(e)),e.isZero())throw Error("division by zero");var t,r,i;if(n)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:b;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return x;i=y}else{if(this.eq(I))return e.eq(v)||e.eq(w)?I:e.eq(I)?v:(t=this.shr(1).div(e).shl(1)).eq(b)?e.isNegative()?v:w:(r=this.sub(e.mul(t)),i=t.add(r.div(e)));if(e.eq(I))return this.unsigned?y:b;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=b}for(r=this;r.gte(e);){t=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var o=Math.ceil(Math.log(t)/Math.LN2),s=o<=48?1:d(2,o-48),c=l(t),h=c.mul(e);h.isNegative()||h.gt(r);)h=(c=l(t-=s,this.unsigned)).mul(e);c.isZero()&&(c=v),i=i.add(c),r=r.sub(h)}return i},N.div=N.divide,N.modulo=function(e){return a(e)||(e=p(e)),n?u((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},N.mod=N.modulo,N.rem=N.modulo,N.not=function(){return u(~this.low,~this.high,this.unsigned)},N.and=function(e){return a(e)||(e=p(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},N.or=function(e){return a(e)||(e=p(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},N.xor=function(e){return a(e)||(e=p(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},N.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},N.shl=N.shiftLeft,N.shiftRight=function(e){return a(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},N.shr=N.shiftRight,N.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},N.shru=N.shiftRightUnsigned,N.shr_u=N.shiftRightUnsigned,N.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},N.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},N.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},N.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},N.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},r.fromBytes=function(e,t,n){return n?r.fromBytesLE(e,t):r.fromBytesBE(e,t)},r.fromBytesLE=function(e,t){return new r(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},r.fromBytesBE=function(e,t){return new r(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}})),pw=lw((()=>{})),hw=lw((()=>{})),fw=lw(((e,t)=>{!function(e,t,n){function r(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function i(e,t){var n=new r(e),i=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,i&&("object"==typeof i&&a(i,n),o.state=function(){return a(n,{})}),o}t&&t.exports?t.exports=i:n&&n.amd?n((function(){return i})):this.alea=i}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),mw=lw(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function i(e,t){var n=new r(e),i=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,i&&("object"==typeof i&&a(i,n),o.state=function(){return a(n,{})}),o}t&&t.exports?t.exports=i:n&&n.amd?n((function(){return i})):this.xor128=i}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),gw=lw(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function i(e,t){var n=new r(e),i=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,i&&("object"==typeof i&&a(i,n),o.state=function(){return a(n,{})}),o}t&&t.exports?t.exports=i:n&&n.amd?n((function(){return i})):this.xorwow=i}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),bw=lw(((e,t)=>{!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],n=(e^=e>>>7)^e<<24,n^=(e=r[a+1&7])^e>>>10,n^=(e=r[a+3&7])^e>>>3,n^=(e=r[a+4&7])^e<<7,e=r[a+7&7],n^=(e^=e<<13)^e<<9,r[a]=n,t.i=a+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function i(e,t){null==e&&(e=+new Date);var n=new r(e),i=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,i&&(i.x&&a(i,n),o.state=function(){return a(n,{})}),o}t&&t.exports?t.exports=i:n&&n.amd?n((function(){return i})):this.xorshift7=i}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),yw=lw(((e,t)=>{!function(e,t,n){function r(e){var t=this;t.next=function(){var e,n,r=t.w,a=t.X,i=t.i;return t.w=r=r+1640531527|0,n=a[i+34&127],e=a[i=i+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[i]=n^e,t.i=i,n+(r^r>>>16)|0},function(e,t){var n,r,a,i,o,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,i=-32;i<l;++i)t&&(r^=t.charCodeAt((i+32)%t.length)),0===i&&(o=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,i>=0&&(o=o+1640531527|0,a=0==(n=s[127&i]^=r+o)?a+1:0);for(a>=128&&(s[127&(t&&t.length||0)]=-1),a=127,i=512;i>0;--i)r=s[a+34&127],n=s[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[a]=r^n;e.w=o,e.X=s,e.i=a}(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function i(e,t){null==e&&(e=+new Date);var n=new r(e),i=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,i&&(i.X&&a(i,n),o.state=function(){return a(n,{})}),o}t&&t.exports?t.exports=i:n&&n.amd?n((function(){return i})):this.xor4096=i}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),vw=lw(((e,t)=>{!function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function i(e,t){var n=new r(e),i=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,i&&("object"==typeof i&&a(i,n),o.state=function(){return a(n,{})}),o}t&&t.exports?t.exports=i:n&&n.amd?n((function(){return i})):this.tychei=i}(0,"object"==typeof t&&t,"function"==typeof define&&define)})),xw=lw((()=>{})),ww=lw(((e,t)=>{!function(e,n,r){var a,i=256,o="random",s=r.pow(i,6),l=r.pow(2,52),u=2*l,d=i-1;function c(t,d,c){var b=[],y=m(f((d=1==d?{entropy:!0}:d||{}).entropy?[t,g(n)]:null==t?function(){try{var t;return a&&(t=a.randomBytes)?t=t(i):(t=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(t)),g(t)}catch(b){var r=e.navigator,o=r&&r.plugins;return[+new Date,e,o,e.screen,g(n)]}}():t,3),b),v=new p(b),x=function(){for(var e=v.g(6),t=s,n=0;e<l;)e=(e+n)*i,t*=i,n=v.g(1);for(;e>=u;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|v.g(4)},x.quick=function(){return v.g(4)/4294967296},x.double=x,m(g(v.S),n),(d.pass||c||function(e,t,n,a){return a&&(a.S&&h(a,v),e.state=function(){return h(v,{})}),n?(r[o]=e,t):e})(x,y,"global"in d?d.global:this==r,d.state)}function p(e){var t,n=e.length,r=this,a=0,o=r.i=r.j=0,s=r.S=[];for(n||(e=[n++]);a<i;)s[a]=a++;for(a=0;a<i;a++)s[a]=s[o=d&o+e[a%n]+(t=s[a])],s[o]=t;(r.g=function(e){for(var t,n=0,a=r.i,o=r.j,s=r.S;e--;)t=s[a=d&a+1],n=n*i+s[d&(s[a]=s[o=d&o+t])+(s[o]=t)];return r.i=a,r.j=o,n})(i)}function h(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function f(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(f(e[n],t-1))}catch(Pa){}return r.length?r:"string"==a?e:e+"\0"}function m(e,t){for(var n,r=e+"",a=0;a<r.length;)t[d&a]=d&(n^=19*t[d&a])+r.charCodeAt(a++);return g(t)}function g(e){return String.fromCharCode.apply(0,e)}if(m(r.random(),n),"object"==typeof t&&t.exports){t.exports=c;try{a=xw()}catch(ro){}}else"function"==typeof define&&define.amd?define((function(){return c})):r["seed"+o]=c}("undefined"!=typeof self?self:e,[],Math)})),kw=lw(((e,t)=>{var n=fw(),r=mw(),a=gw(),i=bw(),o=yw(),s=vw(),l=ww();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=i,l.xor4096=o,l.tychei=s,t.exports=l})),Sw=lw((()=>{})),Iw=lw((()=>{})),Nw=lw((()=>{})),Cw=lw((()=>{})),Tw=lw((()=>{})),$w=lw((()=>{})),Ew=lw(((e,t)=>{var n=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return"undefined"!=typeof __filename&&(e=e||__filename),function(t){function n(){return E.buffer!=R&&W(E.buffer),D}function r(){return E.buffer!=R&&W(E.buffer),M}function a(){return E.buffer!=R&&W(E.buffer),O}function i(){return E.buffer!=R&&W(E.buffer),z}var o,s,l,u=void 0!==(t=t||{})?t:{};u.ready=new Promise((function(e,t){o=e,s=t})),"undefined"!=typeof process&&process.listeners&&(l={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var d,c,p,h=Object.assign({},u),f=(e,t)=>{throw t},m="object"==typeof window,g="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,y=u.ENVIRONMENT_IS_PTHREAD||!1,v="";function x(e){return u.locateFile?u.locateFile(e,v):v+e}if(b){var w=Iw(),k=Nw();let e;v=g?k.dirname(v)+"/":__dirname+"/",d=(e,t)=>(e=re(e)?new URL(e):k.normalize(e),w.readFileSync(e,t?void 0:"utf8")),p=e=>{var t=d(e,!0);return t.buffer||(t=new Uint8Array(t)),t},c=(e,t,n)=>{e=re(e)?new URL(e):k.normalize(e),w.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof oe))throw e})),process.on("unhandledRejection",(function(e){throw e})),f=(e,t)=>{if(q())throw process.exitCode=e,t;(function(e){e instanceof oe||T("exiting due to exception: "+e)})(t),process.exit(e)},u.inspect=function(){return"[Emscripten Module object]"};try{e=Cw()}catch(Ap){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),Ap}global.Worker=e.Worker}else(m||g)&&(g?v=self.location.href:"undefined"!=typeof document&&document.currentScript&&(v=document.currentScript.src),void 0!==e&&e&&(v=e),v=0!==v.indexOf("blob:")?v.substr(0,v.replace(/[?#].*/,"").lastIndexOf("/")+1):"",b||(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),c=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));b&&"undefined"==typeof performance&&(global.performance=Tw().performance);var S=console.log.bind(console),I=console.warn.bind(console);b&&(S=e=>w.writeSync(1,e+"\n"),I=e=>w.writeSync(2,e+"\n"));var N,C=u.print||S,T=u.printErr||I;Object.assign(u,h),h=null,u.arguments&&u.arguments,u.thisProgram&&u.thisProgram,u.quit&&(f=u.quit),u.wasmBinary&&(N=u.wasmBinary);var $=u.noExitRuntime||!0;"object"!=typeof WebAssembly&&J("no native wasm support detected");var E,_,A,R,F,D,M,O,z,P=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function B(e,t,n){for(var r=(t>>>=0)+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&L)return L.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,a):e.subarray(t,a));for(var i="";t<a;){var o=e[t++];if(128&o){var s=63&e[t++];if(192!=(224&o)){var l=63&e[t++];if((o=224==(240&o)?(15&o)<<12|s<<6|l:(7&o)<<18|s<<12|l<<6|63&e[t++])<65536)i+=String.fromCharCode(o);else{var u=o-65536;i+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else i+=String.fromCharCode((31&o)<<6|s)}else i+=String.fromCharCode(o)}return i}function W(e){R=e,u.HEAP8=F=new Int8Array(e),u.HEAP16=new Int16Array(e),u.HEAP32=M=new Int32Array(e),u.HEAPU8=D=new Uint8Array(e),u.HEAPU16=new Uint16Array(e),u.HEAPU32=O=new Uint32Array(e),u.HEAPF32=new Float32Array(e),u.HEAPF64=z=new Float64Array(e)}y&&(R=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(y)E=u.wasmMemory,R=u.buffer;else if(u.wasmMemory)E=u.wasmMemory;else if(!((E=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw T("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),b&&T("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");E&&(R=E.buffer),V=R.byteLength,W(R);var U,j=[],H=[],G=[];function q(){return $}function K(){!y&&pe(H)}function X(e){j.unshift(e)}function Y(e){G.unshift(e)}var Q=0,Z=null;function J(e){u.onAbort&&u.onAbort(e),T(e="Aborted("+e+")"),P=!0,A=1,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw s(t),t}var ee,te="data:application/octet-stream;base64,";function ne(e){return e.startsWith(te)}function re(e){return e.startsWith("file://")}function ae(e){try{if(e==ee&&N)return new Uint8Array(N);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(Ap){J(Ap)}}ne(ee="tfjs-backend-wasm-threaded-simd.wasm")||(ee=x(ee));var ie={};function oe(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function se(e){var t=ce.pthreads[e];(function(e,t){e||J(t)})(t),ce.returnWorkerToPool(t)}function le(e){var t=ce.getNewWorker();if(!t)return 6;ce.runningWorkers.push(t),ce.pthreads[e.pthread_ptr]=t,t.pthread_ptr=e.pthread_ptr;var n={cmd:"run",start_routine:e.startRoutine,arg:e.arg,pthread_ptr:e.pthread_ptr};return t.runPthread=()=>{b&&t.ref(),t.postMessage(n,e.transferList),delete t.runPthread},t.loaded&&t.runPthread(),0}function ue(e){if(y)return xe(1,1,e);A=e,q()||(ce.terminateAllThreads(),u.onExit&&u.onExit(e),P=!0),f(e,new oe(e))}var de=function(e,t){if(A=e,!t&&y)throw he(e),"unwind";ue(e)},ce={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){y?ce.initWorker():ce.initMainThread()},initMainThread:function(){for(var e=8;e--;)ce.allocateUnusedWorker()},initWorker:function(){$=!1},setExitStatus:function(e){A=e},terminateAllThreads:function(){for(var e of Object.values(ce.pthreads))ce.returnWorkerToPool(e);for(var e of ce.unusedWorkers)e.terminate();ce.unusedWorkers=[]},returnWorkerToPool:function(e){var t=e.pthread_ptr;delete ce.pthreads[t],ce.unusedWorkers.push(e),ce.runningWorkers.splice(ce.runningWorkers.indexOf(e),1),e.pthread_ptr=0,b&&e.unref(),Be(t)},receiveObjectTransfer:function(e){},threadInitTLS:function(){ce.tlsInitFunctions.forEach((e=>e()))},loadWasmModuleToWorker:function(t,n){t.onmessage=e=>{var r=e.data,a=r.cmd;if(t.pthread_ptr&&(ce.currentProxiedOperationCallerThread=t.pthread_ptr),r.targetThread&&r.targetThread!=Fe()){var i=ce.pthreads[r.targetThread];return i?i.postMessage(r,r.transferList):T('Internal error! Worker sent a message "'+a+'" to target pthread '+r.targetThread+", but that thread no longer exists!"),void(ce.currentProxiedOperationCallerThread=void 0)}"processProxyingQueue"===a?ye(r.queue):"spawnThread"===a?le(r):"cleanupThread"===a?se(r.thread):"killThread"===a?function(e){var t=ce.pthreads[e];delete ce.pthreads[e],t.terminate(),Be(e),ce.runningWorkers.splice(ce.runningWorkers.indexOf(t),1),t.pthread_ptr=0}(r.thread):"cancelThread"===a?function(e){ce.pthreads[e].postMessage({cmd:"cancel"})}(r.thread):"loaded"===a?(t.loaded=!0,b&&t.unref(),n&&n(t),t.runPthread&&t.runPthread()):"print"===a?C("Thread "+r.threadId+": "+r.text):"printErr"===a?T("Thread "+r.threadId+": "+r.text):"alert"===a?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?t.postMessage(r):"callHandler"===a?u[r.handler](...r.args):a&&T("worker sent an unknown command "+a),ce.currentProxiedOperationCallerThread=void 0},t.onerror=e=>{throw T("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},b&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){})));var r=[];for(var a of["onExit","onAbort","print","printErr"])u.hasOwnProperty(a)&&r.push(a);t.postMessage({cmd:"load",handlers:r,urlOrBlob:u.mainScriptUrlOrBlob||e,wasmMemory:E,wasmModule:_})},allocateUnusedWorker:function(){var e,t=x("tfjs-backend-wasm-threaded-simd.worker.js");e=new Worker(t),ce.unusedWorkers.push(e)},getNewWorker:function(){return 0==ce.unusedWorkers.length&&(ce.allocateUnusedWorker(),ce.loadWasmModuleToWorker(ce.unusedWorkers[0])),ce.unusedWorkers.pop()}};function pe(e){for(;e.length>0;)e.shift()(u)}function he(e){if(y)return xe(2,0,e);try{de(e)}catch(Ap){!function(e){if(e instanceof oe||"unwind"==e)return A;f(1,e)}(Ap)}}u.PThread=ce,u.establishStackSpace=function(){var e=Fe(),t=r()[e+52>>>2],n=r()[e+56>>>2];Ve(t,t-n),je(t)};var fe,me=[];function ge(e,t,n,r){return y?xe(3,1,e,t,n,r):be(e,t,n,r)}function be(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return T("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];if(y&&0===a.length)return ge(e,t,n,r);var i={startRoutine:n,pthread_ptr:e,arg:r,transferList:a};return y?(i.cmd="spawnThread",postMessage(i,a),0):le(i)}function ye(e){Atomics.store(r(),e>>2,1),Fe()&&Le(e),Atomics.compareExchange(r(),e>>2,1,0)}function ve(e){ve.shown||(ve.shown={}),ve.shown[e]||(ve.shown[e]=1,b&&(e="warning: "+e),T(e))}function xe(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=Ue(),n=e();return je(t),n}((()=>{for(var a=n,o=He(8*a),s=o>>3,l=0;l<n;l++){var u=r[2+l];i()[s+l>>>0]=u}return Me(e,a,o,t)}))}u.invokeEntryPoint=function(e,t){var n=function(e){var t=me[e];return t||(e>=me.length&&(me.length=e+1),me[e]=t=U.get(e)),t}(e)(t);q()?ce.setExitStatus(n):We(n)},u.executeNotifiedProxyingQueue=ye,fe=b?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.timeOrigin+performance.now();var we=[];function ke(e){try{return E.grow(e-R.byteLength+65535>>>16),W(E.buffer),1}catch(Ap){}}function Se(e){return y?xe(4,1,e):52}function Ie(e,t,n,r,a){return y?xe(5,1,e,t,n,r,a):70}var Ne=[null,[],[]];function Ce(e,t){var n=Ne[e];0===t||10===t?((1===e?C:T)(B(n,0)),n.length=0):n.push(t)}function Te(e,t,r,i){if(y)return xe(6,1,e,t,r,i);for(var o=0,s=0;s<r;s++){var l=a()[t>>>2],u=a()[t+4>>>2];t+=8;for(var d=0;d<u;d++)Ce(e,n()[l+d>>>0]);o+=u}return a()[i>>>2]=o,0}function $e(e){return u["_"+e]}function Ee(e,t){(E.buffer!=R&&W(E.buffer),F).set(e,t>>>0)}function _e(e,t,r,a,i){var o={string:e=>{var t=0;if(null!=e&&0!==e){var r=1+(e.length<<2);!function(e,t,r){!function(e,t,n,r){if(!(r>0))return 0;n>>>=0;for(var a=n+r-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),o<=127){if(n>=a)break;t[n++>>>0]=o}else if(o<=2047){if(n+1>=a)break;t[n++>>>0]=192|o>>6,t[n++>>>0]=128|63&o}else if(o<=65535){if(n+2>=a)break;t[n++>>>0]=224|o>>12,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}else{if(n+3>=a)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}}t[n>>>0]=0}(e,n(),t,r)}(e,t=He(r),r)}return t},array:e=>{var t=He(e.length);return Ee(e,t),t}};function s(e){return"string"===t?function(e,t){return(e>>>=0)?B(n(),e,t):""}(e):"boolean"===t?!!e:e}var l=$e(e),u=[],d=0;if(a)for(var c=0;c<a.length;c++){var p=o[r[c]];p?(0===d&&(d=Ue()),u[c]=p(a[c])):u[c]=a[c]}var h=l.apply(null,u);return h=function(e){return 0!==d&&je(d),s(e)}(h),h}ce.init();var Ae=[null,ue,he,ge,Se,Ie,Te],Re={__emscripten_init_main_thread_js:function(e){De(e,!g,1,!m),ce.threadInitTLS()},__emscripten_thread_cleanup:function(e){y?postMessage({cmd:"cleanupThread",thread:e}):se(e)},__pthread_create_js:be,_emscripten_default_pthread_stack_size:function(){return 65536},_emscripten_get_now_is_monotonic:function(){return!0},_emscripten_notify_task_queue:function(e,t,n,r){if(e==t)setTimeout((()=>ye(r)));else if(y)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{var a=ce.pthreads[e];if(!a)return;a.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},_emscripten_set_offscreencanvas_size:function(e,t,n){return-1},abort:function(){J("")},emscripten_check_blocking_allowed:function(){b||g||ve("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")},emscripten_date_now:function(){return Date.now()},emscripten_get_heap_max:function(){return 4294901760},emscripten_get_now:fe,emscripten_memcpy_big:function(e,t,r){n().copyWithin(e>>>0,t>>>0,t+r>>>0)},emscripten_num_logical_cores:function(){return b?$w().cpus().length:navigator.hardwareConcurrency},emscripten_receive_on_main_thread_js:function(e,t,n){we.length=t;for(var r=n>>3,a=0;a<t;a++)we[a]=i()[r+a>>>0];return(e<0?ie[-e-1]:Ae[e]).apply(null,we)},emscripten_resize_heap:function(e){var t=n().length;if((e>>>=0)<=t)return!1;var r=4294901760;if(e>r)return!1;let a=(e,t)=>e+(t-e%t)%t;for(var i=1;i<=4;i*=2){var o=t*(1+.2/i);if(o=Math.min(o,e+100663296),ke(Math.min(r,a(Math.max(e,o),65536))))return!0}return!1},emscripten_unwind_to_js_event_loop:function(){throw"unwind"},exit:de,fd_close:Se,fd_seek:Ie,fd_write:Te,memory:E||u.wasmMemory};!function(){var e={env:Re,wasi_snapshot_preview1:Re};function t(e,t){var n=e.exports;if(u.asm=n,function(e){ce.tlsInitFunctions.push(e)}(u.asm._emscripten_tls_init),U=u.asm.__indirect_function_table,function(e){H.unshift(e)}(u.asm.__wasm_call_ctors),_=t,!y){var r=ce.unusedWorkers.length;ce.unusedWorkers.forEach((function(e){ce.loadWasmModuleToWorker(e,(function(){--r||function(e){if(Q--,u.monitorRunDependencies&&u.monitorRunDependencies(Q),0==Q&&Z){var t=Z;Z=null,t()}}()}))}))}}function n(e){t(e.instance,e.module)}function r(t){return function(){if(!N&&(m||g)){if("function"==typeof fetch&&!re(ee))return fetch(ee,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+ee+"'";return e.arrayBuffer()})).catch((function(){return ae(ee)}));if(c)return new Promise((function(e,t){c(ee,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ae(ee)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){T("failed to asynchronously prepare wasm: "+e),J(e)}))}if(y||(Q++,u.monitorRunDependencies&&u.monitorRunDependencies(Q)),u.instantiateWasm)try{return u.instantiateWasm(e,t)}catch(Ur){T("Module.instantiateWasm callback failed with error: "+Ur),s(Ur)}(N||"function"!=typeof WebAssembly.instantiateStreaming||ne(ee)||re(ee)||b||"function"!=typeof fetch?r(n):fetch(ee,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return T("wasm streaming compile failed: "+e),T("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.__wasm_call_ctors).apply(null,arguments)},u._init=function(){return(u._init=u.asm.init).apply(null,arguments)},u._init_with_threads_count=function(){return(u._init_with_threads_count=u.asm.init_with_threads_count).apply(null,arguments)},u._get_threads_count=function(){return(u._get_threads_count=u.asm.get_threads_count).apply(null,arguments)},u._register_tensor=function(){return(u._register_tensor=u.asm.register_tensor).apply(null,arguments)},u._dispose_data=function(){return(u._dispose_data=u.asm.dispose_data).apply(null,arguments)},u._dispose=function(){return(u._dispose=u.asm.dispose).apply(null,arguments)},u._Abs=function(){return(u._Abs=u.asm.Abs).apply(null,arguments)},u._Acos=function(){return(u._Acos=u.asm.Acos).apply(null,arguments)},u._Acosh=function(){return(u._Acosh=u.asm.Acosh).apply(null,arguments)},u._Add=function(){return(u._Add=u.asm.Add).apply(null,arguments)},u._AddN=function(){return(u._AddN=u.asm.AddN).apply(null,arguments)},u._All=function(){return(u._All=u.asm.All).apply(null,arguments)},u._Any=function(){return(u._Any=u.asm.Any).apply(null,arguments)},u._ArgMax=function(){return(u._ArgMax=u.asm.ArgMax).apply(null,arguments)},u._ArgMin=function(){return(u._ArgMin=u.asm.ArgMin).apply(null,arguments)},u._Asin=function(){return(u._Asin=u.asm.Asin).apply(null,arguments)},u._Asinh=function(){return(u._Asinh=u.asm.Asinh).apply(null,arguments)},u._Atan=function(){return(u._Atan=u.asm.Atan).apply(null,arguments)},u._Atan2=function(){return(u._Atan2=u.asm.Atan2).apply(null,arguments)},u._Atanh=function(){return(u._Atanh=u.asm.Atanh).apply(null,arguments)},u._AvgPool=function(){return(u._AvgPool=u.asm.AvgPool).apply(null,arguments)},u._AvgPool3D=function(){return(u._AvgPool3D=u.asm.AvgPool3D).apply(null,arguments)},u._AvgPool3DGrad=function(){return(u._AvgPool3DGrad=u.asm.AvgPool3DGrad).apply(null,arguments)},u._AvgPoolGrad=function(){return(u._AvgPoolGrad=u.asm.AvgPoolGrad).apply(null,arguments)},u._BatchMatMul=function(){return(u._BatchMatMul=u.asm.BatchMatMul).apply(null,arguments)},u._Bincount=function(){return(u._Bincount=u.asm.Bincount).apply(null,arguments)},u._BitwiseAnd=function(){return(u._BitwiseAnd=u.asm.BitwiseAnd).apply(null,arguments)},u._Ceil=function(){return(u._Ceil=u.asm.Ceil).apply(null,arguments)},u._ClipByValue=function(){return(u._ClipByValue=u.asm.ClipByValue).apply(null,arguments)},u._Conv2D=function(){return(u._Conv2D=u.asm.Conv2D).apply(null,arguments)},u._Conv2DBackpropInput=function(){return(u._Conv2DBackpropInput=u.asm.Conv2DBackpropInput).apply(null,arguments)},u._Conv3D=function(){return(u._Conv3D=u.asm.Conv3D).apply(null,arguments)},u._Conv3DBackpropFilterV2=function(){return(u._Conv3DBackpropFilterV2=u.asm.Conv3DBackpropFilterV2).apply(null,arguments)},u._Conv3DBackpropInputV2=function(){return(u._Conv3DBackpropInputV2=u.asm.Conv3DBackpropInputV2).apply(null,arguments)},u._Cos=function(){return(u._Cos=u.asm.Cos).apply(null,arguments)},u._Cosh=function(){return(u._Cosh=u.asm.Cosh).apply(null,arguments)},u._CropAndResize=function(){return(u._CropAndResize=u.asm.CropAndResize).apply(null,arguments)},u._Cumprod=function(){return(u._Cumprod=u.asm.Cumprod).apply(null,arguments)},u._Cumsum=function(){return(u._Cumsum=u.asm.Cumsum).apply(null,arguments)},u._DenseBincount=function(){return(u._DenseBincount=u.asm.DenseBincount).apply(null,arguments)},u._DepthToSpace=function(){return(u._DepthToSpace=u.asm.DepthToSpace).apply(null,arguments)},u._DepthwiseConv2dNative=function(){return(u._DepthwiseConv2dNative=u.asm.DepthwiseConv2dNative).apply(null,arguments)},u._Diag=function(){return(u._Diag=u.asm.Diag).apply(null,arguments)},u._Dilation2D=function(){return(u._Dilation2D=u.asm.Dilation2D).apply(null,arguments)},u._Dilation2DBackpropFilter=function(){return(u._Dilation2DBackpropFilter=u.asm.Dilation2DBackpropFilter).apply(null,arguments)},u._Dilation2DBackpropInput=function(){return(u._Dilation2DBackpropInput=u.asm.Dilation2DBackpropInput).apply(null,arguments)},u._Elu=function(){return(u._Elu=u.asm.Elu).apply(null,arguments)},u._EluGrad=function(){return(u._EluGrad=u.asm.EluGrad).apply(null,arguments)},u._Equal=function(){return(u._Equal=u.asm.Equal).apply(null,arguments)},u._Erf=function(){return(u._Erf=u.asm.Erf).apply(null,arguments)},u._Exp=function(){return(u._Exp=u.asm.Exp).apply(null,arguments)},u._Expm1=function(){return(u._Expm1=u.asm.Expm1).apply(null,arguments)},u._FlipLeftRight=function(){return(u._FlipLeftRight=u.asm.FlipLeftRight).apply(null,arguments)},u._Floor=function(){return(u._Floor=u.asm.Floor).apply(null,arguments)},u._FloorDiv=function(){return(u._FloorDiv=u.asm.FloorDiv).apply(null,arguments)},u._FusedBatchNorm=function(){return(u._FusedBatchNorm=u.asm.FusedBatchNorm).apply(null,arguments)},u._FusedConv2D=function(){return(u._FusedConv2D=u.asm.FusedConv2D).apply(null,arguments)},u._FusedDepthwiseConv2D=function(){return(u._FusedDepthwiseConv2D=u.asm.FusedDepthwiseConv2D).apply(null,arguments)},u._Gather=function(){return(u._Gather=u.asm.Gather).apply(null,arguments)},u._GatherNd=function(){return(u._GatherNd=u.asm.GatherNd).apply(null,arguments)},u._Greater=function(){return(u._Greater=u.asm.Greater).apply(null,arguments)},u._GreaterEqual=function(){return(u._GreaterEqual=u.asm.GreaterEqual).apply(null,arguments)},u._IsFinite=function(){return(u._IsFinite=u.asm.IsFinite).apply(null,arguments)},u._IsInf=function(){return(u._IsInf=u.asm.IsInf).apply(null,arguments)},u._IsNan=function(){return(u._IsNan=u.asm.IsNan).apply(null,arguments)},u._LRN=function(){return(u._LRN=u.asm.LRN).apply(null,arguments)},u._LRNGrad=function(){return(u._LRNGrad=u.asm.LRNGrad).apply(null,arguments)},u._LeakyRelu=function(){return(u._LeakyRelu=u.asm.LeakyRelu).apply(null,arguments)},u._Less=function(){return(u._Less=u.asm.Less).apply(null,arguments)},u._LessEqual=function(){return(u._LessEqual=u.asm.LessEqual).apply(null,arguments)},u._LinSpace=function(){return(u._LinSpace=u.asm.LinSpace).apply(null,arguments)},u._Log=function(){return(u._Log=u.asm.Log).apply(null,arguments)},u._Log1p=function(){return(u._Log1p=u.asm.Log1p).apply(null,arguments)},u._LogicalAnd=function(){return(u._LogicalAnd=u.asm.LogicalAnd).apply(null,arguments)},u._LogicalNot=function(){return(u._LogicalNot=u.asm.LogicalNot).apply(null,arguments)},u._LogicalOr=function(){return(u._LogicalOr=u.asm.LogicalOr).apply(null,arguments)},u._LogicalXor=function(){return(u._LogicalXor=u.asm.LogicalXor).apply(null,arguments)},u._Max=function(){return(u._Max=u.asm.Max).apply(null,arguments)},u._MaxPool=function(){return(u._MaxPool=u.asm.MaxPool).apply(null,arguments)},u._MaxPool3D=function(){return(u._MaxPool3D=u.asm.MaxPool3D).apply(null,arguments)},u._MaxPool3DGrad=function(){return(u._MaxPool3DGrad=u.asm.MaxPool3DGrad).apply(null,arguments)},u._MaxPoolGrad=function(){return(u._MaxPoolGrad=u.asm.MaxPoolGrad).apply(null,arguments)},u._MaxPoolWithArgmax=function(){return(u._MaxPoolWithArgmax=u.asm.MaxPoolWithArgmax).apply(null,arguments)},u._Maximum=function(){return(u._Maximum=u.asm.Maximum).apply(null,arguments)},u._Mean=function(){return(u._Mean=u.asm.Mean).apply(null,arguments)},u._Min=function(){return(u._Min=u.asm.Min).apply(null,arguments)},u._Minimum=function(){return(u._Minimum=u.asm.Minimum).apply(null,arguments)},u._MirrorPad=function(){return(u._MirrorPad=u.asm.MirrorPad).apply(null,arguments)},u._Mod=function(){return(u._Mod=u.asm.Mod).apply(null,arguments)},u._Multinomial=function(){return(u._Multinomial=u.asm.Multinomial).apply(null,arguments)},u._Multiply=function(){return(u._Multiply=u.asm.Multiply).apply(null,arguments)},u._Neg=function(){return(u._Neg=u.asm.Neg).apply(null,arguments)},u._NonMaxSuppressionV3=function(){return(u._NonMaxSuppressionV3=u.asm.NonMaxSuppressionV3).apply(null,arguments)},u._NonMaxSuppressionV4=function(){return(u._NonMaxSuppressionV4=u.asm.NonMaxSuppressionV4).apply(null,arguments)},u._NonMaxSuppressionV5=function(){return(u._NonMaxSuppressionV5=u.asm.NonMaxSuppressionV5).apply(null,arguments)},u._NotEqual=function(){return(u._NotEqual=u.asm.NotEqual).apply(null,arguments)},u._OneHot=function(){return(u._OneHot=u.asm.OneHot).apply(null,arguments)},u._PadV2=function(){return(u._PadV2=u.asm.PadV2).apply(null,arguments)},u._Pow=function(){return(u._Pow=u.asm.Pow).apply(null,arguments)},u._Prelu=function(){return(u._Prelu=u.asm.Prelu).apply(null,arguments)},u._Prod=function(){return(u._Prod=u.asm.Prod).apply(null,arguments)},u._RealDiv=function(){return(u._RealDiv=u.asm.RealDiv).apply(null,arguments)},u._Reciprocal=function(){return(u._Reciprocal=u.asm.Reciprocal).apply(null,arguments)},u._Relu=function(){return(u._Relu=u.asm.Relu).apply(null,arguments)},u._Relu6=function(){return(u._Relu6=u.asm.Relu6).apply(null,arguments)},u._ResizeBilinear=function(){return(u._ResizeBilinear=u.asm.ResizeBilinear).apply(null,arguments)},u._ResizeBilinearGrad=function(){return(u._ResizeBilinearGrad=u.asm.ResizeBilinearGrad).apply(null,arguments)},u._ResizeNearestNeighbor=function(){return(u._ResizeNearestNeighbor=u.asm.ResizeNearestNeighbor).apply(null,arguments)},u._ResizeNearestNeighborGrad=function(){return(u._ResizeNearestNeighborGrad=u.asm.ResizeNearestNeighborGrad).apply(null,arguments)},u._Reverse=function(){return(u._Reverse=u.asm.Reverse).apply(null,arguments)},u._RotateWithOffset=function(){return(u._RotateWithOffset=u.asm.RotateWithOffset).apply(null,arguments)},u._Round=function(){return(u._Round=u.asm.Round).apply(null,arguments)},u._Rsqrt=function(){return(u._Rsqrt=u.asm.Rsqrt).apply(null,arguments)},u._ScatterNd=function(){return(u._ScatterNd=u.asm.ScatterNd).apply(null,arguments)},u._SearchSorted=function(){return(u._SearchSorted=u.asm.SearchSorted).apply(null,arguments)},u._SelectV2=function(){return(u._SelectV2=u.asm.SelectV2).apply(null,arguments)},u._Selu=function(){return(u._Selu=u.asm.Selu).apply(null,arguments)},u._Sigmoid=function(){return(u._Sigmoid=u.asm.Sigmoid).apply(null,arguments)},u._Sign=function(){return(u._Sign=u.asm.Sign).apply(null,arguments)},u._Sin=function(){return(u._Sin=u.asm.Sin).apply(null,arguments)},u._Sinh=function(){return(u._Sinh=u.asm.Sinh).apply(null,arguments)},u._Softmax=function(){return(u._Softmax=u.asm.Softmax).apply(null,arguments)},u._Softplus=function(){return(u._Softplus=u.asm.Softplus).apply(null,arguments)},u._SparseFillEmptyRows=function(){return(u._SparseFillEmptyRows=u.asm.SparseFillEmptyRows).apply(null,arguments)},u._SparseReshape=function(){return(u._SparseReshape=u.asm.SparseReshape).apply(null,arguments)},u._SparseSegmentReduction=function(){return(u._SparseSegmentReduction=u.asm.SparseSegmentReduction).apply(null,arguments)},u._SparseToDense=function(){return(u._SparseToDense=u.asm.SparseToDense).apply(null,arguments)},u._Sqrt=function(){return(u._Sqrt=u.asm.Sqrt).apply(null,arguments)},u._Square=function(){return(u._Square=u.asm.Square).apply(null,arguments)},u._SquaredDifference=function(){return(u._SquaredDifference=u.asm.SquaredDifference).apply(null,arguments)},u._Step=function(){return(u._Step=u.asm.Step).apply(null,arguments)},u._StridedSlice=function(){return(u._StridedSlice=u.asm.StridedSlice).apply(null,arguments)},u._Sub=function(){return(u._Sub=u.asm.Sub).apply(null,arguments)},u._Sum=function(){return(u._Sum=u.asm.Sum).apply(null,arguments)},u._Tan=function(){return(u._Tan=u.asm.Tan).apply(null,arguments)},u._Tanh=function(){return(u._Tanh=u.asm.Tanh).apply(null,arguments)},u._TensorScatterUpdate=function(){return(u._TensorScatterUpdate=u.asm.TensorScatterUpdate).apply(null,arguments)},u._Tile=function(){return(u._Tile=u.asm.Tile).apply(null,arguments)},u._TopK=function(){return(u._TopK=u.asm.TopK).apply(null,arguments)},u._Transform=function(){return(u._Transform=u.asm.Transform).apply(null,arguments)},u._Transpose=function(){return(u._Transpose=u.asm.Transpose).apply(null,arguments)},u.__FusedMatMul=function(){return(u.__FusedMatMul=u.asm._FusedMatMul).apply(null,arguments)},u._malloc=function(){return(u._malloc=u.asm.malloc).apply(null,arguments)},u._free=function(){return(u._free=u.asm.free).apply(null,arguments)},u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm._emscripten_tls_init).apply(null,arguments)};var Fe=u._pthread_self=function(){return(Fe=u._pthread_self=u.asm.pthread_self).apply(null,arguments)};u.___errno_location=function(){return(u.___errno_location=u.asm.__errno_location).apply(null,arguments)};var De=u.__emscripten_thread_init=function(){return(De=u.__emscripten_thread_init=u.asm._emscripten_thread_init).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm._emscripten_thread_crashed).apply(null,arguments)},u._emscripten_main_thread_process_queued_calls=function(){return(u._emscripten_main_thread_process_queued_calls=u.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},u._emscripten_main_browser_thread_id=function(){return(u._emscripten_main_browser_thread_id=u.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var Me=u._emscripten_run_in_main_runtime_thread_js=function(){return(Me=u._emscripten_run_in_main_runtime_thread_js=u.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};u._emscripten_dispatch_to_thread_=function(){return(u._emscripten_dispatch_to_thread_=u.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var Oe,ze,Pe,Le=u.__emscripten_proxy_execute_task_queue=function(){return(Le=u.__emscripten_proxy_execute_task_queue=u.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},Be=u.__emscripten_thread_free_data=function(){return(Be=u.__emscripten_thread_free_data=u.asm._emscripten_thread_free_data).apply(null,arguments)},We=u.__emscripten_thread_exit=function(){return(We=u.__emscripten_thread_exit=u.asm._emscripten_thread_exit).apply(null,arguments)},Ve=u._emscripten_stack_set_limits=function(){return(Ve=u._emscripten_stack_set_limits=u.asm.emscripten_stack_set_limits).apply(null,arguments)},Ue=u.stackSave=function(){return(Ue=u.stackSave=u.asm.stackSave).apply(null,arguments)},je=u.stackRestore=function(){return(je=u.stackRestore=u.asm.stackRestore).apply(null,arguments)},He=u.stackAlloc=function(){return(He=u.stackAlloc=u.asm.stackAlloc).apply(null,arguments)};function Ge(e){if(!(Q>0)){if(y)return o(u),K(),void startWorker(u);(function(){if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)X(u.preRun.shift());pe(j)})(),Q>0||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}function t(){Oe||(Oe=!0,u.calledRun=!0,!P&&(K(),o(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),function(){if(!y){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;)Y(u.postRun.shift());pe(G)}}()))}}if(u.dynCall_iijjiiii=function(){return(u.dynCall_iijjiiii=u.asm.dynCall_iijjiiii).apply(null,arguments)},u.dynCall_jiji=function(){return(u.dynCall_jiji=u.asm.dynCall_jiji).apply(null,arguments)},u.keepRuntimeAlive=q,u.wasmMemory=E,u.cwrap=function(e,t,n,r){var a=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&a&&!r?$e(e):function(){return _e(e,t,n,arguments)}},u.ExitStatus=oe,u.PThread=ce,Z=function e(){Oe||Ge(),Oe||(Z=e)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);u.preInit.length>0;)u.preInit.pop()();if(Ge(),l&&(ze={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!l.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!l.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof WasmBackendModule)Pe=WasmBackendModule;else{if(void 0===t)throw new Error("Could not find wasm module in post.js");Pe=t}if(ze){var qe=Pe._dispose;Pe._dispose=function(){qe(),ze.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),ze.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=n:"function"==typeof define&&define.amd?define([],(function(){return n})):"object"==typeof e&&(e.WasmBackendModuleThreadedSimd=n)})),_w=lw(((e,t)=>{t.exports.wasmWorkerContents='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};'})),Aw=lw(((e,t)=>{var n=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return"undefined"!=typeof __filename&&(e=e||__filename),function(t){var n,r,a,i=void 0!==(t=t||{})?t:{};i.ready=new Promise((function(e,t){n=e,r=t})),"undefined"!=typeof process&&process.listeners&&(a={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var o,s,l,u=Object.assign({},i),d="object"==typeof window,c="function"==typeof importScripts,p="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,h="";if(p){var f=Iw(),m=Nw();h=c?m.dirname(h)+"/":__dirname+"/",o=(e,t)=>(e=L(e)?new URL(e):m.normalize(e),f.readFileSync(e,t?void 0:"utf8")),l=e=>{var t=o(e,!0);return t.buffer||(t=new Uint8Array(t)),t},s=(e,t,n)=>{e=L(e)?new URL(e):m.normalize(e),f.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof W))throw e})),process.on("unhandledRejection",(function(e){throw e})),i.inspect=function(){return"[Emscripten Module object]"}}else(d||c)&&(c?h=self.location.href:"undefined"!=typeof document&&document.currentScript&&(h=document.currentScript.src),e&&(h=e),h=0!==h.indexOf("blob:")?h.substr(0,h.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},c&&(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),s=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var g,b=i.print||console.log.bind(console),y=i.printErr||console.warn.bind(console);Object.assign(i,u),u=null,i.arguments&&i.arguments,i.thisProgram&&i.thisProgram,i.quit&&i.quit,i.wasmBinary&&(g=i.wasmBinary),i.noExitRuntime,"object"!=typeof WebAssembly&&M("no native wasm support detected");var v,x,w,k,S,I=!1,N="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function C(e,t,n){for(var r=(t>>>=0)+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.buffer&&N)return N.decode(e.subarray(t,a));for(var i="";t<a;){var o=e[t++];if(128&o){var s=63&e[t++];if(192!=(224&o)){var l=63&e[t++];if((o=224==(240&o)?(15&o)<<12|s<<6|l:(7&o)<<18|s<<12|l<<6|63&e[t++])<65536)i+=String.fromCharCode(o);else{var u=o-65536;i+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else i+=String.fromCharCode((31&o)<<6|s)}else i+=String.fromCharCode(o)}return i}function T(e){x=e,i.HEAP8=w=new Int8Array(e),i.HEAP16=new Int16Array(e),i.HEAP32=new Int32Array(e),i.HEAPU8=k=new Uint8Array(e),i.HEAPU16=new Uint16Array(e),i.HEAPU32=S=new Uint32Array(e),i.HEAPF32=new Float32Array(e),i.HEAPF64=new Float64Array(e)}i.INITIAL_MEMORY;var $=[],E=[],_=[];function A(e){$.unshift(e)}function R(e){_.unshift(e)}var F=0,D=null;function M(e){i.onAbort&&i.onAbort(e),y(e="Aborted("+e+")"),I=!0,e+=". Build with -sASSERTIONS for more info.";var t=new WebAssembly.RuntimeError(e);throw r(t),t}var O,z="data:application/octet-stream;base64,";function P(e){return e.startsWith(z)}function L(e){return e.startsWith("file://")}function B(e){try{if(e==O&&g)return new Uint8Array(g);if(l)return l(e);throw"both async and sync fetching of the wasm failed"}catch(Ha){M(Ha)}}function W(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function V(e){for(;e.length>0;)e.shift()(i)}function U(e){try{return v.grow(e-x.byteLength+65535>>>16),T(v.buffer),1}catch(Ha){}}P(O="tfjs-backend-wasm.wasm")||(O=function(e){return i.locateFile?i.locateFile(e,h):h+e}(O));var j=[null,[],[]];function H(e,t){var n=j[e];0===t||10===t?((1===e?b:y)(C(n,0)),n.length=0):n.push(t)}function G(e){return i["_"+e]}function q(e,t,n,r,a){var i={string:e=>{var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);!function(e,t,n){!function(e,t,n,r){if(!(r>0))return 0;n>>>=0;for(var a=n+r-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++i)),o<=127){if(n>=a)break;t[n++>>>0]=o}else if(o<=2047){if(n+1>=a)break;t[n++>>>0]=192|o>>6,t[n++>>>0]=128|63&o}else if(o<=65535){if(n+2>=a)break;t[n++>>>0]=224|o>>12,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}else{if(n+3>=a)break;t[n++>>>0]=240|o>>18,t[n++>>>0]=128|o>>12&63,t[n++>>>0]=128|o>>6&63,t[n++>>>0]=128|63&o}}t[n>>>0]=0}(e,k,t,n)}(e,t=ee(n),n)}return t},array:e=>{var t=ee(e.length);return function(e,t){w.set(e,t>>>0)}(e,t),t}};function o(e){return"string"===t?function(e,t){return(e>>>=0)?C(k,e,t):""}(e):"boolean"===t?!!e:e}var s=G(e),l=[],u=0;if(r)for(var d=0;d<r.length;d++){var c=i[n[d]];c?(0===u&&(u=Z()),l[d]=c(r[d])):l[d]=r[d]}var p,h=s.apply(null,l);return p=h,0!==u&&J(u),h=o(p)}var K={abort:function(){M("")},emscripten_get_heap_max:function(){return 4294901760},emscripten_memcpy_big:function(e,t,n){k.copyWithin(e>>>0,t>>>0,t+n>>>0)},emscripten_resize_heap:function(e){var t=k.length,n=4294901760;if((e>>>=0)>n)return!1;let r=(e,t)=>e+(t-e%t)%t;for(var a=1;a<=4;a*=2){var i=t*(1+.2/a);if(i=Math.min(i,e+100663296),U(Math.min(n,r(Math.max(e,i),65536))))return!0}return!1},fd_close:function(e){return 52},fd_seek:function(e,t,n,r,a){return 70},fd_write:function(e,t,n,r){for(var a=0,i=0;i<n;i++){var o=S[t>>>2],s=S[t+4>>>2];t+=8;for(var l=0;l<s;l++)H(e,k[o+l>>>0]);a+=s}return S[r>>>2]=a,0}};!function(){var e={env:K,wasi_snapshot_preview1:K};function t(e,t){var n=e.exports;i.asm=n,T((v=i.asm.memory).buffer),i.asm.__indirect_function_table,function(e){E.unshift(e)}(i.asm.__wasm_call_ctors),function(e){if(F--,i.monitorRunDependencies&&i.monitorRunDependencies(F),0==F&&D){var t=D;D=null,t()}}()}function n(e){t(e.instance)}function a(t){return function(){if(!g&&(d||c)){if("function"==typeof fetch&&!L(O))return fetch(O,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+O+"'";return e.arrayBuffer()})).catch((function(){return B(O)}));if(s)return new Promise((function(e,t){s(O,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return B(O)}))}().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){y("failed to asynchronously prepare wasm: "+e),M(e)}))}if(F++,i.monitorRunDependencies&&i.monitorRunDependencies(F),i.instantiateWasm)try{return i.instantiateWasm(e,t)}catch(oa){y("Module.instantiateWasm callback failed with error: "+oa),r(oa)}(g||"function"!=typeof WebAssembly.instantiateStreaming||P(O)||L(O)||p||"function"!=typeof fetch?a(n):fetch(O,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,e).then(n,(function(e){return y("wasm streaming compile failed: "+e),y("falling back to ArrayBuffer instantiation"),a(n)}))}))).catch(r)}(),i.___wasm_call_ctors=function(){return(i.___wasm_call_ctors=i.asm.__wasm_call_ctors).apply(null,arguments)},i._init=function(){return(i._init=i.asm.init).apply(null,arguments)},i._init_with_threads_count=function(){return(i._init_with_threads_count=i.asm.init_with_threads_count).apply(null,arguments)},i._get_threads_count=function(){return(i._get_threads_count=i.asm.get_threads_count).apply(null,arguments)},i._register_tensor=function(){return(i._register_tensor=i.asm.register_tensor).apply(null,arguments)},i._dispose_data=function(){return(i._dispose_data=i.asm.dispose_data).apply(null,arguments)},i._dispose=function(){return(i._dispose=i.asm.dispose).apply(null,arguments)},i._Abs=function(){return(i._Abs=i.asm.Abs).apply(null,arguments)},i._Acos=function(){return(i._Acos=i.asm.Acos).apply(null,arguments)},i._Acosh=function(){return(i._Acosh=i.asm.Acosh).apply(null,arguments)},i._Add=function(){return(i._Add=i.asm.Add).apply(null,arguments)},i._AddN=function(){return(i._AddN=i.asm.AddN).apply(null,arguments)},i._All=function(){return(i._All=i.asm.All).apply(null,arguments)},i._Any=function(){return(i._Any=i.asm.Any).apply(null,arguments)},i._ArgMax=function(){return(i._ArgMax=i.asm.ArgMax).apply(null,arguments)},i._ArgMin=function(){return(i._ArgMin=i.asm.ArgMin).apply(null,arguments)},i._Asin=function(){return(i._Asin=i.asm.Asin).apply(null,arguments)},i._Asinh=function(){return(i._Asinh=i.asm.Asinh).apply(null,arguments)},i._Atan=function(){return(i._Atan=i.asm.Atan).apply(null,arguments)},i._Atan2=function(){return(i._Atan2=i.asm.Atan2).apply(null,arguments)},i._Atanh=function(){return(i._Atanh=i.asm.Atanh).apply(null,arguments)},i._AvgPool=function(){return(i._AvgPool=i.asm.AvgPool).apply(null,arguments)},i._AvgPool3D=function(){return(i._AvgPool3D=i.asm.AvgPool3D).apply(null,arguments)},i._AvgPool3DGrad=function(){return(i._AvgPool3DGrad=i.asm.AvgPool3DGrad).apply(null,arguments)},i._AvgPoolGrad=function(){return(i._AvgPoolGrad=i.asm.AvgPoolGrad).apply(null,arguments)},i._BatchMatMul=function(){return(i._BatchMatMul=i.asm.BatchMatMul).apply(null,arguments)},i._Bincount=function(){return(i._Bincount=i.asm.Bincount).apply(null,arguments)},i._BitwiseAnd=function(){return(i._BitwiseAnd=i.asm.BitwiseAnd).apply(null,arguments)},i._Ceil=function(){return(i._Ceil=i.asm.Ceil).apply(null,arguments)},i._ClipByValue=function(){return(i._ClipByValue=i.asm.ClipByValue).apply(null,arguments)},i._Conv2D=function(){return(i._Conv2D=i.asm.Conv2D).apply(null,arguments)},i._Conv2DBackpropInput=function(){return(i._Conv2DBackpropInput=i.asm.Conv2DBackpropInput).apply(null,arguments)},i._Conv3D=function(){return(i._Conv3D=i.asm.Conv3D).apply(null,arguments)},i._Conv3DBackpropFilterV2=function(){return(i._Conv3DBackpropFilterV2=i.asm.Conv3DBackpropFilterV2).apply(null,arguments)},i._Conv3DBackpropInputV2=function(){return(i._Conv3DBackpropInputV2=i.asm.Conv3DBackpropInputV2).apply(null,arguments)},i._Cos=function(){return(i._Cos=i.asm.Cos).apply(null,arguments)},i._Cosh=function(){return(i._Cosh=i.asm.Cosh).apply(null,arguments)},i._CropAndResize=function(){return(i._CropAndResize=i.asm.CropAndResize).apply(null,arguments)},i._Cumprod=function(){return(i._Cumprod=i.asm.Cumprod).apply(null,arguments)},i._Cumsum=function(){return(i._Cumsum=i.asm.Cumsum).apply(null,arguments)},i._DenseBincount=function(){return(i._DenseBincount=i.asm.DenseBincount).apply(null,arguments)},i._DepthToSpace=function(){return(i._DepthToSpace=i.asm.DepthToSpace).apply(null,arguments)},i._DepthwiseConv2dNative=function(){return(i._DepthwiseConv2dNative=i.asm.DepthwiseConv2dNative).apply(null,arguments)},i._Diag=function(){return(i._Diag=i.asm.Diag).apply(null,arguments)},i._Dilation2D=function(){return(i._Dilation2D=i.asm.Dilation2D).apply(null,arguments)},i._Dilation2DBackpropFilter=function(){return(i._Dilation2DBackpropFilter=i.asm.Dilation2DBackpropFilter).apply(null,arguments)},i._Dilation2DBackpropInput=function(){return(i._Dilation2DBackpropInput=i.asm.Dilation2DBackpropInput).apply(null,arguments)},i._Elu=function(){return(i._Elu=i.asm.Elu).apply(null,arguments)},i._EluGrad=function(){return(i._EluGrad=i.asm.EluGrad).apply(null,arguments)},i._Equal=function(){return(i._Equal=i.asm.Equal).apply(null,arguments)},i._Erf=function(){return(i._Erf=i.asm.Erf).apply(null,arguments)},i._Exp=function(){return(i._Exp=i.asm.Exp).apply(null,arguments)},i._Expm1=function(){return(i._Expm1=i.asm.Expm1).apply(null,arguments)},i._FlipLeftRight=function(){return(i._FlipLeftRight=i.asm.FlipLeftRight).apply(null,arguments)},i._Floor=function(){return(i._Floor=i.asm.Floor).apply(null,arguments)},i._FloorDiv=function(){return(i._FloorDiv=i.asm.FloorDiv).apply(null,arguments)},i._FusedBatchNorm=function(){return(i._FusedBatchNorm=i.asm.FusedBatchNorm).apply(null,arguments)},i._FusedConv2D=function(){return(i._FusedConv2D=i.asm.FusedConv2D).apply(null,arguments)},i._FusedDepthwiseConv2D=function(){return(i._FusedDepthwiseConv2D=i.asm.FusedDepthwiseConv2D).apply(null,arguments)},i._Gather=function(){return(i._Gather=i.asm.Gather).apply(null,arguments)},i._GatherNd=function(){return(i._GatherNd=i.asm.GatherNd).apply(null,arguments)},i._Greater=function(){return(i._Greater=i.asm.Greater).apply(null,arguments)},i._GreaterEqual=function(){return(i._GreaterEqual=i.asm.GreaterEqual).apply(null,arguments)},i._IsFinite=function(){return(i._IsFinite=i.asm.IsFinite).apply(null,arguments)},i._IsInf=function(){return(i._IsInf=i.asm.IsInf).apply(null,arguments)},i._IsNan=function(){return(i._IsNan=i.asm.IsNan).apply(null,arguments)},i._LRN=function(){return(i._LRN=i.asm.LRN).apply(null,arguments)},i._LRNGrad=function(){return(i._LRNGrad=i.asm.LRNGrad).apply(null,arguments)},i._LeakyRelu=function(){return(i._LeakyRelu=i.asm.LeakyRelu).apply(null,arguments)},i._Less=function(){return(i._Less=i.asm.Less).apply(null,arguments)},i._LessEqual=function(){return(i._LessEqual=i.asm.LessEqual).apply(null,arguments)},i._LinSpace=function(){return(i._LinSpace=i.asm.LinSpace).apply(null,arguments)},i._Log=function(){return(i._Log=i.asm.Log).apply(null,arguments)},i._Log1p=function(){return(i._Log1p=i.asm.Log1p).apply(null,arguments)},i._LogicalAnd=function(){return(i._LogicalAnd=i.asm.LogicalAnd).apply(null,arguments)},i._LogicalNot=function(){return(i._LogicalNot=i.asm.LogicalNot).apply(null,arguments)},i._LogicalOr=function(){return(i._LogicalOr=i.asm.LogicalOr).apply(null,arguments)},i._LogicalXor=function(){return(i._LogicalXor=i.asm.LogicalXor).apply(null,arguments)},i._Max=function(){return(i._Max=i.asm.Max).apply(null,arguments)},i._MaxPool=function(){return(i._MaxPool=i.asm.MaxPool).apply(null,arguments)},i._MaxPool3D=function(){return(i._MaxPool3D=i.asm.MaxPool3D).apply(null,arguments)},i._MaxPool3DGrad=function(){return(i._MaxPool3DGrad=i.asm.MaxPool3DGrad).apply(null,arguments)},i._MaxPoolGrad=function(){return(i._MaxPoolGrad=i.asm.MaxPoolGrad).apply(null,arguments)},i._MaxPoolWithArgmax=function(){return(i._MaxPoolWithArgmax=i.asm.MaxPoolWithArgmax).apply(null,arguments)},i._Maximum=function(){return(i._Maximum=i.asm.Maximum).apply(null,arguments)},i._Mean=function(){return(i._Mean=i.asm.Mean).apply(null,arguments)},i._Min=function(){return(i._Min=i.asm.Min).apply(null,arguments)},i._Minimum=function(){return(i._Minimum=i.asm.Minimum).apply(null,arguments)},i._MirrorPad=function(){return(i._MirrorPad=i.asm.MirrorPad).apply(null,arguments)},i._Mod=function(){return(i._Mod=i.asm.Mod).apply(null,arguments)},i._Multinomial=function(){return(i._Multinomial=i.asm.Multinomial).apply(null,arguments)},i._Multiply=function(){return(i._Multiply=i.asm.Multiply).apply(null,arguments)},i._Neg=function(){return(i._Neg=i.asm.Neg).apply(null,arguments)},i._NonMaxSuppressionV3=function(){return(i._NonMaxSuppressionV3=i.asm.NonMaxSuppressionV3).apply(null,arguments)},i._NonMaxSuppressionV4=function(){return(i._NonMaxSuppressionV4=i.asm.NonMaxSuppressionV4).apply(null,arguments)},i._NonMaxSuppressionV5=function(){return(i._NonMaxSuppressionV5=i.asm.NonMaxSuppressionV5).apply(null,arguments)},i._NotEqual=function(){return(i._NotEqual=i.asm.NotEqual).apply(null,arguments)},i._OneHot=function(){return(i._OneHot=i.asm.OneHot).apply(null,arguments)},i._PadV2=function(){return(i._PadV2=i.asm.PadV2).apply(null,arguments)},i._Pow=function(){return(i._Pow=i.asm.Pow).apply(null,arguments)},i._Prelu=function(){return(i._Prelu=i.asm.Prelu).apply(null,arguments)},i._Prod=function(){return(i._Prod=i.asm.Prod).apply(null,arguments)},i._RealDiv=function(){return(i._RealDiv=i.asm.RealDiv).apply(null,arguments)},i._Reciprocal=function(){return(i._Reciprocal=i.asm.Reciprocal).apply(null,arguments)},i._Relu=function(){return(i._Relu=i.asm.Relu).apply(null,arguments)},i._Relu6=function(){return(i._Relu6=i.asm.Relu6).apply(null,arguments)},i._ResizeBilinear=function(){return(i._ResizeBilinear=i.asm.ResizeBilinear).apply(null,arguments)},i._ResizeBilinearGrad=function(){return(i._ResizeBilinearGrad=i.asm.ResizeBilinearGrad).apply(null,arguments)},i._ResizeNearestNeighbor=function(){return(i._ResizeNearestNeighbor=i.asm.ResizeNearestNeighbor).apply(null,arguments)},i._ResizeNearestNeighborGrad=function(){return(i._ResizeNearestNeighborGrad=i.asm.ResizeNearestNeighborGrad).apply(null,arguments)},i._Reverse=function(){return(i._Reverse=i.asm.Reverse).apply(null,arguments)},i._RotateWithOffset=function(){return(i._RotateWithOffset=i.asm.RotateWithOffset).apply(null,arguments)},i._Round=function(){return(i._Round=i.asm.Round).apply(null,arguments)},i._Rsqrt=function(){return(i._Rsqrt=i.asm.Rsqrt).apply(null,arguments)},i._ScatterNd=function(){return(i._ScatterNd=i.asm.ScatterNd).apply(null,arguments)},i._SearchSorted=function(){return(i._SearchSorted=i.asm.SearchSorted).apply(null,arguments)},i._SelectV2=function(){return(i._SelectV2=i.asm.SelectV2).apply(null,arguments)},i._Selu=function(){return(i._Selu=i.asm.Selu).apply(null,arguments)},i._Sigmoid=function(){return(i._Sigmoid=i.asm.Sigmoid).apply(null,arguments)},i._Sign=function(){return(i._Sign=i.asm.Sign).apply(null,arguments)},i._Sin=function(){return(i._Sin=i.asm.Sin).apply(null,arguments)},i._Sinh=function(){return(i._Sinh=i.asm.Sinh).apply(null,arguments)},i._Softmax=function(){return(i._Softmax=i.asm.Softmax).apply(null,arguments)},i._Softplus=function(){return(i._Softplus=i.asm.Softplus).apply(null,arguments)},i._SparseFillEmptyRows=function(){return(i._SparseFillEmptyRows=i.asm.SparseFillEmptyRows).apply(null,arguments)},i._SparseReshape=function(){return(i._SparseReshape=i.asm.SparseReshape).apply(null,arguments)},i._SparseSegmentReduction=function(){return(i._SparseSegmentReduction=i.asm.SparseSegmentReduction).apply(null,arguments)},i._SparseToDense=function(){return(i._SparseToDense=i.asm.SparseToDense).apply(null,arguments)},i._Sqrt=function(){return(i._Sqrt=i.asm.Sqrt).apply(null,arguments)},i._Square=function(){return(i._Square=i.asm.Square).apply(null,arguments)},i._SquaredDifference=function(){return(i._SquaredDifference=i.asm.SquaredDifference).apply(null,arguments)},i._Step=function(){return(i._Step=i.asm.Step).apply(null,arguments)},i._StridedSlice=function(){return(i._StridedSlice=i.asm.StridedSlice).apply(null,arguments)},i._Sub=function(){return(i._Sub=i.asm.Sub).apply(null,arguments)},i._Sum=function(){return(i._Sum=i.asm.Sum).apply(null,arguments)},i._Tan=function(){return(i._Tan=i.asm.Tan).apply(null,arguments)},i._Tanh=function(){return(i._Tanh=i.asm.Tanh).apply(null,arguments)},i._TensorScatterUpdate=function(){return(i._TensorScatterUpdate=i.asm.TensorScatterUpdate).apply(null,arguments)},i._Tile=function(){return(i._Tile=i.asm.Tile).apply(null,arguments)},i._TopK=function(){return(i._TopK=i.asm.TopK).apply(null,arguments)},i._Transform=function(){return(i._Transform=i.asm.Transform).apply(null,arguments)},i._Transpose=function(){return(i._Transpose=i.asm.Transpose).apply(null,arguments)},i.__FusedMatMul=function(){return(i.__FusedMatMul=i.asm._FusedMatMul).apply(null,arguments)},i._malloc=function(){return(i._malloc=i.asm.malloc).apply(null,arguments)},i._free=function(){return(i._free=i.asm.free).apply(null,arguments)},i.___errno_location=function(){return(i.___errno_location=i.asm.__errno_location).apply(null,arguments)};var X,Y,Q,Z=i.stackSave=function(){return(Z=i.stackSave=i.asm.stackSave).apply(null,arguments)},J=i.stackRestore=function(){return(J=i.stackRestore=i.asm.stackRestore).apply(null,arguments)},ee=i.stackAlloc=function(){return(ee=i.stackAlloc=i.asm.stackAlloc).apply(null,arguments)};function te(e){function t(){X||(X=!0,i.calledRun=!0,!I&&(V(E),n(i),i.onRuntimeInitialized&&i.onRuntimeInitialized(),function(){if(i.postRun)for("function"==typeof i.postRun&&(i.postRun=[i.postRun]);i.postRun.length;)R(i.postRun.shift());V(_)}()))}F>0||(function(){if(i.preRun)for("function"==typeof i.preRun&&(i.preRun=[i.preRun]);i.preRun.length;)A(i.preRun.shift());V($)}(),F>0)||(i.setStatus?(i.setStatus("Running..."),setTimeout((function(){setTimeout((function(){i.setStatus("")}),1),t()}),1)):t())}if(i.dynCall_iijjiiii=function(){return(i.dynCall_iijjiiii=i.asm.dynCall_iijjiiii).apply(null,arguments)},i.dynCall_jiji=function(){return(i.dynCall_jiji=i.asm.dynCall_jiji).apply(null,arguments)},i.cwrap=function(e,t,n,r){var a=(n=n||[]).every((e=>"number"===e||"boolean"===e));return"string"!==t&&a&&!r?G(e):function(){return q(e,t,n,arguments)}},D=function e(){X||te(),X||(D=e)},i.preInit)for("function"==typeof i.preInit&&(i.preInit=[i.preInit]);i.preInit.length>0;)i.preInit.pop()();if(te(),a&&(Y={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!a.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!a.unhandledRejection.indexOf(e)>-1}))}),void 0!==t)Q=t;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");Q=WasmBackendModuleThreadedSimd}if(Y){var ne=Q._dispose;Q._dispose=function(){ne(),Y.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Y.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=n:"function"==typeof define&&define.amd?define([],(function(){return n})):"object"==typeof e&&(e.WasmBackendModule=n)})),Rw=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Fw=class{refCount(e){return Dw("refCount")}incRef(e){return Dw("incRef")}timerAvailable(){return!0}time(e){return Dw("time")}read(e){return Dw("read")}readSync(e){return Dw("readSync")}readToGPU(e,t){return Dw("readToGPU")}numDataIds(){return Dw("numDataIds")}disposeData(e,t){return Dw("disposeData")}write(e,t,n){return Dw("write")}move(e,t,n,r,a){return Dw("move")}createTensorFromGPUData(e,t,n){return Dw("createTensorFromGPUData")}memory(){return Dw("memory")}floatPrecision(){return Dw("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Dw("dispose")}};function Dw(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Mw(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Lw(e,t,n)}function Ow(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,Lw(e,n,r),Lw(t,n,r)}function zw(e,t,n){return Math.max(e,Math.min(t,n))}function Pw(e){return e%2==0?e:e+1}function Lw(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function Bw(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function Ww(e,t){let n=Math.random();return t*n+(1-n)*e}function Vw(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function Uw(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function jw(e,t,n=""){Uw(Xw(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function Hw(e){Uw(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function Gw(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function qw(e){return 0===e.length}function Kw(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function Xw(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Yw(e){return e%1==0}function Qw(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function Zw(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Jw(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return Mw(t),t}function ek(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function tk(e,t=(e=>0),n,r){return new Promise(((a,i)=>{let o=0,s=()=>{if(e())return void a();o++;let l=t(o);null!=n&&o>=n?i():null!=r?r(s,l):setTimeout(s,l)};s()}))}function nk(e,t){let n=1,r=-1;for(let i=0;i<e.length;++i)if(e[i]>=0)n*=e[i];else if(-1===e[i]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(e[i]<0)throw Error(`Shapes can not be < 0. Found ${e[i]} at dim ${i}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function rk(e,t){let n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),Uw(e.every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),Uw(e.every((e=>Yw(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function ak(e,t){let n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||a?null:rk(t,e).sort(),o=0;for(let s=0;s<e.length;++s){if(null!=i){if(i[o]===s&&1!==e[s])throw new Error(`Can't squeeze axis ${s} since its dim '${e[s]}' is not 1`);(null==i[o]||i[o]>s)&&1===e[s]&&(n.push(e[s]),r.push(s)),i[o]<=s&&o++}1!==e[s]&&(n.push(e[s]),r.push(s))}return{newShape:n,keptDims:r}}function ik(e,t){return ok(e,t)}function ok(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function sk(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function lk(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function uk(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function dk(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function ck(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function pk(e){return"string"==typeof e||e instanceof String}function hk(e){return"boolean"==typeof e}function fk(e){return"number"==typeof e}function mk(e){return Array.isArray(e)?mk(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":fk(e)?"float32":pk(e)?"string":hk(e)?"bool":"float32"}function gk(e){return!!(e&&e.constructor&&e.call&&e.apply)}function bk(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function yk(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function vk(e,t,n,r=!1){let a=new Array;if(1===t.length){let i=t[0]*(r?2:1);for(let t=0;t<i;t++)a[t]=n[e+t]}else{let i=t[0],o=t.slice(1),s=o.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<i;t++)a[t]=vk(e+t*s,o,n,r)}return a}function xk(e,t,n=!1){if(0===e.length)return t[0];let r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return vk(0,e,t,n)}function wk(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function kk(e,t){let n=Sk(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Sk(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Ik(e,t){let n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return xk(e,new Float32Array(n));if("int32"===t)return xk(e,new Int32Array(n));if("bool"===t)return xk(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Nk(e){e.forEach((t=>{Uw(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function Ck(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function Tk(e,t,n){if(0===t)return[];if(1===t)return[e];let r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function $k(e){return e&&e.then&&"function"==typeof e.then}var Ek="tfjsflags",_k=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Ak,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(Rk().getBool("IS_TEST")||Rk().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){let t=this.urlFlags[e];Rk().getBool("IS_TEST")||Rk().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if($k(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;let e=this.getQueryParams(this.global.location.search);Ek in e&&e[Ek].split(",").forEach((e=>{let[t,n]=e.split(":");this.urlFlags[t]=function(e,t){let n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}};function Ak(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("=")))),t}function Rk(){return Dk}var Fk,Dk=null;function Mk(){if(null==Fk){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof global)e=global;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}Fk=e}return Fk}function Ok(e,t){let n=function(){let e=Mk();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var zk="Abs",Pk="Acos",Lk="Acosh",Bk="Add",Wk="AddN",Vk="All",Uk="Any",jk="ArgMax",Hk="ArgMin",Gk="Asin",qk="Asinh",Kk="Atan",Xk="Atanh",Yk="Atan2",Qk="AvgPool",Zk="AvgPoolGrad",Jk="AvgPool3D",eS="AvgPool3DGrad",tS="BatchMatMul",nS="BatchToSpaceND",rS="Bincount",aS="BitwiseAnd",iS="BroadcastTo",oS="BroadcastArgs",sS="Cast",lS="Ceil",uS="ClipByValue",dS="Complex",cS="ComplexAbs",pS="Concat",hS="Conv2D",fS="Conv2DBackpropFilter",mS="Conv2DBackpropInput",gS="Conv3D",bS="Conv3DBackpropFilterV2",yS="Conv3DBackpropInputV2",vS="Cos",xS="Cosh",wS="Cumprod",kS="Cumsum",SS="CropAndResize",IS="DenseBincount",NS="DepthToSpace",CS="DepthwiseConv2dNative",TS="DepthwiseConv2dNativeBackpropFilter",$S="DepthwiseConv2dNativeBackpropInput",ES="Diag",_S="Dilation2D",AS="Dilation2DBackpropInput",RS="Dilation2DBackpropFilter",FS="Draw",DS="RealDiv",MS="Einsum",OS="Elu",zS="EluGrad",PS="Erf",LS="Equal",BS="Exp",WS="ExpandDims",VS="Expm1",US="FFT",jS="Fill",HS="FlipLeftRight",GS="Floor",qS="FloorDiv",KS="FusedBatchNorm",XS="GatherV2",YS="GatherNd",QS="Greater",ZS="GreaterEqual",JS="Identity",eI="IFFT",tI="Imag",nI="IsFinite",rI="IsInf",aI="IsNan",iI="LeakyRelu",oI="Less",sI="LessEqual",lI="LinSpace",uI="Log",dI="Log1p",cI="LogicalAnd",pI="LogicalNot",hI="LogicalOr",fI="LogicalXor",mI="LogSoftmax",gI="LowerBound",bI="LRN",yI="LRNGrad",vI="MatrixBandPart",xI="Max",wI="Maximum",kI="MaxPool",SI="MaxPoolGrad",II="MaxPool3D",NI="MaxPool3DGrad",CI="MaxPoolWithArgmax",TI="Mean",$I="Min",EI="Minimum",_I="MirrorPad",AI="Mod",RI="Multinomial",FI="Multiply",DI="Neg",MI="NotEqual",OI="NonMaxSuppressionV3",zI="NonMaxSuppressionV4",PI="NonMaxSuppressionV5",LI="OnesLike",BI="OneHot",WI="Pack",VI="PadV2",UI="Pool",jI="Pow",HI="Prelu",GI="Prod",qI="RaggedGather",KI="RaggedRange",XI="RaggedTensorToTensor",YI="Range",QI="Real",ZI="Reciprocal",JI="Relu",eN="Reshape",tN="ResizeNearestNeighbor",nN="ResizeNearestNeighborGrad",rN="ResizeBilinear",aN="ResizeBilinearGrad",iN="Relu6",oN="Reverse",sN="Round",lN="Rsqrt",uN="ScatterNd",dN="TensorScatterUpdate",cN="SearchSorted",pN="Select",hN="Selu",fN="Slice",mN="Sin",gN="Sinh",bN="Sign",yN="Sigmoid",vN="Softplus",xN="Sqrt",wN="Sum",kN="SpaceToBatchND",SN="SplitV",IN="Softmax",NN="SparseFillEmptyRows",CN="SparseReshape",TN="SparseSegmentMean",$N="SparseSegmentSum",EN="SparseToDense",_N="SquaredDifference",AN="Square",RN="StaticRegexReplace",FN="StridedSlice",DN="StringNGrams",MN="StringSplit",ON="StringToHashBucketFast",zN="Sub",PN="Tan",LN="Tanh",BN="Tile",WN="TopK",VN="Transform",UN="Transpose",jN="Unique",HN="Unpack",GN="UnsortedSegmentSum",qN="UpperBound",KN="ZerosLike",XN="Step",YN="FromPixels",QN="RotateWithOffset",ZN="_FusedMatMul",JN="FusedConv2D",eC="FusedDepthwiseConv2D";function tC(...e){Rk().getBool("IS_TEST")||Rk().getBool("PROD")||console.warn(...e)}function nC(...e){Rk().getBool("IS_TEST")||Rk().getBool("PROD")||console.log(...e)}var rC=Ok("kernelRegistry",(()=>new Map)),aC=Ok("gradRegistry",(()=>new Map));function iC(e,t){let n=hC(e,t);return rC.get(n)}function oC(e){return aC.get(e)}function sC(e){let t=rC.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[i,o]=a,[s]=i.split("_");s===e&&n.push(o)}return n}function lC(e){let{kernelName:t,backendName:n}=e,r=hC(t,n);rC.has(r)&&tC(`The kernel '${t}' for backend '${n}' is already registered`),rC.set(r,e)}function uC(e){let{kernelName:t}=e;aC.has(t)&&Rk().getBool("DEBUG")&&tC(`Overriding the gradient for '${t}'`),aC.set(t,e)}function dC(e,t){let n=hC(e,t);if(!rC.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);rC.delete(n)}function cC(e){if(!aC.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);aC.delete(e)}function pC(e,t){sC(e).forEach((e=>{lC(Object.assign({},e,{backendName:t}))}))}function hC(e,t){return`${t}_${e}`}var fC={};function mC(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}uw(fC,{arraysEqual:()=>Xw,arraysEqualWithNull:()=>Kw,assert:()=>Uw,assertNonNegativeIntegerDimensions:()=>Nk,assertNonNull:()=>Hw,assertShapesMatch:()=>jw,bytesFromStringArray:()=>ck,bytesPerElement:()=>dk,checkConversionForErrors:()=>sk,clamp:()=>zw,computeStrides:()=>yk,convertBackendValuesAndArrayBuffer:()=>wk,createScalarValue:()=>_C,createShuffledIndices:()=>Jw,decodeString:()=>MC,distSquared:()=>Vw,encodeString:()=>DC,fetch:()=>FC,fingerPrint64:()=>EC,flatten:()=>zC,getArrayFromDType:()=>ok,getTypedArrayFromDType:()=>ik,hasEncodingLoss:()=>uk,hexToLong:()=>yC,indexToLoc:()=>Tk,inferDtype:()=>mk,inferFromImplicitShape:()=>nk,isBoolean:()=>hk,isFunction:()=>gk,isInt:()=>Yw,isNumber:()=>fk,isPromise:()=>$k,isScalarShape:()=>qw,isString:()=>pk,isTypedArray:()=>OC,isValidDtype:()=>lk,locToIndex:()=>Ck,makeOnesTypedArray:()=>kk,makeZerosNestedTypedArray:()=>Ik,makeZerosTypedArray:()=>Sk,nearestDivisor:()=>bk,nearestLargerEven:()=>Pw,now:()=>RC,parseAxisParam:()=>rk,randUniform:()=>Ww,repeatedTry:()=>tk,rightPad:()=>ek,shuffle:()=>Mw,shuffleCombo:()=>Ow,sizeFromShape:()=>Gw,sizeToSquarishShape:()=>Zw,squeezeShape:()=>ak,sum:()=>Bw,swap:()=>Lw,tanh:()=>Qw,toNestedArray:()=>xk,toTypedArray:()=>AC});var gC=dw(cw()),bC=gC.default||gC;function yC(e){return bC.fromString(e,!0,16)}var vC=yC("c3a5c85c97cb3127"),xC=yC("b492b66fbe98f273"),wC=yC("9ae16a3b2f90404f");function kC(e){return e.xor(e.shru(47))}function SC(e,t,n){let r=e.slice(t,t+n);return bC.fromBytes(Array.from(r),!0,!0)}function IC(e,t){return SC(e,t,8)}function NC(e,t){return SC(e,t,4)}function CC(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function TC(e,t,n=yC("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function $C(e,t,n,r){return function(e,t,n,r,a,i){a=a.add(e),i=CC(i.add(a).add(r),21);let o=a;return a=(a=a.add(t)).add(n),i=i.add(CC(a,44)),[a.add(r),i.add(o)]}(IC(e,t),IC(e,t+8),IC(e,t+16),IC(e,t+24),n,r)}function EC(e,t=e.length){let n=bC.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){let n=wC.add(2*t),r=IC(e,0).add(wC),a=IC(e,t-8);return TC(CC(a,37).mul(n).add(r),CC(r,25).add(a).mul(n),n)}if(t>=4){let n=wC.add(2*t);return TC(NC(e,0).shl(3).add(t),NC(e,t-4),n)}if(t>0){let n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return kC(wC.mul(n).xor(vC.mul(r))).mul(wC)}return wC}(e,t):function(e,t=e.length){let n=wC.add(2*t),r=IC(e,0).mul(xC),a=IC(e,8),i=IC(e,t-8).mul(n),o=IC(e,t-16).mul(wC);return TC(CC(r.add(a),43).add(CC(i,30)).add(o),r.add(CC(a.add(wC),18)).add(i),n)}(e,t);if(t<=64)return function(e,t=e.length){let n=wC.add(2*t),r=IC(e,0).mul(wC),a=IC(e,8),i=IC(e,t-8).mul(n),o=IC(e,t-16).mul(wC),s=CC(r.add(a),43).add(CC(i,30)).add(o),l=TC(s,r.add(CC(a.add(wC),18)).add(i),n),u=IC(e,16).mul(n),d=IC(e,24),c=s.add(IC(e,t-32)).mul(n),p=l.add(IC(e,t-24)).mul(n);return TC(CC(u.add(d),43).add(CC(c,30)).add(p),u.add(CC(d.add(r),18)).add(c),n)}(e,t);let r=n,a=n.mul(xC).add(113),i=kC(a.mul(wC).add(113)).mul(wC),o=[bC.UZERO,bC.UZERO],s=[bC.UZERO,bC.UZERO];r=r.mul(wC).add(IC(e,0));let l=0,u=64*(t-1>>6),d=u+(t-1&63)-63;do{r=CC(r.add(a).add(o[0]).add(IC(e,l+8)),37).mul(xC),a=CC(a.add(o[1]).add(IC(e,l+48)),42).mul(xC),r=r.xor(s[1]),a=a.add(o[0]).add(IC(e,l+40)),i=CC(i.add(s[0]),33).mul(xC),o=$C(e,l,o[1].mul(xC),r.add(s[0])),s=$C(e,l+32,i.add(s[1]),a.add(IC(e,l+16))),[i,r]=[r,i],l+=64}while(l!==u);let c=xC.add(i.and(255).shl(1));return l=d,s[0]=s[0].add(t-1&63),o[0]=o[0].add(s[0]),s[0]=s[0].add(o[0]),r=CC(r.add(a).add(o[0]).add(IC(e,l+8)),37).mul(c),a=CC(a.add(o[1]).add(IC(e,l+48)),42).mul(c),r=r.xor(s[1].mul(9)),a=a.add(o[0].mul(9).add(IC(e,l+40))),i=CC(i.add(s[0]),33).mul(c),o=$C(e,l,o[1].mul(c),r.add(s[0])),s=$C(e,l+32,i.add(s[1]),a.add(IC(e,l+16))),[i,r]=[r,i],TC(TC(o[0],s[0],c).add(kC(a).mul(vC)).add(i),TC(o[1],s[1],c).add(r),c)}function _C(e,t){return"string"===t?DC(e):AC([e],t)}function AC(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=zC(e)),Rk().getBool("DEBUG")&&sk(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function RC(){return Rk().platform.now()}function FC(e,t){return Rk().platform.fetch(e,t)}function DC(e,t="utf-8"){return t=t||"utf-8",Rk().platform.encode(e,t)}function MC(e,t="utf-8"){return t=t||"utf-8",Rk().platform.decode(e,t)}function OC(e){return null!=Rk().platform.isTypedArray?Rk().platform.isTypedArray(e):mC(e)}function zC(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||$k(e)||null==e||OC(e)&&n)t.push(e);else if(Array.isArray(e)||OC(e))for(let r=0;r<e.length;++r)zC(e[r],t,n);else{let r=-1;for(let t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let a=0;a<=r;a++)zC(e[a],t,n)}return t}function PC(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){let t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}var LC=class{logKernelProfile(e,t,n,r,a,i){let o="number"==typeof r?ek(`${r}ms`,9):r.error,s=ek(e,25),l=t.rank,u=t.size,d=ek(t.shape.toString(),14),c="";for(let p in a){let e=a[p];if(null!=e){let n=e.shape||t.shape,r=n.length;c+=`${p}: ${r}D ${r>0?n:""} `}}console.log(`%c${s}\t%c${o}\t%c${l}D ${d}\t%c${u}\t%c${c}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}},BC=20,WC=3,VC=7;function UC(e,t,n,r){let a=yk(t),i=function(e,t,n,r){let a=Gw(t),i=r[r.length-1],o=new Array(i).fill(0),s=t.length,l="complex64"===n?qC(e):e;if(s>1)for(let u=0;u<a/i;u++){let e=u*i;for(let t=0;t<i;t++)o[t]=Math.max(o[t],jC(l[e+t],0,n).length)}return o}(e,t,n,a),o=t.length,s=GC(e,t,n,a,i),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(s.map((e=>"    "+e)).join("\n")),l.join("\n")}function jC(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(VC))} + ${parseFloat(e[1].toFixed(VC))}j`:pk(e)?`'${e}'`:"bool"===n?HC(e):parseFloat(e.toFixed(VC)).toString(),ek(r,t)}function HC(e){return 0===e?"false":"true"}function GC(e,t,n,r,a,i=!0){let o="complex64"===n?2:1,s=t[0],l=t.length;if(0===l)return"complex64"===n?[jC(qC(e)[0],0,n)]:"bool"===n?[HC(e[0])]:[e[0].toString()];if(1===l){if(s>BC){let t=WC*o,r=Array.from(e.slice(0,t)),i=Array.from(e.slice((s-WC)*o,s*o));return"complex64"===n&&(r=qC(r),i=qC(i)),["["+r.map(((e,t)=>jC(e,a[t],n))).join(", ")+", ..., "+i.map(((e,t)=>jC(e,a[s-WC+t],n))).join(", ")+"]"]}return["["+("complex64"===n?qC(e):Array.from(e)).map(((e,t)=>jC(e,a[t],n))).join(", ")+"]"]}let u=t.slice(1),d=r.slice(1),c=r[0]*o,p=[];if(s>BC){for(let t=0;t<WC;t++){let r=t*c,i=r+c;p.push(...GC(e.slice(r,i),u,n,d,a,!1))}p.push("...");for(let t=s-WC;t<s;t++){let r=t*c,i=r+c;p.push(...GC(e.slice(r,i),u,n,d,a,t===s-1))}}else for(let m=0;m<s;m++){let t=m*c,r=t+c;p.push(...GC(e.slice(t,r),u,n,d,a,m===s-1))}let h=2===l?",":"";p[0]="["+(s>0?p[0]+h:"");for(let m=1;m<p.length-1;m++)p[m]=" "+p[m]+h;let f=",\n";for(let m=2;m<l;m++)f+="\n";return p[p.length-1]=" "+p[p.length-1]+"]"+(i?"":f),p}function qC(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var KC=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Gw(e),null!=n){let e=n.length;Uw(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||ok(t,this.size),this.strides=yk(e)}set(e,...t){0===t.length&&(t=[0]),Uw(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));let n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return XC().makeTensor(this.values,this.shape,this.dtype)}},XC=null,YC=null,QC=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Gw(e),this.strides=yk(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return YC.buffer(this.shape,this.dtype,e)}bufferSync(){return YC.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return xk(this.shape,e,"complex64"===this.dtype)}arraySync(){return xk(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let e=XC().read(this.dataId);if("string"===this.dtype){let t=await e;try{return t.map((e=>MC(e)))}catch(Ep){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),XC().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=XC().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>MC(e)))}catch(Fp){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await XC().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(XC().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return YC.print(this,e)}clone(){return this.throwIfDisposed(),YC.clone(this)}toString(e=!1){return UC(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),YC.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),XC().makeVariable(this,e,t,n)}};function ZC(){return Ok("Tensor",(()=>QC))}Object.defineProperty(QC,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),ZC();var JC=class extends QC{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Xw(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);XC().disposeTensor(this),this.dataId=e.dataId,XC().incRef(this,null)}dispose(){XC().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(JC,Symbol.hasInstance,{value:e=>e instanceof QC&&null!=e.assign&&e.assign instanceof Function});var eT,tT,nT,rT,aT,iT={};uw(iT,{assertTypesMatch:()=>pT,getTensorsInContainer:()=>fT,isTensorInList:()=>hT,makeTypesMatch:()=>cT}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(eT||(eT={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(tT||(tT={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(nT||(nT={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(rT||(rT={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(aT||(aT={}));var oT={float32:rT,int32:tT,bool:nT,complex64:aT};function sT(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return oT[e][t]}function lT(e){return sT(e,"int32")}function uT(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function dT(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function cT(e,t){if(e.dtype===t.dtype)return[e,t];let n=sT(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function pT(e,t){Uw(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function hT(e,t){return t.some((t=>t.id===e.id))}function fT(e){let t=[];return mT(e,t,new Set),t}function mT(e,t,n){if(null==e)return;if(e instanceof QC)return void t.push(e);if(!function(e){return Array.isArray(e)||"object"==typeof e}(e))return;let r=e;for(let a in r){let e=r[a];n.has(e)||(n.add(e),mT(e,t,n))}}function gT(e){return null!=e.kernelName}var bT=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},yT=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new bT}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success)return void(await this.setBackend(n))}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{let{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(tC(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new class{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new LC)}profileKernel(e,t,n){let r,a,i=()=>{r=n()},o=RC();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(i);else{i();for(let e of r)e.dataSync();a=Promise.resolve({kernelMs:RC()-o})}if(Rk().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let s=0;s<r.length;s++){let t=r[s];t.data().then((n=>{PC(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:i}=e;n.forEach((e=>{Promise.all([e.data(),r,i]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}}(this.backendInstance),!0}setupRegisteredKernels(){sC(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){sC(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){let t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(!n||n instanceof Fw||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{let t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0)))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,tC(`Initialization of backend ${e} failed`),tC(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(Ep){return tC(`Initialization of backend ${e} failed`),tC(Ep.stack||Ep.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),i=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{let e=n();return t(),e}catch(ut){throw t(),ut}}nextTensorId(){return yT.nextTensorId++}nextVariableId(){return yT.nextVariableId++}clone(e){let t=xT.runKernel(JS,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{let t={x:e},n={dtype:"float32"};return xT.runKernel(sS,t,n)}})),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==iC(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-t-a-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,n,r=[],a=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let s,l=gT(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(gT(e)){let{kernelName:t,inputs:i,attrs:o}=e;null==this.backendName&&this.backend;let l=iC(t,this.backendName);Uw(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),n=()=>{let e=this.backend.numDataIds();s=l.kernelFunc({inputs:i,attrs:o,backend:this.backend});let n=Array.isArray(s)?s:[s];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,n);let u=n.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){let e=this.getTensorsForGradient(t,i,u);r=this.saveTensorsForBackwardMode(e)}return u}}else{let{forwardFunc:t}=e,i=e=>{a&&(r=e.map((e=>this.keep(this.clone(e)))))};n=()=>{let e=this.backend.numDataIds();s=this.tidy((()=>t(this.backend,i)));let n=Array.isArray(s)?s:[s];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}let u,{inputs:d,attrs:c}=e,p=gT(e)?null:e.backwardsFunc;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(u=this.profiler.profileKernel(l,d,(()=>n())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(u),t=u.outputs):t=n()})),a&&this.addTapeNode(l,d,t,p,r,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map((e=>null!=d[e]?d[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:u.timeMs,extraInfo:u.extraInfo}),Array.isArray(s)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){let r=oC(e);if(null!=r){let e,a=r.inputsToSave||[],i=r.outputsToSave||[];r.saveAllInputs?(Uw(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),e=Object.keys(t).map((e=>t[e]))):e=a.map((e=>t[e]));let o=n.filter(((e,t)=>i[t]));return e.concat(o)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&pk(e[0])&&(a=e.map((e=>DC(e))));let i=r.write(a,t,n),o=new QC(t,n,i,this.nextTensorId());if(this.trackTensor(o,r),"string"===n){let e=this.state.tensorInfo.get(i),t=ck(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return o}makeTensorFromDataId(e,t,n,r){let a={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:r,dtype:a}=e,i=new QC(r,a,n,this.nextTensorId());return this.trackTensor(i,t),i}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));let a=new JC(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*dk(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof JC||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){let t=e.size*dk(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,i){let o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},s=oC(e);null!=s&&(r=s.gradFunc),null!=r&&(o.gradient=e=>(e=e.map(((e,t)=>{if(null==e){let e=n[t],r=Sk(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,i))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=fT(e),n=new Set(t.map((e=>e.id)));for(let a=0;a<this.state.activeScope.track.length;a++){let e=this.state.activeScope.track[a];!e.kept&&!n.has(e.id)&&e.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{!e.kept&&e.scopeId===r.id&&this.track(e)}))}gradients(e,t,n,r=!1){if(Uw(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Uw(a instanceof QC,(()=>"The result y returned by f() must be a tensor."));let i=function(e,t,n){let r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let n=e[l],i=n.inputs;for(let e in i){let o=i[e],s=!1;for(let e=0;e<t.length;e++)if(r[o.id]){n.outputs.forEach((e=>r[e.id]=!0)),s=!0,a[n.id]=!0;break}if(s)break}}let i={};i[n.id]=!0;let o={};for(let l=e.length-1;l>=0;l--){let t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(i[t.outputs[e].id]){for(let e in n)i[n[e].id]=!0,o[t.id]=!0;break}}let s=[];for(let l=0;l<e.length;l++){let t=e[l];if(a[t.id]&&o[t.id]){let e={};for(let a in t.inputs){let n=t.inputs[a];r[n.id]&&(e[a]=n)}let n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,s.push(n)}}return s}(this.state.activeTape,t,a);if(!r&&0===i.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{let e={};e[a.id]=null==n?function(e){let t=kk(Gw(e),"float32");return xT.makeTensor(t,e,"float32")}(a.shape):n,function(e,t,n,r){for(let a=t.length-1;a>=0;a--){let i=t[a],o=[];if(i.outputs.forEach((t=>{let n=e[t.id];null!=n?o.push(n):o.push(null)})),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);let s=i.gradient(o);for(let t in i.inputs){if(!(t in s))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(s)}.`);let a=n((()=>s[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);let o=i.inputs[t];if(!Xw(a.shape,o.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${o.shape}'`);if(null==e[o.id])e[o.id]=a;else{let t=e[o.id];e[o.id]=r(t,a),t.dispose()}}}}(e,i,(e=>this.tidy(e)),wT);let r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(let t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){return Uw(gk(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{Uw(t.every((e=>e instanceof QC)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));let n,r={};return t.forEach(((e,t)=>{r[t]=e})),this.runKernelFunc({forwardFunc:(r,a)=>(n=e(...t,a),Uw(n.value instanceof QC,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Uw(gk(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,r)=>{let a=n.gradFunc(e,r),i=Array.isArray(a)?a:[a];Uw(i.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Uw(i.every((e=>e instanceof QC)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));let o={};return i.forEach(((e,t)=>{o[t]=()=>e})),o},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=RC(),n=await this.backend.time(e);return n.wallMs=RC()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new bT;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};function vT(){let e=Mk();if(null==e._tfengine){let t=new _k(e);e._tfengine=new yT(t)}return function(e){Dk=e}(e._tfengine.ENV),function(e){XC=e}((()=>e._tfengine)),e._tfengine}yT.nextTensorId=0,yT.nextVariableId=0;var xT=vT();function wT(e,t){let n={a:e,b:t};return xT.runKernel(Bk,n)}var kT,ST={};function IT(e){kT=e}function NT(e){if(void 0!==kT)return kT;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function CT(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}uw(ST,{isBrowser:()=>CT,isMobile:()=>NT,mockIsMobile:()=>IT});var TT=Rk();function $T(e,t){let n=e;if(OC(e))return"string"===t?[]:[e.length];if(uT(e)){let t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(dT(e))return[e.buffer.size/(null==t?4:dk(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||OC(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&Rk().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ET(e,r,[]),r}function ET(e,t,n){if(n=n||[],!Array.isArray(e)&&!OC(e))return void Uw(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));Uw(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),Uw(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));let r=t.slice(1);for(let a=0;a<e.length;++a)ET(e[a],r,n.concat(a))}function _T(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function AT(e,t,n,r="numeric"){if(e instanceof QC)return _T(r,e.dtype,t,n),e;let a=mk(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),_T(r,a,t,n),null==e||!OC(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){let r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}let i=$T(e,a);!OC(e)&&!Array.isArray(e)&&(e=[e]);let o="string"!==a?AC(e,a):zC(e,[],!0);return xT.makeTensor(o,i,a)}function RT(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,a)=>AT(e,`${t}[${a}]`,n,r)))}TT.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),TT.registerFlag("IS_BROWSER",(()=>CT())),TT.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),TT.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),TT.registerFlag("IS_SAFARI",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),TT.registerFlag("PROD",(()=>!1)),TT.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>TT.getBool("DEBUG"))),TT.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),TT.registerFlag("IS_TEST",(()=>!1)),TT.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>TT.getBool("DEBUG"))),TT.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),TT.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),TT.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));var FT="__op";function DT(e){let t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=FT;let a=(...e)=>{xT.startScope(n);try{let t=r(...e);return $k(t)&&console.error("Cannot return a Promise inside of tidy."),xT.endScope(t),t}catch(t){throw xT.endScope(null),t}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}var MT=DT({complex_:function(e,t){let n=AT(e,"real","complex"),r=AT(t,"imag","complex");jw(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let a={real:n,imag:r};return xT.runKernel(dS,a)}});function OT(e,t,n,r){if(null==r)r=mk(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(dT(e)||uT(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return xT.backend.createTensorFromGPUData(e,t||n,r)}if(!OC(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Nk(t);let e=Gw(t),r=Gw(n);Uw(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let a=0;a<n.length;++a){let e=n[a],r=a!==n.length-1||e!==Gw(t.slice(a));Uw(n[a]===t[a]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return!OC(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e="string"!==r?AC(e,r):zC(e,[],!0),xT.makeTensor(e,t,r)}function zT(e,t,n){return OT(e,t,$T(e,n),n)}var PT={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},LT=class{static join(e){return new LT(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e||(e instanceof Array||(e=[e]),e=e.map((e=>OC(e)?e.buffer:e)),0===e.length))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){let r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let a=t+r.byteLength;this.shards.push({buffer:r,start:t,end:a}),t=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),(t=Math.min(this.byteLength,t))<=e)return new ArrayBuffer(0);let n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);let r=new ArrayBuffer(t-e),a=new Uint8Array(r),i=0;for(let o=n;o<this.shards.length;o++){let n=this.shards[o],r=e+i-n.start,s=i,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,r,l-r);if(a.set(u,s),i+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;let n=function(e,t){let n=0,r=e.length;for(;n<=r;){let a=Math.floor((r-n)/2)+n,i=t(e[a]);if(0===i)return a;i<0?r=a:n=a+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}},BT=4;async function WT(e,t){let n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let i=0;i<a.length;++i){let o=a[i],s=Array.isArray(e)?e[i].tensor:e[o];if("float32"!==s.dtype&&"int32"!==s.dtype&&"bool"!==s.dtype&&"string"!==s.dtype&&"complex64"!==s.dtype)throw new Error(`Unsupported dtype in weight '${o}': ${s.dtype}`);let l={name:o,shape:s.shape,dtype:s.dtype};if("string"===s.dtype){let e=new Promise((async e=>{let t=await s.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+BT*t.length,r=new Uint8Array(n),a=0;for(let i=0;i<t.length;i++){let e=t[i],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,a),a+=BT,r.set(e,a),a+=e.length}e(r)}));r.push(e)}else r.push(s.data());null!=t&&(l.group=t),n.push(l)}return{data:UT(await Promise.all(r)),specs:n}}function VT(e,t){let n,r=new LT(e),a={},i=0;for(let o of t){let e,t=o.name,s=o.dtype,l=o.shape,u=Gw(l);if("quantization"in o){let a=o.quantization;if("uint8"===a.dtype||"uint16"===a.dtype){if(!("min"in a)||!("scale"in a))throw new Error(`Weight ${o.name} with quantization ${a.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==a.dtype)throw new Error(`Weight ${o.name} has unknown quantization dtype ${a.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==s)throw new Error(`Weight ${o.name} is quantized with ${a.dtype} which only supports weights of type float32 not ${s}.`)}let l=PT[a.dtype],d=r.slice(i,i+u*l),c="uint8"===a.dtype?new Uint8Array(d):new Uint16Array(d);if("float32"===s)if("uint8"===a.dtype||"uint16"===a.dtype){e=new Float32Array(c.length);for(let t=0;t<c.length;t++){let n=c[t];e[t]=n*a.scale+a.min}}else{if("float16"!==a.dtype)throw new Error(`Unsupported quantization type ${a.dtype} for weight type float32.`);void 0===n&&(n=JT()),e=n(c)}else{if("int32"!==s)throw new Error(`Unsupported dtype in weight '${t}': ${s}`);if("uint8"!==a.dtype&&"uint16"!==a.dtype)throw new Error(`Unsupported quantization type ${a.dtype} for weight type int32.`);e=new Int32Array(c.length);for(let t=0;t<c.length;t++){let n=c[t];e[t]=Math.round(n*a.scale+a.min)}}i+=u*l}else if("string"===s){let t=Gw(o.shape);e=[];for(let n=0;n<t;n++){let t=new Uint32Array(r.slice(i,i+BT))[0];i+=BT;let n=new Uint8Array(r.slice(i,i+t));e.push(n),i+=t}}else{let n=PT[s],o=r.slice(i,i+u*n);if("float32"===s)e=new Float32Array(o);else if("int32"===s)e=new Int32Array(o);else if("bool"===s)e=new Uint8Array(o);else{if("complex64"!==s)throw new Error(`Unsupported dtype in weight '${t}': ${s}`);{e=new Float32Array(o);let n=new Float32Array(e.length/2),r=new Float32Array(e.length/2);for(let t=0;t<n.length;t++)n[t]=e[2*t],r[t]=e[2*t+1];let i=zT(n,l,"float32"),s=zT(r,l,"float32");a[t]=MT(i,s),i.dispose(),s.dispose()}}i+=u*n}"complex64"!==s&&(a[t]=zT(e,l,s))}return a}function UT(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));let r=new Uint8Array(t),a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}var jT="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function HT(e){return jT?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function GT(e){return LT.join(e)}function qT(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);let t=e.split("/");return t[t.length-1]}function KT(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function XT(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function YT(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),XT(e,n,r)}function QT(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:HT(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:HT(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new LT(e.weightData).byteLength}}function ZT(e){let t=[];for(let n of e)t.push(...n.weights);return t}function JT(){let e=function(){let e=e=>{let t=e<<13,n=0;for(;!(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{let a=new ArrayBuffer(4*r.length),i=new Uint32Array(a);for(let o=0;o<r.length;o++){let a=r[o],s=e[n[a>>10]+(1023&a)]+t[a>>10];i[o]=s}return new Float32Array(a)}}var e$=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==e$.instance&&(e$.instance=new e$),e$.instance}static registerSaveRouter(e){e$.getInstance().saveRouters.push(e)}static registerLoadRouter(e){e$.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return e$.getHandlers(e,"save")}static getLoadHandlers(e,t){return e$.getHandlers(e,"load",t)}static getHandlers(e,t,n){let r=[];return("load"===t?e$.getInstance().loadRouters:e$.getInstance().saveRouters).forEach((t=>{let a=t(e,n);null!==a&&r.push(a)})),r}},t$=e=>e$.registerSaveRouter(e),n$=e=>e$.registerLoadRouter(e),r$=e=>e$.getSaveHandlers(e),a$=(e,t)=>e$.getLoadHandlers(e,t),i$="tensorflowjs",o$="models_store",s$="model_info_store";function l$(){if(!Rk().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function u$(e){let t=e.result;t.createObjectStore(o$,{keyPath:"modelPath"}),t.createObjectStore(s$,{keyPath:"modelPath"})}var d$=class{constructor(e){if(this.indexedDB=l$(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{let r=this.indexedDB.open(i$,1);r.onupgradeneeded=()=>u$(r),r.onsuccess=()=>{let a=r.result;if(null==t){let t=a.transaction(o$,"readonly"),r=t.objectStore(o$).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{t.weightData=LT.join(t.weightData);let r,i,o=QT(t),s=a.transaction(s$,"readwrite"),l=s.objectStore(s$);try{r=l.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(wp){return n(wp)}r.onsuccess=()=>{i=a.transaction(o$,"readwrite");let r,u=i.objectStore(o$);try{r=u.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(hy){return n(hy)}r.onsuccess=()=>e({modelArtifactsInfo:o}),r.onerror=e=>{l=s.objectStore(s$);let t=l.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(r.error)),t.onerror=e=>(a.close(),n(r.error))}},r.onerror=e=>(a.close(),n(r.error)),s.oncomplete=()=>{null==i?a.close():i.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}};d$.URL_SCHEME="indexeddb://";var c$=e=>Rk().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(d$.URL_SCHEME)?function(e){return new d$(e)}(e.slice(d$.URL_SCHEME.length)):null;e$.registerSaveRouter(c$),e$.registerLoadRouter(c$);var p$="/",h$="tensorflowjs_models",f$="info",m$="model_topology",g$="weight_specs",b$="weight_data",y$="model_metadata";function v$(e){return{info:[h$,e,f$].join(p$),topology:[h$,e,m$].join(p$),weightSpecs:[h$,e,g$].join(p$),weightData:[h$,e,b$].join(p$),modelMetadata:[h$,e,y$].join(p$)}}function x$(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function w$(e){let t=e.split(p$);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(p$)}var k$=class{constructor(e){if(!Rk().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=v$(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=QT(e),i=LT.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(e){if(jT)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(i));let t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:a}}catch(t){throw x$(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){let e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}let i=this.LS.getItem(this.keys.weightData);if(null==i)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(jT){let t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(i),t}};k$.URL_SCHEME="localstorage://";var S$=e=>Rk().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(k$.URL_SCHEME)?function(e){return new k$(e)}(e.slice(k$.URL_SCHEME.length)):null;e$.registerSaveRouter(S$),e$.registerLoadRouter(S$);var I$="://",N$=class{constructor(){this.managers={}}static getInstance(){return null==N$.instance&&(N$.instance=new N$),N$.instance}static registerManager(e,t){Uw(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(I$)&&(e=e.slice(0,e.indexOf(I$))),Uw(e.length>0,(()=>"scheme must not be an empty string."));let n=N$.getInstance();Uw(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){let t=N$.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(N$.getInstance().managers)}};function C$(e){if(-1===e.indexOf(I$))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${N$.getSchemes().join(",")}`);return{scheme:e.split(I$)[0],path:e.split(I$)[1]}}async function T$(e,t,n=!1){Uw(e!==t,(()=>`Old path and new path are the same: '${e}'`));let r=e$.getLoadHandlers(e);Uw(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),Uw(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));let a=r[0],i=e$.getSaveHandlers(t);Uw(i.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),Uw(i.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));let o=i[0],s=C$(e).scheme,l=C$(e).path,u=s===C$(e).scheme,d=await a.load();n&&u&&await N$.getManager(s).removeModel(l);let c=await o.save(d);return n&&!u&&await N$.getManager(s).removeModel(l),c.modelArtifactsInfo}async function $$(){let e=N$.getSchemes(),t={};for(let n of e){let e=await N$.getManager(n).listModels();for(let r in e)t[n+I$+r]=e[r]}return t}async function E$(e){let t=C$(e);return N$.getManager(t.scheme).removeModel(t.path)}async function _$(e,t){return T$(e,t,!1)}async function A$(e,t){return T$(e,t,!0)}if(Rk().get("IS_BROWSER")){Rk().setPlatform("browser",new class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&Rk().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))}),!0))):setTimeout(e,t)}isTypedArray(e){return mC(e)}});try{N$.registerManager(k$.URL_SCHEME,new class{constructor(){Uw(Rk().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Uw("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){let e={},t=h$+p$,n=p$+f$;for(let r=0;r<this.LS.length;++r){let a=this.LS.key(r);a.startsWith(t)&&a.endsWith(n)&&(e[w$(a)]=JSON.parse(this.LS.getItem(a)))}return e}async removeModel(e){let t=v$(e=function(e){return e.startsWith(k$.URL_SCHEME)?e.slice(k$.URL_SCHEME.length):e}(e));if(null==this.LS.getItem(t.info))throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return x$(t),n}})}catch(kp){}try{N$.registerManager(d$.URL_SCHEME,new class{constructor(){this.indexedDB=l$()}async listModels(){return new Promise(((e,t)=>{let n=this.indexedDB.open(i$,1);n.onupgradeneeded=()=>u$(n),n.onsuccess=()=>{let r=n.result,a=r.transaction(s$,"readonly"),i=a.objectStore(s$).getAll();i.onsuccess=()=>{let t={};for(let e of i.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},i.onerror=e=>(r.close(),t(i.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){return e=function(e){return e.startsWith(d$.URL_SCHEME)?e.slice(d$.URL_SCHEME.length):e}(e),new Promise(((t,n)=>{let r=this.indexedDB.open(i$,1);r.onupgradeneeded=()=>u$(r),r.onsuccess=()=>{let a,i=r.result,o=i.transaction(s$,"readwrite"),s=o.objectStore(s$),l=s.get(e);l.onsuccess=()=>{if(null==l.result)return i.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let r=s.delete(e),o=()=>{a=i.transaction(o$,"readwrite");let r=a.objectStore(o$).delete(e);r.onsuccess=()=>t(l.result.modelArtifactsInfo),r.onerror=e=>n(l.error)};r.onsuccess=o,r.onerror=e=>(o(),i.close(),n(l.error))}},l.onerror=e=>(i.close(),n(l.error)),o.oncomplete=()=>{null==a?i.close():a.oncomplete=()=>i.close()}},r.onerror=e=>n(r.error)}))}})}catch(kp){}}var R$,F$=()=>pw();function D$(e,t="float32",n){return t=t||"float32",Nk(e),new KC(e,t,n)}Rk().get("IS_NODE")&&!Rk().get("IS_BROWSER")&&Rk().setPlatform("node",new class{constructor(){this.util=hw(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=Rk().global.fetch?Rk().global.fetch(e,t):(null==R$&&(R$=F$()),R$(e,t))}now(){let e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});var M$=DT({cast_:function(e,t){let n=AT(e,"x","cast");if(!lk(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");let r={x:n},a={dtype:t};return xT.runKernel(sS,r,a)}}),O$=DT({clone_:function(e){let t={x:AT(e,"x","clone","string_or_numeric")};return xT.runKernel(JS,t)}});function z$(e,t=!1){console.log(e.toString(t))}function P$(){Rk().set("PROD",!0)}function L$(){Rk().set("DEBUG",!0)}function B$(){Rk().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function W$(e){Rk().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function V$(){xT.disposeVariables()}function U$(){return xT}function j$(){return xT.memory()}function H$(e){return xT.profile(e)}function G$(e,t){return xT.tidy(e,t)}function q$(e){fT(e).forEach((e=>e.dispose()))}function K$(e){return xT.keep(e)}function X$(e){return xT.time(e)}function Y$(e){return xT.setBackend(e)}function Q$(){return xT.ready()}function Z$(){return xT.backendName}function J$(e){xT.removeBackend(e)}function eE(e){return xT.findBackend(e)}function tE(e){return xT.findBackendFactory(e)}function nE(e,t,n=1){return xT.registerBackend(e,t,n)}function rE(){return xT.backend}function aE(e,t){Rk().setPlatform(e,t)}vT(),function(e){YC=e}({buffer:D$,cast:M$,clone:O$,print:z$});var iE=DT({add_:function(e,t){let n=AT(e,"a","add"),r=AT(t,"b","add");[n,r]=cT(n,r);let a={a:n,b:r};return xT.runKernel(Bk,a)}}),oE=DT({floorDiv_:function(e,t){let n=AT(e,"a","floorDiv"),r=AT(t,"b","floorDiv");[n,r]=cT(n,r);let a={a:n,b:r};return xT.runKernel(qS,a)}}),sE=DT({div_:function(e,t){let n=AT(e,"a","div"),r=AT(t,"b","div");if([n,r]=cT(n,r),"int32"===n.dtype&&"int32"===r.dtype)return oE(n,r);let a={a:n,b:r};return xT.runKernel(DS,a,{})}}),lE=DT({mul_:function(e,t){let n=AT(e,"a","mul"),r=AT(t,"b","mul");[n,r]=cT(n,r);let a={a:n,b:r};return xT.runKernel(FI,a)}}),uE=DT({abs_:function(e){let t=AT(e,"x","abs");if("complex64"===t.dtype){let e={x:t};return xT.runKernel(cS,e)}{let e={x:t};return xT.runKernel(zk,e)}}}),dE=DT({acos_:function(e){let t={x:AT(e,"x","acos")};return xT.runKernel(Pk,t)}}),cE=DT({acosh_:function(e){let t={x:AT(e,"x","acosh")};return xT.runKernel(Lk,t)}}),pE=DT({addN_:function(e){Uw(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),Uw(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));let t=e.map(((e,t)=>AT(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!Xw(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));let r=t;return xT.runKernel(Wk,r)}}),hE=DT({all_:function(e,t=null,n=!1){let r={x:AT(e,"x","all","bool")},a={axis:t,keepDims:n};return xT.runKernel(Vk,r,a)}}),fE=DT({any_:function(e,t=null,n=!1){let r={x:AT(e,"x","any","bool")},a={axis:t,keepDims:n};return xT.runKernel(Uk,r,a)}}),mE=DT({argMax_:function(e,t=0){let n={x:AT(e,"x","argMax")},r={axis:t};return xT.runKernel(jk,n,r)}}),gE=DT({argMin_:function(e,t=0){let n={x:AT(e,"x","argMin")},r={axis:t};return xT.runKernel(Hk,n,r)}}),bE=DT({asin_:function(e){let t={x:AT(e,"x","asin")};return xT.runKernel(Gk,t)}}),yE=DT({asinh_:function(e){let t={x:AT(e,"x","asinh")};return xT.runKernel(qk,t)}}),vE=DT({atan_:function(e){let t={x:AT(e,"x","atan")};return xT.runKernel(Kk,t)}}),xE=DT({atan2_:function(e,t){let n=AT(e,"a","atan2"),r=AT(t,"b","atan2");[n,r]=cT(n,r);let a={a:n,b:r};return xT.runKernel(Yk,a)}}),wE=DT({atanh_:function(e){let t={x:AT(e,"x","atanh")};return xT.runKernel(Xk,t)}});function kE(e,t,n,r,a="NHWC",i){return NE(e,[...t,e[3]],n,i,r,null,null,ME(a))}function SE(e,t,n,r,a,i,o="channelsLast"){let s,[l,u]=$E(t);if("channelsLast"===o)s=[l,u,e[3],e[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);s=[l,u,e[1],e[1]]}return NE(e,s,n,r,a,i,!1,o)}function IE(e,t,n,r,a,i,o="NDHWC"){let s,l,[u,d,c]=EE(t);if("NDHWC"===o)l="channelsLast",s=[u,d,c,e[4],e[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);l="channelsFirst",s=[u,d,c,e[1],e[1]]}return CE(e,s,n,r,a,!1,l,i)}function NE(e,t,n,r,a,i,o=!1,s="channelsLast"){let[l,u,d,c]=[-1,-1,-1,-1];if("channelsLast"===s)[l,u,d,c]=e;else{if("channelsFirst"!==s)throw new Error(`Unknown dataFormat ${s}`);[l,c,u,d]=e}let p,[h,f,,m]=t,[g,b]=$E(n),[y,v]=$E(r),x=_E(h,y),w=_E(f,v),{padInfo:k,outHeight:S,outWidth:I}=function(e,t,n,r,a,i,o,s,l){let u,d,c;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};let a=function(e,t,n,r,a){null==r&&(r=TE(e,t,n));let i=e[0],o=e[1],s=AE((i-t+2*r)/n+1,a),l=AE((o-t+2*r)/n+1,a);return[s,l]}([t,n],i,r,e,s);d=a[0],c=a[1]}else if("same"===e){d=Math.ceil(t/r),c=Math.ceil(n/a);let e=Math.max(0,(d-1)*r+i-t),s=Math.max(0,(c-1)*a+o-n),l=Math.floor(e/2),p=e-l,h=Math.floor(s/2);u={top:l,bottom:p,left:h,right:s-h,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((t-i+1)/r),c=Math.ceil((n-o+1)/a);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{let p="channelsLast"===l?e[1][0]:e[2][0],h="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:p,bottom:h,left:f,right:m,type:0===p&&0===h&&0===f&&0===m?"VALID":"EXPLICIT"},d=AE((t-i+p+h)/r+1,s),c=AE((n-o+f+m)/a+1,s)}}return{padInfo:u,outHeight:d,outWidth:c}}(a,u,d,g,b,x,w,i,s),N=o?m*c:m;return"channelsFirst"===s?p=[l,N,S,I]:"channelsLast"===s&&(p=[l,S,I,N]),{batchSize:l,dataFormat:s,inHeight:u,inWidth:d,inChannels:c,outHeight:S,outWidth:I,outChannels:N,padInfo:k,strideHeight:g,strideWidth:b,filterHeight:h,filterWidth:f,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:v,inShape:e,outShape:p,filterShape:t}}function CE(e,t,n,r,a,i=!1,o="channelsLast",s){let[l,u,d,c,p]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,u,d,c,p]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,p,u,d,c]=e}let h,[f,m,g,,b]=t,[y,v,x]=EE(n),[w,k,S]=EE(r),I=_E(f,w),N=_E(m,k),C=_E(g,S),{padInfo:T,outDepth:$,outHeight:E,outWidth:_}=function(e,t,n,r,a,i,o,s,l,u,d){let c,p,h,f;if("valid"===e&&(e=0),"number"==typeof e){c={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};let m=function(e,t,n,r,a,i){null==a&&(a=TE(e,t[0],r[0]));let o=[0,0,0,n];for(let s=0;s<3;s++)e[s]+2*a>=t[s]&&(o[s]=AE((e[s]-t[s]+2*a)/r[s]+1,i));return o}([t,n,r,1],[s,l,u],1,[a,i,o],e,d);p=m[0],h=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{p=Math.ceil(t/a),h=Math.ceil(n/i),f=Math.ceil(r/o);let e=(p-1)*a+s-t,d=(h-1)*i+l-n,m=(f-1)*o+u-r,g=Math.floor(e/2),b=e-g,y=Math.floor(d/2),v=d-y,x=Math.floor(m/2);c={top:y,bottom:v,left:x,right:m-x,front:g,back:b,type:"SAME"}}}return{padInfo:c,outDepth:p,outHeight:h,outWidth:f}}(a,u,d,c,y,v,x,I,N,C,s),A=i?b*p:b;return"channelsFirst"===o?h=[l,A,$,E,_]:"channelsLast"===o&&(h=[l,$,E,_,A]),{batchSize:l,dataFormat:o,inDepth:u,inHeight:d,inWidth:c,inChannels:p,outDepth:$,outHeight:E,outWidth:_,outChannels:A,padInfo:T,strideDepth:y,strideHeight:v,strideWidth:x,filterDepth:f,filterHeight:m,filterWidth:g,effectiveFilterDepth:I,effectiveFilterHeight:N,effectiveFilterWidth:C,dilationDepth:w,dilationHeight:k,dilationWidth:S,inShape:e,outShape:h,filterShape:t}}function TE(e,t,n,r=1){let a=_E(t,r);return Math.floor((e[0]*(n-1)-n+a)/2)}function $E(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function EE(e){return"number"==typeof e?[e,e,e]:e}function _E(e,t){return t<=1?e:e+(e-1)*(t-1)}function AE(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function RE(e){let[t,n,r]=$E(e);return 1===t&&1===n&&1===r}function FE(e,t){return RE(e)||RE(t)}function DE(e){return $E(e).every((e=>e>0))}function ME(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function OE(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)Uw(Yw(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{Uw(Yw(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}var zE=DT({reshape_:function(e,t){let n={x:AT(e,"x","reshape","string_or_numeric")},r={shape:t};return xT.runKernel(eN,n,r)}}),PE=DT({avgPool_:function(e,t,n,r,a){let i=AT(e,"x","avgPool","float32");Uw(FE(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let o=i,s=!1;3===i.rank&&(s=!0,o=zE(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Uw(4===o.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`)),OE("avgPool",r,a);let l={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},d=xT.runKernel(Qk,l,u);return d=M$(d,i.dtype),s?zE(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),LE=DT({avgPool3d_:function(e,t,n,r,a,i="NDHWC"){let o=AT(e,"x","avgPool3d","float32"),s=o,l=!1;4===o.rank&&(l=!0,s=zE(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Uw(5===s.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${s.rank}.`)),Uw("NDHWC"===i,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`)),Uw("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),OE("avgPool3d",r,a);let u={x:s},d={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:i},c=xT.runKernel(Jk,u,d);return c=M$(c,s.dtype),l?zE(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),BE=DT({concat_:function(e,t=0){Uw(e.length>=1,(()=>"Pass at least one tensor to concat"));let n=RT(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return O$(n[0]);let r=n,a={axis:t};return xT.runKernel(pS,r,a)}}),WE=DT({matMul_:function(e,t,n=!1,r=!1){let a=AT(e,"a","matMul"),i=AT(t,"b","matMul");[a,i]=cT(a,i);let o={a:a,b:i},s={transposeA:n,transposeB:r};return xT.runKernel(tS,o,s)}}),VE=DT({sigmoid_:function(e){let t={x:AT(e,"x","sigmoid","float32")};return xT.runKernel(yN,t)}}),UE=DT({slice_:function(e,t,n){let r=AT(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");let a={x:r},i={begin:t,size:n};return xT.runKernel(fN,a,i)}}),jE=DT({tanh_:function(e){let t={x:AT(e,"x","tanh","float32")};return xT.runKernel(LN,t)}}),HE=DT({basicLSTMCell_:function(e,t,n,r,a,i){let o=AT(e,"forgetBias","basicLSTMCell"),s=AT(t,"lstmKernel","basicLSTMCell"),l=AT(n,"lstmBias","basicLSTMCell"),u=AT(r,"data","basicLSTMCell"),d=AT(a,"c","basicLSTMCell"),c=AT(i,"h","basicLSTMCell"),p=BE([u,c],1),h=WE(p,s),f=iE(h,l),m=f.shape[0],g=f.shape[1]/4,b=[m,g],y=UE(f,[0,0],b),v=UE(f,[0,g],b),x=UE(f,[0,2*g],b),w=UE(f,[0,3*g],b),k=iE(lE(VE(y),jE(v)),lE(d,VE(iE(o,x))));return[k,lE(jE(k),VE(w))]}}),GE=DT({batchToSpaceND_:function(e,t,n){let r=AT(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));Uw(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),Uw(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),Uw(r.shape[0]%a==0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`));let i={x:r},o={blockShape:t,crops:n};return xT.runKernel(nS,i,o)}});function qE(e){let t;return t=0===e.rank||1===e.rank?zE(e,[1,1,1,e.size]):2===e.rank?zE(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?zE(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}var KE=DT({batchNorm_:function(e,t,n,r,a,i){null==i&&(i=.001);let o,s,l=AT(e,"x","batchNorm"),u=AT(t,"mean","batchNorm"),d=AT(n,"variance","batchNorm");null!=a&&(o=AT(a,"scale","batchNorm")),null!=r&&(s=AT(r,"offset","batchNorm")),Uw(u.rank===d.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Uw(null==s||u.rank===s.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Uw(null==o||u.rank===o.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let c={x:qE(l),scale:o,offset:s,mean:u,variance:d},p={varianceEpsilon:i},h=xT.runKernel(KS,c,p);return zE(h,l.shape)}}),XE=DT({batchNorm2d_:function(e,t,n,r,a,i){let o,s,l=AT(e,"x","batchNorm"),u=AT(t,"mean","batchNorm"),d=AT(n,"variance","batchNorm");return null!=a&&(o=AT(a,"scale","batchNorm")),null!=r&&(s=AT(r,"offset","batchNorm")),Uw(2===l.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`)),Uw(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`)),Uw(2===d.rank||1===d.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${d.rank}.`)),null!=o&&Uw(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${o.rank}.`)),null!=s&&Uw(2===s.rank||1===s.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${s.rank}.`)),KE(l,u,d,s,o,i)}}),YE=DT({batchNorm3d_:function(e,t,n,r,a,i){let o,s,l=AT(e,"x","batchNorm"),u=AT(t,"mean","batchNorm"),d=AT(n,"variance","batchNorm");return null!=a&&(o=AT(a,"scale","batchNorm")),null!=r&&(s=AT(r,"offset","batchNorm")),Uw(3===l.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`)),Uw(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`)),Uw(3===d.rank||1===d.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${d.rank}.`)),null!=o&&Uw(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${o.rank}.`)),null!=s&&Uw(3===s.rank||1===s.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${s.rank}.`)),KE(l,u,d,s,o,i)}}),QE=DT({batchNorm4d_:function(e,t,n,r,a,i){let o,s,l=AT(e,"x","batchNorm"),u=AT(t,"mean","batchNorm"),d=AT(n,"variance","batchNorm");return null!=a&&(o=AT(a,"scale","batchNorm")),null!=r&&(s=AT(r,"offset","batchNorm")),Uw(4===l.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`)),Uw(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`)),Uw(4===d.rank||1===d.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${d.rank}.`)),null!=o&&Uw(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${o.rank}.`)),null!=s&&Uw(4===s.rank||1===s.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${s.rank}.`)),KE(l,u,d,s,o,i)}}),ZE=DT({bincount_:function(e,t,n){let r=AT(e,"x","bincount"),a=AT(t,"weights","bincount");Uw("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),Uw(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Uw(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));let i={x:r,weights:a},o={size:n};return xT.runKernel(rS,i,o)}}),JE=DT({bitwiseAnd_:function(e,t){let n=AT(e,"x","bitwiseAnd"),r=AT(t,"y","bitwiseAnd");if(!Xw(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let a={a:n,b:r};return xT.runKernel(aS,a)}}),e_=DT({broadcastArgs_:function(e,t){let n=AT(e,"s0","broadcastArgs","int32"),r=AT(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let a={s0:n,s1:r};return xT.runKernel(oS,a)}}),t_=DT({broadcastTo_:function(e,t){let n=AT(e,"broadcastTo","x"),r=n.shape;if(Nk(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=zE(n,e)}let a=n.shape,i=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])i[l]=1;else if(1!==n.shape[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===i.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return O$(n);let o={x:n},s={reps:i};return xT.runKernel(BN,o,s)}}),n_=DT({ceil_:function(e){let t={x:AT(e,"x","ceil","float32")};return xT.runKernel(lS,t)}});function r_(e,t,n){Nk(e);let r={shape:e,value:t,dtype:n=n||mk(t)};return xT.runKernel(jS,{},r)}var a_=DT({clipByValue_:function(e,t,n){let r=AT(e,"x","clipByValue");if(Uw(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return r_(r.shape,t,r.dtype);let a={x:r},i={clipValueMin:t,clipValueMax:n};return xT.runKernel(uS,a,i)}}),i_=DT({concat1d_:function(e){return BE(e,0)}}),o_=DT({concat2d_:function(e,t){return BE(e,t)}}),s_=DT({concat3d_:function(e,t){return BE(e,t)}}),l_=DT({concat4d_:function(e,t){return BE(e,t)}}),u_=DT({conv2d_:function(e,t,n,r,a="NHWC",i=[1,1],o){let s=AT(e,"x","conv2d","float32"),l=AT(t,"filter","conv2d","float32"),u=s,d=!1;3===s.rank&&(d=!0,u=zE(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Uw(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),Uw(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),OE("conv2d",r,o);let c="NHWC"===a?u.shape[3]:u.shape[1];Uw(c===l.shape[2],(()=>`Error in conv2d: depth of input (${c}) must match input depth for filter ${l.shape[2]}.`)),Uw(FE(n,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`)),Uw(DE(i),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Uw(DE(n),(()=>"Error in conv2D: Strides should be larger than 0."));let p={x:u,filter:l},h={strides:n,pad:r,dataFormat:a,dilations:i,dimRoundingMode:o},f=xT.runKernel(hS,p,h);return d?zE(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),d_=DT({conv1d_:function(e,t,n,r,a="NWC",i=1,o){let s=AT(e,"x","conv1d"),l=AT(t,"filter","conv1d"),u=s,d=!1;2===s.rank&&(d=!0,u=zE(s,[1,s.shape[0],s.shape[1]])),Uw(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),Uw(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),OE("conv1d",r,o),Uw(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),Uw(FE(n,i),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`)),Uw(DE(i),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Uw(DE(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Uw("NWC"===a,(()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`));let c=zE(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=zE(u,[u.shape[0],1,u.shape[1],u.shape[2]]),h=u_(p,c,[1,n],r,"NHWC",[1,i],o);return zE(h,d?[h.shape[2],h.shape[3]]:[h.shape[0],h.shape[2],h.shape[3]])}}),c_=DT({conv2DBackpropInput_:function(e,t,n,r,a,i="NHWC",o){Uw(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let s=e,l=t,u=!1;3===t.rank&&(u=!0,l=zE(t,[1,t.shape[0],t.shape[1],t.shape[2]]),s=[1,e[0],e[1],e[2]]),Uw(4===s.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${s.length}.`)),Uw(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),Uw(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));let d="NHWC"===i?s[3]:s[1],c="NHWC"===i?l.shape[3]:l.shape[1];Uw(d===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${d}) must match input depth for filter ${n.shape[2]}.`)),Uw(c===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[3]}.`)),OE("conv2dDerInput",a,o);let p={dy:l,filter:n},h={strides:r,pad:a,dataFormat:i,dimRoundingMode:o,inputShape:s},f=xT.runKernel(mS,p,h);return u?zE(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),p_=DT({conv2dTranspose_:function(e,t,n,r,a,i){let o=AT(e,"x","conv2dTranspose"),s=AT(t,"filter","conv2dTranspose");return c_(n,o,s,r,a,"NHWC",i)}}),h_=DT({conv3d_:function(e,t,n,r,a="NDHWC",i=[1,1,1]){let o=AT(e,"x","conv3d"),s=AT(t,"filter","conv3d"),l=o,u=!1;4===o.rank&&(u=!0,l=zE(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Uw(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),Uw(5===s.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${s.rank}.`)),Uw(l.shape[4]===s.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${s.shape[3]}.`)),Uw(FE(n,i),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`)),Uw("NDHWC"===a,(()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`)),Uw(DE(i),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Uw(DE(n),(()=>"Error in conv3D: Strides should be larger than 0."));let d={x:l,filter:s},c={strides:n,pad:r,dataFormat:a,dilations:i},p=xT.runKernel(gS,d,c);return u?zE(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),f_=DT({conv3DBackpropInput_:function(e,t,n,r,a){Uw(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let i=e,o=t,s=!1;4===t.rank&&(s=!0,o=zE(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,e[0],e[1],e[2],e[3]]);let l=i[4],u=o.shape[4];Uw(5===i.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`)),Uw(5===o.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`)),Uw(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),Uw(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),Uw(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));let d={dy:o,filter:n},c={pad:a,strides:r,inputShape:i},p=xT.runKernel(yS,d,c);return s?zE(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),m_=DT({conv3dTranspose_:function(e,t,n,r,a){let i=AT(e,"x","conv3dTranspose"),o=AT(t,"filter","conv3dTranspose");return f_(n,i,o,r,a)}}),g_=DT({cos_:function(e){let t={x:AT(e,"x","cos","float32")};return xT.runKernel(vS,t)}}),b_=DT({cosh_:function(e){let t={x:AT(e,"x","cosh","float32")};return xT.runKernel(xS,t)}}),y_=DT({cumprod_:function(e,t=0,n=!1,r=!1){let a={x:AT(e,"x","cumprod")},i={axis:t,exclusive:n,reverse:r};return xT.runKernel(wS,a,i)}}),v_=DT({cumsum_:function(e,t=0,n=!1,r=!1){let a={x:AT(e,"x","cumsum")},i={axis:t,exclusive:n,reverse:r};return xT.runKernel(kS,a,i)}}),x_=DT({denseBincount_:function(e,t,n,r=!1){let a=AT(e,"x","denseBincount"),i=AT(t,"weights","denseBincount");Uw("int32"===a.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`)),Uw(a.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`)),Uw(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Uw(i.size===a.size||0===i.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${i.shape}.`));let o={x:a,weights:i},s={size:n,binaryOutput:r};return xT.runKernel(IS,o,s)}}),w_=DT({depthToSpace_:function(e,t,n="NHWC"){let r=AT(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],i="NHWC"===n?r.shape[2]:r.shape[3],o="NHWC"===n?r.shape[3]:r.shape[1];Uw(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),Uw(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),Uw(i*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),Uw(o%(t*t)==0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${r.shape}`));let s={x:r},l={blockSize:t,dataFormat:n};return xT.runKernel(NS,s,l)}}),k_=DT({depthwiseConv2d_:function(e,t,n,r,a="NHWC",i=[1,1],o){let s=AT(e,"x","depthwiseConv2d","float32"),l=AT(t,"filter","depthwiseConv2d","float32"),u=s,d=!1;3===s.rank&&(d=!0,u=zE(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Uw(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),Uw(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));let c="NHWC"===a?u.shape[3]:u.shape[1];Uw(c===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${c}) must match the inChannels dimension in filter ${l.shape[2]}.`)),OE("depthwiseConv2d",r,o);let p={x:u,filter:l},h={strides:n,pad:r,dataFormat:a,dilations:i,dimRoundingMode:o},f=xT.runKernel(CS,p,h);return d?zE(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),S_=DT({diag_:function(e){let t={x:AT(e,"x","diag")};return xT.runKernel(ES,t)}}),I_=DT({dilation2d_:function(e,t,n,r,a=[1,1],i="NHWC"){let o=AT(e,"x","dilation2d"),s=AT(t,"filter","dilation2d");Uw(3===o.rank||4===o.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`)),Uw(3===s.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${s.rank}.`)),Uw("NHWC"===i,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`));let l=o,u=!1;3===o.rank&&(l=zE(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=!0),Uw(l.shape[3]===s.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${s.shape[2]}`));let d={x:l,filter:s},c={strides:n,pad:r,dilations:a},p=xT.runKernel(_S,d,c);return u?zE(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),N_={};function C_(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let i=n-1-a,o=e[i]||1;(t[t.length-1-a]||1)>1&&1===o&&r.unshift(i)}return r}function T_(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],i=t.length-r-1,o=t[i];(null==a||1===a&&o>1)&&n.unshift(i)}return n}function $_(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let a=0;a<n;a++){let i=e[e.length-a-1];null==i&&(i=1);let o=t[t.length-a-1];if(null==o&&(o=1),1===i)r[n-a-1]=o;else if(1===o)r[n-a-1]=i;else{if(i!==o)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);r[n-a-1]=i}}return r}uw(N_,{assertAndGetBroadcastShape:()=>$_,getBroadcastDims:()=>C_,getReductionAxes:()=>T_});var E_=DT({equal_:function(e,t){let n=AT(e,"a","equal","string_or_numeric"),r=AT(t,"b","equal","string_or_numeric");[n,r]=cT(n,r),$_(n.shape,r.shape);let a={a:n,b:r};return xT.runKernel(LS,a)}}),__=DT({where_:function(e,t,n){let r=AT(t,"a","where"),a=AT(n,"b","where"),i=AT(e,"condition","where","bool"),o=$_($_(i.shape,r.shape),a.shape),s={condition:t_(i,o),t:t_(r,o),e:t_(a,o)};return xT.runKernel(pN,s)}}),A_=DT({zerosLike_:function(e){let t={x:AT(e,"x","zerosLike")};return xT.runKernel(KN,t)}}),R_=DT({divNoNan_:function(e,t){let n=AT(e,"a","div"),r=AT(t,"b","div");[n,r]=cT(n,r);let a=sE(n,r),i=A_(a),o=E_(r,i);return __(o,i,a)}}),F_=DT({dot_:function(e,t){let n=AT(e,"t1","dot"),r=AT(t,"t2","dot");Uw(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));let a=1===n.rank?n.size:n.shape[1],i=1===r.rank?r.size:r.shape[0];if(Uw(a===i,(()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${i}.`)),1===n.rank&&1===r.rank){let e=zE(n,[1,-1]),t=zE(r,[-1,1]),a=WE(e,t);return zE(a,[])}if(1===n.rank&&2===r.rank){let e=zE(n,[1,-1]),t=zE(r,[r.shape[0],r.shape[1]]),a=WE(e,t);return zE(a,[a.size])}if(2===n.rank&&1===r.rank){let e=zE(r,[-1,1]),t=WE(n,e);return zE(t,[t.size])}{let e=zE(r,[r.shape[0],r.shape[1]]);return WE(n,e)}}}),D_=DT({einsum_:function(e,...t){let n=t.map(((e,t)=>AT(e,`tensors${t}`,"einsum"))),r={equation:e};return xT.runKernel(MS,n,r)}}),M_=DT({elu_:function(e){let t={x:AT(e,"x","elu","float32")};return xT.runKernel(OS,t)}}),O_=DT({ensureShape_:function(e,t){let n=AT(e,"x","ensureShape","string_or_numeric");if(!Kw(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}}),z_=DT({erf_:function(e){let t=AT(e,"x","erf");Uw("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=M$(t,"float32"));let n={x:t};return xT.runKernel(PS,n)}});function P_(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function L_(e,t,n){let r=e.length+t.length,a=[],i=0,o=0;for(let s=0;s<r;s++)-1===n.indexOf(s)?a.push(e[i++]):a.push(t[o++]);return a}function B_(e,t){let n=[],r=e.length;for(let a=0;a<r;a++)-1===t.indexOf(a)&&n.push(e[a]);return[n,t.map((t=>e[t]))]}function W_(e,t){return L_(e,t.map((e=>1)),t)}function V_(e,t,n){Uw(P_(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function U_(e,t){if(P_(e,t))return null;let n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function j_(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function H_(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}var G_=DT({max_:function(e,t=null,n=!1){let r={x:AT(e,"x","max")},a={reductionIndices:t,keepDims:n};return xT.runKernel(xI,r,a)}}),q_=DT({min_:function(e,t=null,n=!1){let r={x:AT(e,"x","min")},a={axis:t,keepDims:n};return xT.runKernel($I,r,a)}}),K_=DT({pow_:function(e,t){let n=AT(e,"base","pow"),r=AT(t,"exp","pow");[n,r]=cT(n,r);let a={a:n,b:r};return xT.runKernel(jI,a)}});function X_(e,t){if((OC(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&OC(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return OT(e,[],[],t)}var Y_=DT({sqrt_:function(e){let t={x:AT(e,"x","sqrt","float32")};return xT.runKernel(xN,t)}}),Q_=DT({square_:function(e){let t=AT(e,"x","square");return xT.runKernel("Square",{x:t},{})}}),Z_=DT({sum_:function(e,t=null,n=!1){let r=AT(e,"x","sum");"bool"===r.dtype&&(r=M$(r,"int32"));let a={x:r},i={axis:t,keepDims:n};return xT.runKernel(wN,a,i)}});function J_(e,t,n=null){if(0===e.rank)return uE(e);if(1!==e.rank&&null===n)return J_(zE(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Z_(uE(e),n);if(t===1/0)return G_(uE(e),n);if(t===-1/0)return q_(uE(e),n);if("euclidean"===t||2===t)return Y_(Z_(K_(uE(e),X_(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return G_(Z_(uE(e),n[0]),n[1]-1);if(t===1/0)return G_(Z_(uE(e),n[1]),n[0]);if(t===-1/0)return q_(Z_(uE(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Y_(Z_(Q_(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var eA=DT({norm_:function(e,t="euclidean",n=null,r=!1){let a=J_(e=AT(e,"x","norm"),t,n),i=a.shape;if(r){let t=rk(n,e.shape);i=W_(a.shape,t)}return zE(a,i)}}),tA=DT({euclideanNorm_:function(e,t=null,n=!1){return eA(e,"euclidean",t,n)}}),nA=DT({exp_:function(e){let t={x:AT(e,"x","exp")};return xT.runKernel(BS,t)}}),rA=DT({expandDims_:function(e,t=0){let n=AT(e,"x","expandDims","string_or_numeric");Uw(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));let r={input:n},a={dim:t};return xT.runKernel(WS,r,a)}}),aA=DT({expm1_:function(e){let t={x:AT(e,"x","expm1")};return xT.runKernel(VS,t)}}),iA=DT({tile_:function(e,t){let n=AT(e,"x","tile","string_or_numeric");Uw(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));let r={x:n},a={reps:t};return xT.runKernel(BN,r,a)}}),oA=DT({eye_:function(e,t,n,r="float32"){null==t&&(t=e);let a=D$([e,t],r),i=e<=t?e:t;for(let s=0;s<i;++s)a.set(1,s,s);let o=zE(a.toTensor(),[e,t]);if(null==n)return o;if(1===n.length)return iA(rA(o,0),[n[0],1,1]);if(2===n.length)return iA(rA(rA(o,0),0),[n[0],n[1],1,1]);if(3===n.length)return iA(rA(rA(rA(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}),sA=DT({floor_:function(e){let t={x:AT(e,"x","floor","float32")};return xT.runKernel(GS,t)}}),lA=DT({gather_:function(e,t,n=0,r=0){let a={x:AT(e,"x","gather"),indices:AT(t,"indices","gather","int32")},i={axis:n,batchDims:r};return xT.runKernel(XS,a,i)}}),uA=DT({greater_:function(e,t){let n=AT(e,"a","greater","string_or_numeric"),r=AT(t,"b","greater","string_or_numeric");[n,r]=cT(n,r),$_(n.shape,r.shape);let a={a:n,b:r};return xT.runKernel(QS,a)}}),dA=DT({greaterEqual_:function(e,t){let n=AT(e,"a","greaterEqual","string_or_numeric"),r=AT(t,"b","greaterEqual","string_or_numeric");[n,r]=cT(n,r),$_(n.shape,r.shape);let a={a:n,b:r};return xT.runKernel(ZS,a)}}),cA=DT({imag_:function(e){let t={input:AT(e,"input","imag")};return xT.runKernel(tI,t)}}),pA=DT({isFinite_:function(e){let t={x:AT(e,"x","isFinite")};return xT.runKernel(nI,t)}}),hA=DT({isInf_:function(e){let t={x:AT(e,"x","isInf")};return xT.runKernel(rI,t)}}),fA=DT({isNaN_:function(e){let t={x:AT(e,"x","isNaN")};return xT.runKernel(aI,t)}}),mA=DT({leakyRelu_:function(e,t=.2){let n={x:AT(e,"x","leakyRelu")},r={alpha:t};return xT.runKernel(iI,n,r)}}),gA=DT({less_:function(e,t){let n=AT(e,"a","less","string_or_numeric"),r=AT(t,"b","less","string_or_numeric");[n,r]=cT(n,r),$_(n.shape,r.shape);let a={a:n,b:r};return xT.runKernel(oI,a)}}),bA=DT({lessEqual_:function(e,t){let n=AT(e,"a","lessEqual","string_or_numeric"),r=AT(t,"b","lessEqual","string_or_numeric");[n,r]=cT(n,r),$_(n.shape,r.shape);let a={a:n,b:r};return xT.runKernel(sI,a)}});function yA(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return xT.runKernel(lI,{},r)}var vA=DT({localResponseNormalization_:function(e,t=5,n=1,r=1,a=.5){let i=AT(e,"x","localResponseNormalization");Uw(4===i.rank||3===i.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`)),Uw(Yw(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let o=i,s=!1;3===i.rank&&(s=!0,o=zE(i,[1,i.shape[0],i.shape[1],i.shape[2]]));let l={x:o},u={depthRadius:t,bias:n,alpha:r,beta:a},d=xT.runKernel(bI,l,u);return s?zE(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),xA=DT({log_:function(e){let t={x:AT(e,"x","log","float32")};return xT.runKernel(uI,t)}}),wA=DT({log1p_:function(e){let t={x:AT(e,"x","log1p")};return xT.runKernel(dI,t)}});function kA(e){return Uw(gk(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{let r=AT(t,"x","tf.grad","string_or_numeric"),a=null!=n?AT(n,"dy","tf.grad"):null;return xT.tidy((()=>{let{value:t,grads:n}=xT.gradients((()=>e(r)),[r],a);return null!=a&&jw(t.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),$A(n),n[0]}))}}function SA(e){return Uw(gk(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{Uw(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));let r=RT(t,"args","tf.grads","string_or_numeric"),a=null!=n?AT(n,"dy","tf.grads"):null;return xT.tidy((()=>{let{value:t,grads:n}=xT.gradients((()=>e(...r)),r,a);return null!=a&&jw(t.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),$A(n),n}))}}function IA(e){return Uw(gk(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{Uw(t instanceof QC,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),Uw(null==n||n instanceof QC,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));let{grads:r,value:a}=xT.gradients((()=>e(t)),[t],n);return $A(r),{grad:r[0],value:a}}}function NA(e){return Uw(gk(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{Uw(Array.isArray(t)&&t.every((e=>e instanceof QC)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),Uw(null==n||n instanceof QC,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));let r=xT.gradients((()=>e(...t)),t,n);return null!=n&&jw(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),$A(r.grads),r}}function CA(e,t){Uw(gk(e),(()=>"The f passed in variableGrads(f) must be a function")),Uw(null==t||Array.isArray(t)&&t.every((e=>e instanceof JC)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));let n=null!=t;if(!n){t=[];for(let e in xT.registeredVariables)t.push(xT.registeredVariables[e])}let r=n?t.filter((e=>!e.trainable)):null,a=t.length;t=t.filter((e=>e.trainable)),Uw(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`));let{value:i,grads:o}=xT.gradients(e,t,null,!0);Uw(o.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Uw(0===i.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`));let s={};return t.forEach(((e,t)=>{null!=o[t]&&(s[e.name]=o[t])})),null!=r&&r.forEach((e=>s[e.name]=null)),{value:i,grads:s}}function TA(e){return xT.customGrad(e)}function $A(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}var EA=DT({neg_:function(e){let t={x:AT(e,"x","neg")};return xT.runKernel(DI,t)}}),_A=DT({softplus_:function(e){let t={x:AT(e,"x","softplus")};return xT.runKernel(vN,t)}}),AA=DT({logSigmoid_:function(e){let t=AT(e,"x","logSigmoid");return TA((e=>({value:EA(_A(EA(e))),gradFunc:t=>lE(t,VE(EA(e)))})))(t)}}),RA=DT({sub_:function(e,t){let n=AT(e,"a","sub"),r=AT(t,"b","sub");[n,r]=cT(n,r);let a={a:n,b:r};return xT.runKernel(zN,a)}}),FA=DT({logSoftmax_:function(e,t=-1){let n=AT(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return TA(((e,n)=>{let r=G_(e,t,!0),a=RA(e,r),i=RA(M$(a,"float32"),xA(Z_(nA(a),t,!0)));return n([i]),{value:i,gradFunc:(e,n)=>{let[r]=n,a=nA(r);return RA(e,lE(Z_(e,t,!0),a))}}}))(n)}}),DA=DT({logSumExp_:function(e,t=null,n=!1){let r=AT(e,"x","logSumExp"),a=rk(t,r.shape),i=G_(r,a,!0),o=RA(r,i),s=nA(o),l=Z_(s,a),u=xA(l),d=iE(zE(i,u.shape),u);if(n){let e=W_(d.shape,a);return zE(d,e)}return d}}),MA=DT({logicalAnd_:function(e,t){let n=AT(e,"a","logicalAnd","bool"),r=AT(t,"b","logicalAnd","bool");$_(n.shape,r.shape);let a={a:n,b:r};return xT.runKernel(cI,a)}}),OA=DT({logicalNot_:function(e){let t={x:AT(e,"x","logicalNot","bool")};return xT.runKernel(pI,t)}}),zA=DT({logicalOr_:function(e,t){let n=AT(e,"a","logicalOr","bool"),r=AT(t,"b","logicalOr","bool");$_(n.shape,r.shape);let a={a:n,b:r};return xT.runKernel(hI,a)}}),PA=DT({logicalXor_:function(e,t){let n=AT(e,"a","logicalXor","bool"),r=AT(t,"b","logicalXor","bool");return $_(n.shape,r.shape),MA(zA(e,t),OA(MA(e,t)))}}),LA=2147483648,BA=DT({searchSorted_:function(e,t,n="left"){let r=AT(e,"sortedSequence","searchSorted"),a=AT(t,"values","searchSorted"),i=r.shape[r.shape.length-1],o=a.shape[a.shape.length-1],s=zE(r,[-1,i]),l=zE(a,[-1,o]);if(s.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(s.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Gw(l.shape)>=LA)throw new Error(`values tensor size must less than ${LA}`);if(s.shape[1]>=LA)throw new Error(`trailing dim_size must less than ${LA} for int32 output type, was ${s.shape[1]}`);let u={sortedSequence:s,values:l},d={side:n};return xT.runKernel(cN,u,d)}});function WA(e,t){return BA(e,t,"left")}var VA=DT({maxPool_:function(e,t,n,r,a){let i=AT(e,"x","maxPool"),o=i,s=!1;3===i.rank&&(s=!0,o=zE(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Uw(4===o.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`)),Uw(FE(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),OE("maxPool",r,a);let l={x:o},u={filterSize:t,strides:n,pad:r,dimRoundingMode:a},d=xT.runKernel(kI,l,u);return s?zE(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),UA=DT({maxPool3d_:function(e,t=[1,1,1],n,r,a,i="NDHWC"){let o=AT(e,"x","maxPool3d"),s=o,l=!1;4===o.rank&&(l=!0,s=zE(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Uw(5===s.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${s.rank}.`)),Uw("NDHWC"===i,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`)),OE("maxPool3d",r,a);let u={x:s},d={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:i},c=xT.runKernel(II,u,d);return l?zE(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),jA=DT({maxPoolWithArgmax_:function(e,t,n,r,a=!1){let i={x:AT(e,"x","maxPoolWithArgmax")},o={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},s=xT.runKernel(CI,i,o);return{result:s[0],indexes:s[1]}}}),HA=DT({maximum_:function(e,t){let n=AT(e,"a","maximum"),r=AT(t,"b","maximum");[n,r]=cT(n,r),"bool"===n.dtype&&(n=M$(n,"int32"),r=M$(r,"int32")),$_(n.shape,r.shape);let a={a:n,b:r};return xT.runKernel(wI,a)}}),GA=DT({mean_:function(e,t=null,n=!1){let r={x:AT(e,"x","mean")},a={axis:t,keepDims:n};return xT.runKernel(TI,r,a)}});function qA(e,t="float32"){if(Nk(e),"complex64"===t){let t=qA(e,"float32"),n=qA(e,"float32");return MT(t,n)}let n=Sk(Gw(e),t);return xT.makeTensor(n,e,t)}function KA(e,t="float32"){if(Nk(e),"complex64"===t){let t=KA(e,"float32"),n=qA(e,"float32");return MT(t,n)}let n=kk(Gw(e),t);return xT.makeTensor(n,e,t)}function XA(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=AT(e,"x","meshgrid",e instanceof QC?e.dtype:"float32");if(void 0===t)return[r];let a=AT(t,"y","meshgrid",t instanceof QC?t.dtype:"float32"),i=Gw(r.shape),o=Gw(a.shape);return"xy"===n?(r=zE(r,[1,-1]),a=zE(a,[-1,1]),[WE(KA([o,1],r.dtype),r),WE(a,KA([1,i],a.dtype))]):(r=zE(r,[-1,1]),a=zE(a,[1,-1]),[WE(r,KA([1,o],r.dtype)),WE(KA([i,1],a.dtype),a)])}var YA=DT({minimum_:function(e,t){let n=AT(e,"a","minimum"),r=AT(t,"b","minimum");[n,r]=cT(n,r),"bool"===n.dtype&&(n=M$(n,"int32"),r=M$(r,"int32")),$_(n.shape,r.shape);let a={a:n,b:r};return xT.runKernel(EI,a)}}),QA=DT({mirrorPad_:function(e,t,n){Uw("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));let r=AT(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Uw(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));let a="reflect"===n?1:0;for(let s=0;s<r.rank;s++)Uw(2===t[s].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Uw(t[s][0]>=0&&t[s][0]<=r.shape[s]-a&&t[s][1]>=0&&t[s][1]<=r.shape[s]-a,(()=>`Padding in dimension ${s} cannot be greater than or equal to ${r.shape[s]-a} or less than 0 for input of shape ${r.shape}`));let i={paddings:t,mode:n},o={x:r};return xT.runKernel(_I,o,i)}}),ZA=DT({mod_:function(e,t){let n=AT(e,"a","mod"),r=AT(t,"b","mod");[n,r]=cT(n,r);let a={a:n,b:r};return xT.runKernel(AI,a)}}),JA=DT({moments_:function(e,t=null,n=!1){let r=rk(t,(e=AT(e,"x","moments")).shape),a=GA(e,r,n),i=a.shape;n||(i=W_(a.shape,r));let o=Q_(RA(M$(e,"float32"),zE(a,i)));return{mean:a,variance:GA(o,r,n)}}}),eR=DT({multiRNNCell_:function(e,t,n,r){let a=AT(t,"data","multiRNNCell"),i=RT(n,"c","multiRNNCell"),o=RT(r,"h","multiRNNCell"),s=a,l=[];for(let c=0;c<e.length;c++){let t=e[c](s,i[c],o[c]);l.push(t[0]),l.push(t[1]),s=t[1]}let u=[],d=[];for(let c=0;c<l.length;c+=2)u.push(l[c]),d.push(l[c+1]);return[u,d]}}),tR=DT({multinomial_:function(e,t,n,r=!1){let a=AT(e,"logits","multinomial"),i=a.size,o=a.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();let s={logits:1===o?zE(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},u=xT.runKernel(RI,s,l);return 1===o?zE(u,[u.size]):u}}),nR=DT({notEqual_:function(e,t){let n=AT(e,"a","notEqual","string_or_numeric"),r=AT(t,"b","notEqual","string_or_numeric");[n,r]=cT(n,r),$_(n.shape,r.shape);let a={a:n,b:r};return xT.runKernel(MI,a)}}),rR=DT({oneHot_:function(e,t,n=1,r=0,a="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let i={indices:AT(e,"indices","oneHot","int32")},o={dtype:a,depth:t,onValue:n,offValue:r};return xT.runKernel(BI,i,o)}}),aR=DT({onesLike_:function(e){let t={x:AT(e,"x","onesLike")};return xT.runKernel(LI,t)}}),iR=DT({outerProduct_:function(e,t){let n=AT(e,"v1","outerProduct"),r=AT(t,"v2","outerProduct");Uw(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));let a=zE(n,[-1,1]),i=zE(r,[1,-1]);return WE(a,i)}}),oR=DT({pad_:function(e,t,n=0){let r=AT(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let a={paddings:t,constantValue:n},i={x:r};return xT.runKernel(VI,i,a)}}),sR=DT({pad1d_:function(e,t,n=0){return Uw(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),oR(e,[t],n)}}),lR=DT({pad2d_:function(e,t,n=0){return Uw(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),oR(e,t,n)}}),uR=DT({pad3d_:function(e,t,n=0){return Uw(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),oR(e,t,n)}}),dR=DT({pad4d_:function(e,t,n=0){return Uw(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),oR(e,t,n)}}),cR=DT({spaceToBatchND_:function(e,t,n){let r=AT(e,"x","spaceToBatchND");Uw(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),Uw(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),Uw(r.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]==0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));let a={x:r},i={blockShape:t,paddings:n};return xT.runKernel(kN,a,i)}}),pR=DT({pool_:function(e,t,n,r,a,i,o){null==a&&(a=[1,1]),null==i&&(i=1),0===r&&(r="valid");let s=AT(e,"x","maxPool"),l=s,u=!1;3===s.rank&&(u=!0,l=zE(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Uw(FE(i,a),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${a}'`));let d,c=SE(l.shape,t,i,a,r),p=[c.dilationHeight,c.dilationWidth];d="same"===r?function(e,t){let n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),a=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],a[t]]))}([c.filterHeight,c.filterWidth],p):[[0,0],[0,0]];let h=1===p[0]&&1===p[1],[f,m]=function(e,t,n){let r=n.map((e=>e[0])),a=n.map((e=>e[1])),i=e.concat(r,a),o=t.map(((e,t)=>(e-i[t]%e)%e)),s=a.map(((e,t)=>e+o[t])),l=t.map(((e,t)=>[r[t],s[t]])),u=t.map(((e,t)=>[0,o[t]]));return[l,u]}([c.inHeight,c.inWidth],p,d),g=h?r:"valid",b=h?l:cR(l,p,f),y=("avg"===n?()=>PE(b,t,i,g,o):()=>VA(b,t,i,g,o))(),v=h?y:GE(y,p,m);return u?zE(v,[v.shape[1],v.shape[2],v.shape[3]]):v}}),hR=DT({prelu_:function(e,t){let n={x:AT(e,"x","prelu"),alpha:AT(t,"alpha","prelu")};return xT.runKernel(HI,n)}}),fR=DT({prod_:function(e,t=null,n=!1){let r=AT(e,"x","prod");"bool"===r.dtype&&(r=M$(r,"int32"));let a={x:r},i={axis:t,keepDims:n};return xT.runKernel(GI,a,i)}}),mR=DT({raggedGather_:function(e,t,n,r){let a=e.map(((e,t)=>AT(e,`tensors${t}`,"raggedGather","int32"))),i={paramsNestedSplits:a,paramsDenseValues:AT(t,"paramsDenseValues","raggedGather"),indices:AT(n,"indices","raggedGather","int32")},o={outputRaggedRank:r},s=xT.runKernel(qI,i,o);return{outputNestedSplits:s.slice(0,s.length-1),outputDenseValues:s[s.length-1]}}}),gR=DT({raggedRange_:function(e,t,n){let r=AT(e,"starts","raggedRange"),a={starts:r,limits:AT(t,"limits","raggedRange",r.dtype),deltas:AT(n,"deltas","raggedRange",r.dtype)},i=xT.runKernel(KI,a);return{rtNestedSplits:i[0],rtDenseValues:i[1]}}}),bR=DT({raggedTensorToTensor_:function(e,t,n,r,a){let i=AT(e,"shape","raggedTensorToTensor","int32"),o=AT(t,"values","raggedTensorToTensor"),s=AT(n,"defaultValue","raggedTensorToTensor",o.dtype),l=r.map(((e,t)=>AT(e,`tensors${t}`,"raggedTensorToTensor","int32"))),u={shape:i,values:o,defaultValue:s,rowPartitionTensors:l},d={rowPartitionTypes:a};return xT.runKernel(XI,u,d)}}),yR=DT({rand_:function(e,t,n){Nk(e);let r=Gw(e),a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(r)}for(let i=0;i<r;i++)a[i]=t();return xT.makeTensor(a,e,n)}}),vR=dw(kw()),xR={};uw(xR,{TEST_EPSILON_FLOAT16:()=>kR,createVideoElement:()=>FR,encodeStrings:()=>RR,expectArrayBuffersEqual:()=>AR,expectArraysClose:()=>SR,expectArraysEqual:()=>TR,expectNumbersClose:()=>$R,expectPromiseToFail:()=>CR,expectValuesInRange:()=>_R,play:()=>DR,testEpsilon:()=>IR});var wR=.001,kR=.1;function SR(e,t,n){return null==n&&(n=IR()),NR(e,t,((e,t)=>ER(e,t,n)))}function IR(){return 32===xT.backend.floatPrecision()?wR:kR}function NR(e,t,n){let r=!0;if((OC(e)||OC(t))&&(r=!1),OC(e)&&OC(t)&&(r=!0),r){let n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){let n=$T(e),r=$T(t);if(!Xw(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}let a=OC(e)?e:zC(e),i=OC(t)?t:zC(t);if(a.length!==i.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${i.length}.\nActual:   ${a}.\nExpected: ${i}.`);for(let o=0;o<i.length;++o){let e=a[o],t=i[o];if(!n(e,t))throw new Error(`Arrays differ: actual[${o}] = ${e}, expected[${o}] = ${t}.\nActual:   ${a}.\nExpected: ${i}.`)}"undefined"!=typeof expect&&expect().nothing()}function CR(e,t){e().then((()=>t.fail()),(()=>t())),"undefined"!=typeof expect&&expect().nothing()}function TR(e,t){let n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return pk(e)||pk(e[0])||pk(t)||pk(t[0])?NR(e,n,((e,t)=>e==t)):NR(e,t,((e,t)=>ER(e,t,0)))}function $R(e,t,n){if(null==n&&(n=IR()),!ER(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!=typeof expect&&expect().nothing()}function ER(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function _R(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function AR(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let a=0;a<r.length;a++)if(n[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`)}function RR(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?RR(n):e[t]=DC(n)}return e}function FR(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise((e=>{t.addEventListener("loadeddata",(n=>e(t))),t.load()}))}async function DR(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise((t=>{e.requestVideoFrameCallback(t)}))}var MR=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);let i=a||Math.random();this.random=vR.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,i;do{r=2*this.random()-1,a=2*this.random()-1,i=r*r+a*a}while(i>=1||0===i);let o=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*r*o,t=this.mean+this.stdDev*a*o,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},OR=DT({randomGamma_:function(e,t,n=1,r="float32",a){if(Nk(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);let i=new class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let a=r||Math.random();this.randu=vR.alea(a.toString()),this.randn=new MR(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,i;for(;;){do{r=this.randn.nextValue(),i=1+this.c*r}while(i<=0);if(i*=i*i,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-i+Math.log(i)),a=this.randu(),a<t||Math.log(a)<n)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}(t,n,r,a),o=D$(e,r);for(let s=0;s<o.values.length;s++)o.values[s]=i.nextValue();return o.toTensor()}}),zR=DT({randomNormal_:function(e,t=0,n=1,r,a){if(Nk(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);let i=new MR(t,n,r,!1,a),o=D$(e,r);for(let s=0;s<o.values.length;s++)o.values[s]=i.nextValue();return o.toTensor()}}),PR=DT({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return zR(e,0,1,t,n)}}),LR=DT({randomUniform_:function(e,t=0,n=1,r="float32",a){Nk(e);let i=D$(e,r),o=new class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=vR.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}(t,n,null,a);for(let s=0;s<i.values.length;s++)i.values[s]=o.nextValue();return i.toTensor()}}),BR=DT({randomUniformInt_:function(e,t,n,r){return LR(e,t,n,"int32",r)}});function WR(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");let a={start:e,stop:t,step:n,dtype:r};return xT.runKernel(YI,{},a)}var VR=DT({real_:function(e){let t={input:AT(e,"input","real")};return xT.runKernel(QI,t)}}),UR=DT({reciprocal_:function(e){let t={x:AT(e,"x","reciprocal")};return xT.runKernel(ZI,t)}}),jR=DT({relu_:function(e){let t={x:AT(e,"x","relu")};return xT.runKernel(JI,t)}}),HR=DT({relu6_:function(e){let t={x:AT(e,"x","relu6")};return xT.runKernel(iN,t)}}),GR=DT({reverse_:function(e,t){let n={x:AT(e,"x","reverse")},r={dims:t};return xT.runKernel(oN,n,r)}}),qR=DT({reverse1d_:function(e){let t=AT(e,"x","reverse");return Uw(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),GR(t,0)}}),KR=DT({reverse2d_:function(e,t){let n=AT(e,"x","reverse");return Uw(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),GR(n,t)}}),XR=DT({reverse3d_:function(e,t){let n=AT(e,"x","reverse");return Uw(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),GR(n,t)}}),YR=DT({reverse4d_:function(e,t){let n=AT(e,"x","reverse");return Uw(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),GR(n,t)}}),QR=DT({round_:function(e){let t={x:AT(e,"x","round")};return xT.runKernel(sN,t)}}),ZR=DT({rsqrt_:function(e){let t={x:AT(e,"x","rsqrt","float32")};return xT.runKernel(lN,t)}}),JR=DT({selu_:function(e){let t={x:AT(e,"x","selu")};return xT.runKernel(hN,t)}}),eF=DT({separableConv2d_:function(e,t,n,r,a,i=[1,1],o="NHWC"){let s=AT(e,"x","separableConv2d"),l=AT(t,"depthwiseFilter","separableConv2d"),u=AT(n,"pointwiseFilter","separableConv2d"),d=s,c=!1;if(3===s.rank&&(c=!0,d=zE(s,[1,s.shape[0],s.shape[1],s.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Uw(4===d.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${d.rank}.`)),Uw(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),Uw(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),Uw(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),Uw(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));let p=l.shape[2],h=l.shape[3];Uw(u.shape[2]===p*h,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*h}, but got ${u.shape[2]}.`));let f=k_(d,l,r,a,o,i),m=u_(f,u,1,"valid",o);return c?zE(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),tF=async function(e,t){let n=AT(e,"x","setdiff1d"),r=AT(t,"y","setdiff1d");Uw(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),Uw(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),Uw(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));let a=await n.data(),i=await r.data(),o=new Set(i),s=0;for(let d=0;d<a.length;d++)o.has(a[d])||s++;let l=new KC([s],n.dtype),u=new KC([s],"int32");for(let d=0,c=0;d<a.length;d++)o.has(a[d])||(l.values[c]=a[d],u.values[c]=d,c++);return[l.toTensor(),u.toTensor()]},nF=DT({sign_:function(e){let t={x:AT(e,"x","sign")};return xT.runKernel(bN,t)}}),rF=DT({sin_:function(e){let t={x:AT(e,"x","sin","float32")};return xT.runKernel(mN,t)}}),aF=DT({sinh_:function(e){let t={x:AT(e,"x","sinh")};return xT.runKernel(gN,t)}}),iF=DT({slice1d_:function(e,t,n){let r=AT(e,"x","slice1d");return Uw(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),UE(r,[t],[n])}}),oF=DT({slice2d_:function(e,t,n){let r=AT(e,"x","slice2d");return Uw(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),UE(r,t,n)}}),sF=DT({slice3d_:function(e,t,n){let r=AT(e,"x","slice3d");return Uw(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),UE(r,t,n)}}),lF=DT({slice4d_:function(e,t,n){let r=AT(e,"x","slice4d");return Uw(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),UE(r,t,n)}}),uF=DT({softmax_:function(e,t=-1){let n=AT(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},a={dim:t};return xT.runKernel(IN,r,a)}}),dF=DT({fft_:function(e){Uw("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));let t={input:e};return xT.runKernel(US,t)}}),cF=DT({ifft_:function(e){Uw("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));let t={input:e};return xT.runKernel(eI,t)}}),pF=DT({irfft_:function(e){let t,n=e.shape[e.shape.length-1],r=e.size/n;if(n<=2){let a=zE(e,[r,n]);t=cF(a)}else{let a=[r,2*(n-1)],i=zE(VR(e),[r,n]),o=zE(cA(e),[r,n]),s=GR(UE(i,[0,1],[r,n-2]),1),l=lE(GR(UE(o,[0,1],[r,n-2]),1),X_(-1)),u=BE([i,s],1),d=BE([o,l],1),c=zE(MT(u,d),[a[0],a[1]]);t=cF(c)}if(t=VR(t),3===e.rank&&0!==e.shape[0]){let n=t,r=e.shape[0];t=zE(t,[r,t.shape[0]/r,t.shape[1]]),n.dispose()}return t}}),hF=DT({split_:function(e,t,n=0){let r={x:AT(e,"x","split")},a={numOrSizeSplits:t,axis:n};return xT.runKernel(SN,r,a)}}),fF=DT({rfft_:function(e,t){Uw("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n,r=e.shape[e.shape.length-1],a=e.size/r;if(null!=t&&t<r){let a=e.shape.map((e=>0)),i=e.shape.map((e=>e));i[e.shape.length-1]=t,n=UE(e,a,i),r=t}else if(null!=t&&t>r){let a=e.shape.map((e=>e));a[e.shape.length-1]=t-r,n=BE([e,qA(a)],e.shape.length-1),r=t}else n=e;let i=A_(n),o=zE(MT(n,i),[a,r]),s=dF(o),l=Math.floor(r/2)+1,u=VR(s),d=cA(s),c=hF(u,[l,r-l],u.shape.length-1),p=hF(d,[l,r-l],d.shape.length-1),h=n.shape.slice();return h[n.shape.length-1]=l,zE(MT(c[0],p[0]),h)}}),mF=DT({squaredDifference_:function(e,t){let n=AT(e,"a","squaredDifference"),r=AT(t,"b","squaredDifference");[n,r]=cT(n,r),$_(n.shape,r.shape);let a={a:n,b:r};return xT.runKernel(_N,a,{})}}),gF=DT({squeeze_:function(e,t){let n=AT(e,"x","squeeze","string_or_numeric");return zE(n,ak(n.shape,t).newShape)}}),bF=DT({stack_:function(e,t=0){let n=RT(e,"tensors","stack","string_or_numeric");Uw(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Uw(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));let r=n,a={axis:t};return xT.runKernel(WI,r,a)}}),yF=DT({step_:function(e,t=0){let n={x:AT(e,"x","step")},r={alpha:t};return xT.runKernel(XN,n,r)}}),vF=DT({stridedSlice_:function(e,t,n,r,a=0,i=0,o=0,s=0,l=0){let u={x:AT(e,"x","stridedSlice","string_or_numeric")},d={begin:t,end:n,strides:r,beginMask:a,endMask:i,ellipsisMask:o,newAxisMask:s,shrinkAxisMask:l};return xT.runKernel(FN,u,d)}}),xF=DT({tan_:function(e){let t={x:AT(e,"x","tan","float32")};return xT.runKernel(PN,t)}});function wF(e,t){Hw(e);let n=$T(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return OT(e,null,n,t)}function kF(e,t,n){if(Hw(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");let r=$T(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return OT(e,t,r,n)}function SF(e,t,n){if(Hw(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");let r=$T(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return OT(e,t,r,n)}function IF(e,t,n){if(Hw(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");let r=$T(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return OT(e,t,r,n)}function NF(e,t,n){if(Hw(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");let r=$T(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return OT(e,t,r,n)}function CF(e,t,n){if(Hw(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");let r=$T(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return OT(e,t=t||r,r,n)}var TF={};function $F(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(i+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(i+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(i+" update.rank != "+(a+e.length-r));for(let o=0;o<a;++o)if(n.shape[o]!==t.shape[o])throw new Error(i+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<n.rank-a;++o)if(n.shape[o+a]!==e[o+r])throw new Error(i+` updates.shape[${o+a}] (${n.shape[o+a]}) != shape[${o+a}] (${e[o+a]})`)}function EF(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}$F(n,t,e)}function _F(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,i=n.length,o=1;for(let l=a;l<i;++l)o*=n[l];let s=a<1?1:a;return{sliceRank:a,numUpdates:Gw(t.shape)/s,sliceSize:o,strides:[...yk(n.slice(0,a)),1],outputSize:Gw(n)}}uw(TF,{calculateShapes:()=>_F,validateInput:()=>EF,validateUpdateShape:()=>$F});var AF=DT({tensorScatterUpdate_:function(e,t,n){let r=AT(e,"tensor","tensorScatterupdate"),a=AT(t,"indices","tensorScatterupdate","int32"),i=AT(n,"updates","tensorScatterupdate");if(EF(i,a,r.shape),r.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${i.dtype}.`);let o={tensor:r,indices:a,updates:i};return xT.runKernel(dN,o,{})}}),RF=DT({topk_:function(e,t=1,n=!0){let r=AT(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let i={x:r},o={k:t,sorted:n},[s,l]=xT.runKernel(WN,i,o);return{values:s,indices:l}}}),FF=DT({truncatedNormal_:function(e,t=0,n=1,r,a){if(Nk(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");let i=new MR(t,n,r,!0,a),o=D$(e,r);for(let s=0;s<o.values.length;s++)o.values[s]=i.nextValue();return o.toTensor()}}),DF=DT({unique_:function(e,t=0){let n=AT(e,"x","unique","string_or_numeric");Uw(n.rank>0,(()=>"The input tensor must be at least 1D"));let r={x:n},a={axis:t},[i,o]=xT.runKernel(jN,r,a);return{values:i,indices:o}}}),MF=DT({unsortedSegmentSum_:function(e,t,n){let r=AT(e,"x","unsortedSegmentSum"),a=AT(t,"segmentIds","unsortedSegmentSum","int32");Uw(Yw(n),(()=>"numSegments must be of dtype int"));let i={x:r,segmentIds:a},o={numSegments:n};return xT.runKernel(GN,i,o)}}),OF=DT({unstack_:function(e,t=0){let n=AT(e,"x","unstack","string_or_numeric");Uw(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));let r={value:n},a={axis:t};return xT.runKernel(HN,r,a)}});function zF(e,t){return BA(e,t,"right")}function PF(e,t=!0,n,r){return xT.makeVariable(e,t,n,r)}function LF(e,t){let n=[];for(let i=0;i<t.length;i++)t[i]&&n.push(i);let r=D$(e,"int32"),a=D$([n.length,e.length],"int32");for(let i=0;i<n.length;i++){let t=r.indexToLoc(n[i]),o=i*e.length;a.values.set(t,o)}return a.toTensor()}var BF=async function(e){let t=AT(e,"condition","whereAsync","bool"),n=await t.data(),r=LF(t.shape,n);return e!==t&&t.dispose(),r},WF=async function(e,t,n){let r=AT(e,"tensor","boolMask"),a=AT(t,"mask","boolMask","bool"),i=null==n?0:n,o=a.rank,s=r.shape;Uw(o>0,(()=>"mask cannot be scalar")),jw(s.slice(i,i+o),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=i;m<i+o;m++)l*=s[m];let u=s.slice(0,i).concat([l],s.slice(i+o)),d=zE(r,u),c=zE(a,[-1]),p=await BF(c),h=gF(p,[1]),f=lA(d,h,i);return e!==r&&r.dispose(),t!==a&&a.dispose(),h.dispose(),d.dispose(),c.dispose(),p.dispose(),f},VF=DT({transpose_:function(e,t,n){let r=AT(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),Uw(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{Uw(e>=0&&e<r.rank,(()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`))})),r.rank<=1)return r.clone();let a={x:r},i={perm:t};return"complex64"===r.dtype?G$((()=>{let e=VR(r),t=cA(r);return e=xT.runKernel(UN,{x:e},i),t=xT.runKernel(UN,{x:t},i),n&&(t=EA(t)),MT(e,t)})):xT.runKernel(UN,a,i)}}),UF=DT({movingAverage_:function(e,t,n,r,a=!0){let i=AT(e,"v","movingAverage"),o=AT(t,"x","movingAverage"),s=AT(n,"decay","movingAverage");pT(i,o),Uw(Xw(i.shape,o.shape),(()=>"Shape mismatch in v and x"));let l=X_(1),u=RA(l,s),d=lE(RA(o,i),u);if(a){Uw(null!=r,(()=>"When using zeroDebias: true, step is required."));let e=AT(r,"step","movingAverage");d=sE(d,RA(l,K_(s,e)))}return iE(i,d)}}),jF=DT({scatterND_:function(e,t,n){Nk(n);let r=AT(e,"indices","scatterND","int32"),a=AT(t,"updates","scatterND");EF(a,r,n);let i={indices:r,updates:a},o={shape:n};return xT.runKernel(uN,i,o)}}),HF=DT({sparseToDense_:function(e,t,n,r=0){Nk(n);let a=AT(e,"sparseIndices","sparseToDense","int32"),i=AT(t,"sparseValues","sparseToDense","string_or_numeric"),o=AT(r,"defaultValue","sparseToDense",i.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let a=e.rank>0?e.shape[0]:1,i=e.rank>1?e.shape[1]:1;if(n.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${i}.`);let o=t.size;if(0!==t.rank&&(1!==t.rank||o!==a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(a,i,n,o);let s={sparseIndices:a,sparseValues:i,defaultValue:o},l={outputShape:n};return xT.runKernel(EN,s,l)}}),GF=DT({gatherND_:function(e,t){let n=AT(t,"indices","gatherND","int32"),r={params:AT(e,"x","gatherND","string_or_numeric"),indices:n};return xT.runKernel(YS,r)}}),qF=DT({dropout_:function(e,t,n,r){let a=AT(e,"x","dropout");if(Uw("float32"===a.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`)),Uw(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof QC?a.clone():a;let i=function(e,t){if(null==t)return e.shape.slice();if(Xw(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(a,n),o=1-t,s=sE(sA(iE(LR(i,0,1,"float32",r),o)),o);return lE(a,s)}});function KF(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function XF(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let i=0;i<e;++i){let o=2*Math.PI*i/(e+r-1);a[i]=t-n*Math.cos(o)}return wF(a,"float32")}var YF=async function(e,t,n=1){let r=AT(e,"predictions","inTopK"),a=AT(t,"targets","inTopK");Uw(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),Uw(r.rank-1===a.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`)),jw(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let i=r.shape[r.shape.length-1];Uw(n>0&&n<=i,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${n}`));let o=await r.data(),s=await a.data(),[l,u]=[o.length/i,i],d=ik("bool",l);for(let c=0;c<l;c++){let e=c*u,t=o.subarray(e,e+u),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),d[c]=0;for(let a=0;a<n;a++)if(r[a].index===s[c]){d[c]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),zT(d,a.shape,"bool")},QF={};uw(QF,{conv2d:()=>rD,depthwiseConv2d:()=>oD,matMul:()=>sD});var ZF=DT({conv2DBackpropFilter_:function(e,t,n,r,a,i="NHWC",o){let s=e;3===e.rank&&(s=zE(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=zE(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Uw(4===s.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${s.shape}.`)),Uw(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),Uw(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));let u="NHWC"===i?s.shape[3]:s.shape[1],d="NHWC"===i?l.shape[3]:l.shape[1];Uw(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),Uw(d===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${d}) must match output depth for filter (${n[3]}).`)),OE("conv2dDerFilter",a,o);let c={x:s,dy:l},p={strides:r,pad:a,dataFormat:i,dimRoundingMode:o,filterShape:n};return xT.runKernel(fS,c,p)}});function JF(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return lE(e,yF(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function eD(e,t){let n=t,r=T_(e.shape,t.shape);return r.length>0&&(n=Z_(n,r)),zE(n,e.shape)}function tD(e,t,n,r){if("linear"===t)return e;if("relu"===t)return jR(e);if("elu"===t)return M_(e);if("relu6"===t)return HR(e);if("prelu"===t)return hR(e,n);if("leakyrelu"===t)return mA(e,r);if("sigmoid"===t)return VE(e);throw new Error(`Unknown fused activation ${t}.`)}var nD=(e,t)=>!(e>0)||"linear"===t,rD=DT({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:s,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:d}){if(l=l||"linear",!1===nD(xT.state.gradientDepth,l)){Uw("NHWC"===a,(()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let c=u_(e,t,n,r,a,i,o);return null!=s&&(c=iE(c,s)),tD(c,l,u,d)}let c=AT(e,"x","conv2d","float32"),p=AT(t,"filter","conv2d","float32"),h=c,f=!1;3===c.rank&&(f=!0,h=zE(c,[1,c.shape[0],c.shape[1],c.shape[2]])),Uw(4===h.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`)),Uw(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),OE("fused conv2d",r,o);let m="NHWC"===a?h.shape[3]:h.shape[1];Uw(p.shape[2]===m,(()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${p.shape[2]}.`)),Uw(FE(n,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`));let g,b,y=NE(h.shape,p.shape,n,i,r,o);if(null!=s&&(g=AT(s,"bias","fused conv2d"),[g]=cT(g,c),"NHWC"===a?$_(y.outShape,g.shape):(Uw(g.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${g.shape.length}.`)),Uw(0===g.shape.length||g.shape[0]===y.outChannels||1===g.shape[0],(()=>`Error in fused conv2d: bias shape (${g.shape}) is not compatible with the number of output channels (${y.outChannels})`)))),null!=u){let e=u.shape;if(Uw(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)Uw(1===e[0]||e[0]===y.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${y.outChannels}).`));else if(3===e.length)try{$_(e,y.outShape)}catch(vn){let n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(n)}b=AT(u,"prelu weights","fused conv2d")}let v=(e,t)=>{Uw("NHWC"===a,(()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`));let[o,s,u,d]=t,c=JF(e,u,l);Uw(RE(i),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`));let p=[c_(s.shape,c,o,n,r),ZF(s,c,o.shape,n,r)];if(null!=d){let e=eD(d,c);p.push(e)}return p},x={x:h,filter:p,bias:g,preluActivationWeights:b},w={strides:n,pad:r,dataFormat:a,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:d};return null==s?TA(((e,t,n)=>{let r=xT.runKernel(JN,x,w);return n([t,e,r]),f&&(r=zE(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}))(h,p):TA(((e,t,n,r)=>{let a=xT.runKernel(JN,x,w);return r([t,e,a,n]),f&&(a=zE(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}))(h,p,g)}}),aD=DT({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,a,i=[1,1],o){let s=e;3===e.rank&&(s=zE(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=zE(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:s,dy:l},d={strides:r,pad:a,dimRoundingMode:o,dilations:i,filterShape:n};return xT.runKernel(TS,u,d)}}),iD=DT({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,a,i=[1,1],o){let s=t,l=!1;3===t.rank&&(l=!0,s=zE(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:s,filter:n},d={strides:r,pad:a,dimRoundingMode:o,dilations:i,inputShape:e},c=xT.runKernel($S,u,d);return l?zE(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),oD=DT({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:s,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:d}){if(!1===nD(xT.state.gradientDepth,l)){let c=k_(e,t,n,r,a,i,o);return null!=s&&(c=iE(c,s)),tD(c,l,u,d)}let c=AT(e,"x","depthwiseConv2d","float32"),p=AT(t,"filter","depthwiseConv2d","float32"),h=c,f=!1;3===c.rank&&(f=!0,h=zE(c,[1,c.shape[0],c.shape[1],c.shape[2]])),Uw(4===h.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`)),Uw(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),Uw(h.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==i&&(i=[1,1]),Uw(FE(n,i),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`)),OE("fused depthwiseConv2d",r,o);let m,g,b=NE(h.shape,p.shape,n,i,r,o,!0);null!=s&&(m=AT(s,"bias","fused conv2d"),[m]=cT(m,c),$_(b.outShape,m.shape)),null!=u&&(g=AT(u,"prelu weights","fused depthwiseConv2d"));let y=(e,t)=>{Uw(RE(i),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));let[a,s,u,d]=t,c=JF(e,u,l),p=iD(s.shape,c,a,n,r,i,o),h=aD(s,c,a.shape,n,r,i,o);return null!=d?[p,h,eD(m,c)]:[p,h]},v={x:h,filter:p,bias:m,preluActivationWeights:g},x={strides:n,pad:r,dataFormat:a,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:d};return null==s?TA(((e,t,n)=>{let r=xT.runKernel(eC,v,x);return n([t,e,r]),f&&(r=zE(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:y}}))(h,p):TA(((e,t,n,r)=>{let a=xT.runKernel(eC,v,x);return r([t,e,a,n]),f&&(a=zE(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:y}}))(h,p,m)}}),sD=DT({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:a,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:s=.2}){if(!1===nD(xT.state.gradientDepth,i)){let l=WE(e,t,n,r);return null!=a&&(l=iE(l,a)),tD(l,i,o,s)}let l=AT(e,"a","fused matMul"),u=AT(t,"b","fused matMul");[l,u]=cT(l,u);let d=n?l.shape[l.rank-2]:l.shape[l.rank-1],c=r?u.shape[u.rank-1]:u.shape[u.rank-2],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],h=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=Gw(f),b=Gw(m);Uw(d===c,(()=>`Error in fused matMul: inner shapes (${d}) and (${c}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`));let y,v,x=$_(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,h]),w=zE(l,n?[g,d,p]:[g,p,d]),k=zE(u,r?[b,h,c]:[b,c,h]);null!=a&&(y=AT(a,"bias","fused matMul"),[y]=cT(y,l),$_(x,y.shape)),null!=o&&(v=AT(o,"prelu weights","fused matMul"));let S=(e,t)=>{let o,s,[l,u,d,c]=t,p=JF(zE(e,d.shape),d,i);return n||r?!n&&r?(o=WE(p,u,!1,!1),s=WE(p,l,!0,!1)):n&&!r?(o=WE(u,p,!1,!0),s=WE(l,p,!1,!1)):(o=WE(u,p,!0,!0),s=WE(p,l,!0,!0)):(o=WE(p,u,!1,!0),s=WE(l,p,!0,!1)),null!=a?[o,s,eD(c,p)]:[o,s]},I={a:w,b:k,bias:y,preluActivationWeights:v},N={transposeA:n,transposeB:r,activation:i,leakyreluAlpha:s};return null==a?TA(((e,t,n)=>{let r=xT.runKernel(ZN,I,N);return n([e,t,r]),{value:zE(r,x),gradFunc:S}}))(w,k):TA(((e,t,n,r)=>{let a=xT.runKernel(ZN,I,N);return r([e,t,a,n]),{value:zE(a,x),gradFunc:S}}))(w,k,y)}}),lD=DT({hammingWindow_:function(e){return XF(e,.54,.46)}}),uD=DT({hannWindow_:function(e){return XF(e,.5,.5)}}),dD=DT({frame_:function(e,t,n,r=!1,a=0){let i=0,o=[];for(;i+t<=e.size;)o.push(UE(e,i,t)),i+=n;if(r)for(;i<e.size;){let r=i+t-e.size,s=BE([UE(e,i,t-r),r_([r],a)]);o.push(s),i+=n}return 0===o.length?kF([],[0,t]):zE(BE(o),[o.length,t])}}),cD=DT({stft_:function(e,t,n,r,a=uD){null==r&&(r=KF(t));let i=dD(e,t,n),o=lE(i,a(t));return fF(o,r)}}),pD=DT({cropAndResize_:function(e,t,n,r,a="bilinear",i=0){let o=AT(e,"image","cropAndResize"),s=AT(t,"boxes","cropAndResize","float32"),l=AT(n,"boxInd","cropAndResize","int32"),u=s.shape[0];Uw(4===o.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`)),Uw(2===s.rank&&4===s.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${s.shape}.`)),Uw(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${s.shape}.`)),Uw(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),Uw(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),Uw("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));let d={image:o,boxes:s,boxInd:l},c={method:a,extrapolationValue:i,cropSize:r};return xT.runKernel(SS,d,c)}}),hD=DT({flipLeftRight_:function(e){let t=AT(e,"image","flipLeftRight","float32");Uw(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));let n={image:t};return xT.runKernel(HS,n,{})}}),fD=DT({grayscaleToRGB_:function(e){let t=AT(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Uw(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),Uw(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));let a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,iA(t,a)}}),mD=DT({rotateWithOffset_:function(e,t,n=0,r=.5){let a=AT(e,"image","rotateWithOffset","float32");Uw(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));let i={image:a},o={radians:t,fillValue:n,center:r};return xT.runKernel(QN,i,o)}});function gD(e,t,n,r,a,i){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==i&&(i=0);let o=e.shape[0];return n=Math.min(n,o),Uw(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),Uw(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),Uw(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),Uw(1===t.rank,(()=>"scores must be a 1D tensor")),Uw(t.shape[0]===o,(()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`)),Uw(0<=i&&i<=1,(()=>`softNmsSigma must be in [0, 1], but was '${i}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:i}}var bD=DT({nonMaxSuppression_:function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let i=AT(e,"boxes","nonMaxSuppression","float32"),o=AT(t,"scores","nonMaxSuppression","float32"),s=gD(i,o,n,r,a),l={maxOutputSize:n=s.maxOutputSize,iouThreshold:r=s.iouThreshold,scoreThreshold:a=s.scoreThreshold};return xT.runKernel(OI,{boxes:i,scores:o},l)}});function yD(e,t,n){let r=function(e,t,n){return function(e,t,n){let r=0,a=e.length,i=0,o=!1;for(;r<a;){i=r+(a-r>>>1);let s=n(t,e[i]);s>0?r=i+1:(a=i,o=!s)}return o?r:-r-1}(e,t,n||vD)}(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function vD(e,t){return e>t?1:e<t?-1:0}function xD(e,t,n,r,a){return SD(e,t,n,r,a,0)}function wD(e,t,n,r,a,i){return SD(e,t,n,r,a,0,!1,i,!0)}function kD(e,t,n,r,a,i){return SD(e,t,n,r,a,i,!0)}function SD(e,t,n,r,a,i,o=!1,s=!1,l=!1){let u=[];for(let g=0;g<t.length;g++)t[g]>a&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(CD);let d=i>0?-.5/i:0,c=[],p=[];for(;c.length<n&&u.length>0;){let t=u.pop(),{score:n,boxIndex:i,suppressBeginIndex:o}=t;if(n<a)break;let s=!1;for(let l=c.length-1;l>=o;--l){let n=ID(e,i,c[l]);if(n>=r){s=!0;break}if(t.score=t.score*ND(r,d,n),t.score<=a)break}t.suppressBeginIndex=c.length,s||(t.score===n?(c.push(i),p.push(t.score)):t.score>a&&yD(u,t,CD))}let h=c.length,f=n-h;s&&f>0&&(c.push(...new Array(f).fill(0)),p.push(...new Array(f).fill(0)));let m={selectedIndices:c};return o&&(m.selectedScores=p),l&&(m.validOutputs=h),m}function ID(e,t,n){let r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),i=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),s=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),d=Math.min(a[1],a[3]),c=Math.max(a[0],a[2]),p=Math.max(a[1],a[3]),h=(s-i)*(l-o),f=(c-u)*(p-d);if(h<=0||f<=0)return 0;let m=Math.max(i,u),g=Math.max(o,d),b=Math.min(s,c),y=Math.min(l,p),v=Math.max(b-m,0)*Math.max(y-g,0);return v/(h+f-v)}function ND(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function CD(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}var TD=async function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let i=AT(e,"boxes","nonMaxSuppressionAsync"),o=AT(t,"scores","nonMaxSuppressionAsync"),s=gD(i,o,n,r,a);n=s.maxOutputSize,r=s.iouThreshold,a=s.scoreThreshold;let l=await Promise.all([i.data(),o.data()]),u=l[0],d=l[1],{selectedIndices:c}=xD(u,d,n,r,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),wF(c,"int32")},$D=DT({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,i=0){let o=AT(e,"boxes","nonMaxSuppression"),s=AT(t,"scores","nonMaxSuppression"),l=gD(o,s,n,r,a,i),u={boxes:o,scores:s},d={maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:a=l.scoreThreshold,softNmsSigma:i=l.softNmsSigma},c=xT.runKernel(PI,u,d);return{selectedIndices:c[0],selectedScores:c[1]}}}),ED=async function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,i=0){let o=AT(e,"boxes","nonMaxSuppressionAsync"),s=AT(t,"scores","nonMaxSuppressionAsync"),l=gD(o,s,n,r,a,i);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,i=l.softNmsSigma;let u=await Promise.all([o.data(),s.data()]),d=u[0],c=u[1],{selectedIndices:p,selectedScores:h}=kD(d,c,n,r,a,i);return o!==e&&o.dispose(),s!==t&&s.dispose(),{selectedIndices:wF(p,"int32"),selectedScores:wF(h)}},_D=DT({nonMaxSuppressionPadded_:function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,i=!1){let o=AT(e,"boxes","nonMaxSuppression"),s=AT(t,"scores","nonMaxSuppression"),l=gD(o,s,n,r,a,null),u={boxes:o,scores:s},d={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:i},c=xT.runKernel(zI,u,d);return{selectedIndices:c[0],validOutputs:c[1]}}}),AD=async function(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,i=!1){let o=AT(e,"boxes","nonMaxSuppressionAsync"),s=AT(t,"scores","nonMaxSuppressionAsync"),l=gD(o,s,n,r,a,null),u=l.maxOutputSize,d=l.iouThreshold,c=l.scoreThreshold,[p,h]=await Promise.all([o.data(),s.data()]),{selectedIndices:f,validOutputs:m}=wD(p,h,u,d,c,i);return o!==e&&o.dispose(),s!==t&&s.dispose(),{selectedIndices:wF(f,"int32"),validOutputs:X_(m,"int32")}},RD=DT({resizeBilinear_:function(e,t,n=!1,r=!1){let a=AT(e,"images","resizeBilinear");Uw(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),Uw(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),Uw(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let i=a,o=!1;3===a.rank&&(o=!0,i=zE(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let s={images:i},l={alignCorners:n,halfPixelCenters:r,size:t},u=xT.runKernel(rN,s,l);return o?zE(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),FD=DT({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){let a=AT(e,"images","resizeNearestNeighbor");Uw(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),Uw(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),Uw("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Uw(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let i=a,o=!1;3===a.rank&&(o=!0,i=zE(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let s={images:i},l={alignCorners:n,halfPixelCenters:r,size:t},u=xT.runKernel(tN,s,l);return o?zE(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),DD=DT({threshold_:function(e,t="binary",n=!1,r=.5){let a,i,o,s,l=AT(e,"image","threshold"),u=l.shape[0]*l.shape[1],d=lE(wF([r]),255);if(Uw(3===l.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${l.rank}.`)),Uw(3===l.shape[2]||1===l.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${l.shape[2]}.`)),Uw("int32"===l.dtype||"float32"===l.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${l.dtype}.`)),Uw("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===l.shape[2]){[a,i,o]=hF(l,[1,1,1],-1);let e=lE(a,.2989),t=lE(i,.587),n=lE(o,.114);s=iE(iE(e,t),n)}else s=e;"otsu"===t&&(d=function(e,t){let n,r,a,i,o,s,l=wF([-1]),u=wF([0]),d=wF([0]);for(let c=0;c<e.size-1;c++){n=UE(e,0,c+1),r=UE(e,c+1),o=sE(Z_(n),t),s=sE(Z_(r),t);let p=Z_(lE(n,WR(0,n.size)));a=sE(p,Z_(n));let h=r_(r.shape,n.size),f=iE(WR(0,r.size),h),m=lE(r,f);i=sE(Z_(m),Z_(r));let g=RA(a,i),b=RA(a,i),y=lE(o,s);d=lE(lE(y,g),b);let v=uA(d,u);u=__(v,d,u),l=__(v,wF([c]),l)}return l}(ZE(M$(QR(s),"int32"),zT([]),256),u));let c=n?bA(s,d):uA(s,d);return M$(lE(c,255),"int32")}}),MD=DT({transform_:function(e,t,n="nearest",r="constant",a=0,i){let o=AT(e,"image","transform","float32"),s=AT(t,"transforms","transform","float32");Uw(4===o.rank,(()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`)),Uw(2===s.rank&&(s.shape[0]===o.shape[0]||1===s.shape[0])&&8===s.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Uw(null==i||2===i.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`));let l={image:o,transforms:s},u={interpolation:n,fillMode:r,fillValue:a,outputShape:i};return xT.runKernel(VN,l,u)}}),OD=DT({bandPart_:function(e,t,n){let r=AT(e,"a","bandPart");Uw(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));let a,i,o=r.shape,[s,l]=r.shape.slice(-2);"number"==typeof t?(Uw(t%1==0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),Uw(t<=s,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`)),a=AT(t<0?s:t,"numLower","bandPart")):(Uw("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),a=__(gA(t,0),s,YA(t,s))),"number"==typeof n?(Uw(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),Uw(n<=l,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${l}).`)),i=AT(n<0?l:n,"numUpper","bandPart")):(Uw("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),i=__(gA(n,0),l,YA(n,l)));let u=zE(WR(0,s,1,"int32"),[-1,1]),d=WR(0,l,1,"int32"),c=RA(u,d),p=MA(bA(c,a),dA(c,EA(i))),h=qA([s,l],r.dtype);return zE(bF(OF(zE(r,[-1,s,l])).map((e=>__(p,e,h)))),o)}}),zD=DT({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Uw(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));let n=e[0].shape[0];for(let t=1;t<e.length;++t)Uw(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=hF(e,e.shape[0],0).map((e=>gF(e,[0])));Uw(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));let n=[],r=e;for(let a=0;a<e.length;++a)n.push(xT.tidy((()=>{let e=r[a];if(a>0)for(let t=0;t<a;++t){let r=lE(Z_(lE(n[t],e)),n[t]);e=RA(e,r)}return sE(e,eA(e,"euclidean"))})));return t?bF(n,0):n}});function PD(e,t=!1){return xT.tidy((()=>{Uw(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));let n=e.shape[0],r=e.shape[1],a=oA(n),i=O$(e),o=kF([[1]],[1,1]),s=O$(o),l=n>=r?r:n;for(let e=0;e<l;++e){let t=i,l=s,u=a;[s,i,a]=xT.tidy((()=>{let t=UE(i,[e,e],[n-e,1]),l=eA(t),u=UE(i,[e,e],[1,1]),d=__(uA(u,0),kF([[-1]]),kF([[1]])),c=RA(u,lE(d,l)),p=sE(t,c);s=1===p.shape[0]?O$(o):BE([o,UE(p,[1,0],[p.shape[0]-1,p.shape[1]])],0);let h=EA(sE(WE(d,c),l)),f=UE(i,[e,0],[n-e,r]),m=lE(h,s),g=VF(s);if(0===e)i=RA(f,WE(m,WE(g,f)));else{let t=RA(f,WE(m,WE(g,f)));i=BE([UE(i,[0,0],[e,r]),t],0)}let b=VF(m),y=UE(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=RA(y,WE(WE(y,s),b));else{let t=RA(y,WE(WE(y,s),b));a=BE([UE(a,[0,0],[n,e]),t],1)}return[s,i,a]})),q$([t,l,u])}return!t&&n>r&&(a=UE(a,[0,0],[n,r]),i=UE(i,[0,0],[r,r])),[a,i]}))}var LD,BD=DT({qr_:function(e,t=!1){if(Uw(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return PD(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=OF(zE(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],i=[];return r.forEach((e=>{let[n,r]=PD(e,t);a.push(n),i.push(r)})),[zE(bF(a,0),e.shape),zE(bF(i,0),e.shape)]}}});!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(LD||(LD={}));var WD=DT({computeWeightedLoss_:function(e,t,n=LD.SUM_BY_NONZERO_WEIGHTS){let r=AT(e,"losses","computeWeightedLoss"),a=null;null!=t&&(a=AT(t,"weights","computeWeightedLoss"));let i=null==a?r:lE(r,a);if(n===LD.NONE)return i;if(n===LD.SUM)return Z_(i);if(n===LD.MEAN){if(null==a)return GA(i);{let e=r.size/a.size,t=sE(Z_(i),Z_(a));return e>1?sE(t,X_(e)):t}}if(n===LD.SUM_BY_NONZERO_WEIGHTS){if(null==a)return sE(Z_(i),X_(r.size));{let e=lE(a,KA(r.shape)),t=M$(Z_(nR(e,X_(0))),"float32");return sE(Z_(i),t)}}throw Error(`Unknown reduction: ${n}`)}}),VD=DT({absoluteDifference_:function(e,t,n,r=LD.SUM_BY_NONZERO_WEIGHTS){let a=AT(e,"labels","absoluteDifference"),i=AT(t,"predictions","absoluteDifference"),o=null;null!=n&&(o=AT(n,"weights","absoluteDifference")),jw(a.shape,i.shape,"Error in absoluteDifference: ");let s=uE(RA(a,i));return WD(s,o,r)}}),UD=DT({cosineDistance_:function(e,t,n,r,a=LD.SUM_BY_NONZERO_WEIGHTS){let i=AT(e,"labels","cosineDistance"),o=AT(t,"predictions","cosineDistance"),s=null;null!=r&&(s=AT(r,"weights","cosineDistance")),jw(i.shape,o.shape,"Error in cosineDistance: ");let l=X_(1),u=RA(l,Z_(lE(i,o),n,!0));return WD(u,s,a)}}),jD=DT({hingeLoss_:function(e,t,n,r=LD.SUM_BY_NONZERO_WEIGHTS){let a=AT(e,"labels","hingeLoss"),i=AT(t,"predictions","hingeLoss"),o=null;null!=n&&(o=AT(n,"weights","hingeLoss")),jw(a.shape,i.shape,"Error in hingeLoss: ");let s=X_(1);a=RA(lE(X_(2),a),s);let l=jR(RA(s,lE(a,i)));return WD(l,o,r)}}),HD=DT({huberLoss_:function(e,t,n,r=1,a=LD.SUM_BY_NONZERO_WEIGHTS){let i=AT(e,"labels","huberLoss"),o=AT(t,"predictions","huberLoss"),s=null;null!=n&&(s=AT(n,"weights","huberLoss")),jw(i.shape,o.shape,"Error in huberLoss: ");let l=X_(r),u=uE(RA(o,i)),d=YA(u,l),c=RA(u,d),p=iE(lE(X_(.5),Q_(d)),lE(l,c));return WD(p,s,a)}}),GD=DT({logLoss_:function(e,t,n,r=1e-7,a=LD.SUM_BY_NONZERO_WEIGHTS){let i=AT(e,"labels","logLoss"),o=AT(t,"predictions","logLoss"),s=null;null!=n&&(s=AT(n,"weights","logLoss")),jw(i.shape,o.shape,"Error in logLoss: ");let l=X_(1),u=X_(r),d=EA(lE(i,xA(iE(o,u)))),c=lE(RA(l,i),xA(iE(RA(l,o),u))),p=RA(d,c);return WD(p,s,a)}}),qD=DT({meanSquaredError_:function(e,t,n,r=LD.SUM_BY_NONZERO_WEIGHTS){let a=AT(e,"labels","meanSquaredError"),i=AT(t,"predictions","meanSquaredError"),o=null;null!=n&&(o=AT(n,"weights","meanSquaredError")),jw(a.shape,i.shape,"Error in meanSquaredError: ");let s=mF(a,i);return WD(s,o,r)}}),KD=DT({sigmoidCrossEntropy_:function(e,t,n,r=0,a=LD.SUM_BY_NONZERO_WEIGHTS){let i=AT(e,"multiClassLabels","sigmoidCrossEntropy"),o=AT(t,"logits","sigmoidCrossEntropy"),s=null;if(null!=n&&(s=AT(n,"weights","sigmoidCrossEntropy")),jw(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){let e=X_(r),t=X_(1),n=X_(.5);i=iE(lE(i,RA(t,e)),lE(n,e))}let l=function(e,t){let n=AT(e,"labels","sigmoidCrossEntropyWithLogits"),r=AT(t,"logits","sigmoidCrossEntropyWithLogits");jw(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let a=jR(r),i=lE(r,n),o=wA(nA(EA(uE(r))));return iE(RA(a,i),o)}(i,o);return WD(l,s,a)}}),XD=DT({softmaxCrossEntropy_:function(e,t,n,r=0,a=LD.SUM_BY_NONZERO_WEIGHTS){let i=AT(e,"onehotLabels","softmaxCrossEntropy"),o=AT(t,"logits","softmaxCrossEntropy"),s=null;if(null!=n&&(s=AT(n,"weights","softmaxCrossEntropy")),jw(i.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){let e=X_(r),t=X_(1),n=X_(i.shape[1]);i=iE(lE(i,RA(t,e)),sE(e,n))}let l=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return TA(((e,t,r)=>{let a=DA(t,[n],!0),i=RA(M$(t,"float32"),a);r([e,i]);let o=EA(lE(i,e));return{value:Z_(o,[n]),gradFunc:(e,t)=>{let[r,a]=t,i=W_(e.shape,[n]);return[lE(zE(e,i),RA(M$(r,"float32"),nA(a))),lE(zE(e,i),RA(nA(a),M$(r,"float32")))]}}}))(e,t)}(i,o);return WD(l,s,a)}}),YD=DT({sparseFillEmptyRows_:function(e,t,n,r){let a=AT(e,"indices","sparseFillEmptyRows","int32"),i=AT(t,"values","sparseFillEmptyRows"),o=AT(n,"denseShape","sparseFillEmptyRows","int32"),s=AT(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==s.rank)throw new Error(`Default value should be a scalar but received shape ${s.shape}`);let l={indices:a,values:i,denseShape:o,defaultValue:s},u=xT.runKernel(NN,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),QD=DT({sparseReshape_:function(e,t,n){let r=AT(e,"inputIndices","sparseReshape","int32"),a=AT(t,"inputShape","sparseReshape","int32"),i=AT(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);let o={inputIndices:r,inputShape:a,newShape:i},s=xT.runKernel(CN,o);return{outputIndices:s[0],outputShape:s[1]}}}),ZD=DT({sparseSegmentMean_:function(e,t,n){let r=AT(e,"data","sparseSegmentMean"),a=AT(t,"indices","sparseSegmentMean","int32"),i=AT(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${i.shape}`);let o={data:r,indices:a,segmentIds:i};return xT.runKernel(TN,o)}}),JD=DT({sparseSegmentSum_:function(e,t,n){let r=AT(e,"data","sparseSegmentSum"),a=AT(t,"indices","sparseSegmentSum","int32"),i=AT(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${i.shape}`);let o={data:r,indices:a,segmentIds:i};return xT.runKernel($N,o)}}),eM=DT({stringNGrams_:function(e,t,n,r,a,i,o,s){let l=AT(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=AT(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");let d={separator:n,nGramWidths:r,leftPad:a,rightPad:i,padWidth:o,preserveShortSequences:s},c={data:l,dataSplits:u},p=xT.runKernel(DN,c,d);return{nGrams:p[0],nGramsSplits:p[1]}}}),tM=DT({stringSplit_:function(e,t,n=!0){let r=AT(e,"input","stringSplit","string"),a=AT(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);let i={skipEmpty:n},o={input:r,delimiter:a},s=xT.runKernel(MN,o,i);return{indices:s[0],values:s[1],shape:s[2]}}}),nM=DT({stringToHashBucketFast_:function(e,t){let n=AT(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let a={input:n};return xT.runKernel(ON,a,r)}}),rM=DT({staticRegexReplace_:function(e,t,n,r=!0){let a=AT(e,"input","staticRegexReplace","string"),i={pattern:t,rewrite:n,replaceGlobal:r};return xT.runKernel(RN,{x:a},i)}}),aM={fft:dF,ifft:cF,rfft:fF,irfft:pF},iM={hammingWindow:lD,hannWindow:uD,frame:dD,stft:cD},oM={flipLeftRight:hD,grayscaleToRGB:fD,resizeNearestNeighbor:FD,resizeBilinear:RD,rotateWithOffset:mD,cropAndResize:pD,nonMaxSuppression:bD,nonMaxSuppressionAsync:TD,nonMaxSuppressionWithScore:$D,nonMaxSuppressionWithScoreAsync:ED,nonMaxSuppressionPadded:_D,nonMaxSuppressionPaddedAsync:AD,threshold:DD,transform:MD},sM={bandPart:OD,gramSchmidt:zD,qr:BD},lM={absoluteDifference:VD,computeWeightedLoss:WD,cosineDistance:UD,hingeLoss:jD,huberLoss:HD,logLoss:GD,meanSquaredError:qD,sigmoidCrossEntropy:KD,softmaxCrossEntropy:XD},uM={sparseFillEmptyRows:YD,sparseReshape:QD,sparseSegmentMean:ZD,sparseSegmentSum:JD},dM={stringNGrams:eM,stringSplit:tM,stringToHashBucketFast:nM,staticRegexReplace:rM},cM={};uw(cM,{Serializable:()=>pM,SerializationMap:()=>hM,registerClass:()=>fM});var pM=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},hM=class{constructor(){this.classNameMap={}}static getMap(){return null==hM.instance&&(hM.instance=new hM),hM.instance}static register(e){hM.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function fM(e){Uw(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Uw("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Uw(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),hM.register(e)}var mM=class extends pM{minimize(e,t=!1,n){let{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){let e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return q$(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return CA(e,t)}dispose(){null!=this.iterations_&&q$(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:X_(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(mM,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});var gM=class extends mM{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=xT.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=xT.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:G$((()=>A_(r).variable(!1)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:G$((()=>A_(r).variable(!1)))});let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;G$((()=>{let e=iE(lE(i,this.rho),lE(Q_(a),1-this.rho)),t=lE(sE(Y_(iE(o,this.epsilon)),Y_(iE(i,this.epsilon))),a),n=iE(lE(o,this.rho),lE(Q_(t),1-this.rho));i.assign(e),o.assign(n);let s=iE(lE(t,-this.learningRate),r);r.assign(s)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(q$(this.accumulatedGrads.map((e=>e.variable))),q$(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){let t=(e=await this.extractIterations(e)).length/2;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},bM=class extends mM{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=xT.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:G$((()=>r_(r.shape,this.initialAccumulatorValue).variable(!1)))});let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let i=this.accumulatedGrads[n].variable;G$((()=>{let e=iE(i,Q_(a));i.assign(e);let t=iE(lE(sE(a,Y_(iE(e,xT.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&q$(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},yM=class extends mM{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],G$((()=>{this.accBeta1=X_(t).variable(),this.accBeta2=X_(n).variable()})),null==r&&(this.epsilon=xT.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);G$((()=>{let n=RA(1,this.accBeta1),r=RA(1,this.accBeta2);t.forEach(((t,a)=>{let i=xT.registeredVariables[t];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:G$((()=>A_(i).variable(!1)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:G$((()=>A_(i).variable(!1)))});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let s=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,u=iE(lE(s,this.beta1),lE(o,1-this.beta1)),d=iE(lE(l,this.beta2),lE(Q_(o),1-this.beta2)),c=sE(u,n),p=sE(d,r);s.assign(u),l.assign(d);let h=iE(lE(sE(c,iE(Y_(p),this.epsilon)),-this.learningRate),i);i.assign(h)})),this.accBeta1.assign(lE(this.accBeta1,this.beta1)),this.accBeta2.assign(lE(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&q$(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&q$(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),G$((()=>{this.accBeta1.assign(K_(this.beta1,this.iterations_+1)),this.accBeta2.assign(K_(this.beta2,this.iterations_+1))}));let t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},vM=class extends mM{static get className(){return"Adamax"}constructor(e,t,n,r=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],G$((()=>{this.iteration=X_(0).variable(),this.accBeta1=X_(t).variable()})),null==r&&(this.epsilon=xT.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);G$((()=>{let n=RA(1,this.accBeta1),r=sE(-this.learningRate,iE(lE(this.iteration,this.decay),1));t.forEach(((t,a)=>{let i=xT.registeredVariables[t];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:A_(i).variable(!1)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:A_(i).variable(!1)});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let s=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,u=iE(lE(s,this.beta1),lE(o,1-this.beta1)),d=lE(l,this.beta2),c=uE(o),p=HA(d,c);s.assign(u),l.assign(p);let h=iE(lE(sE(r,n),sE(u,iE(p,this.epsilon))),i);i.assign(h)})),this.iteration.assign(iE(this.iteration,1)),this.accBeta1.assign(lE(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&q$(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&q$(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},xM=class extends mM{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;let a=xT.registeredVariables[t];G$((()=>{let e=iE(lE(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=K$(X_(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},wM=class extends xM{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=X_(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=xT.registeredVariables[t];null==this.accumulations[n]&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:G$((()=>A_(r).variable(!1)))});let a=this.accumulations[n].variable,i=Array.isArray(e)?e[n].tensor:e[t];null!=i&&G$((()=>{let e,t=iE(lE(this.m,a),i);e=this.useNesterov?iE(lE(this.c,iE(i,lE(t,this.m))),r):iE(lE(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&q$(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},kM=class extends mM{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=xT.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=xT.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:G$((()=>A_(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:G$((()=>A_(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:G$((()=>A_(r).variable(a)))});let i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;let o=this.accumulatedMeanSquares[n].variable,s=this.accumulatedMoments[n].variable;G$((()=>{let e=iE(lE(o,this.decay),lE(Q_(i),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[n].variable,a=iE(lE(t,this.decay),lE(i,1-this.decay)),l=sE(lE(i,this.learningRate),Y_(RA(e,iE(Q_(a),this.epsilon)))),u=iE(lE(s,this.momentum),l);o.assign(e),t.assign(a),s.assign(u);let d=RA(r,u);r.assign(d)}else{let e=iE(lE(o,this.decay),lE(Q_(i),1-this.decay)),t=iE(lE(s,this.momentum),sE(lE(i,this.learningRate),Y_(iE(e,this.epsilon))));o.assign(e),s.assign(t);let n=RA(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&q$(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&q$(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&q$(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},SM=[gM,bM,yM,vM,wM,kM,xM],IM={};function NM(e){return new Promise((e=>setTimeout(e))).then(e)}uw(IM,{CompositeArrayBuffer:()=>LT,browserFiles:()=>$M,browserHTTPRequest:()=>zM,concatenateArrayBuffers:()=>GT,copyModel:()=>_$,decodeWeights:()=>VT,encodeWeights:()=>WT,fromMemory:()=>WM,fromMemorySync:()=>VM,getLoadHandlers:()=>a$,getModelArtifactsForJSON:()=>YT,getModelArtifactsForJSONSync:()=>XT,getModelArtifactsInfoForJSON:()=>QT,getSaveHandlers:()=>r$,getWeightSpecs:()=>ZT,http:()=>OM,isHTTPScheme:()=>DM,listModels:()=>$$,loadWeights:()=>AM,moveModel:()=>A$,registerLoadRouter:()=>n$,registerSaveRouter:()=>t$,removeModel:()=>E$,weightsLoaderFactory:()=>RM,withSaveHandler:()=>UM,withSaveHandlerSync:()=>jM});var CM=class{constructor(e){if(!Rk().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(CM.URL_SCHEME)&&(e=e.slice(CM.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=LT.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let t=KT(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),a=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await NM((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){let e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await NM((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:QT(e)}}}};CM.URL_SCHEME="downloads://";var TM=class{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{let n=new FileReader;n.onload=n=>{let r=JSON.parse(n.target.result),a=r.modelTopology;if(null==a)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:a});let i=YT(r,(e=>this.loadWeights(e)));e(i)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){let t=[],n=[];for(let i of e)t.push(...i.weights),n.push(...i.paths);let r=this.checkManifestAndWeightFiles(e),a=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(a).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{let a=new FileReader;a.onload=e=>{let t=e.target.result;n(t)},a.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map((e=>qT(e.name))),r={};for(let a of e)a.paths.forEach((e=>{let a=qT(e);if(-1!==t.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===n.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(a)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}};function $M(e){return new TM(e)}function EM(e,t,n,r){(function(e){Uw(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))})(e),function(e,t){Uw(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),Uw(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),Uw(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let a=0;return Promise.all(e.map((i=>(i.then((i=>{let o=n+ ++a/e.length*(r-n);return t(o),i})),i))))}async function _M(e,t){null==t&&(t={});let n=null==t.fetchFunc?Rk().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=(null==t.onProgress?await Promise.all(r):await EM(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(a):await EM(a,t.onProgress,.5,1)}async function AM(e,t="",n,r){return RM((e=>_M(e,{requestInit:r})))(e,t,n)}function RM(e){return async(t,n="",r)=>{let a=t.map((()=>!1)),i={},o=null!=r?r.map((()=>!1)):[],s=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{let l="quantization"in e?e.quantization.dtype:e.dtype,u=PT[l]*Gw(e.shape),d=()=>{a[t]=!0,null==i[t]&&(i[t]=[]),i[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(d(),o[n]=!0)})):d(),s.push(e.name),n+=u}))})),!o.every((e=>e))){let e=r.filter(((e,t)=>!o[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${s.join(", ")}.`)}let l=a.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{let t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));let d=await e(u),c={},p=0;return l.forEach((e=>{let n=t[e].paths.length,r=new LT(d.slice(p,p+n));i[e].forEach((e=>{let t=VT(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(let n in t)c[n]=t[n]})),p+=n})),c}}e$.registerSaveRouter((e=>Rk().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(CM.URL_SCHEME)?function(e="model"){return new CM(e)}(e.slice(CM.URL_SCHEME.length)):null));var FM=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Uw("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=Rk().platform.fetch,Uw(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&Uw(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=KT(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){let n=LT.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}let r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:QT(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async load(){let e,t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);try{e=await t.json()}catch(Rp){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}let n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return YT(e,(e=>this.loadWeights(e)))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}(t),a=this.weightPathPrefix||n,i=ZT(e),o=[],s=[];for(let l of e)for(let e of l.paths)null!=this.weightUrlConverter?s.push(this.weightUrlConverter(e)):o.push(a+e+r);return this.weightUrlConverter&&o.push(...await Promise.all(s)),[i,await _M(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress})]}};function DM(e){return null!=e.match(FM.URL_SCHEME_REGEX)}FM.URL_SCHEME_REGEX=/^https?:\/\//;var MM=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>DM(e))):DM(e),n)return OM(e,t)}return null};function OM(e,t){return new FM(e,t)}function zM(e,t){return OM(e,t)}e$.registerSaveRouter(MM),e$.registerLoadRouter(MM);var PM=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},LM=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},BM=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function WM(e,t,n,r){return new BM(VM(...arguments))}function VM(e,t,n,r){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new PM(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new PM({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new PM({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function UM(e){return new LM(e)}function jM(e){return new LM(e)}var HM={};uw(HM,{confusionMatrix:()=>GM});var GM=DT({confusionMatrix_:function(e,t,n){let r=AT(e,"labels","confusionMatrix"),a=AT(t,"predictions","confusionMatrix");Uw(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),Uw(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),Uw(1===a.rank,(()=>`Expected the rank of predictions to be 1, but got ${a.rank}`)),Uw(r.shape[0]===a.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`)),Uw(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));let i=rR(M$(r,"int32"),n),o=rR(M$(a,"int32"),n),s=VF(i),l=WE(s,o);return M$(l,"int32")}}),qM={};uw(qM,{draw:()=>tO,fromPixels:()=>nO,fromPixelsAsync:()=>ZM,toPixels:()=>eO});var KM,XM=!1;function YM(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,i=!1,o=!1,s=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)a=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)i=!0;else if(null!=e.getContext)o=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);s=!0}if(null!=iC(YN,xT.backendName)){let n={pixels:e},r={numChannels:t};return xT.runKernel(YN,n,r)}let l,u,[d,c]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];if(o)l=e.getContext("2d").getImageData(0,0,d,c).data;else if(r||n)l=e.data;else if(i||a||s){if(null==KM)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");KM=new OffscreenCanvas(1,1).getContext("2d")}else KM=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});KM.canvas.width=d,KM.canvas.height=c,KM.drawImage(e,0,0,d,c),l=KM.getImageData(0,0,d,c).data}if(4===t)u=new Int32Array(l);else{let e=d*c;u=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)u[n*t+e]=l[4*n+e]}return SF(u,[c,d,t],"int32")}function QM(e){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}async function ZM(e,t=3){let n=null;if(Rk().getBool("WRAP_TO_IMAGEBITMAP")&&QM(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(Rp){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return YM(n,t)}function JM(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function eO(e,t){let n=AT(e,"img","toPixels");if(!(e instanceof QC)){let e=n;n=M$(e,"int32"),e.dispose()}JM(n);let[r,a]=n.shape.slice(0,2),i=2===n.rank?1:n.shape[2],o=await n.data(),s="float32"===n.dtype?255:1,l=new Uint8ClampedArray(a*r*4);for(let u=0;u<r*a;++u){let e=[0,0,0,255];for(let r=0;r<i;r++){let t=o[u*i+r];if("float32"===n.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===n.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===i?(e[0]=t*s,e[1]=t*s,e[2]=t*s):e[r]=t*s}let t=4*u;l[t+0]=Math.round(e[0]),l[t+1]=Math.round(e[1]),l[t+2]=Math.round(e[2]),l[t+3]=Math.round(e[3])}if(null!=t){XM||(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),XM=!0),t.width=a,t.height=r;let e=t.getContext("2d"),n=new ImageData(l,a,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}function tO(e,t,n){let r=AT(e,"img","draw");if(!(e instanceof QC)){let e=r;r=M$(e,"int32"),e.dispose()}JM(r),function(e){let t=(null==e?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}(null==n?void 0:n.imageOptions);let a={image:r},i={canvas:t,options:n};xT.runKernel(FS,a,i)}var nO=DT({fromPixels_:YM}),rO={};function aO(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Gw(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,i=a[a.length-1],o=1;for(let c=0;c<a.length-1;++c)o*=a[c];let s=e.shape,l=a.slice();l.pop();let u=1;for(let c=i;c<n;++c)u*=s[c],l.push(s[c]);let d=[...yk(e.shape).map((e=>e/u)),1].slice(0,i);return[l,o,u,d]}uw(rO,{prepareAndValidate:()=>aO});var iO={};uw(iO,{assertParamsValid:()=>lO,computeFlatOffset:()=>wO,computeOutShape:()=>dO,getNormalizedAxes:()=>fO,isSliceContinous:()=>xO,maskToAxes:()=>uO,parseSliceParams:()=>kO,sliceInfo:()=>SO,startForAxis:()=>yO,startIndicesWithElidedDims:()=>mO,stopForAxis:()=>vO,stopIndicesWithElidedDims:()=>gO,stridesForAxis:()=>bO,stridesWithElidedDims:()=>cO});var oO=-2,sO=-1;function lO(e,t,n){let r=e.shape.length;Uw(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),Uw(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let a=0;a<r;++a)Uw(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function uO(e){let t=[],n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function dO(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function cO(e,t,n,r){let a=[...e];for(let i=a.length;i<r.length;i++)a.push(1);for(let i=0;i<n;i++)0===i?a[t]=1:(a.splice(t,0,1),a.pop());return a}function pO(e,t,n){return n<=e?n:n-(t-1)}function hO(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function fO(e,t,n,r,a,i,o,s,l){let u=e.length,d=new Array(u),c=new Array(u),p=new Array(u);if(t.length&&n>0){let l=t[0],u=n+1;d=mO(o,l,u,r,e),c=gO(s,l,u,a,e),p=cO(i,l,u,e)}else for(let h=0;h<u;h++)d[h]=yO(o,r,i,e,h,l),c[h]=vO(s,a,i,e,h,l),p[h]=bO(i,h,l);return{begin:d,end:c,strides:p}}function mO(e,t,n,r,a){let i=[...a],o=hO(n,t);for(let s=0;s<i.length;s++)if(o.indexOf(s)>-1)i[s]=0;else{let a=pO(t,n,s),o=r[a];e&1<<a&&(o=0),i[s]=o}return i}function gO(e,t,n,r,a){let i=[...a],o=hO(n,t);for(let s=0;s<i.length;s++)if(o.indexOf(s)>-1)i[s]=Number.MAX_SAFE_INTEGER;else{let a=pO(t,n,s),o=r[a];e&1<<a&&(o=Number.MAX_SAFE_INTEGER),i[s]=o}for(let s=0;s<i.length;s++){let e=a[s];i[s]<0&&(i[s]+=e),i[s]=zw(0,i[s],a[s])}return i}function bO(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function yO(e,t,n,r,a,i){let o=t[a],s=n[a]||1;(e&1<<a||i&1<<a||null==o)&&(o=s>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let l=r[a];return o<0&&(o+=l),o=zw(0,o,l-1),o}function vO(e,t,n,r,a,i){let o=t[a],s=n[a]||1;(e&1<<a||i&1<<a||null==o)&&(o=s>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let l=r[a];return o<0&&(o+=l),o=s>0?zw(0,o,l):zw(-1,o,l-1),o}function xO(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function wO(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function kO(e,t,n){let r,a,i=e.shape.length;return r="number"==typeof t?[t,...new Array(i-1).fill(0)]:t.length<i?t.concat(new Array(i-t.length).fill(0)):t.slice(),r.forEach((e=>{Uw(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(i).fill(-1):"number"==typeof n?[n,...new Array(i-1).fill(-1)]:n.length<i?n.concat(new Array(i-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(Uw(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function SO(e,t,n,r,a,i,o,s,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=o&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1,c={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:i,ellipsisMask:o,newAxisMask:s,shrinkAxisMask:l};for(let y=0;y<c.dims;y++)d&&1<<y&s&&c.numAddAxisAfterEllipsis++,1<<y&o&&(d=!0);d||(c.ellipsisMask|=1<<c.dims,c.dims++);let p={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(oO),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(sO),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(c,p);let h=!0,f=!0,m=!0,g=[],b=[];for(let y=0;y<e.length;++y){if(0===p.strides[y])throw Error(`strides[${y}] must be non-zero`);let t=!!(p.shrinkAxisMask&1<<y),n=e[y];if(-1===n){g.push(t?1:-1);continue}let r=[p.beginMask&1<<y,p.endMask&1<<y],a=[p.strides[y]>0?0:-1,p.strides[y]>0?n:n-1];if(t&&p.strides[y]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===p.strides[y];let i=!!(p.beginMask&1<<y&&p.endMask&1<<y);if(p.beginValid&&p.endValid){if(t){let e=p.begin[y]<0?n+p.begin[y]:p.begin[y];if(p.begin[y]=e,p.end[y]=p.begin[y]+1,e<0||e>=n)throw Error(`slice index ${p.begin[y]} of dimension ${y} out of bounds.`)}else p.begin[y]=IO(p.begin[y],0,p.strides[y],n,r,a),p.end[y]=IO(p.end[y],1,p.strides[y],n,r,a);let e=1===p.strides[y]&&0===p.begin[y]&&p.end[y]===n;h=h&&e,f=f&&(0===y&&1===p.strides[y]||e)}else h=h&&1===p.strides[y]&&i,f=f&&(0===y&&1===p.strides[y]||i);let o,s=!1;if(p.beginValid&&p.endValid?(o=p.end[y]-p.begin[y],s=!0):t?(o=1,s=!0):i&&n>=0&&(o=p.strides[y]<0?-n:n,s=!0),s){let e;e=0===o||o<0!=p.strides[y]<0?0:Math.trunc(o/p.strides[y])+(o%p.strides[y]!=0?1:0),g.push(e)}else g.push(-1)}for(let y=0;y<p.finalShapeGatherIndices.length;++y){let e=p.finalShapeGatherIndices[y];e>=0?b.push(g[e]):e===oO&&b.push(1)}return{finalShapeSparse:b.filter(((e,t)=>p.finalShapeGatherIndices[t]!==oO)),finalShape:b,isIdentity:h,sliceDim0:f,isSimpleSlice:m,begin:p.begin,end:p.end,strides:p.strides}}function IO(e,t,n,r,a,i){if(a[t])return n>0?i[t]:i[t+1&1];{let t=e<0?r+e:e;return t<i[0]?i[0]:t>i[1]?i[1]:t}}var NO="4.7.0",CO=class{static sgd(e){return new xM(e)}static momentum(e,t,n=!1){return new wM(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,a=!1){return new kM(e,t,n,r,a)}static adam(e=.001,t=.9,n=.999,r=null){return new yM(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new gM(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,a=0){return new vM(e,t,n,r,a)}static adagrad(e,t=.1){return new bM(e,t)}},TO=CO,$O="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function EO(){return new Promise((e=>$O((()=>e()))))}var _O,AO={};function RO(e,t){let n=e[0].length;e.forEach(((e,t)=>{Uw(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),Uw(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));let r=e[0];e.forEach(((e,a)=>{for(let i=0;i<n;i++)Uw(i===t||e[i]===r[i],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}function FO(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}function DO(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){let i=n[a],o=r[r.length-n.length+a],s=r[o];if(i>=0)if(s>=0){if(s!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${i} but shape[${a+e}] = ${s}`)}else r[o]=i}return r}function MO(e){let t={FIRST_DIM_SIZE:_O.FIRST_DIM_SIZE,VALUE_ROWIDS:_O.VALUE_ROWIDS,ROW_LENGTHS:_O.ROW_LENGTHS,ROW_SPLITS:_O.ROW_SPLITS,ROW_LIMITS:_O.ROW_LIMITS,ROW_STARTS:_O.ROW_STARTS},n=[];for(let r of e){if(!(r in t))break;n.push(t[r])}return n}function OO(e){return 0===e.length?0:e[0]===_O.FIRST_DIM_SIZE?e.length-1:e.length}function zO(e,t){if(null==e||null==t)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){let n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${n} but ragged tensor input.flatValues.shape[${a-e.length}] = ${r}`)}}uw(AO,{ERF_A1:()=>XO,ERF_A2:()=>YO,ERF_A3:()=>QO,ERF_A4:()=>ZO,ERF_A5:()=>JO,ERF_P:()=>KO,PARALLELIZE_THRESHOLD:()=>PO,RowPartitionType:()=>_O,SELU_SCALE:()=>qO,SELU_SCALEALPHA:()=>GO,applyActivation:()=>tD,assertAndGetBroadcastShape:()=>$_,assertAxesAreInnerMostDims:()=>V_,assertParamsConsistent:()=>RO,assignToTypedArray:()=>iz,axesAreInnerMostDims:()=>P_,calculateShapes:()=>_F,checkEinsumDimSizes:()=>fz,checkPadOnDimRoundingMode:()=>OE,combineLocations:()=>L_,combineRaggedTensorToTensorShapes:()=>DO,complexWithEvenIndex:()=>nz,complexWithOddIndex:()=>rz,computeConv2DInfo:()=>NE,computeConv3DInfo:()=>CE,computeDefaultPad:()=>TE,computeDilation2DInfo:()=>kE,computeOptimalWindowSize:()=>LO,computeOutAndReduceShapes:()=>B_,computeOutShape:()=>FO,computePool2DInfo:()=>SE,computePool3DInfo:()=>IE,convertConv2DDataFormat:()=>ME,decodeEinsumEquation:()=>pz,eitherStridesOrDilationsAreOne:()=>FE,expandShapeToKeepDim:()=>W_,exponent:()=>sz,exponents:()=>oz,fromStringArrayToUint8:()=>Oz,fromUint8ToStringArray:()=>Mz,getAxesPermutation:()=>U_,getBroadcastDims:()=>C_,getComplexWithIndex:()=>az,getEinsumComputePath:()=>mz,getEinsumPermutation:()=>hz,getFusedBiasGradient:()=>eD,getFusedDyActivation:()=>JF,getImageCenter:()=>BO,getInnerMostAxes:()=>H_,getPermuted:()=>VO,getRaggedRank:()=>OO,getReductionAxes:()=>T_,getReshaped:()=>WO,getReshapedPermuted:()=>UO,getRowPartitionTypesHelper:()=>MO,getSliceBeginCoords:()=>jO,getSliceSize:()=>HO,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>vz,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>xz,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>wz,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Iz,getSparseReshapeInputOutputMismatchErrorMessage:()=>Cz,getSparseReshapeInputOutputMultipleErrorMessage:()=>Nz,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>kz,getSparseReshapeNegativeOutputDimErrorMessage:()=>Sz,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>_z,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Tz,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>$z,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Ez,getUndoAxesPermutation:()=>j_,isIdentityPermutation:()=>gz,log:()=>nC,mergeRealAndImagArrays:()=>ez,prepareAndValidate:()=>aO,prepareSplitSize:()=>yz,segment_util:()=>Az,shouldFuse:()=>nD,slice_util:()=>iO,splitRealAndImagArrays:()=>tz,stridesOrDilationsArePositive:()=>DE,tupleValuesAreOne:()=>RE,upcastType:()=>sT,validateDefaultValueShape:()=>zO,validateInput:()=>EF,validateUpdateShape:()=>$F,warn:()=>tC}),function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(_O||(_O={}));var PO=30;function LO(e){return e<=PO?e:bk(e,Math.floor(Math.sqrt(e)))}function BO(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function WO(e,t,n,r=!0){let a=[];if(r)a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);let n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function VO(e,t,n=!0){let r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{let n=[],a=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?a.push(r):n.push(r);r.push(...n),r.push(0),r.push(...a)}return r}function UO(e,t,n,r=!0){let a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let i=1;i<e.length;++i)i<=t.length?r?a.push(t[i-1]*e[i]):a.push(e[i]/t[i-1]):a.push(e[i]);return a}function jO(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function HO(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var GO=1.7580993408473768,qO=1.0507009873554805,KO=.3275911,XO=.254829592,YO=-.284496736,QO=1.421413741,ZO=-1.453152027,JO=1.061405429;function ez(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function tz(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function nz(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function rz(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function az(e,t){return{real:e[2*t],imag:e[2*t+1]}}function iz(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function oz(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let i=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(i),r[a]=Math.sin(i)}return{real:n,imag:r}}function sz(e,t,n){let r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}var lz="->",uz=/->/g,dz=",",cz="...";function pz(e,t){let n=((e=e.replace(/\s/g,"")).length-e.replace(uz,"").length)/lz.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${lz}").`);let[r,a]=e.split(lz);Uw(-1===r.indexOf(cz),(()=>`The ellipsis notation ("${cz}") is not supported yet.`));let i=r.split(dz),o=i.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let s=[];for(let c=0;c<a.length;++c){let e=a[c];if(!i.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===s.indexOf(e)&&s.push(e)}for(let c=0;c<r.length;++c){let e=r[c];-1===s.indexOf(e)&&e!==dz&&s.push(e)}let l=new Array(i.length);for(let c=0;c<o;++c){if(new Set(i[c].split("")).size!==i[c].length)throw new Error(`Found duplicate axes in input component ${i[c]}. Support for duplicate axes in input is not implemented yet.`);l[c]=[];for(let e=0;e<i[c].length;++e)l[c].push(s.indexOf(i[c][e]))}let u=s.length,d=[];for(let c=a.length;c<u;++c)d.push(c);return{allDims:s,summedDims:d,idDims:l}}function hz(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;let r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function fz(e,t,n){let r=new Array(e);for(let a=0;a<n.length;++a){let e=n[a].shape;for(let n=0;n<t[a].length;++n)void 0===r[t[a][n]]?r[t[a][n]]=e[n]:Uw(r[t[a][n]]===e[n],(()=>`Expected dimension ${r[t[a][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function mz(e,t){let n=e,r=[],a=0;0===e.length&&n.push(-1),a=e.length+1;for(let o=0;o<a;++o)r.push([]);let i=[];for(let o=0;o<n.length;++o){let e=bz(t,n[o]);for(let t of e)-1===i.indexOf(t)&&(r[o].push(t),i.push(t))}return{path:n,steps:r}}function gz(e){return e.every(((e,t)=>e===t))}function bz(e,t){let n=[];for(let r=0;r<e.length;++r)(0===e[r].length||-1!==e[r].indexOf(t)||-1===t)&&n.push(r);return n}function yz(e,t,n=0){let r=[];if("number"==typeof t)Uw(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{Uw(t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0)<=1,(()=>"There should be only one negative value in split array."));let a=t.indexOf(-1);if(-1!==a){let r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}Uw(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function vz(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function xz(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function wz(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function kz(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Sz(e,t){return`size ${e} must be non-negative, not ${t}`}function Iz(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Nz(e,t){return`Input to reshape is a SparseTensor with ${Gw(e)}\n  dense values, but the requested shape requires a multiple of ${Gw(t)}. inputShape=${e} outputShape= ${t}`}function Cz(e,t){return`Input to reshape is a tensor with ${Gw(e)} dense values, but the requested shape has ${Gw(t)}. inputShape=${e} outputShape=${t}`}function Tz(){return"segment ids must be >= 0"}function $z(){return"segment ids are not increasing"}function Ez(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function _z(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var Az={};function Rz(e,t){let n,r=!1;for(e<=PO?(n=e,r=!0):n=bk(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=bk(e,n+1);return n}function Fz(e,t,n){let r=[],a=e.length;for(let i=0;i<a;i++)i!==t?r.push(e[i]):r.push(n);return r}function Dz(e,t,n,r){let a=t.shape.length,i=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${i}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let c=0;c<r;++c)if(e.shape[c]!==t.shape[c])throw new Error(`x.shape[${c}]: ${e.shape[c]} should be equal to indices.shape[${c}]: ${t.shape[c]}.`);let o=e.shape[n],s=[],l=1,u=1,d=1;for(let c=0;c<r;++c)s.push(e.shape[c]),l*=e.shape[c];for(let c=r;c<n;c++)s.push(e.shape[c]),u*=e.shape[c];for(let c=r;c<a;c++)s.push(t.shape[c]);for(let c=n+1;c<i;c++)s.push(e.shape[c]),d*=e.shape[c];return{batchSize:l,sliceSize:d,outerSize:u,dimSize:o,outputShape:s}}function Mz(e){try{return e.map((e=>MC(e)))}catch(Fp){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${Fp}`)}}function Oz(e){return e.map((e=>DC(e)))}uw(Az,{collectGatherOpShapeInfo:()=>Dz,computeOutShape:()=>Fz,segOpComputeOptimalWindowSize:()=>Rz});var zz={};uw(zz,{nonMaxSuppressionV3Impl:()=>xD,nonMaxSuppressionV4Impl:()=>wD,nonMaxSuppressionV5Impl:()=>kD,whereImpl:()=>LF}),function(){for(let e of SM)fM(e)}();var Pz={kernelName:zk,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>lE(e,yF(M$(n,"float32"),-1))}}},Lz={kernelName:Pk,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=Q_(M$(n,"float32")),r=Y_(RA(X_(1),t));return EA(sE(e,r))}}}},Bz={kernelName:Lk,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=Y_(RA(Q_(M$(n,"float32")),1));return sE(e,t)}}}},Wz={kernelName:Bk,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=$_(n.shape,r.shape);return{a:()=>{let t=e,r=T_(n.shape,a);return r.length>0&&(t=Z_(t,r)),zE(t,n.shape)},b:()=>{let t=e,n=T_(r.shape,a);return n.length>0&&(t=Z_(t,n)),zE(t,r.shape)}}}},Vz={kernelName:Wk,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},Uz={kernelName:jk,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>A_(n)}}},jz={kernelName:Hk,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>A_(n)}}},Hz={kernelName:Gk,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sE(e,Y_(RA(X_(1),Q_(M$(n,"float32")))))}}},Gz={kernelName:qk,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=Y_(iE(X_(1),Q_(M$(n,"float32"))));return sE(e,t)}}}},qz={kernelName:Yk,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=$_(n.shape,r.shape);return{a:()=>{let t=iE(Q_(n),Q_(r)),i=lE(e,sE(r,t)),o=T_(n.shape,a);return o.length>0&&(i=Z_(i,o)),zE(i,n.shape)},b:()=>{let t=iE(Q_(n),Q_(r)),i=EA(lE(e,sE(n,t))),o=T_(r.shape,a);return o.length>0&&(i=Z_(i,o)),zE(i,r.shape)}}}},Kz={kernelName:Kk,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sE(e,iE(Q_(M$(n,"float32")),1))}}},Xz={kernelName:Xk,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sE(e,RA(X_(1),Q_(M$(n,"float32"))))}}},Yz=DT({avgPool3dGrad_:function(e,t,n,r,a,i){let o=AT(e,"dy","avgPool3dGrad"),s=AT(t,"input","avgPool3dGrad"),l=o,u=s,d=!1;4===s.rank&&(d=!0,l=zE(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),u=zE(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]])),Uw(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),Uw(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),OE("avgPool3dGrad",a,i);let c={dy:l,input:u},p={filterSize:n,strides:r,pad:a,dimRoundingMode:i},h=xT.runKernel(eS,c,p);return d?zE(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),Qz={kernelName:Jk,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:s}=n;return{x:()=>Yz(e,r,a,i,o,s)}}},Zz=DT({avgPoolGrad_:function(e,t,n,r,a){let i=AT(e,"dy","avgPoolGrad"),o=AT(t,"input","avgPoolGrad");Uw(o.rank===i.rank,(()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`));let s=o,l=i,u=!1;3===o.rank&&(u=!0,s=zE(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=zE(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Uw(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),Uw(4===s.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${s.rank}.`));let d={dy:l,input:s},c={filterSize:n,strides:r,pad:a},p=xT.runKernel(Zk,d,c);return u?zE(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),Jz={kernelName:Qk,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>Zz(e,r,a,i,o)}}},eP={kernelName:tS,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:i,transposeB:o}=n;return i||o?!i&&o?{a:()=>WE(e,a,!1,!1),b:()=>WE(e,r,!0,!1)}:i&&!o?{a:()=>WE(a,e,!1,!0),b:()=>WE(r,e,!1,!1)}:{a:()=>WE(a,e,!0,!0),b:()=>WE(e,r,!0,!0)}:{a:()=>WE(e,a,!1,!0),b:()=>WE(r,e,!0,!1)}}},tP={kernelName:nS,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>cR(e,r,a)}}},nP={kernelName:iS,gradFunc:(e,t,n)=>{let r=n,a=r.inputShape,i=r.shape,o=Array.from(i);for(let l=a.length-1;l>=0;l--)if(a[l]===i[l])o[l]=1;else if(1!==a[l])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${i}].`);let s=[];for(let l=0;l<o.length;l++)o[l]>1&&s.push(l);return{x:()=>Z_(e,s,!0)}}},rP={kernelName:sS,gradFunc:e=>({x:()=>e.clone()})},aP={kernelName:lS,gradFunc:e=>({x:()=>A_(e)})},iP={kernelName:uS,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:i}=n;return{x:()=>__(MA(dA(r,a),bA(r,i)),e,A_(e))}}},oP={kernelName:cS,inputsToSave:["x"],gradFunc:Pz.gradFunc},sP={kernelName:pS,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map((e=>e.shape)),{axis:a}=n,i=rk(a,t[0].shape)[0],o=r.map((e=>e[i]));return hF(e,o,i).map((e=>()=>e))}},lP={kernelName:hS,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:i,strides:o,pad:s,dataFormat:l}=n;return Uw(RE(i),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`)),{x:()=>c_(r.shape,e,a,o,s,l),filter:()=>ZF(r,e,a.shape,o,s,l)}}},uP={kernelName:mS,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:i,pad:o,dataFormat:s,dimRoundingMode:l}=n;return{dy:()=>u_(e,a,i,o,s,1,l),filter:()=>ZF(e,r,a.shape,i,o,s,l)}}},dP=DT({conv3DBackpropFilter_:function(e,t,n,r,a){let i=e;4===e.rank&&(i=zE(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let o=t;4===o.rank&&(o=zE(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Uw(5===i.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`)),Uw(5===o.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`)),Uw(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),Uw(i.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`)),Uw(o.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${n[4]}).`));let s={x:i,dy:o},l={strides:r,pad:a,filterShape:n};return xT.runKernel(bS,s,l)}}),cP={kernelName:gS,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:i}=n;Uw(RE(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));let[o,s]=t;return{x:()=>f_(o.shape,e,s,a,i),filter:()=>dP(o,e,s.shape,a,i)}}},pP={kernelName:vS,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>lE(EA(rF(M$(n,"float32"))),e)}}},hP={kernelName:xS,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>lE(aF(M$(n,"float32")),e)}}},fP={kernelName:kS,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:i,reverse:o}=n;return{x:()=>{let t=U_([a],r.rank),n=v_(e,a,i,!o);return null!=t&&(n=VF(n,t)),n}}}},mP={kernelName:CS,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:i,dimRoundingMode:o}=n,s=null==r?[1,1]:r;Uw(RE(s),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`));let[l,u]=t;return Uw(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),Uw(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),Uw(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),Uw(FE(a,s),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${s}'.`)),OE("depthwiseConv2d",i,o),{x:()=>iD(l.shape,e,u,a,i,s,o),filter:()=>aD(l,e,u.shape,a,i,s,o)}}},gP={kernelName:_S,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,i={x:r,filter:a,dy:e},o={x:r,filter:a,dy:e};return{x:()=>xT.runKernel(AS,i,n),filter:()=>xT.runKernel(RS,o,n)}}},bP={kernelName:OS,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>xT.runKernel(zS,r)}}},yP={kernelName:PS,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=lE(nA(EA(Q_(n))),2/Math.sqrt(Math.PI));return{x:()=>lE(e,r)}}},vP={kernelName:BS,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>lE(e,n)}}},xP={kernelName:WS,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>zE(e,n.shape)}}},wP={kernelName:VS,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>lE(e,nA(n))}}},kP={kernelName:GS,gradFunc:e=>({x:()=>A_(e)})},SP={kernelName:qS,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=$_(n.shape,r.shape);return{a:()=>{let t=sE(e,M$(r,"float32")),i=T_(n.shape,a);return i.length>0?zE(Z_(t,i),n.shape):t},b:()=>{let t=lE(e,M$(n,"float32")),i=T_(r.shape,a);i.length>0&&(t=zE(Z_(t,i),r.shape));let o=Q_(r);return EA(sE(t,M$(o,"float32")))}}}},IP={kernelName:KS,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,i,o,s]=t,l=null==s?X_(1):s,u=T_(i.shape,a.shape),d=[];if(1===i.rank){for(let e=0;e<a.shape.length-1;++e)d.push(a.shape[e]);d.push(1)}let c=RA(a,i),p=lE(e,l),h=ZR(iE(o,X_(r))),f=lE(lE(lE(h,h),h),X_(-.5));return{x:()=>1===i.rank?zE(lE(lE(e,iA(zE(h,[1,1,1,i.shape[0]]),d)),l),a.shape):zE(lE(lE(e,h),l),a.shape),mean:()=>{let e=lE(lE(h,X_(-1)),p);return 1===i.rank&&(e=Z_(e,u)),zE(e,i.shape)},variance:()=>{let e=lE(lE(f,c),p);return 1===i.rank&&(e=Z_(e,u)),zE(e,i.shape)},scale:()=>{let t=lE(c,h),n=lE(e,t);return 1===i.rank&&(n=Z_(n,u)),zE(n,i.shape)},offset:()=>{let t=e;return 1===i.rank&&(t=Z_(t,u)),zE(t,i.shape)}}}},NP={kernelName:XS,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:i}=n,o=rk(i,r.shape)[0];return{x:()=>{let t=r.shape,n=a.size,s=t.slice(0,o),l=s.length,u=t.slice(i,t.length).slice(1),d=u.length,c=CP(0,l),p=CP(l+1,l+1+d),h=TP([s,[n],u]),f=zE(e,h),m=zE(a,[n]),g=TP([[l],c,p]),b=VF(f,g),y=MF(b,m,r.shape[o]),v=j_(g);return y=VF(y,v),y},indices:()=>a}}};function CP(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function TP(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var $P={kernelName:ZS,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>A_(n),b:()=>A_(r)}}},EP={kernelName:JS,gradFunc:e=>({x:()=>M$(e,"float32")})},_P={kernelName:nI,gradFunc:e=>({x:()=>A_(e)})},AP={kernelName:rI,gradFunc:e=>({x:()=>A_(e)})},RP={kernelName:aI,gradFunc:e=>({x:()=>A_(e)})},FP={kernelName:iI,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,i=uA(r,0);return{x:()=>__(i,e,lE(e,a))}}},DP={kernelName:dI,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sE(e,iE(n,1))}}},MP={kernelName:uI,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sE(e,M$(n,"float32"))}}},OP={kernelName:mI,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let t=nA(r);return RA(e,lE(Z_(e,a,!0),t))}}}},zP=DT({localResponseNormalizationBackprop_:function(e,t,n,r=5,a=1,i=1,o=.5){let s={x:e,y:t,dy:n},l={depthRadius:r,bias:a,alpha:i,beta:o};return xT.runKernel(yI,s,l)}}),PP={kernelName:bI,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:i,bias:o,alpha:s,beta:l}=n;return{x:()=>zP(r,a,e,i,o,s,l)}}};function LP(e,t,n,r){return t.rank<n.rank&&(t=zE(t,W_(t.shape,r))),e.rank<n.rank&&(e=zE(e,W_(e.shape,r))),{x:()=>lE(e,M$(E_(n,t),e.dtype))}}var BP={kernelName:xI,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:a}=r,i=t[0],o=LP(e,t[1],i,rk(a,i.shape));return{x:()=>o.x()}}},WP={kernelName:wI,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>lE(e,M$(dA(n,r),"float32")),b:()=>lE(e,M$(gA(n,r),"float32"))}}},VP=DT({maxPool3dGrad_:function(e,t,n,r,a,i,o){let s=AT(e,"dy","maxPool3dGrad"),l=AT(t,"input","maxPool3dGrad"),u=AT(n,"output","maxPool3dGrad"),d=s,c=l,p=u,h=!1;4===l.rank&&(h=!0,d=zE(s,[1,s.shape[0],s.shape[1],s.shape[2],s.shape[3]]),c=zE(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),p=zE(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Uw(5===d.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`)),Uw(5===c.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${c.rank}.`)),Uw(5===p.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${p.rank}.`)),OE("maxPool3dGrad",i,o);let f={dy:d,input:c,output:p},m={filterSize:r,strides:a,pad:i,dimRoundingMode:o},g=xT.runKernel(NI,f,m);return h?zE(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),UP={kernelName:II,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:i,strides:o,pad:s,dimRoundingMode:l}=n;return{x:()=>VP(e,r,a,i,o,s,l)}}},jP=DT({maxPoolGrad_:function(e,t,n,r,a,i,o){let s=AT(e,"dy","maxPoolGrad"),l=AT(t,"input","maxPoolGrad"),u=AT(n,"output","maxPoolGrad");Uw(l.rank===s.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${s.rank})`)),Uw(4===s.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${s.rank}.`)),Uw(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),OE("maxPoolGrad",i,o);let d={dy:s,input:l,output:u},c={filterSize:r,strides:a,pad:i,dimRoundingMode:o};return xT.runKernel(SI,d,c)}}),HP={kernelName:kI,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:i,strides:o,pad:s}=n;return{x:()=>jP(e,r,a,i,o,s)}}},GP={kernelName:TI,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,i=rk(a,r.shape),o=Gw(B_(r.shape,i)[1]);return{x:()=>{let t=r.shape.slice();i.forEach((e=>{t[e]=1}));let n=zE(e,t);return sE(lE(n,KA(r.shape,"float32")),o)}}}},qP={kernelName:$I,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:a}=r,[i,o]=t,s=LP(e,o,i,rk(a,i.shape));return{x:()=>s.x()}}},KP={kernelName:EI,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>lE(e,M$(bA(n,r),"float32")),b:()=>lE(e,M$(uA(n,r),"float32"))}}},XP={kernelName:_I,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,i=a.map((e=>e[0]));return{x:()=>UE(e,i,r.shape)}}},YP={kernelName:AI,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=$_(n.shape,r.shape);return{a:()=>{let t=T_(n.shape,a);return t.length>0?zE(Z_(e,t),n.shape):e},b:()=>{let t=lE(e,EA(sA(sE(n,r)))),i=T_(r.shape,a);return i.length>0?zE(Z_(t,i),r.shape):t}}}},QP={kernelName:FI,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=$_(n.shape,r.shape);return{a:()=>{let t=lE(e,M$(r,"float32")),i=T_(n.shape,a);return i.length>0?zE(Z_(t,i),n.shape):t},b:()=>{let t=lE(e,M$(n,"float32")),i=T_(r.shape,a);return i.length>0?zE(Z_(t,i),r.shape):t}}}},ZP={kernelName:DI,gradFunc:e=>({x:()=>EA(e)})},JP={kernelName:BI,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>qA(n.shape,"float32")}}},eL={kernelName:LI,gradFunc:e=>({x:()=>A_(e)})},tL={kernelName:WI,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return OF(e,r).map((e=>()=>e))}},nL={kernelName:VI,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,i=a.map((e=>e[0]));return{x:()=>UE(e,i,r.shape)}}},rL={kernelName:jI,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,i=n,o=r,s=$_(i.shape,o.shape);return{a:()=>{let t=M$(o,"float32"),n=lE(e,lE(t,K_(i,RA(t,X_(1))))),r=T_(i.shape,s);return r.length>0&&(n=Z_(n,r)),zE(n,i.shape)},b:()=>{let t=uA(i,0),n=__(t,xA(i),A_(i)),r=lE(e,lE(a,n)),l=T_(o.shape,s);return l.length>0&&(r=Z_(r,l)),zE(r,o.shape)}}}},aL={kernelName:HI,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=uA(n,0);return{x:()=>__(a,e,lE(e,r)),alpha:()=>{let t=__(a,A_(e),lE(e,n)),i=T_(r.shape,e.shape);return i.length>0&&(t=Z_(t,i)),zE(t,r.shape)}}}};function iL(e,t,n){let r=e.shape.length,a=r-n.length,i=AO.getAxesPermutation(n,r),o=e;null!=i&&(o=VF(e,i));let s=o.shape.slice(),l=s.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);s.push(l);let u=function(e,t,n){let r=e.shape.slice();r[n]=1;let a=zE(t,r),i=y_(e,n,!0,!1),o=y_(e,n,!0,!0),s=lE(i,o);return lE(a,s)}(o.reshape(s),t,a);if(u=u.reshape(o.shape),null!=i){let e=AO.getUndoAxesPermutation(i);u=VF(u,e)}return u}var oL={kernelName:GI,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,i=[];return i=null==a?r.shape.map(((e,t)=>t)):"number"==typeof a?[a]:a,{x:()=>iL(r,e,i)}}},sL={kernelName:DS,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=$_(n.shape,r.shape);return{a:()=>{let t=sE(e,M$(r,"float32")),i=T_(n.shape,a);return i.length>0?zE(Z_(t,i),n.shape):t},b:()=>{let t=lE(e,M$(n,"float32")),i=T_(r.shape,a);i.length>0&&(t=zE(Z_(t,i),r.shape));let o=Q_(r);return EA(sE(t,M$(o,"float32")))}}}},lL={kernelName:ZI,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sE(e,EA(Q_(n)))}}},uL={kernelName:iN,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=lE(bA(n,6),yF(n));return{x:()=>lE(e,M$(r,"float32"))}}},dL={kernelName:JI,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>lE(e,M$(yF(n),"float32"))}}},cL={kernelName:eN,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>zE(e,n.shape)}}},pL={kernelName:rN,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>xT.runKernel(aN,a,n)}}},hL={kernelName:tN,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>xT.runKernel(nN,a,n)}}},fL={kernelName:oN,gradFunc:(e,t,n)=>{let{dims:r}=n,a=rk(r,e.shape);return{x:()=>GR(e,a)}}},mL={kernelName:sN,gradFunc:e=>({x:()=>A_(e)})},gL={kernelName:lN,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>EA(sE(e,lE(K_(n,1.5),2)))}}},bL={kernelName:pN,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>M$(A_(n),"float32"),t:()=>lE(e,M$(n,e.dtype)),e:()=>lE(e,M$(OA(n),e.dtype))}}},yL={kernelName:hN,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=uA(n,X_(0)),r=X_(GO),a=X_(qO),i=lE(e,a),o=lE(lE(e,r),nA(M$(n,"float32")));return __(t,i,o)}}}},vL={kernelName:yN,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>lE(e,lE(n,RA(X_(1),n)))}}},xL={kernelName:bN,gradFunc:e=>({x:()=>A_(e)})},wL={kernelName:mN,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>lE(g_(M$(n,"float32")),e)}}},kL={kernelName:gN,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>lE(b_(M$(n,"float32")),e)}}},SL={kernelName:fN,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:i}=n,o=r.shape,[s,l]=kO(r,a,i),u=[];for(let d=0;d<e.rank;d++)u.push([s[d],o[d]-s[d]-l[d]]);return{x:()=>oR(e,u)}}},IL={kernelName:IN,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,i=lE(e,r);return{logits:()=>RA(i,lE(Z_(i,[a],!0),r))}}},NL={kernelName:vN,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>lE(e,VE(n))}}},CL={kernelName:kN,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>GE(e,r,a)}}},TL={kernelName:SN,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>BE(e,r)}}},$L={kernelName:xN,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sE(e,lE(Y_(M$(n,"float32")),2))}}},EL={kernelName:AN,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>lE(e,lE(M$(n,"float32"),2))}}},_L={kernelName:_N,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=X_(2);return{a:()=>lE(e,lE(a,RA(n,r))),b:()=>lE(e,lE(a,RA(r,n)))}}},AL={kernelName:XN,gradFunc:e=>({x:()=>A_(e)})},RL={kernelName:zN,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=$_(n.shape,r.shape);return{a:()=>{let t=e,r=T_(n.shape,a);return r.length>0&&(t=Z_(t,r)),zE(t,n.shape)},b:()=>{let t=e,n=T_(r.shape,a);return n.length>0&&(t=Z_(t,n)),zE(EA(t),r.shape)}}}},FL={kernelName:wN,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:i}=n;rk(i,r.shape).forEach((e=>{a[e]=1}));let o=zE(e,a),s=lE(o,KA(r.shape,"float32"));return{x:()=>s}}},DL={kernelName:PN,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>sE(e,Q_(g_(n)))}}},ML={kernelName:LN,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>lE(RA(X_(1),Q_(n)),e)}}},OL={kernelName:BN,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let t=A_(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=iE(t,UE(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let i=0;i<a[1];++i)t=iE(t,UE(e,[n*r.shape[0],i*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let i=0;i<a[1];++i)for(let o=0;o<a[2];++o)t=iE(t,UE(e,[n*r.shape[0],i*r.shape[1],o*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<a[0];++n)for(let i=0;i<a[1];++i)for(let o=0;o<a[2];++o)for(let s=0;s<a[3];++s)t=iE(t,UE(e,[n*r.shape[0],i*r.shape[1],o*r.shape[2],s*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},zL={kernelName:UN,gradFunc:(e,t,n)=>{let r=n,{perm:a}=r,i=j_(a);return{x:()=>VF(e,i)}}},PL={kernelName:HN,gradFunc:(e,t,n)=>{let r=n,{axis:a}=r;return{value:()=>bF(e,a)}}},LL={kernelName:GN,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>function(e,t){let n=HA(t,A_(t)),r=lA(e,n),a=dA(t,X_(0,"int32")),i=r.rank-a.rank;for(let s=0;s<i;++s)a=rA(a,s+1);a=MA(a,KA(r.shape,"bool"));let o=A_(r);return __(a,r,o)}(e,n)}}},BL={kernelName:KN,gradFunc:e=>({x:()=>A_(e)})},WL=[Pz,Lz,Bz,Wz,Vz,Uz,jz,Hz,Gz,qz,Kz,Xz,Qz,Jz,eP,tP,nP,rP,aP,iP,oP,sP,uP,lP,cP,pP,hP,fP,mP,gP,sL,bP,yP,vP,xP,wP,SP,kP,IP,NP,$P,EP,_P,AP,RP,FP,DP,MP,OP,PP,BP,BP,WP,UP,HP,GP,qP,KP,XP,YP,QP,ZP,JP,eL,tL,nL,nL,rL,aL,oL,lL,uL,dL,cL,pL,hL,fL,mL,gL,bL,yL,vL,xL,wL,kL,SL,IL,NL,CL,CL,TL,TL,$L,_L,EL,AL,RL,FL,DL,ML,OL,zL,PL,LL,BL];for(let e of WL)uC(e);ZC().prototype.abs=function(){return this.throwIfDisposed(),uE(this)},ZC().prototype.acos=function(){return this.throwIfDisposed(),dE(this)},ZC().prototype.acosh=function(){return this.throwIfDisposed(),cE(this)},ZC().prototype.add=function(e){return this.throwIfDisposed(),iE(this,e)},ZC().prototype.all=function(e,t){return this.throwIfDisposed(),hE(this,e,t)},ZC().prototype.any=function(e,t){return this.throwIfDisposed(),fE(this,e,t)},ZC().prototype.argMax=function(e){return this.throwIfDisposed(),mE(this,e)},ZC().prototype.argMin=function(e){return this.throwIfDisposed(),gE(this,e)},ZC().prototype.asScalar=function(){return this.throwIfDisposed(),Uw(1===this.size,(()=>"The array must have only 1 element.")),zE(this,[])},ZC().prototype.asType=function(e){return this.throwIfDisposed(),M$(this,e)},ZC().prototype.as1D=function(){return this.throwIfDisposed(),zE(this,[this.size])},ZC().prototype.as2D=function(e,t){return this.throwIfDisposed(),zE(this,[e,t])},ZC().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),zE(this,[e,t,n])},ZC().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),zE(this,[e,t,n,r])},ZC().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),zE(this,[e,t,n,r,a])},ZC().prototype.asin=function(){return this.throwIfDisposed(),bE(this)},ZC().prototype.asinh=function(){return this.throwIfDisposed(),yE(this)},ZC().prototype.atan=function(){return this.throwIfDisposed(),vE(this)},ZC().prototype.atan2=function(e){return this.throwIfDisposed(),xE(this,e)},ZC().prototype.atanh=function(){return this.throwIfDisposed(),wE(this)},ZC().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),PE(this,e,t,n,r)},ZC().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),GE(this,e,t)},ZC().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),KE(this,e,t,n,r,a)},ZC().prototype.broadcastTo=function(e){return this.throwIfDisposed(),t_(this,e)},ZC().prototype.cast=function(e){return this.throwIfDisposed(),M$(this,e)},ZC().prototype.ceil=function(){return this.throwIfDisposed(),n_(this)},ZC().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),a_(this,e,t)},ZC().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof QC&&(e=[e]),BE([this,...e],t)},ZC().prototype.conv1d=function(e,t,n,r,a,i){return this.throwIfDisposed(),d_(this,e,t,n,r,a,i)},ZC().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),p_(this,e,t,n,r,a)},ZC().prototype.conv2d=function(e,t,n,r,a,i){return this.throwIfDisposed(),u_(this,e,t,n,r,a,i)},ZC().prototype.cos=function(){return this.throwIfDisposed(),g_(this)},ZC().prototype.cosh=function(){return this.throwIfDisposed(),b_(this)},ZC().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),y_(this,e,t,n)},ZC().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),v_(this,e,t,n)},ZC().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),w_(this,e,t)},ZC().prototype.depthwiseConv2d=function(e,t,n,r,a,i){return this.throwIfDisposed(),k_(this,e,t,n,r,a,i)},ZC().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),I_(this,e,t,n,r,a)},ZC().prototype.divNoNan=function(e){return this.throwIfDisposed(),R_(this,e)},ZC().prototype.div=function(e){return this.throwIfDisposed(),sE(this,e)},ZC().prototype.dot=function(e){return this.throwIfDisposed(),F_(this,e)},ZC().prototype.elu=function(){return this.throwIfDisposed(),M_(this)},ZC().prototype.equal=function(e){return this.throwIfDisposed(),E_(this,e)},ZC().prototype.erf=function(){return this.throwIfDisposed(),z_(this)},ZC().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),tA(this,e,t)},ZC().prototype.exp=function(){return this.throwIfDisposed(),nA(this)},ZC().prototype.expandDims=function(e){return this.throwIfDisposed(),rA(this,e)},ZC().prototype.expm1=function(){return this.throwIfDisposed(),aA(this)},ZC().prototype.fft=function(){return this.throwIfDisposed(),dF(this)},ZC().prototype.flatten=function(){return this.throwIfDisposed(),zE(this,[this.size])},ZC().prototype.floor=function(){return this.throwIfDisposed(),sA(this)},ZC().prototype.floorDiv=function(e){return this.throwIfDisposed(),oE(this,e)},ZC().prototype.gather=function(e,t,n){return this.throwIfDisposed(),lA(this,e,t,n)},ZC().prototype.greaterEqual=function(e){return this.throwIfDisposed(),dA(this,e)},ZC().prototype.greater=function(e){return this.throwIfDisposed(),uA(this,e)},ZC().prototype.ifft=function(){return this.throwIfDisposed(),cF(this)},ZC().prototype.irfft=function(){return this.throwIfDisposed(),pF(this)},ZC().prototype.isFinite=function(){return this.throwIfDisposed(),pA(this)},ZC().prototype.isInf=function(){return this.throwIfDisposed(),hA(this)},ZC().prototype.isNaN=function(){return this.throwIfDisposed(),fA(this)},ZC().prototype.leakyRelu=function(e){return this.throwIfDisposed(),mA(this,e)},ZC().prototype.lessEqual=function(e){return this.throwIfDisposed(),bA(this,e)},ZC().prototype.less=function(e){return this.throwIfDisposed(),gA(this,e)},ZC().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),vA(this,e,t,n,r)},ZC().prototype.logSigmoid=function(){return this.throwIfDisposed(),AA(this)},ZC().prototype.logSoftmax=function(e){return this.throwIfDisposed(),FA(this,e)},ZC().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),DA(this,e,t)},ZC().prototype.log=function(){return this.throwIfDisposed(),xA(this)},ZC().prototype.log1p=function(){return this.throwIfDisposed(),wA(this)},ZC().prototype.logicalAnd=function(e){return this.throwIfDisposed(),MA(this,e)},ZC().prototype.logicalNot=function(){return this.throwIfDisposed(),OA(this)},ZC().prototype.logicalOr=function(e){return this.throwIfDisposed(),zA(this,e)},ZC().prototype.logicalXor=function(e){return this.throwIfDisposed(),PA(this,e)},ZC().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),WE(this,e,t,n)},ZC().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),VA(this,e,t,n,r)},ZC().prototype.max=function(e,t){return this.throwIfDisposed(),G_(this,e,t)},ZC().prototype.maximum=function(e){return this.throwIfDisposed(),HA(this,e)},ZC().prototype.mean=function(e,t){return this.throwIfDisposed(),GA(this,e,t)},ZC().prototype.min=function(e,t){return this.throwIfDisposed(),q_(this,e,t)},ZC().prototype.minimum=function(e){return this.throwIfDisposed(),YA(this,e)},ZC().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),QA(this,e,t)},ZC().prototype.mod=function(e){return this.throwIfDisposed(),ZA(this,e)},ZC().prototype.mul=function(e){return this.throwIfDisposed(),lE(this,e)},ZC().prototype.neg=function(){return this.throwIfDisposed(),EA(this)},ZC().prototype.norm=function(e,t,n){return this.throwIfDisposed(),eA(this,e,t,n)},ZC().prototype.notEqual=function(e){return this.throwIfDisposed(),nR(this,e)},ZC().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),rR(this,e,t,n)},ZC().prototype.onesLike=function(){return this.throwIfDisposed(),aR(this)},ZC().prototype.pad=function(e,t){return this.throwIfDisposed(),oR(this,e,t)},ZC().prototype.pool=function(e,t,n,r,a,i){return this.throwIfDisposed(),pR(this,e,t,n,r,a,i)},ZC().prototype.pow=function(e){return this.throwIfDisposed(),K_(this,e)},ZC().prototype.prelu=function(e){return this.throwIfDisposed(),hR(this,e)},ZC().prototype.prod=function(e,t){return this.throwIfDisposed(),fR(this,e,t)},ZC().prototype.reciprocal=function(){return this.throwIfDisposed(),UR(this)},ZC().prototype.relu=function(){return this.throwIfDisposed(),jR(this)},ZC().prototype.relu6=function(){return this.throwIfDisposed(),HR(this)},ZC().prototype.reshapeAs=function(e){return this.throwIfDisposed(),zE(this,e.shape)},ZC().prototype.reshape=function(e){return this.throwIfDisposed(),zE(this,e)},ZC().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),RD(this,e,t,n)},ZC().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),FD(this,e,t,n)},ZC().prototype.reverse=function(e){return this.throwIfDisposed(),GR(this,e)},ZC().prototype.rfft=function(){return this.throwIfDisposed(),fF(this)},ZC().prototype.round=function(){return this.throwIfDisposed(),QR(this)},ZC().prototype.rsqrt=function(){return this.throwIfDisposed(),ZR(this)},ZC().prototype.selu=function(){return this.throwIfDisposed(),JR(this)},ZC().prototype.separableConv2d=function(e,t,n,r,a,i){return this.throwIfDisposed(),eF(this,e,t,n,r,a,i)},ZC().prototype.sigmoid=function(){return this.throwIfDisposed(),VE(this)},ZC().prototype.sign=function(){return this.throwIfDisposed(),nF(this)},ZC().prototype.sin=function(){return this.throwIfDisposed(),rF(this)},ZC().prototype.sinh=function(){return this.throwIfDisposed(),aF(this)},ZC().prototype.slice=function(e,t){return this.throwIfDisposed(),UE(this,e,t)},ZC().prototype.softmax=function(e){return this.throwIfDisposed(),uF(this,e)},ZC().prototype.softplus=function(){return this.throwIfDisposed(),_A(this)},ZC().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),cR(this,e,t)},ZC().prototype.split=function(e,t){return this.throwIfDisposed(),hF(this,e,t)},ZC().prototype.sqrt=function(){return this.throwIfDisposed(),Y_(this)},ZC().prototype.square=function(){return this.throwIfDisposed(),Q_(this)},ZC().prototype.squaredDifference=function(e){return this.throwIfDisposed(),mF(this,e)},ZC().prototype.squeeze=function(e){return this.throwIfDisposed(),gF(this,e)},ZC().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof QC?[this,e]:[this,...e];return bF(n,t)},ZC().prototype.step=function(e){return this.throwIfDisposed(),yF(this,e)},ZC().prototype.stridedSlice=function(e,t,n,r,a,i,o,s){return this.throwIfDisposed(),vF(this,e,t,n,r,a,i,o,s)},ZC().prototype.sub=function(e){return this.throwIfDisposed(),RA(this,e)},ZC().prototype.sum=function(e,t){return this.throwIfDisposed(),Z_(this,e,t)},ZC().prototype.tan=function(){return this.throwIfDisposed(),xF(this)},ZC().prototype.tanh=function(){return this.throwIfDisposed(),jE(this)},ZC().prototype.tile=function(e){return this.throwIfDisposed(),iA(this,e)},ZC().prototype.toBool=function(){return this.throwIfDisposed(),M$(this,"bool")},ZC().prototype.toFloat=function(){return this.throwIfDisposed(),M$(this,"float32")},ZC().prototype.toInt=function(){return this.throwIfDisposed(),M$(this,"int32")},ZC().prototype.topk=function(e,t){return this.throwIfDisposed(),RF(this,e,t)},ZC().prototype.transpose=function(e){return this.throwIfDisposed(),VF(this,e)},ZC().prototype.unique=function(e){return this.throwIfDisposed(),DF(this,e)},ZC().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),MF(this,e,t)},ZC().prototype.unstack=function(e){return this.throwIfDisposed(),OF(this,e)},ZC().prototype.where=function(e,t){return this.throwIfDisposed(),__(e,this,t)},ZC().prototype.zerosLike=function(){return this.throwIfDisposed(),A_(this)};var VL=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,VL.prototype)}},UL=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,UL.prototype)}},jL=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,jL.prototype)}},HL=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,HL.prototype)}},GL=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,GL.prototype)}},qL=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}};function KL(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{let n=new Array(t);return n.fill(e),n}}function XL(e,t){if(!e)throw new GL(t)}function YL(e,t){let n=0;for(let r of e)r===t&&n++;return n}function QL(e){return 1===e.length?e[0]:e}function ZL(e){return Array.isArray(e)?e:[e]}function JL(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function eB(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}var tB={};function nB(e){if(null==e)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function rB(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>rB(e)));else{let t=Object.keys(e);for(let n of t){let t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?rB(t):e[n]=t.value)}}}function aB(e,t={},n={},r="object",a=!1){if("string"==typeof e){let a,i=e;if(i in n)a=n[i];else if(i in tB)a=tB[i];else if(a=t[i],null==a)throw new jL(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{let i=e;if(null==i.className||null==i.config)throw new jL(`${r}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);let o,s,l=i.className;if(l in n?[o,s]=n[l]:l in tB?[o,s]=tB.className:l in t&&([o,s]=t[l]),null==o)throw new jL(`Unknown ${r}: ${l}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=s){let e={};for(let n of Object.keys(tB))e[n]=tB[n];for(let a of Object.keys(n))e[a]=n[a];i.config.customObjects=e;let t=Object.assign({},tB);for(let a of Object.keys(n))tB[a]=n[a];rB(i.config);let r=s(o,i.config,n,a);return tB=Object.assign({},t),r}{let e=Object.assign({},tB);for(let r of Object.keys(n))tB[r]=n[r];let t=new o(i.config);return tB=Object.assign({},e),t}}}function iB(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function oB(e){if(null==e)return e;let t=[];for(let n of e)-1===t.indexOf(n)&&t.push(n);return t}function sB(e){if(null==e)throw new jL(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function lB(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new jL(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function uB(e,t,n=0,r=1/0){return XL(n>=0),XL(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function dB(e,t){Array.isArray(e)?(fC.assert(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>dB(e,`element ${n+1} of ${t}`)))):fC.assert(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${cB(e)}.`))}function cB(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>cB(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function pB(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}var hB=0;function fB(){return hB++}var mB={};function gB(e=""){return e in mB||(mB[e]=0),mB[e]+=1,e+mB[e].toString()}var bB=["channelsFirst","channelsLast"],yB=["nearest","bilinear"],vB=["valid","same","causal"],xB=["max","avg"],wB=["sum","mul","concat","ave"],kB=new Map;function SB(e){lB(bB,"DataFormat",e)}function IB(e){lB(vB,"PaddingMode",e)}function NB(e){lB(xB,"PoolMode",e)}var CB=[],TB="/";function $B(e,t){CB.push(e);try{let e=t();return CB.pop(),e}catch(Ep){throw CB.pop(),Ep}}function EB(e){if(!FB(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===CB.length?"":CB.join(TB)+TB)+e}function _B(e){if(!FB(e))throw new Error("Not a valid tensor name: '"+e+"'");kB.has(e)||kB.set(e,0);let t=kB.get(e);if(kB.set(e,kB.get(e)+1),t>0){let n=`${e}_${t}`;return kB.set(n,1),n}return e}var AB,RB=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function FB(e){return!!e.match(RB)}function DB(e){return e===parseInt(e.toString(),10)}function MB(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function OB(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function zB(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function PB(e,t){if(t<e)throw new jL(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}function LB(){return null==AB&&(AB=rE().epsilon()),AB}function BB(e,t){return M$(e,t)}function WB(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),zE(e,n)}function VB(e,t,n){return G$((()=>{switch(e.rank){case 1:return iF(e,t,n);case 2:return oF(e,[t,0],[n,e.shape[1]]);case 3:return sF(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return lF(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return UE(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return UE(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new jL(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function UB(e,t,n){return G$((()=>{switch(e.rank){case 1:return iF(e,t,n);case 2:return oF(e,[0,t],[e.shape[0],n]);case 3:return sF(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return lF(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new jL(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function jB(e,t,n,r){return G$((()=>{switch(e.rank){case 1:return iF(e,t,n);case 2:switch(r){case 1:return VB(e,t,n);case 2:return UB(e,t,n);default:throw new jL(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return VB(e,t,n);case 2:return sF(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return UB(e,t,n);default:throw new jL(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return VB(e,t,n);case 2:return lF(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return lF(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return UB(e,t,n);default:throw new jL(`The axis is not within the rank of the tensor ${r}`)}default:throw new jL(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function HB(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),BE(e,t)}function GB(e,t){switch(e.rank){case 1:return i_([e,t]);case 2:return o_([e,t],0);case 3:return s_([e,t],0);case 4:return l_([e,t],0);default:throw new jL(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function qB(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new jL(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return iA(e,t)}function KB(e,t=0,n=1,r,a){return zR(e,t,n,r,a)}function XB(e,t,n,r){if(e.rank<2||t.rank<2)throw new HL(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3&&e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new HL(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);if(2===e.rank&&2===t.rank)return QF.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?ZB(e.rank,r,"channelsLast"):null,activation:n});{let a=e.shape.slice(),i=a.pop();e=zE(e,[-1,i]);let o=t.shape.slice(),s=o.pop(),l=o.pop(),u=[...o,s],d=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=zE(VF(t,d),[l,-1]);let c=[...a,...u],p=!1,h=!1;return zE(QF.matMul({a:e,b:t,transposeA:p,transposeB:h,bias:r?ZB(e.rank,r,"channelsLast"):null,activation:n}),c)}}function YB(e,t,n){return G$((()=>(t=Array.isArray(t)?wF(t,"int32"):M$(t,"int32"),lA(e,t,n))))}function QB(e){return lE(e,e)}function ZB(e,t,n){let r=t.shape;if(1!==t.rank&&t.rank!==e)throw new jL(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?zE(t,[1,r[0],1,1,1]):zE(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?zE(t,[1,1,1,1,r[0]]):zE(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?zE(t,[1,r[0],1,1]):zE(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?zE(t,[1,1,1,r[0]]):zE(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?zE(t,[1,r[0],1]):zE(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?zE(t,[1,1,r[0]]):zE(t,[1].concat(r))}else if(e<3)return t;throw new jL(`Unsupported input rank by biasAdd: ${t.rank}`)}function JB(e,t,n){return G$((()=>(null==n&&(n="channelsLast"),SB(n),iE(e,ZB(e.rank,t,n)))))}function eW(e,t,n,r){return G$((()=>qF(e,t,n,r)))}function tW(e,t,n=!1){return n?e():t()}var nW=["fanIn","fanOut","fanAvg"],rW=["normal","uniform","truncatedNormal"],aW=class extends cM.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},iW=class extends aW{apply(e,t){return qA(e,t)}};iW.className="Zeros",cM.registerClass(iW);var oW=class extends aW{apply(e,t){return KA(e,t)}};oW.className="Ones",cM.registerClass(oW);var sW=class extends aW{constructor(e){if(super(),"object"!=typeof e)throw new jL(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new jL(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return G$((()=>lE(X_(this.value),KA(e,t))))}getConfig(){return{value:this.value}}};sW.className="Constant",cM.registerClass(sW);var lW=class extends aW{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return LR(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};lW.className="RandomUniform",cM.registerClass(lW);var uW=class extends aW{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new HL(`randomNormal does not support dType ${t}.`);return KB(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};uW.className="RandomNormal",cM.registerClass(uW);var dW=class extends aW{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new HL(`truncatedNormal does not support dType ${t}.`);return FF(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};dW.className="TruncatedNormal",cM.registerClass(dW);var cW=class extends aW{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return G$((()=>{if(2!==e.length||e[0]!==e[1])throw new jL("Identity matrix initializer can only be used for 2D square matrices.");return lE(this.gain,oA(e[0]))}))}getConfig(){return{gain:this.gain}}};cW.className="Identity",cM.registerClass(cW);var pW=class extends aW{constructor(e){if(super(),e.scale<0)throw new jL(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function(e){lB(nW,"FanMode",e)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function(e){lB(rW,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){let n=function(e,t="channelsLast"){let n,r;if(SB(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){let t=MB(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){let t=MB(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{let t=MB(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}(e),r=n[0],a=n[1],i=this.scale;if("fanIn"===this.mode?i/=Math.max(1,r):"fanOut"===this.mode?i/=Math.max(1,a):i/=Math.max(1,(r+a)/2),"normal"===this.distribution){let n=Math.sqrt(i);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new HL(`${this.getClassName()} does not support dType ${t}.`);return FF(e,0,n,t,this.seed)}{let n=Math.sqrt(3*i);return LR(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};pW.className="VarianceScaling",cM.registerClass(pW);var hW=class extends pW{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return pW.className}};hW.className="GlorotUniform",cM.registerClass(hW);var fW=class extends pW{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return pW.className}};fW.className="GlorotNormal",cM.registerClass(fW);var mW=class extends pW{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return pW.className}};mW.className="HeNormal",cM.registerClass(mW);var gW=class extends pW{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return pW.className}};gW.className="HeUniform",cM.registerClass(gW);var bW=class extends pW{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return pW.className}};bW.className="LeCunNormal",cM.registerClass(bW);var yW=class extends pW{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return pW.className}};yW.className="LeCunUniform",cM.registerClass(yW);var vW=class extends aW{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return G$((()=>{if(e.length<2)throw new HL("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);let n=fC.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],a=n*r;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);let i=KB([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),o=sM.qr(i,!1),s=o[0],l=o[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return s=lE(s,l.sign()),n<r&&(s=s.transpose()),lE(X_(this.gain),s.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}};vW.className="Orthogonal",cM.registerClass(vW);var xW={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function wW(e,t={}){return aB(e,cM.SerializationMap.getMap().classNameMap,t,"initializer")}function kW(e){return nB(e)}function SW(e){if("string"==typeof e){let t=e in xW?xW[e]:e;if("GlorotNormal"===t)return new fW;if("GlorotUniform"===t)return new hW;if("HeNormal"===t)return new mW;if("HeUniform"===t)return new gW;if("LeCunNormal"===t)return new bW;if("LeCunUniform"===t)return new yW;{let e={};return e.className=t,e.config={},wW(e)}}return e instanceof aW?e:wW(e)}function IW(e){return Array.isArray(e)&&Array.isArray(e[0])}function NW(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function CW(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new jL(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function TW(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new jL(`Expected exactly 1 Shape; got ${e.length}`)}return e}function $W(e){let t=0;for(let n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}var EW="Variable",_W=class{constructor(e,t="float32",n=EW,r=!0,a=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=fB(),n=null==n?EW:n,this.originalName=EB(n),this.name=_B(this.originalName),this.trainable_=r,this.constraint=a,this.val=PF(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function AW(e){return e.map((e=>e.read()))}function RW(e){e.forEach((e=>{e[0].write(e[1])}))}var FW=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},DW=class{constructor(e,t,n,r,a,i,o){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=o,this.id=fB(),null!=i&&(this.originalName=EB(i),this.name=_B(this.originalName)),this.rank=t.length}},MW=0,OW=class{constructor(e,t){this.callArgs=t,this.id=MW++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},zW=0,PW=class extends cM.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=zW++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let e=this.getClassName();t=JL(e)+"_"+gB(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new UL(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new jL(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return QL(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return QL(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new VL(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new VL(`Layer ${this.name} is not connected, no input to return.`);return QL(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new VL(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new VL(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return QL(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=ZL(e),null==this.inputSpec||0===this.inputSpec.length)return;let t=ZL(this.inputSpec);if(e.length!==t.length)throw new jL(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){let r=e[n],a=t[n];if(null==a)continue;let i=r.rank;if(null!=a.ndim&&i!==a.ndim)throw new jL(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${i}`);if(null!=a.maxNDim&&i>a.maxNDim)throw new jL(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${i}`);if(null!=a.minNDim&&i<a.minNDim)throw new jL(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${i}.`);if(null!=a.dtype&&r.dtype!==a.dtype)throw new jL(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${r.dtype}.`);if(a.axes){let e=r.shape;for(let t in a.axes){let r=Number(t),i=a.axes[t],o=r>=0?e[r]:e[e.length+r];if(null!=i&&-1===[i,null].indexOf(o))throw new jL(`Input ${n} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${i} but got shape ${e}.`)}}if(null!=a.shape)for(let e=0;e<a.shape.length;++e){let t=a.shape[e],i=r.shape[e];if(null!=t&&null!=i&&t!==i)throw new jL(`Input ${n} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=ZL(e),r=!0;for(let i of n)if(!(i instanceof DW)){r=!1;break}let a=!0;for(let i of n)if(i instanceof DW){a=!1;break}if(r===a)throw new jL("Arguments to apply() must be all SymbolicTensors or all Tensors");return $B(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);let t=[];for(let n of ZL(e))t.push(n.shape);this.build(QL(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t),a=ZL(r),i=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),i.push(e);if(r=QL(i),null!=this.activityRegularizer)throw new HL("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{let n,r=function(e){e=ZL(e);let t=[];for(let n of e)t.push(n.shape);return QL(t)}(e),a=this.computeOutputShape(r),i="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?r[0]:r),n=null!=a&&a.length>0&&Array.isArray(a[0])?a.map(((n,r)=>new DW(i,n,this,ZL(e),t,this.name,r))):new DW(i,a,this,ZL(e),t,this.name),this.addInboundNode(e,n,null,null,r,a,t),this._refCount++,null!=this.activityRegularizer)throw new HL("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return n}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new VL(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new VL(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new UL(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return $W(this.weights)}build(e){this.built=!0}getWeights(e=!1){return AW(e?this.trainableWeights:this.weights)}setWeights(e){G$((()=>{let t=this.weights;if(t.length!==e.length)throw new jL(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;let n=[],r=AW(t);for(let a=0;a<r.length;++a){let i=r[a],o=t[a],s=e[a];if(!fC.arraysEqual(i.shape,s.shape))throw new jL(`Layer weight shape ${i.shape} not compatible with provided weight shape ${s.shape}`);n.push([o,s])}RW(n)}))}addWeight(e,t,n,r,a,i,o,s){if(-1!==this._addedWeightNames.indexOf(e))throw new jL(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=s?s():SW("zeros"));let l=r.apply(t,n),u=new _W(l,n,e,i,o);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(u.read()))),null==i&&(i=!0),i?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=ZL(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}addInboundNode(e,t,n,r,a,i,o=null){let s=ZL(e);t=ZL(t),n=ZL(n),r=ZL(r),a=NW(a),i=NW(i);let l=[],u=[],d=[];for(let c of s)l.push(c.sourceLayer),u.push(c.nodeIndex),d.push(c.tensorIndex);new OW({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:d,inputTensors:s,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:i},o);for(let c=0;c<t.length;c++)t[c].sourceLayer=this,t[c].nodeIndex=this.inboundNodes.length-1,t[c].tensorIndex=c}getConfig(){let e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function LW(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{let e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{let t=[];for(let n=0;n<e.inboundLayers.length;n++){let r=LW(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(let e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}var BW=class extends PW{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:gB("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new jL("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new jL("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new jL("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new DW(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new OW({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new jL(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};function WW(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new jL("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new BW({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}BW.className="InputLayer",cM.registerClass(BW);var VW=class{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof VW)for(let t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(let t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new jL(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return M$(t,e.dtype)}catch(n){throw new jL(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof DW){if(null==this.id2Value[e.id])throw new jL(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{let t=this.name2Id[e];if(null==t)throw new jL(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof DW){if(null==this.id2Value[e.id])throw new jL(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{let t=this.name2Id[e];if(null==t)throw new jL(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&q$(this.id2Mask)}},UW=new qL,jW=new qL;function HW(e,t,n,r){let a=null!=n&&n.training,i=Array.isArray(e),o=i?e:[e],s=o.map((e=>e.name)),l=[],u=t.names();for(let f of s)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let d,c=s.join(",")+"|"+t.names().sort().join(","),p=UW.get(c);if(null==p){let e=function(e,t){fC.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){let a=qW(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let i of e){let{sorted:e,recipientMap:o}=qW(i,t);for(let t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(let t in o)null==r[t]&&(r[t]=new Set),o[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:GW(r)}}(o,t);p=e.sorted,d=e.recipientCounts,UW.put(c,p),jW.put(c,d)}d={},a||Object.assign(d,jW.get(c));let h=new VW(t);for(let f=0;f<p.length;++f){if(null!=r){let e=j$().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}let e=p[f],i=e.sourceLayer;if(i instanceof BW)continue;let o=[],u=[],c=[],m=!1;for(let n of e.inputs){let e=h.getValue(n),r=h.getMask(n);o.push(e),u.push(r),null!=r&&(m=!0),a||(d[n.name]--,0===d[n.name]&&!t.hasKey(n)&&-1===s.indexOf(n.name)&&!e.isDisposed&&!0!==n.sourceLayer.stateful&&c.push(e))}m&&((n=n||{}).mask=u[0]);let g=ZL(i.apply(o,n)),b=null;i.supportsMasking&&(b=i.computeMask(o,u));let y=KW(e),v=Array.isArray(y)?y:[y];for(let t=0;t<v.length;++t){h.hasKey(v[t])||h.add(v[t],g[t],Array.isArray(b)?b[0]:b);let e=s.indexOf(v[t].name);-1!==e&&(l[e]=g[t])}a||q$(c)}return h.disposeMasks(),i?l:l[0]}function GW(e){let t={};for(let n in e)t[n]=e[n].size;return t}function qW(e,t){let n=new Set,r=[],a={};for(let s of t.names())n.add(s);let i=[],o=[];for(i.push(e);i.length>0;){let e=i[i.length-1];if(n.has(e.name)){i.pop();continue}let t=o[o.length-1]===i.length-1;if(0===e.inputs.length||t)i.pop(),r.push(e),n.add(e.name),t&&o.pop();else{o.push(i.length-1);for(let t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),!n.has(t.name)&&i.push(t)}}return{sorted:r,recipientMap:a}}function KW(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(let r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}Rk().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=UW&&UW.setMaxEntries(e),null!=jW&&jW.setMaxEntries(e)}));var XW={};function YW(e,t){return G$((()=>Y_(Z_(lE(e,e),t,!0))))}uw(XW,{maxNorm:()=>oV,minMaxNorm:()=>uV,nonNeg:()=>lV,unitNorm:()=>sV});var QW=class extends cM.Serializable{getConfig(){return{}}},ZW=class extends QW{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return G$((()=>{let t=YW(e,this.axis),n=a_(t,0,this.maxValue);return lE(e,sE(n,iE(LB(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};ZW.className="MaxNorm",cM.registerClass(ZW);var JW=class extends QW{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return G$((()=>sE(e,iE(LB(),YW(e,this.axis)))))}getConfig(){return{axis:this.axis}}};JW.className="UnitNorm",cM.registerClass(JW);var eV=class extends QW{apply(e){return jR(e)}};eV.className="NonNeg",cM.registerClass(eV);var tV=class extends QW{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return G$((()=>{let t=YW(e,this.axis),n=iE(lE(this.rate,a_(t,this.minValue,this.maxValue)),lE(1-this.rate,t));return lE(e,sE(n,iE(LB(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};tV.className="MinMaxNorm",cM.registerClass(tV);var nV={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function rV(e){return nB(e)}function aV(e,t={}){return aB(e,cM.SerializationMap.getMap().classNameMap,t,"constraint")}function iV(e){return null==e?null:"string"==typeof e?aV({className:e in nV?nV[e]:e,config:{}}):e instanceof QW?e:aV(e)}function oV(e){return new ZW(e)}function sV(e){return new JW(e)}function lV(){return new eV}function uV(e){return new tV(e)}var dV={};function cV(){return new iW}function pV(){return new oW}function hV(e){return new sW(e)}function fV(e){return new lW(e)}function mV(e){return new uW(e)}function gV(e){return new dW(e)}function bV(e){return new cW(e)}function yV(e){return new pW(e)}function vV(e){return new hW(e)}function xV(e){return new fW(e)}function wV(e){return new mW(e)}function kV(e){return new gW(e)}function SV(e){return new bW(e)}function IV(e){return new yW(e)}function NV(e){return new vW(e)}uw(dV,{constant:()=>hV,glorotNormal:()=>xV,glorotUniform:()=>vV,heNormal:()=>wV,heUniform:()=>kV,identity:()=>bV,leCunNormal:()=>SV,leCunUniform:()=>IV,ones:()=>pV,orthogonal:()=>NV,randomNormal:()=>mV,randomUniform:()=>fV,truncatedNormal:()=>gV,varianceScaling:()=>yV,zeros:()=>cV});var CV,TV={};async function $V(e){if(null==e)return;let t=[],n=[],r=[];for(let a in e){let i=e[a];if("number"!=typeof i){let e=i;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){let a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];q$(r)}}function EV(e){if(null!=e)for(let t in e){let n=e[t];"number"!=typeof n&&n.dispose()}}uw(TV,{Layer:()=>PW,RNN:()=>Wj,RNNCell:()=>Vj,activation:()=>xG,add:()=>EG,alphaDropout:()=>vq,average:()=>_G,averagePooling1d:()=>LG,averagePooling2d:()=>VG,averagePooling3d:()=>HG,avgPool1d:()=>BG,avgPool2d:()=>UG,avgPool3d:()=>GG,avgPooling1d:()=>WG,avgPooling2d:()=>jG,avgPooling3d:()=>qG,batchNormalization:()=>OG,bidirectional:()=>cq,categoryEncoding:()=>Iq,centerCrop:()=>kq,concatenate:()=>AG,conv1d:()=>cG,conv2d:()=>pG,conv2dTranspose:()=>hG,conv3d:()=>fG,conv3dTranspose:()=>mG,convLstm2d:()=>sq,convLstm2dCell:()=>lq,cropping2D:()=>bG,dense:()=>wG,depthwiseConv2d:()=>vG,dot:()=>MG,dropout:()=>kG,elu:()=>iG,embedding:()=>$G,flatten:()=>IG,gaussianDropout:()=>yq,gaussianNoise:()=>bq,globalAveragePooling1d:()=>KG,globalAveragePooling2d:()=>XG,globalMaxPool1d:()=>hq,globalMaxPool2d:()=>fq,globalMaxPooling1d:()=>YG,globalMaxPooling2d:()=>QG,gru:()=>tq,gruCell:()=>nq,input:()=>VU,inputLayer:()=>aG,layerNormalization:()=>zG,leakyReLU:()=>sG,lstm:()=>rq,lstmCell:()=>aq,masking:()=>xq,maxPool1d:()=>mq,maxPool2d:()=>gq,maxPooling1d:()=>ZG,maxPooling2d:()=>JG,maxPooling3d:()=>eq,maximum:()=>RG,minimum:()=>FG,multiply:()=>DG,permute:()=>TG,prelu:()=>lG,randomWidth:()=>Nq,reLU:()=>oG,repeatVector:()=>NG,rescaling:()=>wq,reshape:()=>CG,resizing:()=>Sq,rnn:()=>uq,separableConv2d:()=>gG,simpleRNN:()=>iq,simpleRNNCell:()=>oq,softmax:()=>uG,spatialDropout1d:()=>SG,stackedRNNCells:()=>dq,thresholdedReLU:()=>dG,timeDistributed:()=>pq,upSampling2d:()=>yG,zeroPadding2d:()=>PG}),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(CV||(CV={}));var _V=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},AV=class{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},RV=class extends _V{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});let n=null==t.size?0:t.size;this.seen+=n;for(let r in t){let e=t[r];if("number"==typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;let a=G$((()=>iE(this.totals[r],lE(e,n))));this.totals[r]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(let n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?t[n]=this.totals[n]/this.seen:G$((()=>{let e=lE(sE(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),K$(t[n])})))}},FV=class extends _V{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(let n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let a in this.history){let r=this.history[a];for(let i=0;i<r.length;++i)if("number"!=typeof r[i]){let o=r[i];e.push(o.data()),t.push(a),n.push(i)}}let r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}},DV=class extends _V{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||EO,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");fC.isNumber(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,a=null!=n?n():fC.now();return(...i)=>{let o=null!=n?n():fC.now();return o-a<t||(a=o,r=e(...i)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];null!=this.yield&&(await $V(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await $V(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];null!=this.epochEnd&&(await $V(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await $V(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];null!=this.batchEnd&&(await $V(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):fC.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await $V(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await $V(e),await this.trainEnd(e))}};function MV(e,t){return null==e&&(e={}),e instanceof _V?[e]:Array.isArray(e)&&e[0]instanceof _V?e:ZL(e).map((e=>new DV(e,t)))}var OV=class{constructor(){}static registerCallbackConstructor(e,t){fC.assert(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),OV.checkForDuplicate(t),null==OV.constructors[e]&&(OV.constructors[e]=[]),OV.constructors[e].push(t)}static checkForDuplicate(e){for(let t in OV.constructors)OV.constructors[+t].forEach((t=>{if(t===e)throw new jL("Duplicate callback constructor.")}))}static clear(){OV.constructors={}}static createCallbacks(e){let t=[];for(let n in OV.constructors){let r=+n;e>=r&&t.push(...OV.constructors[r])}return t.map((e=>new e))}};function zV(e,t,n,r,a,i,o,s,l){let u=new FV,d=[new RV,...OV.createCallbacks(t)];null!=e&&d.push(...e),d.push(u);let c=new AV(d);return c.setParams({epochs:n,initialEpoch:r,samples:a,steps:i,batchSize:o,verbose:t,doValidation:s,metrics:l}),{callbackList:c,history:u}}function PV(e,t={},n=!1){return aB(e,cM.SerializationMap.getMap().classNameMap,t,"layer",n)}function LV(e,t){return G$((()=>{"float32"!==e.dtype&&(e=M$(e,"float32"));let n=Z_(QB(e),t,!0),r=r_(n.shape,LB()),a=Y_(HA(n,r));return sE(e,a)}))}function BV(e,t){return G$((()=>GA(QB(RA(t,e)),-1)))}function WV(e,t){return G$((()=>GA(uE(RA(t,e)),-1)))}function VV(e,t){return G$((()=>{let n=RA(e,t),r=a_(uE(e),LB(),Number.MAX_VALUE),a=uE(sE(n,r));return lE(100,GA(a,-1))}))}function UV(e,t,n=!1){return G$((()=>{if(n)t=uF(t);else{let e=Z_(t,t.shape.length-1,!0);t=sE(t,e)}return t=a_(t,LB(),1-LB()),EA(Z_(lE(M$(e,"float32"),xA(t)),t.shape.length-1))}))}function jV(e,t,n=!1){return G$((()=>{let r=M$(sA(function(e){let t=[MB(e.shape)];return zE(e,t)}(e)),"int32"),a=(t=a_(t,LB(),1-LB())).shape;return UV(zE(rR(r,a[a.length-1]),a),t,n)}))}function HV(e,t){return G$((()=>{let n;return n=a_(t,LB(),1-LB()),n=xA(sE(n,RA(1,n))),GA(function(e,t){if(!fC.arraysEqual(e.shape,t.shape))throw new jL(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return G$((()=>{let n=jR(t),r=EA(uE(t));return iE(RA(n,lE(t,e)),wA(nA(r)))}))}(e,n),-1)}))}function GV(e,t){return G$((()=>{let n=LV(e,-1),r=LV(t,-1),a=lE(n,r);return EA(Z_(a,-1))}))}OV.constructors={};var qV={meanSquaredError:BV,meanAbsoluteError:WV,meanAbsolutePercentageError:VV,meanSquaredLogarithmicError:function(e,t){return G$((()=>{let n=a_(t,LB(),Number.MAX_VALUE),r=xA(iE(1,n)),a=a_(e,LB(),Number.MAX_VALUE),i=xA(iE(1,a));return GA(QB(RA(r,i)),-1)}))},squaredHinge:function(e,t){return G$((()=>{let n=HA(0,RA(1,lE(e,t)));return GA(QB(n),-1)}))},hinge:function(e,t){return G$((()=>{let n=HA(0,RA(1,lE(e,t)));return GA(n,-1)}))},categoricalHinge:function(e,t){return G$((()=>{let n=Z_(lE(e,t),-1),r=G_(lE(RA(1,e),t),-1);return HA(0,iE(1,RA(r,n)))}))},logcosh:function(e,t){return G$((()=>{let n=Math.log(2),r=RA(t,e),a=RA(iE(r,_A(lE(-2,r))),n);return GA(a,-1)}))},categoricalCrossentropy:UV,sparseCategoricalCrossentropy:jV,binaryCrossentropy:HV,kullbackLeiblerDivergence:function(e,t){return G$((()=>{let n=a_(e,LB(),1),r=a_(t,LB(),1);return Z_(lE(e,xA(sE(n,r))),-1)}))},poisson:function(e,t){return G$((()=>{let n=xA(iE(LB(),t));return GA(RA(t,lE(e,n)),-1)}))},cosineProximity:GV};function KV(e){if("string"==typeof e){if(e in qV)return qV[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new jL(t)}return e}function XV(e,t){return G$((()=>{let n=lE(.5,aR(t)),r=BB(uA(t,n),e.dtype);return GA(E_(e,r),-1)}))}function YV(e,t){return G$((()=>BB(E_(mE(e,-1),mE(t,-1)),"float32")))}function QV(e,t){return G$((()=>M$(Z_(MA(E_(e,1),E_(t,1))),"float32")))}function ZV(e,t){return G$((()=>{let n=QV(e,t),r=function(e,t){return G$((()=>M$(Z_(MA(E_(e,0),E_(t,1))),"float32")))}(e,t),a=iE(n,r);return M$(__(uA(a,0),sE(n,a),0),"float32")}))}function JV(e,t){return G$((()=>{let n=QV(e,t),r=function(e,t){return G$((()=>M$(Z_(MA(E_(e,1),E_(t,0))),"float32")))}(e,t),a=iE(n,r);return M$(__(uA(a,0),sE(n,a),0),"float32")}))}function eU(e,t){return HV(e,t)}function tU(e,t){return e.rank===t.rank&&(e=gF(e,[e.rank-1])),(t=mE(t,-1)).dtype!==e.dtype&&(t=M$(t,e.dtype)),M$(E_(e,t),"float32")}var nU=UV,rU=jV,aU={binaryAccuracy:XV,categoricalAccuracy:YV,precision:ZV,categoricalCrossentropy:nU,sparseCategoricalCrossentropy:rU,mse:BV,MSE:BV,mae:WV,MAE:WV,mape:VV,MAPE:VV,cosine:GV};function iU(e){if("string"==typeof e&&e in aU)return aU[e];if("string"!=typeof e&&null!=e)return e;throw new jL(`Unknown metric ${e}`)}function oU(e){if(XL(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(let n of Object.keys(qV))if(qV[n]===e){t=n;break}if(void 0!==t)return t;for(let n of Object.keys(aU))if(aU[n]===e){t=n;break}return void 0!==t?t:e.name}}function sU(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!lU(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function lU(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if("string"!=typeof n||!lU(e[n]))return!1;return!0}if(Array.isArray(e)){for(let t of e)if(!lU(t))return!1;return!0}return!1}{let t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function uU(e,t,n,r=console.log){let a,i=function(e){let t=!0,n=[],r=[];for(let a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(let a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(let a of e.layers){let e=!1;for(let n of a.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),o=["Layer (type)","Input Shape","Output shape","Param #"];if(i?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!i){o.push("Receives inputs"),a=[];for(let t in e.nodesByDepth)a.push(...e.nodesByDepth[t])}r("_".repeat(t)),dU(o,n,r),r("=".repeat(t));let s=e.layers;for(let d=0;d<s.length;++d)i?cU(s[d],n,r):pU(s[d],n,a,r),r((d===s.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=function(e){let t;return t=null!=e.collectedTrainableWeights?$W(e.collectedTrainableWeights):$W(e.trainableWeights),t}(e),u=$W(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function dU(e,t,n=console.log){let r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function cU(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(Tp){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(Tp){r="multiple"}dU([`${e.name} (${e.getClassName()})`,a,r,e.countParams().toString()],t,n)}function pU(e,t,n,r){let a,i;try{i=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(wp){i="multiple"}try{a=JSON.stringify(e.outputShape)}catch(wp){a="multiple"}let o=[];for(let d of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(d)))for(let e=0;e<d.inboundLayers.length;++e){let t=d.inboundLayers[e].name,n=d.nodeIndices[e],r=d.tensorIndices[e];o.push(`${t}[${n}][${r}]`)}let s=e.name,l=e.getClassName(),u=0===o.length?"":o[0];dU([`${s} (${l})`,i,a,e.countParams().toString(),u],t,r);for(let d=1;d<o.length;++d)dU(["","","","",o[d]],t,r)}function hU(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function fU(e,t){if(null===e)return null;if("string"==typeof e)return eB(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];hU(t,a,r)?n.push(r):n.push(fU(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{let e=eB(n);t[e]=fU(r,e)}}return t}}function mU(e,t){if(null==e)return null;if("string"==typeof e)return JL(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];hU(t,a,r)?n.push(r):n.push(mU(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n],a=JL(n);t[a]="name"!==n&&"className"!==n||"string"!=typeof r?mU(r,n):r}return t}}var gU="4.7.0",bU=class extends PW{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){let e=this.getClassName().toLowerCase();this.name=gB(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],oB(this.inputs).length!==this.inputs.length)throw new jL(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);oB(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(let b of this.inputs){let e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;XL(0===t,"input layer has >1 nodes"),XL(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let t=this.inputLayers[b];if(!(t instanceof BW))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));let t={},n={},r={},a={},i={},o=[],s=(e,t,n,r,a,l)=>{(null==r||null==a||null==l)&&(r=e.sourceLayer,a=e.nodeIndex,l=e.tensorIndex);let u=r.inboundNodes[a];if(-1!==n.indexOf(u))throw new UL(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(bU.nodeKey(r,a)),r.id in i||(i[r.id]=Object.keys(i).length),-1===n.indexOf(u)&&n.push(u);let d=u.inboundLayers.length;for(let i=0;i<d;i++){let e=u.inputTensors[i],r=u.inboundLayers[i],a=u.nodeIndices[i],o=u.tensorIndices[i];s(e,t,n,r,a,o)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);o.push(u)},l=[],u=[];for(let b of this.outputs)s(b,l,u);let d=o.slice().reverse();for(let b of d){n[b.id]=b,b.id in t||(t[b.id]=0);let e=t[b.id],i=null==r[b.outboundLayer.id]?0:r[b.outboundLayer.id];e=Math.max(e,i),r[b.outboundLayer.id]=e,a[b.outboundLayer.id]=b.outboundLayer,t[b.id]=e;for(let r=0;r<b.inboundLayers.length;r++){let a=b.inboundLayers[r],i=b.nodeIndices[r],o=a.inboundNodes[i],s=null==t[o.id]?0:t[o.id];t[o.id]=Math.max(e+1,s),n[o.id]=o}}let c={};for(let b in t){let e=t[b];e in c||(c[e]=[]),c[e].push(n[b])}let p={};for(let b in r){let e=r[b];e in p||(p[e]=[]),p[e].push(a[b])}let h=Object.keys(p).map((e=>parseInt(e,10))).sort(iB);this.layers=[];for(let b of h){let e=p[b];e.sort(((e,t)=>{let n=i[e.id],r=i[t.id];return n<r?-1:n>r?1:0}));for(let t of e)t instanceof bU&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=p,h=Object.keys(c).map((e=>parseInt(e,10))).sort(iB);let f=this.inputs.slice(),m=[];for(let b of h)for(let e of c[b]){let t=e.outboundLayer;if(null!=t){for(let n of e.inputTensors)if(-1===f.indexOf(n))throw new UL(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(let t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=c;let g=this.layers.map((e=>e.name));for(let b of g){let e=g.filter((e=>e===b)).length;if(1!==e)throw new UL(`The name "${b}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new OW({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new jL("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},r=0;for(let i of this.layers)for(let e of i.weights){if(null!=n[e.originalName])throw new jL(`Duplicate weight name: ${e.originalName}`);n[e.originalName]=e,r++}let a=[];for(let i in e){let r=i;if(null==n[i]){let e=i.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])a.push([n[r],e[i]]);else if(t)throw new jL(`Provided weight data has no target variable: ${i}`);delete n[r]}if(t){let e=[];for(let t in n)e.push(t);if(e.length>0)throw new jL(`${e.length} of ${r} weights are not set: ${e}`)}RW(a)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${gU}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=mU(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return G$((()=>{e=ZL(e);let n=new VW;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return HW(this.outputs,n,t)}))}computeMask(e,t){return G$((()=>{let n;return e=ZL(e),n=null==t?KL(null,e.length):ZL(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){let t=NW(e);if(t.length!==this.inputLayers.length)throw new jL(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let o=0;o<t.length;o++){let e=this.inputLayers[o],r=t[o];n[e.name+"_0_0"]=r}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(iB);if(r.length>1)for(let o of r){let e=this.nodesByDepth[o];for(let t of e){let e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;let r=[];for(let o=0;o<t.inboundLayers.length;o++){let e=t.inboundLayers[o],a=t.nodeIndices[o],i=t.tensorIndices[o],s=n[`${e.name}_${a}_${i}`];r.push(s)}let a=NW(e.computeOutputShape(QL(r))),i=e.inboundNodes.indexOf(t);for(let t=0;t<a.length;t++)n[`${e.name}_${i}_${t}`]=a[t]}}let a=[],i=[];for(let o=0;o<this.outputLayers.length;o++){let e=this.outputLayers[o],t=this.outputLayersNodeIndices[o],n=this.outputLayersTensorIndices[o],r=`${e.name}_${t}_${n}`;i.push(r)}for(let o=0;o<i.length;o++){let e=i[o];XL(e in n),a.push(n[e])}return QL(a)}runInternalGraph(e,t){null==t&&(t=KL(null,e.length));let n={};for(let s=0;s<this.inputs.length;++s){let r=this.inputs[s],a=e[s],i=t[s];n[r.id]=[a,i]}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(iB);for(let s of r){let e=this.nodesByDepth[s];for(let t of e){let e=t.outboundLayer,r=t.inputTensors,a=t.outputTensors,i=new Array;for(let t of r)t.id in n&&i.push(n[t.id]);if(i.length===r.length){let r,o,s,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===i.length){let[t,n]=i[0];null==u.mask&&(u.mask=n),s=ZL(e.call(t,u)),l=ZL(e.computeMask(t,n)),r=[t],o=[n]}else r=i.map((e=>e[0])),o=i.map((e=>e[1])),null==u.mask&&(u.mask=o),s=ZL(e.call(r,u)),l=ZL(e.computeMask(r,o));if(e.activityRegularizer)throw new HL("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){let t=a[e],r=s[e],i=l[e];n[t.id]=[r,i]}}}}let a=[],i=[],o=[];for(let s of this.outputs){XL(s.id in n,`Could not compute output ${s.name} : ${s.id}`);let[e,t]=n[s.id];o.push(e.shape),a.push(e),i.push(t)}return[a,i,o]}buildNodeConversionMap(e){let t,n={};for(let r of this.layers){t=r instanceof bU?1:0;for(let e=0;e<r.inboundNodes.length;e++){let a=bU.nodeKey(r,e);this.containerNodes.has(a)&&(n[a]=t,t+=1)}}return n}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new jL("Provide either a layer name or layer index");if("number"==typeof e)return this.findLayer(e);for(let n of this.layers)if(n.name===e)return n;throw new jL(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new jL(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return G$((()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let r=bU.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let i of this.layers){let e=i.getClassName(),r=i.getConfig(),a=[];for(let n=0;n<i.inboundNodes.length;n++){let e=i.inboundNodes[n],r=bU.nodeKey(i,n),o={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),o=e.callArgs}catch($p){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),o={}}if(e.inboundLayers.length>0){let n=[];for(let r=0;r<e.inboundLayers.length;r++){let a=e.inboundLayers[r],i=e.nodeIndices[r],s=e.tensorIndices[r],l=t[bU.nodeKey(a,i)];null==l&&(l=0),n.push([a.name,l,s,o])}a.push(n)}}}let o={};o.name=i.name,o.className=e,o.config=r,o.inboundNodes=a,n.push(o)}e.layers=n;let r=[];for(let i=0;i<this.inputLayers.length;i++){let e=this.inputLayers[i],n=this.inputLayersNodeIndices[i],a=bU.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let o=t[a];null==o&&(o=0);let s=this.inputLayersTensorIndices[i];r.push([e.name,o,s])}e.inputLayers=r;let a=[];for(let i=0;i<this.outputLayers.length;i++){let e=this.outputLayers[i],n=this.outputLayersNodeIndices[i],r=bU.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let o=t[r];null==o&&(o=0);let s=this.outputLayersTensorIndices[i];a.push([e.name,o,s])}return e.outputLayers=a,e}static fromConfig(e,t,n={},r=!1){let a={},i={};function o(e,t){e.name in i?i[e.name].push(t):i[e.name]=[t]}function s(e,t){let n,r=[];for(let i of t){let s=i[0],l=i[1],u=i[2];if(n=null==i[3]?{}:i[3],!(s in a))return void o(e,t);let d=a[s];if(d.inboundNodes.length<=l)return void o(e,t);let c=d.inboundNodes[l];r.push(c.outputTensors[u])}r.length>0&&e.apply(QL(r),n)}function l(e){let n=e.name,i=PV(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(r),a[n]=i,e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new jL(`Corrupted configuration, expected array for nodeData: ${e}`);o(i,e)}))}let u=t.name,d=t.layers;for(let m of d)l(m);for(;!sB(i);)for(let e of d){let t=a[e.name];if(t.name in i){let e=i[t.name];delete i[t.name];for(let n of e)s(t,n)}}let c=[],p=[],h=t.inputLayers;for(let m of h){let e=m[0],t=m[1],n=m[2];XL(e in a);let r=a[e].inboundNodes[t].outputTensors;c.push(r[n])}let f=t.outputLayers;for(let m of f){let e=m[0],t=m[1],n=m[2];XL(e in a);let r=a[e].inboundNodes[t].outputTensors;p.push(r[n])}return new e({inputs:c,outputs:p,name:u})}get stateful(){if(this._stateful)throw new jL("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){G$((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}};function yU(e,t){return function(e,t,n){let r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){let n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}(e,t,"classWeight")}async function vU(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){let t=G$((()=>{if(1===e.shape.length)return O$(e);if(2===e.shape.length){if(e.shape[1]>1)return mE(e,1);if(1===e.shape[1])return zE(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());q$(t);let a=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(n[e])})),wF(a,"float32")}return null}function xU(e,t){return lE(e,t)}function wU(e,t){let n,r,a=t;n=a.xs,r=a.ys,fC.assert(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));let i=kU("input",e.inputNames,n),o=kU("output",e.outputNames,r),s=i[0].shape[0];fC.assert(i.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),fC.assert(o.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<i.length;l++)fC.assert(i[l].shape[0]===s,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${i[l].shape[0]}; expected  ${s} based on input ${e.inputNames[0]}.`));for(let l=0;l<o.length;l++)fC.assert(o[l].shape[0]===s,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${o[l].shape[0]}; expected  ${s} based on input ${e.inputNames[0]}.`));return{xs:i,ys:o}}function kU(e,t,n){if(n instanceof QC)return[n];if(Array.isArray(n))return fC.assert(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{let r=[];for(let a of t){if(null==n[a])throw new jL(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}async function SU(e,t,n){let r=null!=n.batchesPerEpoch;if(fC.assert(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),fC.assert(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),fC.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),fC.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),fC.assert(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let a,i,o=null!=n.validationData;if(o)if(IU(n.validationData))fC.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{let e=function(e){if(3===e.length)throw new HL("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,i=e.ys}let s,l=e.makeTrainFunction(),u=e.getDedupedMetricsNames();s=o?u.slice().concat(u.map((e=>"val_"+e))):u.slice();let d=MV(n.callbacks,n.yieldEvery),c=null==n.verbose?1:n.verbose,{callbackList:p,history:h}=zV(d,c,n.epochs,null,null,function(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}(t,n),null,o,s);p.setModel(e),e.history=h,await p.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let s={};await p.onEpochBegin(f);let d=0,c=0;for(r||(m=await t.iterator());!r||d<n.batchesPerEpoch;){let t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${d} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=t.value){let{xs:r,ys:a}=wU(e,t.value),i={};i.batch=c,i.size=r[0].shape[0],await p.onBatchBegin(c,i);let o=[];if(null!=n.classWeight){let t=yU(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)o.push(await vU(a[e],null,t[e]))}let s=r.concat(a).concat(o),h=l(s);q$(s);for(let e=0;e<u.length;++e){let t=u[e],n=h[e];i[t]=n,K$(n)}await p.onBatchEnd(c,i),EV(i),c++,d++}if(r?d>=n.batchesPerEpoch:t.done){if(o){let t;t=IU(n.validationData)?ZL(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):ZL(e.evaluate(a,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)s[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await p.onEpochEnd(f,s),f++,e.stopTraining_)break}return await p.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function IU(e){return"function"==typeof e.iterator}function NU(e){fC.assert(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function CU(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>VB(e,t,n-t))):VB(e,t,n-t)}function TU(e,t){return G$((()=>null==e?null:Array.isArray(e)?e.map((e=>TU(e,t))):YB(e,"int32"===t.dtype?t:M$(t,"int32"))))}function $U(e,t){let n=[],r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}function EU(e){let t=[];e instanceof QC&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(1===r.rank)t.push(WB(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function _U(e,t){if(null==e)return;let n=[];if(t instanceof QC)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(let a in t){let e=t[a];n.push(e.id)}let r=[];if(e instanceof QC)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(let a in e){let t=e[a];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function AU(e){return Array.isArray(e)}function RU(e){return!function(e){return e instanceof QC}(e)&&!AU(e)}function FU(e,t,n,r=!0,a=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(AU(e)&&e.length>0)t=!0;else if(RU(e)){for(let n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new jL(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));let i;if(RU(e)){i=[];for(let n of t){if(null==e[n])throw new jL(`No data provided for "${n}". Need data for each key in: ${t}`);i.push(e[n])}}else if(AU(e)){if(e.length!==t.length)throw new jL(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);i=e}else{if(t.length>1)throw new jL(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);i=[e]}if(i=EU(i),null!=n)for(let o=0;o<t.length;++o){if(null==n[o])continue;let e=i[o];if(e.shape.length!==n[o].length)throw new jL(`Error when checking ${a}: expected ${t[o]} to have ${n[o].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[o].length;++t){if(0===t&&!r)continue;let i=e.shape[t],s=n[o][t];if(null!=s&&s>=0&&i!==s)throw new jL(`${a} expected a batch of elements where each example has shape [${n[o].slice(1,n[o].length)}] (i.e.,tensor shape [*,${n[o].slice(1,n[o].length)}]) but the ${a} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return i}function DU(e,t,n,r=!0,a=""){let i;if(Array.isArray(e)){if(e.length!==t.length)throw new jL(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);i=e}else{if(t.length>1)throw new jL(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);i=[e]}if(null!=n)for(let o=0;o<t.length;++o){if(null==n[o])continue;let e=i[o];if(e.shape.length!==n[o].length)throw new jL(`Error when checking ${a}: expected ${t[o]} to have ${n[o].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let i=0;i<n[o].length;++i){if(0===i&&!r)continue;let s=e.shape[i],l=n[o][i];if(null!=l&&l!==s)throw new jL(`Error when checking ${a}: expected ${t[o]} to have shape ${JSON.stringify(n[o])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}var MU=class extends bU{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new jL("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");uU(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){let t={Adagrad:()=>TO.adagrad(.01),Adadelta:()=>TO.adadelta(1,.95,LB()),Adam:()=>TO.adam(.001,.9,.999,LB()),Adamax:()=>TO.adamax(.002,.9,.999,LB(),0),RMSProp:()=>TO.rmsprop(.001,.9,0,LB()),SGD:()=>TO.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new jL(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof mM))throw new jL("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new jL(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map((e=>KV(e)))}else{let n=KV(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(let t in e.loss)if(-1===this.outputNames.indexOf(t))throw new jL(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(let n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(KV(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){let e=this.internalOutputShapes[i],t=this.outputNames[i];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[i])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],$B("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;let t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));let r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{let e=[];for(let r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};$B("metric",(()=>{for(let e=0;e<this.outputs.length;++e)-1===n.indexOf(e)&&(t=>{let n,r,i;for(let o of t){if("string"==typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){let t,a=this.internalOutputShapes[e];1===a[a.length-1]||this.lossFunctions[e]===HV?-1!==["accuracy","acc"].indexOf(o)?r=XV:-1!==["crossentropy","ce"].indexOf(o)&&(r=eU):this.lossFunctions[e]===jV?-1!==["accuracy","acc"].indexOf(o)?r=tU:-1!==["crossentropy","ce"].indexOf(o)&&(r=rU):-1!==["accuracy","acc"].indexOf(o)?r=YV:-1!==["crossentropy","ce"].indexOf(o)&&(r=nU),-1!==["accuracy","acc"].indexOf(o)?t="acc":-1!==["crossentropy","ce"].indexOf(o)&&(t="ce"),i=r,n=""+t}else i=iU(o),n=""+oU(o);let t;$B(n,(()=>{t=i})),a(e,n,t)}})(r[e])})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=null==n.batchSize?32:n.batchSize;NU(r);let a=this.standardizeUserDataXY(e,t,!0,r);try{let e=a[0].concat(a[1]);this.makeTestFunction();let t=this.testFunction;return QL(this.testLoop(t,e,r,n.verbose,n.steps))}finally{_U(a[0],e),_U(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){let r=null!=(n=n||{}).batches,a=e.testFunction,i=[];if(n.verbose>0)throw new HL("Verbose mode is not implemented yet.");fC.assert(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));let o=function(e){return"function"==typeof e.next}(t)?t:await t.iterator(),s=0,l=0;for(;!r||l<n.batches;){let t=await o.next();if(i=G$((()=>{if(t.value){let{xs:n,ys:r}=wU(e,t.value),o=n.concat(r),u=G$((()=>a(o)));if(q$(o),0===l)for(let e=0;e<u.length;++e)i.push(X_(0));let d=o[0].shape[0];for(let e=0;e<u.length;++e){let t=u[e],n=i[e];i[e]=G$((()=>iE(i[e],lE(d,t)))),l>0&&q$(n)}q$(u),s+=d,++l}return i})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<i.length;++u){let e=i[u];i[u]=sE(i[u],s),q$(e)}return QL(i)}(this,e,t)}checkNumSamples(e,t,n,r="steps"){let a;if(null!=n){if(a=null,null!=t)throw new jL(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new jL(`Either the input data should have a defined shape, or ${r} shoud be specified.`);a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new jL("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),i=new VW;if(e instanceof QC&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new jL(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)i.add(this.inputs[t],e[t])}else for(let s of this.inputs){let t=e[s.name];if(null==t)throw new jL(`No value is provided for the model's input ${s.name}`);i.add(s,t)}let o=HW(a,i);return n?o:o[0]}retrieveSymbolicTensors(e){let t=KL(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],i=a.map((e=>e.name));for(let r=0;r<e.length;++r){let o=i.indexOf(e[r]);if(-1!==o&&(t[r]=a[o],n--),0===n)break}if(0===n)break}if(n>0){let n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new jL(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return G$((()=>{let r=this.checkNumSamples(e);if(n)throw new HL("Verbose predictLoop() is not implemented yet.");let a=$U(r,t),i=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t)G$((()=>{let n=a[t][0],r=a[t][1],i=CU(e,n,r),o=[];if(Array.isArray(i))for(let e=0;e<i.length;++e)o.push({key:this.inputs[e],value:i[e]});else o.push({key:this.inputs[0],value:i});let s=new VW(o);return HW(this.outputs,s)})).forEach(((e,t)=>i[t].push(e)));return QL(i.map((e=>BE(e,0))))}))}predict(e,t={}){let n=EU(e);DU(n,this.inputNames,this.feedInputShapes,!1);try{let e=null==t.batchSize?32:t.batchSize;return NU(e),this.predictLoop(n,e)}finally{_U(n,e)}}predictOnBatch(e){DU(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new UL("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let a=[];for(let i=0;i<this.feedOutputShapes.length;++i){let e=this.feedOutputShapes[i];this.feedLossFns[i]===jV?a.push(e.slice(0,e.length-1).concat([1])):a.push(e)}if(function(e,t,n){let r=oB(e.map((e=>e.shape[0])));r.sort();let a=oB(t.map((e=>e.shape[0])));if(a.sort(),r.length>1)throw new jL(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(a.length>1)throw new jL(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(r.length>0&&a.length>0&&!fC.arraysEqual(r,a))throw new jL(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${a[0]} target sample(s).`)}(e=FU(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=FU(t,this.feedOutputNames,a,!1,"target")),function(e,t,n){let r=[BV,HV,UV];for(let a=0;a<e.length;++a){let i=e[a],o=t[a],s=n[a];if(null!=o){if(o===UV&&1===i.shape[i.shape.length-1])throw new jL(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(o)){let e=i.shape.slice(1),t=s.slice(1);for(let n=0;n<e.length;++n){let r=e[n],a=t[n];if(null!=a&&r!==a)throw new jL(`A target Tensor with shape ${i.shape} was passed for an output of shape ${s}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new jL(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,a=!0,i){let[o,s]=this.standardizeUserDataXY(e,t,a,i);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){let e=yU(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await vU(s[t],null,e[t]))}return[o,s,l]}testLoop(e,t,n,r=0,a){return G$((()=>{let i=this.checkNumSamples(t,n,a,"steps"),o=[];if(r>0)throw new HL("Verbose mode is not implemented yet.");if(null!=a)throw new HL("steps mode in testLoop() is not implemented yet");{let r=$U(i,n),a=wF(PB(0,i));for(let n=0;n<r.length;++n){let i=r[n][0],s=r[n][1],l=VB(a,i,s-i),u=TU(t,l),d=e(u);if(0===n)for(let e=0;e<d.length;++e)o.push(X_(0));for(let e=0;e<d.length;++e){let t=d[e];o[e]=iE(o[e],lE(s-i,t))}}for(let e=0;e<o.length;++e)o[e]=sE(o[e],i)}return o}))}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;YL(e,r)>1&&(a+=`_${YL(e.slice(0,n),r)}`),t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),i=[],o=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{let e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});let o,s=new VW(e),l=HW(this.outputs,s,{training:!0});for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],l[n]);null!=a[n]&&(e=xU(e,a[n]));let i=GA(e);t.push(i),o=0===n?e:iE(o,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{let t=this.metricsTensors[n][0],a=this.metricsTensors[n][1];e=GA(t(r[a],l[a]))}K$(e),i.push(e)}return o=GA(o),this.calculateLosses().forEach((e=>{o=iE(o,e)})),o}),!0,o)].concat(i)}}makeTestFunction(){this.testFunction=e=>G$((()=>{let t,n=[],r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let e=0;e<this.inputs.length;++e)i.push({key:this.inputs[e],value:r[e]});let o=new VW(i),s=HW(this.outputs,o);for(let e=0;e<this.lossFunctions.length;++e){let r=this.lossFunctions[e],i=GA(r(a[e],s[e]));t=0===e?i:iE(t,i),n.push(t)}for(let e=0;e<this.metricsTensors.length;++e){let t=this.metricsTensors[e][0],r=this.metricsTensors[e][1],i=GA(t(a[r],s[r]));n.push(i)}return n}))}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let r,a,i,o,s,l,u,d,c;this.isTraining=!0;try{let p=null==n.batchSize?32:n.batchSize;NU(p);let h=!1,f=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,h,p);r=f[0],a=f[1],c=f[2];let m,g=!1;if(null!=n.validationData&&n.validationData.length>0){if(g=!0,2!==n.validationData.length)throw 3===n.validationData.length?new HL("validationData including sample weights is not supported yet."):new jL(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);s=n.validationData[0],l=n.validationData[1];let e=!0,t=await this.standardizeUserData(s,l,null,null,e,p);u=t[0],d=t[1],m=u.concat(d)}else if(null!=n.validationSplit&&n.validationSplit>0&&n.validationSplit<1){g=!0;let e=Math.floor(r[0].shape[0]*(1-n.validationSplit)),t=r[0].shape[0];u=CU(r,e,t),i=r,r=CU(r,0,e),d=CU(a,e,t),o=a,a=CU(a,0,e),m=u.concat(d)}else null!=n.validationSteps&&(g=!0);let b=r.concat(a).concat(c);this.checkTrainableWeightsConsistency();let y,v,x=this.makeTrainFunction(),w=this.getDedupedMetricsNames();g?(this.makeTestFunction(),y=this.testFunction,v=w.slice().concat(w.map((e=>"val_"+e)))):(y=null,m=[],v=w.slice());let k=MV(n.callbacks,n.yieldEvery);return await this.fitLoop(x,b,w,p,n.epochs,n.verbose,k,y,m,n.shuffle,v,n.initialEpoch,null,null)}finally{this.isTraining=!1,_U(r,e),_U(a,t),_U(i,e),_U(o,t),_U(u,s),_U(d,l),null!=c&&q$(c)}}async fitLoop(e,t,n,r,a,i,o,s,l,u,d,c,p,h){null==r&&(r=32),null==a&&(a=1),null==u&&(u=!0),null==c&&(c=0);let f=!1;if(null!=s&&null!=l&&(f=!0),null!=h&&(f=!0,null==p))throw new jL("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m,g=this.checkNumSamples(t,r,p,"steps_per_epoch");null!=g&&(m=PB(0,g)),null==i&&(i=1);let{callbackList:b,history:y}=zV(o,i,a,c,g,p,r,f,d);b.setModel(this),this.history=y,await b.onTrainBegin(),this.stopTraining_=!1;for(let v=c;v<a;++v){await b.onEpochBegin(v);let a={};if(null!=p)throw new HL("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new HL("batch shuffling is not implemneted yet");u&&fC.shuffle(m);let i=wF(m),o=$U(g,r);for(let u=0;u<o.length;++u){let d={};if(await b.onBatchBegin(u,d),G$((()=>{let c=o[u][0],p=o[u][1],h=VB(i,c,p-c);d.batch=u,d.size=p-c;let m=TU(t,h),g=e(m);for(let e=0;e<n.length;++e){let t=n[e],r=g[e];d[t]=r,K$(r)}if(u===o.length-1&&f){let e=this.testLoop(s,l,r);for(let t=0;t<n.length;++t){let r=n[t],i=e[t];K$(i),a["val_"+r]=i}}})),await b.onBatchEnd(u,d),EV(d),this.stopTraining_)break}i.dispose()}if(await b.onEpochEnd(v,a),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return SU(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],a=n[1],i=this.makeTrainFunction()(r.concat(a)),o=[];for(let s of i){let e=await s.data();o.push(e[0])}return q$(i),_U(n[0],e),_U(n[1],t),QL(o)}getNamedWeights(e){let t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let i=0;i<r.length;++i)n&&!r[i].trainable||t.push({name:r[i].originalName,tensor:a[i]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){let t=j$().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-j$().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=JL(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>JL(e)))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=JL(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[JL(oU(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>JL(oU(e))));{let e={};for(let t in this.metrics)e[t]=JL(oU(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");let t,n,r=PV(fU(e.optimizer_config));if("string"==typeof e.loss)t=eB(e.loss);else if(Array.isArray(e.loss))t=e.loss.map((e=>eB(e)));else if(null!=e.loss){t={};for(let n in e.loss)t[n]=eB(e.loss[n])}if(Array.isArray(e.metrics))n=e.metrics.map((e=>eB(e)));else if(null!=e.metrics){n={};for(let t in e.metrics)n[t]=eB(e.metrics[t])}this.compile({loss:t,metrics:n,optimizer:r})}async save(e,t){if("string"==typeof e){let t=IM.getSaveHandlers(e);if(0===t.length)throw new jL(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new jL(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new jL("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await IM.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${gU}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();let e="optimizer",{data:t,specs:a}=await IM.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...a),n.data=IM.concatenateArrayBuffers([n.data,t])}return null!=this.userDefinedMetadata&&(sU(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){sU(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};MU.className="Model",cM.registerClass(MU);var OU=class extends MU{};async function zU(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);let r=PV(fU(n),t);if(null!=e.weightsManifest){let t=await IM.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map((e=>e.originalName))),n={};for(let e of r.weights)n[e.originalName]=t[e.originalName];r.loadWeights(n),q$(t)}return r}async function PU(e,t){if(null==t&&(t={}),"string"==typeof e){let n=IM.getLoadHandlers(e,t);if(0===n.length)n.push(IM.browserHTTPRequest(e,t));else if(n.length>1)throw new jL(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return async function(e,t,n){if(null==n&&(n={}),null==e.load)throw new jL("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),a=r.modelTopology;null!=a.model_config&&(a=a.model_config);let i=null==n.strict||n.strict,o=null!=r.weightData&&null!=r.weightSpecs&&i,s=PV(fU(a),t,o),l=r.trainingConfig;if(null!=l&&s.loadTrainingConfig(l),null!=r.userDefinedMetadata&&s.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new jL("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:e,optimizerWeights:t}=function(e,t){let n=IM.decodeWeights(e,t),r={},a=[];return t.forEach((e=>{"optimizer"===e.group?a.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]})),{modelWeights:r,optimizerWeights:a}}(r.weightData,r.weightSpecs);s.loadWeights(e,i),null!=s.optimizer&&t.length>0&&await s.optimizer.setWeights(t),q$(e),q$(t.map((e=>e.tensor)))}return s}(e,void 0,t)}OU.className="Functional",cM.registerClass(OU);var LU=class extends MU{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:gB("sequential_"),null!=e.layers)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new jL(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t,n=e instanceof LU||e instanceof MU;if(n){if(t=e,1!==t.outputs.length)throw new jL("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==t.inputs.length)throw new jL("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new jL("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let t=WW({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(n)this.outputs=t.outputs,this.inputs=t.inputs;else{if(1!==e.inboundNodes.length)throw new jL(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new jL("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=LW(this.outputs[0])}this.inboundNodes=[],new OW({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:KL(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{let t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(TW(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new MU({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new UL("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new UL("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new UL("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new UL("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let a,i={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new jL("Legacy serialization format not supported yet.");a=t}else fC.assert(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),a=t.layers,delete t.layers,i=t;let o=new e(i);if(!(o instanceof LU))throw new HL(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let s of a){let e=PV(s,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),o.add(e)}return o}set stopTraining(e){if(null==this.model)throw new jL("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new jL("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};function BU(e){return new MU(e)}function WU(e){return new LU(e)}function VU(e){return WW(e)}function UU(e,t){OV.registerCallbackConstructor(e,t)}LU.className="Sequential",cM.registerClass(LU);var jU=class extends cM.Serializable{getConfig(){return{}}},HU=class extends jU{apply(e,t=1){return function(e,t=1){if(1!==t)throw new HL(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return M_(e)}(e,t)}};HU.className="elu",cM.registerClass(HU);var GU=class extends jU{apply(e){return JR(e)}};GU.className="selu",cM.registerClass(GU);var qU=class extends jU{apply(e){return jR(e)}};qU.className="relu",cM.registerClass(qU);var KU=class extends jU{apply(e){return G$((()=>YA(6,jR(e))))}};KU.className="relu6",cM.registerClass(KU);var XU=class extends jU{apply(e){return e}};XU.className="linear",cM.registerClass(XU);var YU=class extends jU{apply(e){return VE(e)}};YU.className="sigmoid",cM.registerClass(YU);var QU=class extends jU{apply(e){return function(e){return G$((()=>{let t=iE(.5,lE(.2,e));return a_(t,0,1)}))}(e)}};QU.className="hardSigmoid",cM.registerClass(QU);var ZU=class extends jU{apply(e){return _A(e)}};ZU.className="softplus",cM.registerClass(ZU);var JU=class extends jU{apply(e){return function(e){return G$((()=>sE(e,iE(uE(e),1))))}(e)}};JU.className="softsign",cM.registerClass(JU);var ej=class extends jU{apply(e){return jE(e)}};ej.className="tanh",cM.registerClass(ej);var tj=class extends jU{apply(e,t=-1){return uF(e,t)}};tj.className="softmax",cM.registerClass(tj);var nj=class extends jU{apply(e,t=-1){return FA(e,t)}};nj.className="logSoftmax",cM.registerClass(nj);var rj=class extends jU{apply(e,t=1){return G$((()=>lE(VE(lE(e,t)),e)))}};rj.className="swish",cM.registerClass(rj);var aj=class extends jU{apply(e){return G$((()=>lE(e,jE(_A(e)))))}};function ij(e){return e.getClassName()}function oj(e,t={}){return aB(e,cM.SerializationMap.getMap().classNameMap,t,"activation")}function sj(e){if(null==e){let e={className:"linear",config:{}};return oj(e)}if("string"==typeof e){let t={};return t.className=e,t.config={},oj(t)}return e instanceof jU?e:oj(e)}function lj(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}aj.className="mish",cM.registerClass(aj);var uj=class extends cM.Serializable{},dj=class extends uj{constructor(e){super(),lj(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return G$((()=>{let t=qA([1]);return this.hasL1&&(t=iE(t,Z_(lE(this.l1,uE(e))))),this.hasL2&&(t=iE(t,Z_(lE(this.l2,QB(e))))),zE(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};dj.className="L1L2",cM.registerClass(dj);var cj={l1l2:"L1L2"};function pj(e){return nB(e)}function hj(e,t={}){return aB(e,cM.SerializationMap.getMap().classNameMap,t,"regularizer")}function fj(e){return null==e?null:"string"==typeof e?hj({className:e in cj?cj[e]:e,config:{}}):e instanceof uj?e:hj(e)}var mj=class extends PW{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=CW(e);let n=jR(e);return null!=this.maxValue&&(n=a_(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};mj.className="ReLU",cM.registerClass(mj);var gj=class extends PW{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=CW(e);return mA(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};gj.className="LeakyReLU",cM.registerClass(gj);var bj=class extends PW{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=SW(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=fj(e.alphaRegularizer),this.alphaConstraint=iV(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new jL(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){let t=(e=TW(e)).slice(1);if(null!=this.sharedAxes)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new FW({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=CW(e),hR(e,this.alpha.read())}getConfig(){let e={alphaInitializer:kW(this.alphaInitializer),alphaRegularizer:pj(this.alphaRegularizer),alphaConstraint:rV(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};bj.className="PReLU",cM.registerClass(bj);var yj=class extends PW{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new HL(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=CW(e);return M_(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};yj.className="ELU",cM.registerClass(yj);var vj=class extends PW{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){let n=CW(e);return lE(n,M$(uA(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};vj.className="ThresholdedReLU",cM.registerClass(vj);var xj=class extends PW{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new tj).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){let n=CW(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function wj(e,t,n){if("number"==typeof e)return KL(e,t);if(e.length!==t)throw new jL(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(!DB(a))throw new jL(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function kj(e,t,n,r,a=1){if(null==e)return e;let i;return i="same"===n?e:e-(t+(t-1)*(a-1))+1,Math.floor((i+r-1)/r)}function Sj(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+zB([n-t,0]);else{if("same"!==r)throw new jL(`Unsupport padding mode: ${r}.`);e*=t}return e}function Ij(e,t){return G$((()=>(SB(t),"channelsFirst"===t?VF(e,[0,2,3,1]):e)))}function Nj(e,t){return G$((()=>(SB(t),"channelsFirst"===t?VF(e,[0,2,3,4,1]):e)))}function Cj(e,t,n,r=[1,1],a="valid",i,o,s=null){return G$((()=>{if(null==i&&(i="channelsLast"),SB(i),3!==e.rank&&4!==e.rank)throw new jL(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new jL(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=Ij(e,i);if("causal"===a)throw new HL("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=QF.conv2d({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:s}),"channelsFirst"===i&&(l=VF(l,[0,3,1,2])),l}))}xj.className="Softmax",cM.registerClass(xj);var Tj=class extends PW{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Tj.verifyArgs(t),this.rank=e,dB(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new HL(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=wj(t.kernelSize,e,"kernelSize"),this.strides=wj(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,IB(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,SB(this.dataFormat),this.activation=sj(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=SW(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=iV(t.biasConstraint),this.biasRegularizer=fj(t.biasRegularizer),this.activityRegularizer=fj(t.activityRegularizer),this.dilationRate=wj(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new jL(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new jL(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new jL(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(XL("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!uB(e.kernelSize,"number",1,3))throw new jL(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ij(this.activation),useBias:this.useBias,biasInitializer:kW(this.biasInitializer),biasRegularizer:pj(this.biasRegularizer),activityRegularizer:pj(this.activityRegularizer),biasConstraint:rV(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},$j=class extends Tj{constructor(e,t){super(e,t),this.kernel=null,$j.verifyArgs(t),this.filters=t.filters,dB(this.filters,"filters"),this.kernelInitializer=SW(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=iV(t.kernelConstraint),this.kernelRegularizer=fj(t.kernelRegularizer)}build(e){e=TW(e);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new jL(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return G$((()=>{e=CW(e);let t,n=null==this.bias?null:this.bias.read(),r=pB(this.activation.getClassName());if(null!=r&&2===this.rank)t=Cj(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n,r=1,a="valid",i,o=1){return G$((()=>{if(null==i&&(i="channelsLast"),SB(i),3!==e.shape.length)throw new jL(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new jL(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new jL(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===i&&(e=VF(e,[0,2,1])),"causal"===a)throw new HL("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let s=d_(e,t,r,"same"===a?"same":"valid","NWC",o);return null!=n&&(s=JB(s,n)),s}))}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=Cj(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new HL("convolutions greater than 3D are not implemented yet.");t=function(e,t,n,r=[1,1,1],a="valid",i,o){return G$((()=>{if(null==i&&(i="channelsLast"),SB(i),4!==e.rank&&5!==e.rank)throw new jL(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new jL(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let s=Nj(e,i);if("causal"===a)throw new HL("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return s=h_(s,t,r,"same"===a?"same":"valid","NDHWC",o),null!=n&&(s=JB(s,n)),"channelsFirst"===i&&(s=VF(s,[0,4,1,2,3])),s}))}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=TW(e);let t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){let e=kj(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:kW(this.kernelInitializer),kernelRegularizer:pj(this.kernelRegularizer),kernelConstraint:rV(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new jL(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},Ej=class extends $j{constructor(e){super(2,e),Ej.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!uB(e.kernelSize,"number",1,2))throw new jL(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};Ej.className="Conv2D",cM.registerClass(Ej);var _j=class extends $j{constructor(e){super(3,e),_j.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new jL(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};_j.className="Conv3D",cM.registerClass(_j);var Aj=class extends Ej{constructor(e){if(super(e),this.inputSpec=[new FW({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new jL(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=TW(e)).length)throw new jL("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new jL("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new FW({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return G$((()=>{let t=CW(e);if(4!==t.shape.length)throw new jL(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a=t.shape,i=a[0];"channelsFirst"===this.dataFormat?(n=2,r=3):(n=1,r=2);let o=a[n],s=a[r],l=this.kernelSize[0],u=this.kernelSize[1],d=this.strides[0],c=this.strides[1],p=[i,Sj(o,d,l,this.padding),Sj(s,c,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=VF(t,[0,2,3,1]));let h=p_(t,this.kernel.read(),p,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(h=VF(h,[0,3,1,2])),null!=this.bias&&(h=JB(h,this.bias.read(),this.dataFormat)),null!=this.activation&&(h=this.activation.apply(h)),h}))}computeOutputShape(e){let t,n,r,a=(e=TW(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3):(t=3,n=1,r=2);let i=this.kernelSize[0],o=this.kernelSize[1],s=this.strides[0],l=this.strides[1];return a[t]=this.filters,a[n]=Sj(a[n],s,i,this.padding),a[r]=Sj(a[r],l,o,this.padding),a}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};Aj.className="Conv2DTranspose",cM.registerClass(Aj);var Rj=class extends _j{constructor(e){if(super(e),this.inputSpec=[new FW({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new jL(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=TW(e)).length)throw new jL("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new jL("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new FW({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return G$((()=>{let t=CW(e);if(5!==t.shape.length)throw new jL(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a,i=t.shape,o=i[0];"channelsFirst"===this.dataFormat?(a=2,n=3,r=4):(a=1,n=2,r=3);let s=i[a],l=i[n],u=i[r],d=this.kernelSize[0],c=this.kernelSize[1],p=this.kernelSize[2],h=this.strides[0],f=this.strides[1],m=this.strides[2],g=[o,Sj(s,h,d,this.padding),Sj(l,f,c,this.padding),Sj(u,m,p,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=VF(t,[0,2,3,4,1]));let b=m_(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=VF(b,[0,4,1,2,3])),null!==this.bias&&(b=JB(b,this.bias.read(),this.dataFormat)),null!==this.activation&&(b=this.activation.apply(b)),b}))}computeOutputShape(e){let t,n,r,a,i=(e=TW(e)).slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3,a=4):(t=4,n=1,r=2,a=3);let o=this.kernelSize[0],s=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],d=this.strides[1],c=this.strides[2];return i[t]=this.filters,i[n]=Sj(i[n],u,o,this.padding),i[r]=Sj(i[r],d,s,this.padding),i[a]=Sj(i[a],c,l,this.padding),i}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};Rj.className="Conv3DTranspose",cM.registerClass(Rj);var Fj=class extends $j{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new jL("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new jL("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new jL(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=SW(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=fj(t.depthwiseRegularizer),this.depthwiseConstraint=iV(t.depthwiseConstraint),this.pointwiseInitializer=SW(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=fj(t.pointwiseRegularizer),this.pointwiseConstraint=iV(t.pointwiseConstraint)}build(e){if((e=TW(e)).length<this.rank+2)throw new jL(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new jL(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(n*this.depthMultiplier,this.filters);let i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new FW({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return G$((()=>{let t;if(e=CW(e),1===this.rank)throw new HL("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=VF(e,[0,2,3,1])),t=eF(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=JB(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=VF(t,[0,3,1,2])),t}))}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=kW(this.depthwiseInitializer),e.pointwiseInitializer=kW(this.pointwiseInitializer),e.depthwiseRegularizer=pj(this.depthwiseRegularizer),e.pointwiseRegularizer=pj(this.pointwiseRegularizer),e.depthwiseConstraint=rV(this.depthwiseConstraint),e.pointwiseConstraint=rV(this.pointwiseConstraint),e}};Fj.className="SeparableConv";var Dj=class extends Fj{constructor(e){super(2,e)}};Dj.className="SeparableConv2D",cM.registerClass(Dj);var Mj=class extends $j{constructor(e){super(1,e),Mj.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!uB(e.kernelSize,"number",1,1))throw new jL(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};Mj.className="Conv1D",cM.registerClass(Mj);var Oj=class extends PW{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return G$((()=>{if(e=CW(e),"channelsLast"===this.dataFormat){let t=jB(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return jB(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{let t=jB(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return jB(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};Oj.className="Cropping2D",cM.registerClass(Oj);var zj=class extends PW{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,SB(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function(e){lB(yB,"InterpolationFormat",e)}(this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){let t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{let t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return G$((()=>{let t=CW(e),n=t.shape;if("channelsFirst"===this.dataFormat){t=VF(t,[0,2,3,1]);let e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?oM.resizeNearestNeighbor(t,[e,r]):oM.resizeBilinear(t,[e,r]);return VF(a,[0,3,1,2])}{let e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?oM.resizeNearestNeighbor(t,[e,r]):oM.resizeBilinear(t,[e,r])}}))}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};zj.className="UpSampling2D",cM.registerClass(zj);var Pj=class extends Tj{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=SW(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=iV(e.depthwiseConstraint),this.depthwiseRegularizer=fj(e.depthwiseRegularizer)}build(e){if((e=TW(e)).length<4)throw new jL(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new jL(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return G$((()=>{let t=function(e,t,n=[1,1],r="valid",a,i){return G$((()=>{null==a&&(a="channelsLast"),SB(a);let o=Ij(e,a);if(4!==e.rank)throw new jL(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new jL(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=k_(o,t,n,"same"===r?"same":"valid","NHWC",i),"channelsFirst"===a&&(o=VF(o,[0,3,1,2])),o}))}(e=CW(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=JB(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=TW(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=kj(t,this.kernelSize[0],this.padding,this.strides[0]),i=kj(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,i]:[e[0],a,i,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=kW(this.depthwiseInitializer),e.depthwiseRegularizer=pj(this.depthwiseRegularizer),e.depthwiseConstraint=rV(this.depthwiseRegularizer),e}};function Lj(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new jL("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=a(t),constants:n=a(n)}}function Bj(e,t,n,r=!1,a,i,o=!1,s=!1){return G$((()=>{let l=t.shape.length;if(l<3)throw new jL(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(PB(2,l));if(t=VF(t,u),null!=i)throw new HL("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&((a=M$(M$(a,"bool"),"float32")).rank===l-1&&(a=rA(a,-1)),a=VF(a,u)),r&&(t=GR(t,0),null!=a&&(a=GR(a,0)));let d,c,p,h=[],f=n,m=t.shape[0],g=OF(t);null!=a&&(c=OF(a));for(let t=0;t<m;++t){let n=g[t],r=G$((()=>e(n,f)));if(null==a)d=r[0],f=r[1];else{let e=G$((()=>{let e=c[t],n=RA(aR(e),e),a=iE(lE(r[0],e),lE(f[0],n)),i=f.map(((t,a)=>iE(lE(r[1][a],e),lE(t,n))));return{output:a,newStates:i}}));d=e.output,f=e.newStates}s&&h.push(d)}return s&&(p=bF(h,1)),[d,p,f]}))}Pj.className="DepthwiseConv2D",cM.registerClass(Pj);var Wj=class extends PW{constructor(e){let t;if(super(e),null==e.cell)throw new jL("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new Xj({cells:e.cell}):e.cell,null==t.stateSize)throw new jL("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new FW({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?PB(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null)):this.states_}setStates(e){this.states_=e}computeOutputShape(e){IW(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n,r=t[0];if(n=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){let r=[];for(let n of t)r.push([e[0],n]);return[n].concat(r)}return n}computeMask(e,t){return G$((()=>{Array.isArray(t)&&(t=t[0]);let e=this.returnSequences?t:null;if(this.returnState){let t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new HL("Constants support is not implemented in RNN yet.");IW(e)&&(e=e[0]);let t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new FW({shape:[t,null,...n]});let r,a=[e[0]].concat(e.slice(2));if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!fC.arraysEqual(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new jL(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map((e=>new FW({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e,t=!1){G$((()=>{if(!this.stateful)throw new VL("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(null==n)throw new jL("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>qA([n,e]))):this.states_=[qA([n,this.cell.stateSize])];else if(null==e)q$(this.states_),null!=this.keptStates&&(q$(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>qA([n,e]))):this.states_[0]=qA([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new jL(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):q$(this.states_);for(let t=0;t<this.states_.length;++t){let r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,i=[n,a];if(!fC.arraysEqual(r.shape,i))throw new jL(`State ${t} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>K$(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=Lj(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let i=[],o=[];if(null!=n){t.initialState=n,i=i.concat(n),this.stateSpec=[];for(let e of n)this.stateSpec.push(new FW({shape:e.shape}));o=o.concat(this.stateSpec)}if(null!=r&&(t.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof DW){let n=[e].concat(i),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;let s=super.apply(n,t);return this.inputSpec=a,s}return super.apply(e,t)}call(e,t){return G$((()=>{let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;e=CW(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==i)throw new jL(`RNN Layer has ${i} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:r},s=Bj(((e,t)=>{let n=this.cell.call([e].concat(t),o);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=s[0],u=s[1],d=s[2];this.stateful&&this.resetStates(d,r);let c=this.returnSequences?u:l;return this.returnState?[c].concat(d):c}))}getInitialState(e){return G$((()=>{let t=qA(e.shape);return t=Z_(t,[1,2]),t=WB(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?qB(t,[1,e]):t)):this.cell.stateSize>1?[qB(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===Wj.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t,n={}){let r=PV(t.cell,n);return new e(Object.assign(t,{cell:r}))}};Wj.className="RNN",cM.registerClass(Wj);var Vj=class extends PW{},Uj=class extends Vj{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,dB(this.units,"units"),this.activation=sj(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=SW(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=SW(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=SW(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=fj(e.kernelRegularizer),this.recurrentRegularizer=fj(e.recurrentRegularizer),this.biasRegularizer=fj(e.biasRegularizer),this.kernelConstraint=iV(e.kernelConstraint),this.recurrentConstraint=iV(e.recurrentConstraint),this.biasConstraint=iV(e.biasConstraint),this.dropout=OB([1,zB([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=OB([1,zB([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=TW(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return G$((()=>{if(2!==e.length)throw new jL(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=null!=t.training&&t.training;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Yj({ones:()=>aR(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Yj({ones:()=>aR(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a,i=this.dropoutMask,o=this.recurrentDropoutMask;a=XB(null!=i?lE(e,i):e,this.kernel.read()),null!=this.bias&&(a=JB(a,this.bias.read())),null!=o&&(n=lE(n,o));let s=iE(a,XB(n,this.recurrentKernel.read()));return null!=this.activation&&(s=this.activation.apply(s)),[s,s]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:ij(this.activation),useBias:this.useBias,kernelInitializer:kW(this.kernelInitializer),recurrentInitializer:kW(this.recurrentInitializer),biasInitializer:kW(this.biasInitializer),kernelRegularizer:pj(this.kernelRegularizer),recurrentRegularizer:pj(this.recurrentRegularizer),biasRegularizer:pj(this.biasRegularizer),activityRegularizer:pj(this.activityRegularizer),kernelConstraint:rV(this.kernelConstraint),recurrentConstraint:rV(this.recurrentConstraint),biasConstraint:rV(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};Uj.className="SimpleRNNCell",cM.registerClass(Uj);var jj=class extends Wj{constructor(e){e.cell=new Uj(e),super(e)}call(e,t){return G$((()=>{null!=this.cell.dropoutMask&&(q$(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(q$(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}};jj.className="SimpleRNN",cM.registerClass(jj);var Hj=class extends Vj{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new jL("GRUCell does not support reset_after parameter set to true.");this.units=e.units,dB(this.units,"units"),this.activation=sj(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=sj(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=SW(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=SW(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=SW(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=fj(e.kernelRegularizer),this.recurrentRegularizer=fj(e.recurrentRegularizer),this.biasRegularizer=fj(e.biasRegularizer),this.kernelConstraint=iV(e.kernelConstraint),this.recurrentConstraint=iV(e.recurrentConstraint),this.biasConstraint=iV(e.biasConstraint),this.dropout=OB([1,zB([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=OB([1,zB([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){let t=(e=TW(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return G$((()=>{if(2!==e.length)throw new jL(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=null!=t.training&&t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Yj({ones:()=>aR(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Yj({ones:()=>aR(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let a,i,o,s=this.dropoutMask,l=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=lE(e,s[0]));let u=XB(e,this.kernel.read());this.useBias&&(u=JB(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=lE(r,l[0]));let d=this.recurrentKernel.read(),[c,p]=hF(d,[2*this.units,this.units],d.rank-1),h=XB(r,c),[f,m,g]=hF(u,3,u.rank-1),[b,y]=hF(h,2,h.rank-1);a=this.recurrentActivation.apply(iE(f,b)),i=this.recurrentActivation.apply(iE(m,y));let v=XB(lE(i,r),p);o=this.activation.apply(iE(g,v));let x=iE(lE(a,r),lE(iE(1,EA(a)),o));return[x,x]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:ij(this.activation),recurrentActivation:ij(this.recurrentActivation),useBias:this.useBias,kernelInitializer:kW(this.kernelInitializer),recurrentInitializer:kW(this.recurrentInitializer),biasInitializer:kW(this.biasInitializer),kernelRegularizer:pj(this.kernelRegularizer),recurrentRegularizer:pj(this.recurrentRegularizer),biasRegularizer:pj(this.biasRegularizer),activityRegularizer:pj(this.activityRegularizer),kernelConstraint:rV(this.kernelConstraint),recurrentConstraint:rV(this.recurrentConstraint),biasConstraint:rV(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};Hj.className="GRUCell",cM.registerClass(Hj);var Gj=class extends Wj{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Hj(e),super(e)}call(e,t){return G$((()=>{null!=this.cell.dropoutMask&&(q$(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(q$(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};Gj.className="GRU",cM.registerClass(Gj);var qj=class extends Vj{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,dB(this.units,"units"),this.activation=sj(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=sj(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=SW(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=SW(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=SW(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=fj(e.kernelRegularizer),this.recurrentRegularizer=fj(e.recurrentRegularizer),this.biasRegularizer=fj(e.biasRegularizer),this.kernelConstraint=iV(e.kernelConstraint),this.recurrentConstraint=iV(e.recurrentConstraint),this.biasConstraint=iV(e.biasConstraint),this.dropout=OB([1,zB([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=OB([1,zB([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;let n,r=(e=TW(e))[e.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){let e=this.biasInitializer,r=this.units;n=new(t=class extends aW{apply(t,n){let a=e.apply([r]),i=(new oW).apply([r]),o=e.apply([2*r]);return GB(GB(a,i),o)}},t.className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return G$((()=>{let n=null!=t.training&&t.training;if(3!==e.length)throw new jL(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Yj({ones:()=>aR(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Yj({ones:()=>aR(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let i,o,s,l,u=this.dropoutMask,d=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=lE(e,u[0]));let c=XB(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=lE(r,d[0])),c=iE(c,XB(r,this.recurrentKernel.read())),this.useBias&&(c=JB(c,this.bias.read()));let[p,h,f,m]=hF(c,4,c.rank-1);i=this.recurrentActivation.apply(p),o=this.recurrentActivation.apply(h),s=iE(lE(o,a),lE(i,this.activation.apply(f))),l=this.recurrentActivation.apply(m);let g=lE(l,this.activation.apply(s));return[g,g,s]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:ij(this.activation),recurrentActivation:ij(this.recurrentActivation),useBias:this.useBias,kernelInitializer:kW(this.kernelInitializer),recurrentInitializer:kW(this.recurrentInitializer),biasInitializer:kW(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:pj(this.kernelRegularizer),recurrentRegularizer:pj(this.recurrentRegularizer),biasRegularizer:pj(this.biasRegularizer),activityRegularizer:pj(this.activityRegularizer),kernelConstraint:rV(this.kernelConstraint),recurrentConstraint:rV(this.recurrentConstraint),biasConstraint:rV(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};qj.className="LSTMCell",cM.registerClass(qj);var Kj=class extends Wj{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new qj(e),super(e)}call(e,t){return G$((()=>{null!=this.cell.dropoutMask&&(q$(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(q$(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};Kj.className="LSTM",cM.registerClass(Kj);var Xj=class extends Vj{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return G$((()=>{let n=e.slice(1),r=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();let a,i=[];for(let o=0;o<this.cells.length;++o){let s=this.cells[o];n=r[o],a=0===o?[e[0]].concat(n):[a[0]].concat(n),a=s.call(a,t),i.push(a.slice(1))}n=[];for(let e of i.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;IW(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{$B(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){let e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t,n={}){let r=[];for(let a of t.cells)r.push(PV(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return AW(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}RW(t)}};function Yj(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:i}=e,o=()=>null!=i?i(t(),n):eW(t(),n),s=()=>tW(o,t,r);return!a||a<=1?K$(s().clone()):Array(a).fill(void 0).map(s).map((e=>K$(e.clone())))}Xj.className="StackedRNNCells",cM.registerClass(Xj);var Qj=class extends Wj{constructor(e){if(e.unroll)throw new HL("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new HL("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new FW({ndim:5})]}call(e,t){return G$((()=>{if(null!=this.cell.dropoutMask&&(q$(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(q$(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new jL("ConvRNN2D cell does not support constants");let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return G$((()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=qA([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(a):[a]}))}resetStates(e,t=!1){G$((()=>{if(!this.stateful)throw new VL("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new jL("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>qA(a))):this.states_=[qA(a)];else if(null==e)q$(this.states_),null!=this.keptStates&&(q$(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>qA(a))):this.states_[0]=qA(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new jL(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):q$(this.states_);for(let t=0;t<this.states_.length;++t){let n=e[t],r=a;if(!fC.arraysEqual(n.shape,r))throw new jL(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>K$(e.clone())))}))}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:i,dilationRate:o}=this.cell,s="channelsFirst"===t,l=e[s?3:2],u=e[s?4:3],d=kj(l,r[0],a,i[0],o[0]),c=kj(u,r[1],a,i[1],o[1]);return[...e.slice(0,2),...s?[n,d,c]:[d,c,n]]}};Qj.className="ConvRNN2D";var Zj=class extends qj{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:i,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,dB(this.filters,"filters"),this.kernelSize=wj(n,2,"kernelSize"),this.kernelSize.forEach((e=>dB(e,"kernelSize"))),this.strides=wj(r||1,2,"strides"),this.strides.forEach((e=>dB(e,"strides"))),this.padding=a||"valid",IB(this.padding),this.dataFormat=i||"channelsLast",SB(this.dataFormat),this.dilationRate=wj(o||1,2,"dilationRate"),this.dilationRate.forEach((e=>dB(e,"dilationRate")))}build(e){var t;e=TW(e);let n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new jL(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],a=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){let n=this.biasInitializer,r=this.filters;e=new((t=class extends aW{apply(e,t){return HB([n.apply([r]),KA([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return G$((()=>{if(3!==e.length)throw new jL(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],a=e[1],i=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Yj({ones:()=>aR(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,s=(e,t,n)=>t&&t[n]?lE(t[n],e):e,l=s(r,o,0),u=s(r,o,1),d=s(r,o,2),c=s(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Yj({ones:()=>aR(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let p=this.recurrentDropoutMask,h=s(a,p,0),f=s(a,p,1),m=s(a,p,2),g=s(a,p,3),[b,y,v,x]=hF(this.kernel.read(),4,3),[w,k,S,I]=this.useBias?hF(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,b,w,this.padding),u=this.inputConv(u,y,k,this.padding),d=this.inputConv(d,v,S,this.padding),c=this.inputConv(c,x,I,this.padding);let[N,C,T,$]=hF(this.recurrentKernel.read(),4,3);h=this.recurrentConv(h,N),f=this.recurrentConv(f,C),m=this.recurrentConv(m,T),g=this.recurrentConv(g,$);let E=this.recurrentActivation.apply(iE(l,h)),_=this.recurrentActivation.apply(iE(u,f)),A=iE(lE(_,i),lE(E,this.activation.apply(iE(d,m)))),R=lE(this.recurrentActivation.apply(iE(c,g)),this.activation.apply(A));return[R,R,A]}))}getConfig(){let e=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n}(super.getConfig(),["units"]),t={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},e),t)}inputConv(e,t,n,r){let a=u_(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?JB(a,n,this.dataFormat):a}recurrentConv(e,t){return u_(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}};Zj.className="ConvLSTM2DCell",cM.registerClass(Zj);var Jj=class extends Qj{constructor(e){let t=new Zj(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};Jj.className="ConvLSTM2D",cM.registerClass(Jj);var eH=class extends PW{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return G$((()=>{this.invokeCallHook(e,t);let n=CW(e);if(0<this.rate&&this.rate<1){let e=null!=t.training&&t.training,r=this.getNoiseShape(n);return tW((()=>eW(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};eH.className="Dropout",cM.registerClass(eH);var tH=class extends eH{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};tH.className="SpatialDropout1D",cM.registerClass(tH);var nH=class extends PW{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,dB(this.units,"units"),this.activation=sj(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=SW(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=SW(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=iV(e.kernelConstraint),this.biasConstraint=iV(e.biasConstraint),this.kernelRegularizer=fj(e.kernelRegularizer),this.biasRegularizer=fj(e.biasRegularizer),this.activityRegularizer=fj(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){let t=(e=TW(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){let t=(e=TW(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return G$((()=>{this.invokeCallHook(e,t);let n,r=CW(e),a=pB(this.activation.getClassName());return null!=a?n=XB(r,this.kernel.read(),a,this.bias?this.bias.read():null):(n=XB(r,this.kernel.read()),null!=this.bias&&(n=JB(n,this.bias.read())),null!=this.activation&&(n=this.activation.apply(n))),n}))}getConfig(){let e={units:this.units,activation:ij(this.activation),useBias:this.useBias,kernelInitializer:kW(this.kernelInitializer),biasInitializer:kW(this.biasInitializer),kernelRegularizer:pj(this.kernelRegularizer),biasRegularizer:pj(this.biasRegularizer),activityRegularizer:pj(this.activityRegularizer),kernelConstraint:rV(this.kernelConstraint),biasConstraint:rV(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};nH.className="Dense",cM.registerClass(nH);var rH=class extends PW{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=TW(e);for(let t of e.slice(1))if(null==t)throw new jL(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],MB(e,1)]}call(e,t){return G$((()=>{this.invokeCallHook(e,t);let n=CW(e);if("channelsFirst"===this.dataFormat&&n.rank>1){let e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=VF(n,e)}return function(e){if(e.rank<=1)throw new jL(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],MB(e.shape,1)];return zE(e,t)}(n)}))}getConfig(){let e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};rH.className="Flatten",cM.registerClass(rH);var aH=class extends PW{constructor(e){super(e),this.supportsMasking=!0,this.activation=sj(e.activation)}call(e,t){return G$((()=>{this.invokeCallHook(e,t);let n=CW(e);return this.activation.apply(n)}))}getConfig(){let e={activation:ij(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};aH.className="Activation",cM.registerClass(aH);var iH=class extends PW{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return G$((()=>function(e,t){return G$((()=>{if(2!==e.shape.length)throw new jL(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return qB(WB(e,1),[1,t,1])}))}(e=CW(e),this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};iH.className="RepeatVector",cM.registerClass(iH);var oH=class extends PW{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),a=1,i=null;for(let s=0;s<r.length;++s){let e=r[s];if(this.isUnknown(e)){if(null!==i)throw new jL("Can only specifiy one unknown dimension.");i=s}else a*=e}let o=MB(e);if(null!==i){if(0===a||o%a!=0)throw new jL(n);r[i]=o/a}else if(o!==a)throw new jL(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return G$((()=>{this.invokeCallHook(e,t);let n=CW(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return zE(n,a)}))}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};oH.className="Reshape",cM.registerClass(oH);var sH=class extends PW{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=PB(1,e.dims.length+1);if(!fC.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new FW({ndim:this.dims.length+1})]}computeOutputShape(e){let t=(e=TW(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return VF(CW(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};sH.className="Permute",cM.registerClass(sH);var lH=class extends PW{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=CW(e);return fE(nR(n,this.maskValue),-1)}call(e,t){return G$((()=>{this.invokeCallHook(e,t);let n=CW(e),r=fE(nR(n,this.maskValue),-1,!0);return lE(n,M$(r,n.dtype))}))}};lH.className="Masking",cM.registerClass(lH);var uH=class extends PW{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(ZL(e.inputLength))}this.inputDim=e.inputDim,dB(this.inputDim,"inputDim"),this.outputDim=e.outputDim,dB(this.outputDim,"outputDim"),this.embeddingsInitializer=SW(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=fj(e.embeddingsRegularizer),this.activityRegularizer=fj(e.activityRegularizer),this.embeddingsConstraint=iV(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return G$((()=>this.maskZero?(e=CW(e),nR(e,A_(e))):null))}computeOutputShape(e){if(e=TW(e),null==this.inputLength)return[...e,this.outputDim];let t=ZL(this.inputLength);if(t.length!==e.length-1)throw new jL(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let a=t[r],i=e[r+1];if(null!=a&&null!=i&&a!==i)throw new jL(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[n]=i),n++}}return[e[0],...t,this.outputDim]}call(e,t){return G$((()=>{this.invokeCallHook(e,t);let n=CW(e);"int32"!==n.dtype&&(n=BB(n,"int32"));let r=YB(this.embeddings.read(),zE(n,[n.size]));return zE(r,TW(this.computeOutputShape(n.shape)))}))}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:kW(this.embeddingsInitializer),embeddingsRegularizer:pj(this.embeddingsRegularizer),activityRegularizer:pj(this.activityRegularizer),embeddingsConstraint:rV(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};uH.className="Embedding",cM.registerClass(uH);var dH=class extends PW{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new HL}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],i=t[r];if(null==a||null==i||a<0||i<0)n.push(null);else if(1===a)n.push(i);else if(1===i)n.push(a);else{if(a!==i)throw new jL("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[TW(e)]),e.length<2)throw new jL(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let a of e)null!=a&&null!==a[0]&&t.push(a[0]);if(t=oB(t),t.length>1)throw new jL(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){let t=null==e[a]?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}let r=e.map((e=>e.length));-1===e.indexOf(null)&&1===oB(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return G$((()=>{if(this.reshapeRequired){let t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){let r=zB(n);for(let n of e){let e=n.rank;for(let t=0;t<r-e;++t)n=WB(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(let i of e){let e=i.rank;if(null==e){let e=i.shape,r=e[0],a=e.slice(1).concat([r]),o=zE(i,[r].concat(MB(e.slice(1))));o=VF(o,[1,0]),o=zE(o,a),t.push(o),n=!0}else if(e>1){let r=PB(1,e).concat([0]);t.push(VF(i,r)),n=!0}else t.push(i)}let r=this.mergeFunction(t),a=r.rank;if(n)if(null==a){let e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=zE(VF(zE(r,[-1,t]),[1,0]),n)}else if(a>1){let e=[a-1].concat(PB(0,a-1));r=VF(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){let n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(let r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=oB(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return G$((()=>{if(null==t)return null;if(!Array.isArray(t))throw new jL("`mask` should be an Array");if(!Array.isArray(e))throw new jL("`inputs` should be an Array");if(t.length!==e.length)throw new jL(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;t=t.map((e=>null==e?e:rA(e,0)));let n=t[0];for(let e=1;e<t.length-1;++e)n=MA(n,t[e]);return n}))}},cH=class extends dH{constructor(e){super(e)}mergeFunction(e){return G$((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=iE(t,e[n]);return t}))}};cH.className="Add",cM.registerClass(cH);var pH=class extends dH{constructor(e){super(e)}mergeFunction(e){return G$((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=lE(t,e[n]);return t}))}};pH.className="Multiply",cM.registerClass(pH);var hH=class extends dH{constructor(e){super(e)}mergeFunction(e){return G$((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=iE(t,e[n]);return lE(1/e.length,t)}))}};hH.className="Average",cM.registerClass(hH);var fH=class extends dH{constructor(e){super(e)}mergeFunction(e){return G$((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=HA(t,e[n]);return t}))}};fH.className="Maximum",cM.registerClass(fH);var mH=class extends dH{constructor(e){super(e)}mergeFunction(e){return G$((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=YA(t,e[n]);return t}))}};mH.className="Minimum",cM.registerClass(mH);var gH=class extends dH{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new jL("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(let r of e)if(null!=r){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let t=e[r].slice();t.splice(this.axis,1);let a=!1;for(let e of n)if(fC.arraysEqual(e,t)){a=!0;break}a||n.push(t)}if(n.length>1)throw new jL("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return G$((()=>HB(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new jL("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let a of t.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new jL("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new jL("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new jL(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return G$((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;let r=[];for(let i=0;i<e.length;++i)null==t[i]?r.push(M$(aR(e[i]),"bool")):t[i].rank<e[i].rank?r.push(rA(t[i],-1)):r.push(t[i]);let a=BE(r,this.axis);return hE(a,-1,!1)}))}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function bH(e,t){for(;e<0;)e+=t;return e}gH.className="Concatenate",cM.registerClass(gH);var yH=class extends dH{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){fC.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new HL("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new jL(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new jL(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>bH(t,e[n].shape.length))):[bH(this.axes,n.shape.length),bH(this.axes,r.shape.length)],this.normalize&&(n=LV(n,t[0]),r=LV(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new HL("batchDot is not implemented for tensors of 4D or higher rank yet");if(fC.assert(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),fC.assert(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new HL("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);let i=n;return G$((()=>{let n,o;if(r>a){n=r-a;let e=[];for(let t=0;t<n;++t)e.push(1);t=zE(t,t.shape.concat(e))}else if(a>r){n=a-r;let t=[];for(let e=0;e<n;++e)t.push(1);e=zE(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)o=i[0]===i[1]?Z_(lE(e,t),i[0]):Z_(lE(VF(e,[1,0]),t),i[1]);else{let n=i[0]!==e.shape.length-1,r=i[1]===t.shape.length-1;o=WE(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;let t=[];for(let r=e;r<e+n;++r)t.push(r);o=gF(o,t)}return 1===o.shape.length&&(o=rA(o,1)),o}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[bH(this.axes,e.length),bH(this.axes,t.length)],n}computeOutputShape(e){fC.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new HL("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};yH.className="Dot",cM.registerClass(yH);var vH=class extends PW{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return G$((()=>{this.invokeCallHook(e,t);let n=CW(e);return tW((()=>iE(KB(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}};vH.className="GaussianNoise",cM.registerClass(vH);var xH=class extends PW{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return G$((()=>{this.invokeCallHook(e,t);let n=CW(e);return this.rate>0&&this.rate<1?tW((()=>{let e=Math.sqrt(this.rate/(1-this.rate));return lE(n,KB(n.shape,1,e))}),(()=>n),t.training||!1):n}))}};xH.className="GaussianDropout",cM.registerClass(xH);var wH=class extends PW{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||CW(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return G$((()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return tW((()=>{let t=CW(e),r=-1.7580993408473766,a=dA(LR(n),this.rate);a=BB(a,"float32");let i=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-i*r*this.rate,s=iE(lE(t,a),lE(iE(a,-1),r));return iE(lE(s,i),o)}),(()=>CW(e)),t.training||!1)}return e}))}};function kH(e,t,n,r,a,i=.001){let o;if(2===e.rank)o=XE(e,t,n,r,a,i);else if(3===e.rank)o=YE(e,t,n,r,a,i);else{if(4!==e.rank)throw new HL(`batchNormalization is not implemented for array of rank ${e.rank} yet`);o=QE(e,t,n,r,a,i)}return o}function SH(e,t,n,r,a=.001){return fC.arraysEqual(r.slice().sort(),PB(0,e.rank-1))?function(e,t,n,r,a=.001){return G$((()=>{let i=JA(e,r),o=i.mean,s=i.variance;return[kH(e,o,s,n,t,a),o,s]}))}(e,t,n,r,a):function(e,t,n,r,a=.001){return G$((()=>{let i=JA(e,r),o=i.mean,s=i.variance,l=[];for(let t of PB(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);let u=zE(o,l),d=zE(s,l),c=null==t?null:zE(t,l),p=null==n?null:zE(n,l);return[kH(e,u,d,p,c,a),o,s]}))}(e,t,n,r,a)}wH.className="AlphaDropout",cM.registerClass(wH);var IH=class extends PW{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=SW(e.betaInitializer||"zeros"),this.gammaInitializer=SW(e.gammaInitializer||"ones"),this.movingMeanInitializer=SW(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=SW(e.movingVarianceInitializer||"ones"),this.betaConstraint=iV(e.betaConstraint),this.gammaConstraint=iV(e.gammaConstraint),this.betaRegularizer=fj(e.betaRegularizer),this.gammaRegularizer=fj(e.gammaRegularizer)}build(e){e=TW(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new jL(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new FW({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return G$((()=>{let n=null!=t.training&&t.training,r=CW(e),a=r.shape,i=a.length,o=PB(0,i),s=this.axis>=0?this.axis:this.axis+i;o.splice(s,1);let l=KL(1,i);l[s]=a[s];let u=o.slice();u.sort();let d=!fC.arraysEqual(u,PB(0,i).slice(0,i-1));if(!n)return(()=>{if(d){let e=zE(this.movingMean.read(),l),t=zE(this.movingVariance.read(),l),n=this.center?zE(this.beta.read(),l):null,a=this.scale?zE(this.gamma.read(),l):null;return kH(r,e,t,n,a,this.epsilon)}return kH(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();let[c,p,h]=SH(r,this.gamma.read(),this.beta.read(),o,this.epsilon),f=(e,t,n)=>{G$((()=>{let r=1-n,a=e.read(),i=lE(RA(a,t),r);e.write(RA(a,i))}))};return f(this.movingMean,p,this.momentum),f(this.movingVariance,h,this.momentum),c}))}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:kW(this.betaInitializer),gammaInitializer:kW(this.gammaInitializer),movingMeanInitializer:kW(this.movingMeanInitializer),movingVarianceInitializer:kW(this.movingVarianceInitializer),betaRegularizer:pj(this.betaRegularizer),gammaRegularizer:pj(this.gammaRegularizer),betaConstraint:rV(this.betaConstraint),gammaConstraint:rV(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};IH.className="BatchNormalization",cM.registerClass(IH);var NH=class extends PW{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=SW(e.betaInitializer||"zeros"),this.gammaInitializer=SW(e.gammaInitializer||"ones"),this.betaRegularizer=fj(e.betaRegularizer),this.gammaRegularizer=fj(e.gammaRegularizer),this.supportsMasking=!0}build(e){let t=(e=TW(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(let r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==oB(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map((t=>e[t]));this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,!0):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,!0):this.beta=null,this.built=!0}call(e,t){let n=CW(e),r=n.shape,a=r.length;return G$((()=>{let{mean:e,variance:t}=JA(n,this.axis,!0),i=KL(1,a);for(let n of this.axis)i[n]=r[n];let o=e=>null!=e&&e.shape.length!==a?zE(e,i):e,s=this.scale?o(this.gamma.read()):null,l=this.center?o(this.beta.read()):null,u=[],d=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),d.push(1)):(u.push(1),d.push(r[n]));return e=iA(e,u),t=iA(t,u),null!=s&&(s=iA(s,d)),null!=l&&(l=iA(l,d)),kH(n,e,t,l,s,this.epsilon)}))}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:kW(this.betaInitializer),gammaInitializer:kW(this.gammaInitializer),betaRegularizer:pj(this.betaRegularizer),gammaRegularizer:pj(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};NH.className="LayerNormalization",cM.registerClass(NH);var CH=class extends PW{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new jL(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new jL(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new jL(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new FW({ndim:4})]}computeOutputShape(e){let t,n;return e=TW(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return G$((()=>function(e,t,n){return G$((()=>{if(4!==e.rank)throw new jL(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new jL("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n="channelsLast"),"channelsLast"!==n&&"channelsFirst"!==n)throw new jL(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],oR(e,r)}))}(CW(e),this.padding,this.dataFormat)))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};function TH(e,t,n,r,a,i){return G$((()=>{SB(a),NB(i),IB(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==i&&(i="max"),e=Ij(e,a);let o,s="same"===r?"same":"valid";return o="max"===i?VA(e,t,n,s):PE(e,t,n,s),"channelsFirst"===a&&(o=VF(o,[0,3,1,2])),o}))}function $H(e,t,n,r,a,i){return G$((()=>{SB(a),NB(i),IB(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a="channelsLast"),null==i&&(i="max"),e=Nj(e,a);let o,s="same"===r?"same":"valid";return o="max"===i?UA(e,t,n,s):LE(e,t,n,s),"channelsFirst"===a&&(o=VF(o,[0,4,1,2,3])),o}))}CH.className="ZeroPadding2D",cM.registerClass(CH);var EH=class extends PW{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new jL(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(dB(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new jL(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}dB(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,IB(this.padding),this.inputSpec=[new FW({ndim:3})]}computeOutputShape(e){let t=kj((e=TW(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return G$((()=>{this.invokeCallHook(e,t),e=WB(CW(e),2);let n=this.poolingFunction(CW(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return gF(n,[2])}))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},_H=class extends EH{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return SB(a),IB(r),TH(e,t,n,r,a,"max")}};_H.className="MaxPooling1D",cM.registerClass(_H);var AH=class extends EH{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return SB(a),IB(r),TH(e,t,n,r,a,"avg")}};AH.className="AveragePooling1D",cM.registerClass(AH);var RH=class extends PW{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new jL(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];dB(this.poolSize,"poolSize"),dB(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,SB(this.dataFormat),IB(this.padding),this.inputSpec=[new FW({ndim:4})]}computeOutputShape(e){e=TW(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=kj(t,this.poolSize[0],this.padding,this.strides[0]),n=kj(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return G$((()=>(this.invokeCallHook(e,t),this.poolingFunction(CW(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},FH=class extends RH{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return SB(a),IB(r),TH(e,t,n,r,a,"max")}};FH.className="MaxPooling2D",cM.registerClass(FH);var DH=class extends RH{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return SB(a),IB(r),TH(e,t,n,r,a,"avg")}};DH.className="AveragePooling2D",cM.registerClass(DH);var MH=class extends PW{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new jL(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];dB(this.poolSize,"poolSize"),dB(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,SB(this.dataFormat),IB(this.padding),this.inputSpec=[new FW({ndim:5})]}computeOutputShape(e){e=TW(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=kj(t,this.poolSize[0],this.padding,this.strides[0]),n=kj(n,this.poolSize[1],this.padding,this.strides[1]),r=kj(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return G$((()=>(this.invokeCallHook(e,t),this.poolingFunction(CW(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},OH=class extends MH{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return SB(a),IB(r),$H(e,t,n,r,a,"max")}};OH.className="MaxPooling3D",cM.registerClass(OH);var zH=class extends MH{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return SB(a),IB(r),$H(e,t,n,r,a,"avg")}};zH.className="AveragePooling3D",cM.registerClass(zH);var PH=class extends PW{constructor(e){super(e),this.inputSpec=[new FW({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new HL}},LH=class extends PH{constructor(e){super(e||{})}call(e,t){return G$((()=>{let t=CW(e);return GA(t,1)}))}};LH.className="GlobalAveragePooling1D",cM.registerClass(LH);var BH=class extends PH{constructor(e){super(e||{})}call(e,t){return G$((()=>{let t=CW(e);return G_(t,1)}))}};BH.className="GlobalMaxPooling1D",cM.registerClass(BH);var WH=class extends PW{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,SB(this.dataFormat),this.inputSpec=[new FW({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new HL}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},VH=class extends WH{call(e,t){return G$((()=>{let t=CW(e);return"channelsLast"===this.dataFormat?GA(t,[1,2]):GA(t,[2,3])}))}};VH.className="GlobalAveragePooling2D",cM.registerClass(VH);var UH=class extends WH{call(e,t){return G$((()=>{let t=CW(e);return"channelsLast"===this.dataFormat?G_(t,[1,2]):G_(t,[2,3])}))}};UH.className="GlobalMaxPooling2D",cM.registerClass(UH);var jH=class extends PW{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=PV(t.layer,n);delete t.layer;let a={layer:r};return Object.assign(a,t),new e(a)}},HH=class extends jH{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=TW(e)).length<3)throw new jL(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){let t=[(e=TW(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return G$((()=>Bj(((e,n)=>[CW(this.layer.call(e,t)),[]]),e=CW(e),[],!1,null,null,!1,!0)[1]))}};HH.className="TimeDistributed",cM.registerClass(HH);var GH=class extends jH{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=PV(n),t.goBackwards=!0!==t.goBackwards;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=PV(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function(e){lB(wB,"BidirectionalMergeMode",e)}(this.mergeMode),e.weights)throw new HL("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState&&(r=a.slice(1)),t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):QL(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=Lj(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);let i=[],o=[];if(null!=n){let e=n.length;if(e%2>0)throw new jL("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,i.push(...n);let r=n.map((e=>new FW({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),o.push(...r)}if(null!=r)throw new HL("Support for constants in Bidirectional layers is not implemented yet.");let s=i[0]instanceof DW;for(let l of i)if(l instanceof DW!==s)throw new jL("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(s){let n=[e].concat(i),r=this.inputSpec.concat(o),a=this.inputSpec;this.inputSpec=r;let s=super.apply(n,t);return this.inputSpec=a,s}return super.apply(e,t)}call(e,t){return G$((()=>{let n,r,a,i,o=t.initialState;if(null==o)n=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let a=o.slice(0,o.length/2),i=o.slice(o.length/2);n=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(n)&&(a=n.slice(1).concat(r.slice(1))),n=n[0],r=r[0]),this.returnSequences&&(r=GR(r,1)),"concat"===this.mergeMode?i=HB([n,r]):"sum"===this.mergeMode?i=iE(n,r):"ave"===this.mergeMode?i=lE(.5,iE(n,r)):"mul"===this.mergeMode?i=lE(n,r):null==this.mergeMode&&(i=[n,r]),this.returnState?null==this.mergeMode?i.concat(a):[i].concat(a):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){$B(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),$B(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){let e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=PV(t.layer);if(delete t.layer,null!=t.numConstants)throw new HL("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};GH.className="Bidirectional",cM.registerClass(GH);var qH=class extends PW{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return G$((()=>("float32"!==(e=CW(e)).dtype&&(e=BB(e,"float32")),iE(lE(e,this.scale),this.offset))))}};qH.className="Rescaling",cM.registerClass(qH);var{resizeBilinear:KH,cropAndResize:XH}=oM,YH=class extends PW{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,a,i,o,s){return G$((()=>{let l,u=!1,d=[t/i,n/o,(r+t)/i,(a+n)/o],c=[];3===e.rank?(u=!0,l=bF([e])):l=e;for(let e=0;e<l.shape[0];e++)c.push(d);let p=zT(c,[c.length,4]),h=WR(0,c.length,1,"int32"),f=XH(l,p,h,[r,a],"nearest");return BB(u?CW(OF(f)):f,s)}))}upsize(e,t,n,r){return G$((()=>BB(KH(e,[t,n]),r)))}call(e,t){return G$((()=>{let t=CW(e),n=t.dtype,r=t.shape,a=r[r.length-3],i=r[r.length-2],o=0;a!==this.height&&(o=Math.floor((a-this.height)/2));let s=0;return i!==this.width&&(s=Math.floor((i-this.width)/2),0===s&&(s=1)),o>=0&&s>=0?this.centerCrop(t,o,s,this.height,this.width,a,i,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){let t=(e=TW(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};YH.className="CenterCrop",cM.registerClass(YH);var QH=class extends PW{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=TW(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return G$((()=>{let n;if("int32"!==(e=CW(e)).dtype&&(e=BB(e,"int32")),void 0!==t.countWeights){if("count"!==this.outputMode)throw new jL(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=CW(t.countWeights)}let r=G_(e),a=q_(e),i=uA(this.numTokens,r).bufferSync().get(0),o=dA(a,0).bufferSync().get(0);if(!i||!o)throw new jL(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let a=CW(e);if("int32"!==a.dtype&&(a=BB(a,"int32")),"int"===t)return a;let i=a.shape;if(0===a.rank&&(a=rA(a,-1)),"oneHot"===t&&1!==a.shape[a.shape.length-1]&&(a=rA(a,-1)),a.rank>2)throw new jL(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${a.rank}.`);let o,s=["multiHot","oneHot"].includes(t),l=a;if(o=x_(l,void 0!==r&&"count"===t?r:[],n,s),"tfIdf"!==t)return o;if(r)return lE(o,r);throw new jL("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}};QH.className="CategoryEncoding",cM.registerClass(QH);var ZH=new Set(["bilinear","nearest"]),JH=class extends PW{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!ZH.has(e.interpolation))throw new jL(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){let t=(e=TW(e))[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return G$((()=>{let t=[this.height,this.width];if("bilinear"===this.interpolation)return oM.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return oM.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...ZH]} are supported`)}))}};JH.className="Resizing",cM.registerClass(JH);var eG=class{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}};eG.className="RandomSeed";var tG=class extends PW{constructor(e){super(e),this.randomGenerator=new eG(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};tG.className="BaseRandomLayer";var nG=new Set(["bilinear","nearest"]),rG=class extends tG{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new jL(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new jL(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new jL(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!nG.has(n))throw new jL(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){let t=(e=TW(e))[2];return[this.imgHeight,-1,t]}call(e,t){return G$((()=>{let t=CW(e);this.imgHeight=t.shape[t.shape.length-3];let n=t.shape[t.shape.length-2];this.widthFactor=LR([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);let a=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return oM.resizeBilinear(e,a);case"nearest":return oM.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...nG]} are supported`)}}))}};function aG(e){return new BW(e)}function iG(e){return new yj(e)}function oG(e){return new mj(e)}function sG(e){return new gj(e)}function lG(e){return new bj(e)}function uG(e){return new xj(e)}function dG(e){return new vj(e)}function cG(e){return new Mj(e)}function pG(e){return new Ej(e)}function hG(e){return new Aj(e)}function fG(e){return new _j(e)}function mG(e){return new Rj(e)}function gG(e){return new Dj(e)}function bG(e){return new Oj(e)}function yG(e){return new zj(e)}function vG(e){return new Pj(e)}function xG(e){return new aH(e)}function wG(e){return new nH(e)}function kG(e){return new eH(e)}function SG(e){return new tH(e)}function IG(e){return new rH(e)}function NG(e){return new iH(e)}function CG(e){return new oH(e)}function TG(e){return new sH(e)}function $G(e){return new uH(e)}function EG(e){return new cH(e)}function _G(e){return new hH(e)}function AG(e){return new gH(e)}function RG(e){return new fH(e)}function FG(e){return new mH(e)}function DG(e){return new pH(e)}function MG(e){return new yH(e)}function OG(e){return new IH(e)}function zG(e){return new NH(e)}function PG(e){return new CH(e)}function LG(e){return new AH(e)}function BG(e){return LG(e)}function WG(e){return LG(e)}function VG(e){return new DH(e)}function UG(e){return VG(e)}function jG(e){return VG(e)}function HG(e){return new zH(e)}function GG(e){return HG(e)}function qG(e){return HG(e)}function KG(e){return new LH(e)}function XG(e){return new VH(e)}function YG(e){return new BH(e)}function QG(e){return new UH(e)}function ZG(e){return new _H(e)}function JG(e){return new FH(e)}function eq(e){return new OH(e)}function tq(e){return new Gj(e)}function nq(e){return new Hj(e)}function rq(e){return new Kj(e)}function aq(e){return new qj(e)}function iq(e){return new jj(e)}function oq(e){return new Uj(e)}function sq(e){return new Jj(e)}function lq(e){return new Zj(e)}function uq(e){return new Wj(e)}function dq(e){return new Xj(e)}function cq(e){return new GH(e)}function pq(e){return new HH(e)}rG.className="RandomWidth",cM.registerClass(rG);var hq=YG,fq=QG,mq=ZG,gq=JG;function bq(e){return new vH(e)}function yq(e){return new xH(e)}function vq(e){return new wH(e)}function xq(e){return new lH(e)}function wq(e){return new qH(e)}function kq(e){return new YH(e)}function Sq(e){return new JH(e)}function Iq(e){return new QH(e)}function Nq(e){return new rG(e)}var Cq={};function Tq(e,t){return XV(e,t)}function $q(e,t){return eU(e,t)}function Eq(e,t){return tU(e,t)}function _q(e,t){return YV(e,t)}function Aq(e,t){return nU(e,t)}function Rq(e,t){return ZV(e,t)}function Fq(e,t){return JV(e,t)}function Dq(e,t){return GV(e,t)}function Mq(e,t){return WV(e,t)}function Oq(e,t){return VV(e,t)}function zq(e,t){return VV(e,t)}function Pq(e,t){return VV(e,t)}function Lq(e,t){return BV(e,t)}function Bq(e,t){return BV(e,t)}function Wq(e,t){return BV(e,t)}uw(Cq,{MAPE:()=>zq,MSE:()=>Bq,binaryAccuracy:()=>Tq,binaryCrossentropy:()=>$q,categoricalAccuracy:()=>_q,categoricalCrossentropy:()=>Aq,cosineProximity:()=>Dq,mape:()=>Pq,meanAbsoluteError:()=>Mq,meanAbsolutePercentageError:()=>Oq,meanSquaredError:()=>Lq,mse:()=>Wq,precision:()=>Rq,recall:()=>Fq,sparseCategoricalAccuracy:()=>Eq});var Vq={};uw(Vq,{modelFromJSON:()=>zU});var Uq={};function jq(e){return new dj(e)}function Hq(e){return function(e){return lj(e),new dj({l1:null!=e?e.l1:null,l2:0})}(e)}function Gq(e){return function(e){return lj(e),new dj({l2:null!=e?e.l2:null,l1:0})}(e)}uw(Uq,{l1:()=>Hq,l1l2:()=>jq,l2:()=>Gq});var qq=class extends _V{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof MU))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function Kq(e,t){return e<t}function Xq(e,t){return e>t}var Yq,Qq,Zq=class extends qq{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new HL("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=Kq:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=Xq:this.monitorFunc=Kq,this.monitorFunc===Kq&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===Kq?1/0:-1/0}async onEpochEnd(e,t){await $V(t);let n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});let t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}},Jq={earlyStopping:function(e){return new Zq(e)}};Rk().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(Yq||(Yq={})),function(e){!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(Qq||(Qq={}));var eK={};function tK(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};eK[e]=n}function nK(e){return eK[e]}function rK(e){delete eK[e]}function aK(e,t,n,r,a){let i=t.inputParams[e];if(i&&void 0!==i.inputIndexStart){let e=i.inputIndexStart,o=0===i.inputIndexEnd?void 0:void 0===i.inputIndexEnd?e+1:i.inputIndexEnd,s=e<0?t.inputNames.length+e:e;if("tensor"===i.type)return iK(t.inputNames[s],n,r,a);if("tensors"===i.type){let i=t.inputs.slice(e,o);return t.inputNames.slice(e,o).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=i[t])||void 0===n?void 0:n.op)})).map((e=>iK(e,n,r,a)))}let l=iK(t.inputNames[s],n,r,a),u=l.dataSync();return"number"===i.type?u[0]:fC.toNestedArray(l.shape,u)}let o=t.attrParams[e];return o&&o.value}function iK(e,t,n,r){let[a,i]=uK(e,n);if(null!=r){let e=r.getHashTableHandleByName(a);if(null!=e)return e}let o=n.currentContextIds.find((e=>!!t[lK(a,e)]));return void 0!==o?t[lK(a,o)][i]:void 0}function oK(e,t,n){return t[lK(e,n.currentContextId)]}function sK(e,t){let[n,r,a]=uK(e,t);return[lK(n,t&&t.currentContextId),r,a]}function lK(e,t){return t?`${e}-${t}`:e}function uK(e,t){if(""===e)return["",0,void 0];let n=null!=t&&null!=t.parseNodeNameCache;if(n){let n=t.parseNodeNameCache.get(e);if(null!=n)return n}let r,a=e.split(":");if(1===a.length)r=[e,0,void 0];else{let e=a[0],t=3===a.length?a[1]:void 0;r=[e,Number(a[a.length-1]),t]}return n&&t.parseNodeNameCache.set(e,r),r}function dK(e,t,n){let r=aK("pad",e,t,n);if("explicit"===r){r=aK("explicitPaddings",e,t,n);let a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)a[e][0]=r[2*e],a[e][1]=r[2*e+1];return a}return r}function cK(e){return e.kept?e:O$(e)}var pK={};uw(pK,{json:()=>hK});var hK=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],fK={};uw(fK,{json:()=>mK});var mK=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],gK={};uw(gK,{json:()=>bK});var bK=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],yK={};uw(yK,{json:()=>vK});var vK=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],xK={};uw(xK,{json:()=>wK});var wK=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],kK={};uw(kK,{json:()=>SK});var SK=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],IK={};uw(IK,{json:()=>NK});var NK=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],CK={};uw(CK,{json:()=>TK});var TK=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],$K={};uw($K,{json:()=>EK});var EK=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],_K={};uw(_K,{json:()=>AK});var AK=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],RK={};uw(RK,{json:()=>FK});var FK=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],DK={};uw(DK,{json:()=>MK});var MK=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],OK={};uw(OK,{json:()=>zK});var zK=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],PK={};uw(PK,{json:()=>LK});var LK=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],BK={};uw(BK,{json:()=>WK});var WK=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],VK={};uw(VK,{json:()=>UK});var UK=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],jK={};uw(jK,{json:()=>HK});var HK=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],GK={};uw(GK,{json:()=>qK});var qK=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],KK={};uw(KK,{json:()=>XK});var XK=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],YK=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[].concat(...[pK,fK,gK,yK,xK,kK,IK,CK,$K,_K,RK,DK,OK,PK,BK,VK,jK,GK,KK].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){let n=e.node,r=[],a=[],i=[],o=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?a.push(e[t.name]):(null==t.input||0===t.input.length)&&i.push(e[t.name]),e)),{}),s=[],l=[],u={},d={};null!=t&&(u=this.mapSignatureEntries(t.inputs),d=this.mapSignatureEntries(t.outputs));let c=Object.keys(o);c.forEach((e=>{let t=o[e];t.inputNames.forEach(((e,n)=>{let[r,,a]=sK(e),i=o[r];if(null!=i.outputs){let e=i.outputs.indexOf(a);if(-1!==e){let a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(i),i.children.push(t)}))})),0===Object.keys(d).length?c.forEach((e=>{let t=o[e];0===t.children.length&&l.push(t)})):Object.keys(d).forEach((e=>{let[t]=sK(e),n=o[t];null!=n&&(n.signatureKey=d[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{let[t]=sK(e),n=o[t];n&&(n.signatureKey=u[e],s.push(n))})):s=r;let p={};null!=e.library&&null!=e.library.function&&(p=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));let h={nodes:o,inputs:s,outputs:l,weights:a,placeholders:r,signature:t,functions:p};return i.length>0&&(h.initNodes=i),h}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){let t=nK(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{let r,a=n.type;switch(n.type){case"string":r=ZK(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=ZK(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=lX(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=lX(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=eX(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=eX(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=sX(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=sX(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=JK(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=JK(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=dX(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=dX(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=oX(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=oX(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=uX(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=uX(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=rX(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=rX(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=aX(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=aX(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=nX(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=nX(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:r,type:a},t}),{})),n}mapFunction(e){let t=e.nodeDef,n=[],r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));let a=[],i=[];e.signature.inputArg.forEach((e=>{let[t]=sK(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:tX(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,a.push(n),r[t]=n})),Object.keys(r).forEach((e=>{let t=r[e];t.inputNames.forEach(((e,n)=>{let[a,,i]=sK(e),o=r[a];if(null!=o.outputs){let e=o.outputs.indexOf(i);if(-1!==e){let r=`${a}:${e}`;t.inputNames[n]=r}}t.inputs.push(o),o.children.push(t)}))}));let o=e.ret;e.signature.outputArg.forEach((e=>{let[t,n]=sK(o[e.name]),a=r[t];null!=a&&(a.defaultOutput=n,i.push(a))}));let s=this.mapArgsToSignature(e);return{nodes:r,inputs:a,outputs:i,weights:n,placeholders:[],signature:s}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}};function QK(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){let t=Rk().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function ZK(e,t,n,r=!1){let a=e[t];return null!=a?QK(a.s,r):n}function JK(e,t,n){let r=e[t];return r?r.b:n}function eX(e,t,n){let r=e[t]||{},a=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof a?a:parseInt(a,10)}function tX(e){switch("string"==typeof e&&(e=Yq[e]),e){case Yq.DT_FLOAT:case Yq.DT_HALF:return"float32";case Yq.DT_INT32:case Yq.DT_INT64:case Yq.DT_INT8:case Yq.DT_UINT8:return"int32";case Yq.DT_BOOL:return"bool";case Yq.DT_DOUBLE:return"float32";case Yq.DT_STRING:return"string";default:return null}}function nX(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function rX(e,t,n){let r=e[t];return r&&r.type?tX(r.type):n}function aX(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>tX(e))):n}function iX(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function oX(e,t,n){let r=e[t];return r&&r.shape?iX(r.shape):n}function sX(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function lX(e,t,n,r=!1){let a=e[t];return a&&a.list&&a.list.s?a.list.s.map((e=>QK(e,r))):n}function uX(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>iX(e))):n}function dX(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var cX={};function pX(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){fC.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){let a=e[r],i=t[r];fC.assert(a<0||i<0||a===i,(()=>n+` Shapes ${e} and ${t} must match`))}}}function hX(e){return!("number"==typeof e||e.some((e=>e<0)))}function fX(e,t,n){let r=mX(e,n),a=!hX(r);if(a&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach((e=>{r=mX(e.shape,r)})),!hX(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function mX(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let a=e[r],i=t[r];if(a>=0&&i>=0&&a!==i)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:i}return n}uw(cX,{OP_SCOPE_SUFFIX:()=>FT,abs:()=>uE,acos:()=>dE,acosh:()=>cE,add:()=>iE,addN:()=>pE,all:()=>hE,any:()=>fE,argMax:()=>mE,argMin:()=>gE,asin:()=>bE,asinh:()=>yE,atan:()=>vE,atan2:()=>xE,atanh:()=>wE,avgPool:()=>PE,avgPool3d:()=>LE,basicLSTMCell:()=>HE,batchNorm:()=>KE,batchNorm2d:()=>XE,batchNorm3d:()=>YE,batchNorm4d:()=>QE,batchToSpaceND:()=>GE,bincount:()=>ZE,bitwiseAnd:()=>JE,booleanMaskAsync:()=>WF,broadcastArgs:()=>e_,broadcastTo:()=>t_,buffer:()=>D$,cast:()=>M$,ceil:()=>n_,clipByValue:()=>a_,clone:()=>O$,complex:()=>MT,concat:()=>BE,concat1d:()=>i_,concat2d:()=>o_,concat3d:()=>s_,concat4d:()=>l_,conv1d:()=>d_,conv2d:()=>u_,conv2dTranspose:()=>p_,conv3d:()=>h_,conv3dTranspose:()=>m_,cos:()=>g_,cosh:()=>b_,cosineWindow:()=>XF,cumprod:()=>y_,cumsum:()=>v_,denseBincount:()=>x_,depthToSpace:()=>w_,depthwiseConv2d:()=>k_,diag:()=>S_,dilation2d:()=>I_,div:()=>sE,divNoNan:()=>R_,dot:()=>F_,dropout:()=>qF,einsum:()=>D_,elu:()=>M_,enclosingPowerOfTwo:()=>KF,ensureShape:()=>O_,equal:()=>E_,erf:()=>z_,euclideanNorm:()=>tA,exp:()=>nA,expandDims:()=>rA,expm1:()=>aA,eye:()=>oA,fft:()=>dF,fill:()=>r_,floor:()=>sA,floorDiv:()=>oE,fused:()=>QF,gather:()=>lA,gatherND:()=>GF,greater:()=>uA,greaterEqual:()=>dA,ifft:()=>cF,imag:()=>cA,image:()=>oM,inTopKAsync:()=>YF,irfft:()=>pF,isFinite:()=>pA,isInf:()=>hA,isNaN:()=>fA,leakyRelu:()=>mA,less:()=>gA,lessEqual:()=>bA,linalg:()=>sM,linspace:()=>yA,localResponseNormalization:()=>vA,log:()=>xA,log1p:()=>wA,logSigmoid:()=>AA,logSoftmax:()=>FA,logSumExp:()=>DA,logicalAnd:()=>MA,logicalNot:()=>OA,logicalOr:()=>zA,logicalXor:()=>PA,losses:()=>lM,lowerBound:()=>WA,matMul:()=>WE,max:()=>G_,maxPool:()=>VA,maxPool3d:()=>UA,maxPoolWithArgmax:()=>jA,maximum:()=>HA,mean:()=>GA,meshgrid:()=>XA,min:()=>q_,minimum:()=>YA,mirrorPad:()=>QA,mod:()=>ZA,moments:()=>JA,movingAverage:()=>UF,mul:()=>lE,multiRNNCell:()=>eR,multinomial:()=>tR,neg:()=>EA,norm:()=>eA,notEqual:()=>nR,oneHot:()=>rR,ones:()=>KA,onesLike:()=>aR,op:()=>DT,outerProduct:()=>iR,pad:()=>oR,pad1d:()=>sR,pad2d:()=>lR,pad3d:()=>uR,pad4d:()=>dR,pool:()=>pR,pow:()=>K_,prelu:()=>hR,print:()=>z$,prod:()=>fR,raggedGather:()=>mR,raggedRange:()=>gR,raggedTensorToTensor:()=>bR,rand:()=>yR,randomGamma:()=>OR,randomNormal:()=>zR,randomStandardNormal:()=>PR,randomUniform:()=>LR,randomUniformInt:()=>BR,range:()=>WR,real:()=>VR,reciprocal:()=>UR,relu:()=>jR,relu6:()=>HR,reshape:()=>zE,reverse:()=>GR,reverse1d:()=>qR,reverse2d:()=>KR,reverse3d:()=>XR,reverse4d:()=>YR,rfft:()=>fF,round:()=>QR,rsqrt:()=>ZR,scalar:()=>X_,scatterND:()=>jF,searchSorted:()=>BA,selu:()=>JR,separableConv2d:()=>eF,setdiff1dAsync:()=>tF,sigmoid:()=>VE,sign:()=>nF,signal:()=>iM,sin:()=>rF,sinh:()=>aF,slice:()=>UE,slice1d:()=>iF,slice2d:()=>oF,slice3d:()=>sF,slice4d:()=>lF,softmax:()=>uF,softplus:()=>_A,spaceToBatchND:()=>cR,sparse:()=>uM,sparseToDense:()=>HF,spectral:()=>aM,split:()=>hF,sqrt:()=>Y_,square:()=>Q_,squaredDifference:()=>mF,squeeze:()=>gF,stack:()=>bF,step:()=>yF,stridedSlice:()=>vF,string:()=>dM,sub:()=>RA,sum:()=>Z_,tan:()=>xF,tanh:()=>jE,tensor:()=>zT,tensor1d:()=>wF,tensor2d:()=>kF,tensor3d:()=>SF,tensor4d:()=>IF,tensor5d:()=>NF,tensor6d:()=>CF,tensorScatterUpdate:()=>AF,tile:()=>iA,topk:()=>RF,transpose:()=>VF,truncatedNormal:()=>FF,unique:()=>DF,unsortedSegmentSum:()=>MF,unstack:()=>OF,upperBound:()=>zF,variable:()=>PF,where:()=>__,whereAsync:()=>BF,zeros:()=>qA,zerosLike:()=>A_});var gX=class{get id(){return this.idTensor.id}constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);pX(t,e.shape,"TensorList shape mismatch: "),K$(e)})),this.idTensor=X_(0),this.maxNumElements=r,K$(this.idTensor)}copy(){return new gX([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.id))&&t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);pX(e,this.elementShape,"TensorList shape mismatch: ");let r=fX(this.elementShape,this.tensors,e);return G$((()=>{let e=this.tensors.map((e=>zE(e,r)));return bF(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");let n=fX(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,pX(r.shape,e,"TensorList shape mismatch: "),zE(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(pX(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");K$(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let t=new gX([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);pX(this.tensors[e].shape,t,"TensorList shape mismatch: ");let r=fX(this.elementShape,this.tensors,t);return zE(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);pX(this.elementShape,t.shape,"TensorList shape mismatch: "),K$(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);pX(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let r=fX(this.elementShape,this.tensors,n);return 0===e.length?zT([],[0].concat(r)):G$((()=>{let t=e.map((e=>zE(this.tensors[e],r)));return bF(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);pX(this.elementShape,t,"TensorList shape mismatch: ");let n=fX(this.elementShape,this.tensors,t);return 0===this.size()?zT([],[0].concat(n)):G$((()=>{let e=this.tensors.map((e=>zE(e,n)));return BE(e,0)}))}},bX=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=aK("thenBranch",e,t,n),a=aK("elseBranch",e,t,n),i=aK("cond",e,t,n),o=aK("args",e,t,n);return(await i.data())[0]?n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=aK("body",e,t,n),a=aK("cond",e,t,n),i=aK("args",e,t,n),o=await n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap),s=i.map((e=>e.id)),l=await o[0].data();o.forEach((e=>{!e.kept&&-1===s.indexOf(e.id)&&e.dispose()}));let u=i;for(;l[0];){let e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let t=u.map((e=>e.id));e.forEach((e=>{!e.kept&&-1===s.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}));let i=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await i[0].data(),i.forEach((e=>{!e.kept&&-1===s.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}))}return u}case"LoopCond":return[cK(aK("pred",e,t,n))];case"Switch":{let r=aK("pred",e,t,n),a=aK("data",e,t,n);return a.kept||(a=cK(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{let r=e.inputNames.find((e=>void 0!==iK(e,t,n)));return r?[cK(iK(r,t,n))]:void 0}case"Enter":{let r=aK("frameName",e,t,n),a=aK("tensor",e,t,n);return n.enterFrame(r),[cK(a)]}case"Exit":{let r=aK("tensor",e,t,n);return n.exitFrame(),[cK(r)]}case"NextIteration":{let r=aK("tensor",e,t,n);return n.nextIteration(),[cK(r)]}case"TensorArrayV3":{let r=aK("size",e,t,n),a=aK("dtype",e,t,n),i=aK("elementShape",e,t,n),o=aK("dynamicSize",e,t,n),s=aK("clearAfterRead",e,t,n),l=aK("identicalElementShapes",e,t,n),u=aK("name",e,t,n),d=new class{constructor(e,t,n,r,a,i,o){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=i,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=X_(0),K$(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.tensor.id))&&t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),pX(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,K$(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return zT([],[0].concat(this.elementShape));let n=this.readMany(e);return pX(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),bF(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return zT([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return pX(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),BE(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,OF(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=0===n?0:t.size/n,i=[];G$((()=>{t=zE(t,[1,n,a]);for(let n=0;n<e.length;++n){let o=[0,0===n?0:r[n-1],0],s=[1,e[n],a];i[n]=zE(UE(t,o,s),this.elementShape)}return i}));let o=[];for(let s=0;s<e.length;s++)o[s]=s;this.writeMany(o,i)}}(u,a,r,i,l,o,s);return n.addTensorArray(d),[d.idTensor,X_(1)]}case"TensorArrayWriteV3":{let r=aK("tensorArrayId",e,t,n),a=aK("index",e,t,n),i=aK("tensor",e,t,n),o=n.getTensorArray(r.id);return o.write(a,i),[o.idTensor]}case"TensorArrayReadV3":{let r=aK("tensorArrayId",e,t,n),a=aK("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{let r=aK("tensorArrayId",e,t,n),a=aK("indices",e,t,n),i=aK("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,i)]}case"TensorArrayScatterV3":{let r=aK("tensorArrayId",e,t,n),a=aK("indices",e,t,n),i=aK("tensor",e,t,n),o=n.getTensorArray(r.id);return o.scatter(a,i),[o.idTensor]}case"TensorArrayConcatV3":{let r=aK("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),i=aK("dtype",e,t,n);return[a.concat(i)]}case"TensorArraySplitV3":{let r=aK("tensorArrayId",e,t,n),a=aK("tensor",e,t,n),i=aK("lengths",e,t,n),o=n.getTensorArray(r.id);return o.split(i,a),[o.idTensor]}case"TensorArraySizeV3":{let r=aK("tensorArrayId",e,t,n);return[X_(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{let r=aK("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{let r=aK("tensorListId",e,t,n),a=aK("index",e,t,n),i=aK("tensor",e,t,n),o=n.getTensorList(r.id);return o.setItem(a,i),[o.idTensor]}case"TensorListGetItem":{let r=aK("tensorListId",e,t,n),a=aK("index",e,t,n),i=aK("elementShape",e,t,n),o=aK("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,i,o)]}case"TensorListScatterV2":case"TensorListScatter":{let r=aK("indices",e,t,n),a=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);let i=new gX([],n,e.dtype,r),o=OF(e,0);return t.forEach(((e,t)=>{i.setItem(e,o[t])})),i}(aK("tensor",e,t,n),r,aK("elementShape",e,t,n),aK("numElements",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r,a=aK("elementShape",e,t,n),i=aK("elementDType",e,t,n);r="TensorListReserve"===e.op?"numElements":"maxNumElements";let o=aK(r,e,t,n),s=function(e,t,n,r){return new gX([],e,t,r)}(a,i,0,"TensorListReserve"===e.op?-1:o);return n.addTensorList(s),[s.idTensor]}case"TensorListGather":{let r=aK("tensorListId",e,t,n),a=aK("indices",e,t,n),i=aK("elementShape",e,t,n),o=aK("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,o,i)]}case"TensorListStack":{let r=aK("tensorListId",e,t,n),a=aK("elementShape",e,t,n),i=aK("elementDType",e,t,n),o=aK("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,i,o)]}case"TensorListFromTensor":{let r=function(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);pX(e.shape.slice(1),t,"TensorList shape mismatch: ");let a=OF(e);return new gX(a,t,r)}(aK("tensor",e,t,n),aK("elementShape",e,t,n),aK("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=aK("tensorListId",e,t,n),a=n.getTensorList(r.id),i=aK("dtype",e,t,n),o=aK("elementShape",e,t,n);return[a.concat(i,o)]}case"TensorListPushBack":{let r=aK("tensorListId",e,t,n),a=aK("tensor",e,t,n),i=n.getTensorList(r.id);return i.pushBack(a),[i.idTensor]}case"TensorListPopBack":{let r=aK("tensorListId",e,t,n),a=aK("elementShape",e,t,n),i=aK("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,i)]}case"TensorListSplit":{let r=aK("tensor",e,t,n),a=aK("elementShape",e,t,n),i=function(e,t,n){let r=0,a=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);let i=mX(e.shape.slice(1),n),o=0===r?0:e.size/r,s=G$((()=>{let n=[];e=zE(e,[1,r,o]);for(let r=0;r<t.length;++r){let s=[0,0===r?0:a[r-1],0],l=[1,t[r],o];n[r]=zE(UE(e,s,l),i)}return e.dispose(),n})),l=new gX([],n,e.dtype,t.length);for(let u=0;u<s.length;u++)l.setItem(u,s[u]);return l}(r,aK("lengths",e,t,n),a);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=aK("tensorListId",e,t,n);return[X_(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{let r=aK("tensorListId",e,t,n),a=aK("size",e,t,n),i=n.getTensorList(r.id).resize(a);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function yX(e,t,n){let[r,a]=aK("fusedOps",e,t,n),i="biasadd"===r,o=!i,s="prelu"===a,l="fusedbatchnorm"===r,u=aK("numArgs",e,t,n);if(i){if(s&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!s&&i&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let d=aK("strides",e,t,n),c=dK(e,t,n),p=aK("dataFormat",e,t,n).toUpperCase(),h=aK("dilations",e,t,n),[f,m]=aK("args",e,t,n);return o&&(m=f,f=void 0),{stride:d,pad:c,dataFormat:p,dilations:h,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:aK("leakyreluAlpha",e,t,n)}}function vX(e,t,n){return{boxes:aK("boxes",e,t,n),scores:aK("scores",e,t,n),maxOutputSize:aK("maxOutputSize",e,t,n),iouThreshold:aK("iouThreshold",e,t,n),scoreThreshold:aK("scoreThreshold",e,t,n),softNmsSigma:aK("softNmsSigma",e,t,n)}}var xX=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let a=r.getHashTableHandleByName(e.name);if(null!=a)return[a];{let a=aK("keyDType",e,t,n),i=aK("valueDType",e,t,n),o=new class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=X_(0),this.tensorMap=new Map,K$(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return X_(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),G$((()=>{let e=OF(t),r=n.length,a=e.length;fC.assert(r===a,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`));for(let t=0;t<r;t++){let r=n[t],a=e[t];K$(a),this.tensorMap.set(r,a)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return G$((()=>{let e=[];for(let r=0;r<n.length;r++){let a=n[r],i=this.findWithDefault(a,t);e.push(i)}return bF(e)}))}findWithDefault(e,t){let n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}(a,i);return r.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let a=aK("tableHandle",e,t,n,r),i=aK("keys",e,t,n),o=aK("values",e,t,n);return[await r.getHashTableById(a.id).import(i,o)]}case"LookupTableFind":case"LookupTableFindV2":{let a=aK("tableHandle",e,t,n,r),i=aK("keys",e,t,n),o=aK("defaultValue",e,t,n);return[await r.getHashTableById(a.id).find(i,o)]}case"LookupTableSize":case"LookupTableSizeV2":{let a=aK("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function wX(e,t,n,r,a=G$){let i=((e,t,n)=>{switch(e.category){case"arithmetic":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(aK("a",e,t,n),aK("b",e,t,n))];case"AddN":return[r.addN(aK("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(aK("a",e,t,n),aK("b",e,t,n))];case"Mul":return[r.mul(aK("a",e,t,n),aK("b",e,t,n))];case"RealDiv":case"Div":return[r.div(aK("a",e,t,n),aK("b",e,t,n))];case"DivNoNan":return[r.divNoNan(aK("a",e,t,n),aK("b",e,t,n))];case"FloorDiv":return[r.floorDiv(aK("a",e,t,n),aK("b",e,t,n))];case"Sub":return[r.sub(aK("a",e,t,n),aK("b",e,t,n))];case"Minimum":return[r.minimum(aK("a",e,t,n),aK("b",e,t,n))];case"Maximum":return[r.maximum(aK("a",e,t,n),aK("b",e,t,n))];case"Pow":return[r.pow(aK("a",e,t,n),aK("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(aK("a",e,t,n),aK("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"basic_math":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(aK("x",e,t,n))];case"Acos":return[r.acos(aK("x",e,t,n))];case"Acosh":return[r.acosh(aK("x",e,t,n))];case"Asin":return[r.asin(aK("x",e,t,n))];case"Asinh":return[r.asinh(aK("x",e,t,n))];case"Atan":return[r.atan(aK("x",e,t,n))];case"Atan2":return[r.atan2(aK("x",e,t,n),aK("y",e,t,n))];case"Atanh":return[r.atanh(aK("x",e,t,n))];case"Ceil":return[r.ceil(aK("x",e,t,n))];case"Complex":return[r.complex(aK("real",e,t,n),aK("imag",e,t,n))];case"Cos":return[r.cos(aK("x",e,t,n))];case"Cosh":return[r.cosh(aK("x",e,t,n))];case"Elu":return[r.elu(aK("x",e,t,n))];case"Erf":return[r.erf(aK("x",e,t,n))];case"Exp":return[r.exp(aK("x",e,t,n))];case"Expm1":return[r.expm1(aK("x",e,t,n))];case"Floor":return[r.floor(aK("x",e,t,n))];case"Log":return[r.log(aK("x",e,t,n))];case"Log1p":return[r.log1p(aK("x",e,t,n))];case"Imag":return[r.imag(aK("x",e,t,n))];case"Neg":return[r.neg(aK("x",e,t,n))];case"Reciprocal":return[r.reciprocal(aK("x",e,t,n))];case"Real":return[r.real(aK("x",e,t,n))];case"Relu":return[r.relu(aK("x",e,t,n))];case"Round":return[r.round(aK("x",e,t,n))];case"Selu":return[r.selu(aK("x",e,t,n))];case"Sigmoid":return[r.sigmoid(aK("x",e,t,n))];case"Sin":return[r.sin(aK("x",e,t,n))];case"Sign":return[r.sign(aK("x",e,t,n))];case"Sinh":return[r.sinh(aK("x",e,t,n))];case"Softplus":return[r.softplus(aK("x",e,t,n))];case"Sqrt":return[r.sqrt(aK("x",e,t,n))];case"Square":return[r.square(aK("x",e,t,n))];case"Tanh":return[r.tanh(aK("x",e,t,n))];case"Tan":return[r.tan(aK("x",e,t,n))];case"ClipByValue":return[r.clipByValue(aK("x",e,t,n),aK("clipValueMin",e,t,n),aK("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(aK("x",e,t,n))];case"Rsqrt":return[r.rsqrt(iK(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(aK("x",e,t,n),aK("alpha",e,t,n))];case"Prelu":return[r.prelu(aK("x",e,t,n),aK("alpha",e,t,n))];case"IsNan":return[r.isNaN(iK(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(iK(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(iK(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"control":return bX(e,t,n);case"convolution":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"Conv1D":{let a=aK("stride",e,t,n),i=aK("pad",e,t,n),o=aK("dataFormat",e,t,n).toUpperCase(),s=aK("dilation",e,t,n);return[r.conv1d(aK("x",e,t,n),aK("filter",e,t,n),a,i,o,s)]}case"Conv2D":{let a=aK("strides",e,t,n),i=dK(e,t,n),o=aK("dataFormat",e,t,n).toUpperCase(),s=aK("dilations",e,t,n);return[r.conv2d(aK("x",e,t,n),aK("filter",e,t,n),[a[1],a[2]],i,o,[s[1],s[2]])]}case"_FusedConv2D":{let{stride:a,pad:i,dataFormat:o,dilations:s,biasArg:l,preluArg:u,activationFunc:d,leakyreluAlpha:c}=yX(e,t,n);return[r.fused.conv2d({x:aK("x",e,t,n),filter:aK("filter",e,t,n),strides:[a[1],a[2]],pad:i,dataFormat:o,dilations:[s[1],s[2]],bias:l,activation:d,preluActivationWeights:u,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{let{stride:a,pad:i,dataFormat:o,dilations:s,biasArg:l,preluArg:u,activationFunc:d,leakyreluAlpha:c}=yX(e,t,n);return[r.fused.depthwiseConv2d({x:aK("x",e,t,n),filter:aK("filter",e,t,n),strides:[a[1],a[2]],pad:i,dataFormat:o,dilations:[s[1],s[2]],bias:l,activation:d,preluActivationWeights:u,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let a=aK("outputShape",e,t,n),i=aK("strides",e,t,n),o=dK(e,t,n);return[r.conv2dTranspose(aK("x",e,t,n),aK("filter",e,t,n),a,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let a=aK("strides",e,t,n),i=dK(e,t,n),o=aK("dilations",e,t,n),s=aK("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(aK("input",e,t,n),aK("filter",e,t,n),[a[1],a[2]],i,s,[o[1],o[2]])]}case"Conv3D":{let a=aK("strides",e,t,n),i=aK("pad",e,t,n),o=aK("dataFormat",e,t,n).toUpperCase(),s=aK("dilations",e,t,n);return[r.conv3d(aK("x",e,t,n),aK("filter",e,t,n),[a[1],a[2],a[3]],i,o,[s[1],s[2],s[3]])]}case"AvgPool":{let a=aK("strides",e,t,n),i=aK("pad",e,t,n),o=aK("kernelSize",e,t,n);return[r.avgPool(aK("x",e,t,n),[o[1],o[2]],[a[1],a[2]],i)]}case"MaxPool":{let a=aK("strides",e,t,n),i=aK("pad",e,t,n),o=aK("kernelSize",e,t,n);return[r.maxPool(aK("x",e,t,n),[o[1],o[2]],[a[1],a[2]],i)]}case"MaxPoolWithArgmax":{let a=aK("strides",e,t,n),i=aK("pad",e,t,n),o=aK("kernelSize",e,t,n),s=aK("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(aK("x",e,t,n),[o[1],o[2]],[a[1],a[2]],i,s);return[l,u]}case"AvgPool3D":{let a=aK("strides",e,t,n),i=aK("pad",e,t,n),o=aK("kernelSize",e,t,n);return[r.avgPool3d(aK("x",e,t,n),[o[1],o[2],o[3]],[a[1],a[2],a[3]],i)]}case"MaxPool3D":{let a=aK("strides",e,t,n),i=aK("pad",e,t,n),o=aK("kernelSize",e,t,n);return[r.maxPool3d(aK("x",e,t,n),[o[1],o[2],o[3]],[a[1],a[2],a[3]],i)]}case"Dilation2D":{let a=aK("strides",e,t,n),i=aK("pad",e,t,n),o=aK("dilations",e,t,n),s=a[1],l=a[2],u=o[1],d=o[2];return[r.dilation2d(aK("x",e,t,n),aK("filter",e,t,n),[s,l],i,[u,d],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"creation":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"Fill":{let a=aK("shape",e,t,n),i=aK("dtype",e,t,n),o=aK("value",e,t,n);return[r.fill(a,o,i)]}case"LinSpace":{let a=aK("start",e,t,n),i=aK("stop",e,t,n),o=aK("num",e,t,n);return[r.linspace(a,i,o)]}case"Multinomial":{let a=aK("logits",e,t,n),i=aK("numSamples",e,t,n),o=aK("seed",e,t,n);return[r.multinomial(a,i,o)]}case"OneHot":{let a=aK("indices",e,t,n),i=aK("depth",e,t,n),o=aK("onValue",e,t,n),s=aK("offValue",e,t,n),l=aK("dtype",e,t,n);return[r.oneHot(a,i,o,s,l)]}case"Ones":return[r.ones(aK("shape",e,t,n),aK("dtype",e,t,n))];case"OnesLike":return[r.onesLike(aK("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(aK("shape",e,t,n),aK("dtype",e,t,n),aK("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(aK("shape",e,t,n),aK("minval",e,t,n),aK("maxval",e,t,n),aK("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(aK("shape",e,t,n),aK("minval",e,t,n),aK("maxval",e,t,n),aK("seed",e,t,n))];case"Range":{let a=aK("start",e,t,n),i=aK("stop",e,t,n),o=aK("step",e,t,n);return[r.range(a,i,o,aK("dtype",e,t,n))]}case"TruncatedNormal":{let a=aK("shape",e,t,n),i=aK("mean",e,t,n),o=aK("stdDev",e,t,n),s=aK("seed",e,t,n);return[r.truncatedNormal(a,i,o,aK("dtype",e,t,n),s)]}case"Zeros":return[r.zeros(aK("shape",e,t,n),aK("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(aK("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"dynamic":return(async(e,t,n,r,a=cX)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:r,scores:i,maxOutputSize:o,iouThreshold:s,scoreThreshold:l,softNmsSigma:u}=vX(e,t,n),d=await a.image.nonMaxSuppressionWithScoreAsync(r,i,o,s,l,u);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:r,scores:i,maxOutputSize:o,iouThreshold:s,scoreThreshold:l}=vX(e,t,n),u=aK("padToMaxOutputSize",e,t,n),d=await a.image.nonMaxSuppressionPaddedAsync(r,i,o,s,l,u);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:r,scores:i,maxOutputSize:o,iouThreshold:s,scoreThreshold:l}=vX(e,t,n);return[await a.image.nonMaxSuppressionAsync(r,i,o,s,l)]}case"Where":{let r=a.cast(aK("condition",e,t,n),"bool"),i=[await a.whereAsync(r)];return r.dispose(),i}case"ListDiff":return a.setdiff1dAsync(aK("x",e,t,n),aK("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"evaluation":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"LowerBound":{let a=aK("sortedSequence",e,t,n),i=aK("values",e,t,n);return[r.lowerBound(a,i)]}case"TopKV2":{let a=aK("x",e,t,n),i=aK("k",e,t,n),o=aK("sorted",e,t,n),s=r.topk(a,i,o);return[s.values,s.indices]}case"UpperBound":{let a=aK("sortedSequence",e,t,n),i=aK("values",e,t,n);return[r.upperBound(a,i)]}case"Unique":{let a=aK("x",e,t,n),i=r.unique(a);return[i.values,i.indices]}case"UniqueV2":{let a=aK("x",e,t,n),i=aK("axis",e,t,n),o=r.unique(a,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"image":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"ResizeBilinear":{let a=aK("images",e,t,n),i=aK("size",e,t,n),o=aK("alignCorners",e,t,n),s=aK("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(a,[i[0],i[1]],o,s)]}case"ResizeNearestNeighbor":{let a=aK("images",e,t,n),i=aK("size",e,t,n),o=aK("alignCorners",e,t,n),s=aK("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(a,[i[0],i[1]],o,s)]}case"CropAndResize":{let a=aK("image",e,t,n),i=aK("boxes",e,t,n),o=aK("boxInd",e,t,n),s=aK("cropSize",e,t,n),l=aK("method",e,t,n),u=aK("extrapolationValue",e,t,n);return[r.image.cropAndResize(a,i,o,s,l,u)]}case"ImageProjectiveTransformV3":{let a=aK("images",e,t,n),i=aK("transforms",e,t,n),o=aK("outputShape",e,t,n),s=aK("fillValue",e,t,n),l=aK("interpolation",e,t,n),u=aK("fillMode",e,t,n);return[r.image.transform(a,i,l.toLowerCase(),u.toLowerCase(),s,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"graph":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let a=aK("default",e,t,n);return[iK(e.name,t,n)||a];case"Placeholder":return[iK(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[cK(aK("x",e,t,n))];case"IdentityN":return aK("x",e,t,n).map((e=>cK(e)));case"Shape":return[r.tensor1d(aK("x",e,t,n).shape,"int32")];case"ShapeN":return aK("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(aK("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(aK("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=aK("x",e,t,n),o=aK("data",e,t,n),s=aK("message",e,t,n),l=aK("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(s);for(let e=0;e<o.length;e++)console.log(Array.prototype.slice.call(o[e].dataSync()).slice(0,l));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"logical":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"Equal":return[r.equal(aK("a",e,t,n),aK("b",e,t,n))];case"NotEqual":return[r.notEqual(aK("a",e,t,n),aK("b",e,t,n))];case"Greater":return[r.greater(aK("a",e,t,n),aK("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(aK("a",e,t,n),aK("b",e,t,n))];case"Less":return[r.less(aK("a",e,t,n),aK("b",e,t,n))];case"LessEqual":return[r.lessEqual(aK("a",e,t,n),aK("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(aK("a",e,t,n),aK("b",e,t,n))];case"LogicalNot":return[r.logicalNot(aK("a",e,t,n))];case"LogicalOr":return[r.logicalOr(aK("a",e,t,n),aK("b",e,t,n))];case"Select":case"SelectV2":return[r.where(aK("condition",e,t,n),aK("a",e,t,n),aK("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(aK("a",e,t,n),aK("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"matrices":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(aK("a",e,t,n),aK("b",e,t,n),aK("transposeA",e,t,n),aK("transposeB",e,t,n))];case"Einsum":return[r.einsum(aK("equation",e,t,n),...aK("tensors",e,t,n))];case"Transpose":return[r.transpose(aK("x",e,t,n),aK("perm",e,t,n))];case"_FusedMatMul":let[a,i]=aK("fusedOps",e,t,n),o="biasadd"===a,s="prelu"===i,l=aK("numArgs",e,t,n),u=aK("leakyreluAlpha",e,t,n);if(o){if(s&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!s&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[d,c]=aK("args",e,t,n);return[r.fused.matMul({a:aK("a",e,t,n),b:aK("b",e,t,n),transposeA:aK("transposeA",e,t,n),transposeB:aK("transposeB",e,t,n),bias:d,activation:i,preluActivationWeights:c,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(aK("a",e,t,n),aK("numLower",e,t,n),aK("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"normalization":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(aK("x",e,t,n),aK("axis",e,t,n),aK("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(aK("x",e,t,n),aK("mean",e,t,n),aK("variance",e,t,n),aK("offset",e,t,n),aK("scale",e,t,n),aK("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(aK("x",e,t,n),aK("radius",e,t,n),aK("bias",e,t,n),aK("alpha",e,t,n),aK("beta",e,t,n))];case"Softmax":return[r.softmax(aK("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(aK("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"ragged":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:a,outputDenseValues:i}=r.raggedGather(aK("paramsNestedSplits",e,t,n),aK("paramsDenseValues",e,t,n),aK("indices",e,t,n),aK("outputRaggedRank",e,t,n));return a.concat(i)}case"RaggedRange":{let{rtNestedSplits:a,rtDenseValues:i}=r.raggedRange(aK("starts",e,t,n),aK("limits",e,t,n),aK("splits",e,t,n));return[a,i]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(aK("shape",e,t,n),aK("values",e,t,n),aK("defaultValue",e,t,n),aK("rowPartitionTensors",e,t,n),aK("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"reduction":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"Max":{let a=aK("axis",e,t,n),i=aK("keepDims",e,t,n);return[r.max(aK("x",e,t,n),a,i)]}case"Mean":{let a=aK("axis",e,t,n),i=aK("keepDims",e,t,n);return[r.mean(aK("x",e,t,n),a,i)]}case"Min":{let a=aK("axis",e,t,n),i=aK("keepDims",e,t,n);return[r.min(aK("x",e,t,n),a,i)]}case"Sum":{let a=aK("axis",e,t,n),i=aK("keepDims",e,t,n);return[r.sum(aK("x",e,t,n),a,i)]}case"All":{let a=aK("axis",e,t,n),i=aK("keepDims",e,t,n);return[r.all(aK("x",e,t,n),a,i)]}case"Any":{let a=aK("axis",e,t,n),i=aK("keepDims",e,t,n);return[r.any(aK("x",e,t,n),a,i)]}case"ArgMax":{let a=aK("axis",e,t,n);return[r.argMax(aK("x",e,t,n),a)]}case"ArgMin":{let a=aK("axis",e,t,n);return[r.argMin(aK("x",e,t,n),a)]}case"Prod":{let a=aK("axis",e,t,n),i=aK("keepDims",e,t,n);return[r.prod(aK("x",e,t,n),a,i)]}case"Cumprod":{let a=aK("axis",e,t,n),i=aK("exclusive",e,t,n),o=aK("reverse",e,t,n);return[r.cumprod(aK("x",e,t,n),a,i,o)]}case"Cumsum":{let a=aK("axis",e,t,n),i=aK("exclusive",e,t,n),o=aK("reverse",e,t,n);return[r.cumsum(aK("x",e,t,n),a,i,o)]}case"Bincount":let a=aK("x",e,t,n),i=aK("weights",e,t,n),o=aK("size",e,t,n);return[r.bincount(a,i,o)];case"DenseBincount":{let a=aK("x",e,t,n),i=aK("weights",e,t,n),o=aK("size",e,t,n),s=aK("binaryOutput",e,t,n);return[r.denseBincount(a,i,o,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"slice_join":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"ConcatV2":case"Concat":{let a=aK("n",e,t,n),i=aK("axis",e,t,n),o=aK("tensors",e,t,n);return o=o.slice(0,a),[r.concat(o,i)]}case"Gather":{let a=aK("x",e,t,n),i=aK("indices",e,t,n);return[r.gather(a,r.cast(i,"int32"),0)]}case"GatherV2":{let a=aK("axis",e,t,n),i=aK("batchDims",e,t,n),o=aK("x",e,t,n),s=aK("indices",e,t,n);return[r.gather(o,r.cast(s,"int32"),a,i)]}case"Reverse":{let a=aK("dims",e,t,n),i=[];for(let e=0;e<a.length;e++)a[e]&&i.push(e);let o=aK("x",e,t,n);return[r.reverse(o,i)]}case"ReverseV2":{let a=aK("axis",e,t,n),i=aK("x",e,t,n);return[r.reverse(i,a)]}case"Slice":{let a=aK("begin",e,t,n),i=aK("size",e,t,n);return[r.slice(aK("x",e,t,n),a,i)]}case"StridedSlice":{let a=aK("begin",e,t,n),i=aK("end",e,t,n),o=aK("strides",e,t,n),s=aK("beginMask",e,t,n),l=aK("endMask",e,t,n),u=aK("ellipsisMask",e,t,n),d=aK("newAxisMask",e,t,n),c=aK("shrinkAxisMask",e,t,n),p=aK("x",e,t,n);return[r.stridedSlice(p,a,i,o,s,l,u,d,c)]}case"Pack":return G$((()=>{let a=aK("axis",e,t,n),i=aK("tensors",e,t,n),o=i[0].shape,s=r.squeeze(i[0]).shape,l=i.map((e=>{let t=fC.arraysEqual(e.shape,o);if(!t&&!fC.arraysEqual(r.squeeze(e).shape,s))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,o)}));return[r.stack(l,a)]}));case"Unpack":{let a=aK("axis",e,t,n),i=aK("tensor",e,t,n);return r.unstack(i,a)}case"Tile":{let a=aK("reps",e,t,n);return[r.tile(aK("x",e,t,n),a)]}case"Split":case"SplitV":{let a=aK("axis",e,t,n),i=aK("numOrSizeSplits",e,t,n),o=aK("x",e,t,n);return r.split(o,i,a)}case"ScatterNd":{let a=aK("indices",e,t,n),i=aK("values",e,t,n),o=aK("shape",e,t,n);return[r.scatterND(a,i,o)]}case"GatherNd":{let a=aK("x",e,t,n),i=aK("indices",e,t,n);return[r.gatherND(a,i)]}case"SparseToDense":{let a=aK("sparseIndices",e,t,n),i=aK("outputShape",e,t,n),o=aK("sparseValues",e,t,n),s=aK("defaultValue",e,t,n);return[r.sparseToDense(a,o,i,o.dtype===s.dtype?s:r.cast(s,o.dtype))]}case"TensorScatterUpdate":{let a=aK("indices",e,t,n),i=aK("values",e,t,n),o=aK("tensor",e,t,n);return[r.tensorScatterUpdate(o,a,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"sparse":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:a,outputValues:i,emptyRowIndicator:o,reverseIndexMap:s}=r.sparse.sparseFillEmptyRows(aK("indices",e,t,n),aK("values",e,t,n),aK("denseShape",e,t,n),aK("defaultValue",e,t,n));return[a,i,o,s]}case"SparseReshape":{let{outputIndices:a,outputShape:i}=r.sparse.sparseReshape(aK("inputIndices",e,t,n),aK("inputShape",e,t,n),aK("newShape",e,t,n));return[a,i]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(aK("data",e,t,n),aK("indices",e,t,n),aK("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(aK("data",e,t,n),aK("indices",e,t,n),aK("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"spectral":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"FFT":return[r.fft(aK("x",e,t,n))];case"IFFT":return[r.ifft(aK("x",e,t,n))];case"RFFT":return[r.rfft(aK("x",e,t,n))];case"IRFFT":return[r.irfft(aK("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"string":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(aK("input",e,t,n),aK("pattern",e,t,n),aK("rewrite",e,t,n),aK("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:a,nGramsSplits:i}=r.string.stringNGrams(aK("data",e,t,n),aK("dataSplits",e,t,n),aK("separator",e,t,n),aK("nGramWidths",e,t,n),aK("leftPad",e,t,n),aK("rightPad",e,t,n),aK("padWidth",e,t,n),aK("preserveShortSequences",e,t,n));return[a,i]}case"StringSplit":{let{indices:a,values:i,shape:o}=r.string.stringSplit(aK("input",e,t,n),aK("delimiter",e,t,n),aK("skipEmpty",e,t,n));return[a,i,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(aK("input",e,t,n),aK("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"transformation":return a((()=>((e,t,n,r=cX)=>{switch(e.op){case"Cast":return[r.cast(aK("x",e,t,n),aK("dtype",e,t,n))];case"ExpandDims":{let a=aK("axis",e,t,n);return[r.expandDims(aK("x",e,t,n),a)]}case"Squeeze":{let a=aK("axis",e,t,n);return[r.squeeze(aK("x",e,t,n),a)]}case"Reshape":return[r.reshape(aK("x",e,t,n),aK("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(aK("x",e,t,n),aK("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(aK("x",e,t,n),aK("padding",e,t,n),aK("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(aK("x",e,t,n),aK("padding",e,t,n),aK("constantValue",e,t,n))];case"SpaceToBatchND":{let a=aK("blockShape",e,t,n),i=aK("paddings",e,t,n);return[r.spaceToBatchND(aK("x",e,t,n),a,i)]}case"BatchToSpaceND":{let a=aK("blockShape",e,t,n),i=aK("crops",e,t,n);return[r.batchToSpaceND(aK("x",e,t,n),a,i)]}case"DepthToSpace":{let a=aK("blockSize",e,t,n),i=aK("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(aK("x",e,t,n),a,i)]}case"BroadcastTo":return[r.broadcastTo(aK("x",e,t,n),aK("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(aK("s0",e,t,n),aK("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"hash_table":return xX(e,t,n,r);case"custom":let i=nK(e.op);if(i&&i.customExecutor)return i.customExecutor(new class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return iK(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(null!=n.tensor)return iK(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return eX(this.node.rawAttrs,e,t);if(null!=n.s)return ZK(this.node.rawAttrs,e,t);if(null!=n.b)return JK(this.node.rawAttrs,e,t);if(null!=n.shape)return oX(this.node.rawAttrs,e,t);if(null!=n.type)return rX(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return sX(this.node.rawAttrs,e,t);if(null!=n.list.s)return lX(this.node.rawAttrs,e,t);if(null!=n.list.shape)return uX(this.node.rawAttrs,e,t);if(null!=n.list.b)return dX(this.node.rawAttrs,e,t);if(null!=n.list.type)return aX(this.node.rawAttrs,e,t)}return t}}(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return fC.isPromise(i)?i.then((e=>[].concat(e))):[].concat(i)}var kX=class{constructor(e={},t={},n={},r={},a){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function SX(e,t,n,r){let a=new Set,i=[],o=null,s=null,l=new Set,u=new Set(Object.keys(e).map((e=>uK(e)[0])));r=r||[];let d=new Set(r.map((e=>uK(e.name)[0]))),c=[...t];for(;c.length>0;){let e=c.pop();if((EX(e)||_X(e)||AX(e))&&null==o&&(o=e,s=o.children.map((e=>e.name)).filter((e=>a.has(e)))),a.add(e.name),null==n[e.name]&&!u.has(e.name)&&!d.has(e.name)){if(0===e.inputs.length){i.push(e.name);continue}e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),c.push(e))}))}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:i,dynamicNode:o,syncInputs:s}}function IX(e,t){let{usedNodes:n,inputs:r}=t,a=Object.keys(r).map((e=>uK(e)[0])).map((t=>e.nodes[t])),i=e.initNodes||[],o=e=>n.has("string"==typeof e?e:e.name);function s(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}let l=s([...a,...e.weights,...i]).filter(o),u=s([...l,...Object.values(e.nodes)]).filter(o),d=new Map(u.map((e=>[e.name,e]))),c={};for(let g of u){c[g.name]=c[g.name]||0;for(let e of g.children)o(e)||(c[e.name]=Number.POSITIVE_INFINITY),c[e.name]=(c[e.name]||0)+1}let p=Object.entries(c).filter((([,e])=>0===e)).map((([e])=>e)),h=[...p];for(;p.length>0;){let e=p.pop(),t=d.get(e);for(let n of t.children.filter(o))0==--c[n.name]&&(h.push(n.name),p.push(n.name))}let f=h.map((e=>d.get(e))),m=function(e,t){let n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),a=new Set(r);for(;r.length>0;){let e=r.pop(),t=n.get(e);for(let i of t.children)!n.has(i.name)||a.has(i.name)||(a.add(i.name),r.push(i.name))}return e.filter((e=>a.has(e.name)))}(f,l);return function(e,t){let n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),a=e=>r.has("string"==typeof e?e:e.name),i=new Set(e.map((e=>e.name))),o=e=>i.has("string"==typeof e?e:e.name);for(let s of e){for(let e of s.children.filter(o)){if(!n.has(e.name))throw new NX(`Child ${e.name} of node ${s.name} is unreachable.`);if(n.get(s.name)>n.get(e.name))throw new NX(`Node ${s.name} is scheduled to run after its child ${e.name}.`)}if(!a(s))for(let e of s.inputs){if(!n.has(e.name))throw new NX(`Input ${e.name} of node ${s.name} is unreachable.`);if(n.get(e.name)>n.get(s.name))throw new NX(`Node ${s.name} is scheduled to run before its input ${e.name}.`)}}}(m,l),m}var NX=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}},CX=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),TX=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),$X=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function EX(e){return CX.has(e.op)}function _X(e){return TX.has(e.op)}function AX(e){return $X.has(e.op)}var RX=class{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new RX(e.functions[t],this)}))}getCompilationKey(e,t){let n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){let n=SX(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:i}=n;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){let n=t.map((e=>e.name)),a=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${a}]. Missing the following inputs: [${r}]`)}let o=IX(this.graph,n),s=function(e){let t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>EX(e)?n:t)),a=e=>{let n=r[t.get(e.name)];return null==n?-1:n},i=e.map(((e,t)=>e.children.map(a).reduce(((e,t)=>Math.max(e,t)),r[t]))),o=new Map;for(let s=0;s<e.length;++s){let t=i[s];if(t===n)continue;let r=e[s],a=e[t];o.has(a.name)||o.set(a.name,[]),o.get(a.name).push(r)}return o}(o);return{orderedNodes:o,nodeLiveUntilMap:s}}cloneAndKeepTensor(e){if(null==e)return null;let t=e.clone();return K$(t),t}cloneTensorList(e){return e?e.map((e=>this.cloneAndKeepTensor(e))):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((([e,t])=>[e,this.cloneTensorList(t)])))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let r=n.map((e=>this.graph.nodes[uK(e)[0]])),a=t.map((e=>uK(e)[0])),i=new Set(a),o=a.map((e=>this.graph.nodes[e]));0===o.length&&(o=this._outputs);let s=this.getCompilationKey(r,o),l=this.compiledMap.get(s);null==l&&(l=this.compile(e,o),this.compiledMap.set(s,l));try{this.keepIntermediateTensors=Rk().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(wp){this.keepIntermediateTensors=!1,console.warn(wp.message)}let u={},d={};return G$((()=>{let n=new kX(this.weightMap,u,d,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{let[a,i]=uK(t,n),o=[];o[i]=e[t],r[a]=o,this.keepIntermediateTensors&&(this.clonedTensorsMap[a]=this.cloneTensorList(o))}));let a=this.getFrozenTensorIds(r),{orderedNodes:o,nodeLiveUntilMap:s}=l;for(let e of o){if(r[e.name])continue;let t=wX(e,r,n,this._resourceManager);if(fC.isPromise(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,a,i,s.get(e.name))}return null==this.parent&&n.dispose(a),t.map((e=>iK(e,r,n)))}))}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,i,o){if(!EX(t)&&!i.has(e)){for(let r of n[e])null!=r&&(o[r.id]=(o[r.id]||0)+t.children.length);for(let e of t.inputs){if(EX(e))continue;let t=oK(e.name,n,r);if(null!=t)for(let e of t){if(!e||e.kept||a.has(e.id))continue;let t=o[e.id];1===t?(e.dispose(),delete o[e.id]):null!=t&&o[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,a,i){function o(e){return EX(e)||a.has(e.name)}if(!EX(e)&&null!=i)for(let s of i){if(o(s))continue;let e=oK(s.name,t,n);for(let t of e)!t||t.kept||r.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,r={},a={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=Rk().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(wp){this.keepIntermediateTensors=!1,console.warn(wp.message)}let i=new kX(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(e,i,t,n),s=t.map((e=>iK(e,o,i))),l=s.map((e=>e.id)),u=Object.keys(e).map((t=>e[t].id)),d=new Set([...l,...u,...this.weightIds]);return Object.values(o).forEach((e=>{e.forEach((e=>{e&&!e.isDisposed&&!d.has(e.id)&&e.dispose()}))})),null==this.parent&&i.dispose(d),s}async executeFunctionAsync(e,t,n){let r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){let a=Object.keys(e),i=a.map((e=>this.graph.nodes[uK(e)[0]])),o=n.map((e=>uK(e)[0])),s=new Set(o),l=o.map((e=>this.graph.nodes[e]));0===l.length&&(l=this._outputs);let{usedNodes:u,missingInputs:d,dynamicNode:c,syncInputs:p}=SX(e,l,this.weightMap,this._initNodes),h=[...i,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{let[n,r]=uK(t),a=[];a[r]=e[t],f[n]=a}));let m={},g=this.getFrozenTensorIds(f),b={};for(;h.length>0;){let e=this.processStack(i,h,t,f,b,g,s,m,u);await Promise.all(e)}null==c&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let y=l.filter((e=>!EX(e)&&!iK(e.name,f,t))).map((e=>e.name));if(y.length>0){let e="";throw null!=c&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${y}] from the provided inputs [${a}]. Consider providing the following inputs: [${d}]. ${e}`)}return f}processStack(e,t,n,r,a,i,o,s,l){let u=[];for(;t.length>0;){let e=t.pop();n.currentContext=e.contexts;let d="";if("Enter"===e.node.op&&aK("isConstant",e.node,r,n)&&([d]=sK(e.node.name,n)),null==r[e.node.name]){let c=wX(e.node,r,n,this._resourceManager);d||([d]=sK(e.node.name,n));let p=n.currentContext;fC.isPromise(c)?u.push(c.then((u=>(r[d]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(u)),n.currentContext=p,this.checkTensorForDisposal(d,e.node,r,n,i,o,s),this.processChildNodes(e.node,t,n,r,a,l),u)))):(r[d]=c,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(c)),this.checkTensorForDisposal(d,e.node,r,n,i,o,s),this.processChildNodes(e.node,t,n,r,a,l))}else this.processChildNodes(e.node,t,n,r,a,l)}return u}processChildNodes(e,t,n,r,a,i){e.children.forEach((e=>{let[o]=sK(e.name,n);a[o]||!i.has(e.name)||("Merge"===e.op?e.inputNames.some((e=>!!iK(e,r,n)))&&(a[o]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!iK(e,r,n)))&&(a[o]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{let n=e[t],[r]=uK(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){let e=a.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));fC.assert(t,(()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}a.attrParams.dtype&&a.attrParams.dtype.value&&fC.assert(n.dtype===a.attrParams.dtype.value,(()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;let r={};for(let a in e){let i=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[a];null!=i?r[i.name]=e[a]:r[a]=e[a]}return r}checkInputs(e){let t=Object.keys(e).filter((e=>{let[t]=uK(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;let r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{let[t]=uK(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}},FX="?tfjs-format=file",DX="model.json",MX=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=IM){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}}findIOHandler(){let e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return fC.isPromise(e)?e.then((e=>this.loadSync(e))):this.loadSync(e)}loadSync(e){this.artifacts=e;let t=this.artifacts.modelTopology,n=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){let e=this.artifacts.userDefinedMetadata;null!=e.signature&&(n=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;let r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new RX(YK.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){let t=YK.Instance.transformGraph(e.modelInitializer);this.initializer=new RX(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){let t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t={};return(e instanceof QC?[e]:e).forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e)),t}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof QC||Array.isArray(e))){let n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(let t in n){let r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var a,i,o;let s=null===(o=null===(i=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===i?void 0:i[n])||void 0===o?void 0:o.resourceId;return t[n]=null!=s?this.resourceIdToCapturedInput[s]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let a=t[n[r]];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&q$(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function OX(e,t={},n=IM){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=function(e){return e.endsWith("/")||(e+="/"),`${e}${DX}${FX}`}(e));let r=new MX(e,t,n);return await r.load(),r}function zX(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[n,r]=e;if(!n)throw new Error("modelJSON must be the first element of the array");if(!(r&&r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");let a=IM.getWeightSpecs(n.weightsManifest),i=IM.getModelArtifactsForJSONSync(n,a,r);t=IM.fromMemorySync(i)}else if("load"in e)t=e;else{if(!("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e))throw new Error("Unknown model format");t=IM.fromMemorySync(e)}let n=new MX(t);return n.load(),n}var PX="4.7.0",LX={};uw(LX,{CSVDataset:()=>AY,Dataset:()=>yY,FileDataSource:()=>jY,TextLineDataset:()=>IY,URLDataSource:()=>HY,array:()=>xY,csv:()=>GY,func:()=>qY,generator:()=>KY,microphone:()=>YY,version_data:()=>QY,webcam:()=>XY,zip:()=>wY});var BX=dw(kw()),WX=dw(kw());function VX(e,t,n=new Map,r=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(qX(e)){let a=Array.isArray(e)?[]:{};r.add(e);for(let i in e){let o=VX(e[i],t,n,r);a[i]=o}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,a.value),a.value}function UX(e,t=HX){return jX(e,t)}function jX(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(qX(r)){let a=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let r=e.map((e=>e[i])),o=jX(r,t,n);a[i]=o}return n.delete(r),a}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return a.value}function HX(e){return null===e?null:qX(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function GX(e,t){let n=new Map;VX(e,t,n);for(let r of Array.from(n.keys())){let e=n.get(r);if(fC.isPromise(e)){let t=await e;n.set(r,t)}}return VX(e,t,n)}function qX(e){let t=!1;if(Rk().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=Sw();t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof QC)&&!(e instanceof Promise)&&!t)}function KX(e){return function(e,t){return VX(e,t)}(e,XX)}function XX(e){return e instanceof QC?{value:e.clone(),recurse:!1}:qX(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var YX=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},QX=class extends YX{constructor(){super(QX.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};function ZX(e){return new nY(e)}function JX(e){return new rY(e)}QX.INITIAL_CAPACITY=32;var eY,tY=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new dY(this,e)}filter(e){return new lY(this,e)}map(e){return new uY(this,e)}mapAsync(e){return new cY(this,e)}serialMapAsync(e){return new cY(this,e).serial()}flatmap(e){return new hY(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e,t=!0){return new sY(this,e,t)}columnMajorBatch(e,t=!0,n=HX){return this.rowMajorBatch(e,t).map((e=>UX(e,n)))}concatenate(e,t){return new fY(ZX([this,e]),t)}take(e){return e<0||null==e?this:new oY(this,e)}skip(e){return e<0||null==e?this:new iY(this,e)}prefetch(e){return new gY(this,e)}shuffle(e,t){return new bY(this,e,t)}serial(){return new aY(this)}},nY=class extends tY{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:KX(e),done:!1}}},rY=class extends tY{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(kp){throw kp.message=`Error thrown while iterating through a dataset: ${kp.message}`,kp}}},aY=class extends tY{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}},iY=class extends tY{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;q$(e.value)}return this.upstream.next()}},oY=class extends tY{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},sY=class extends tY{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},lY=class extends tY{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;q$(e.value)}}},uY=class extends tY{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=iT.getTensorsInContainer(e.value),n=this.transform(e.value),r=iT.getTensorsInContainer(n);for(let a of t)iT.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},dY=class extends tY{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(kp){if(!this.handler(kp))return{value:null,done:!0}}}},cY=class extends tY{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=iT.getTensorsInContainer(e.value),n=await this.transform(e.value),r=iT.getTensorsInContainer(n);for(let a of t)iT.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},pY=class extends tY{constructor(){super(),this.outputQueue=new QX,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!(await this.pump()))return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},hY=class extends pY{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=iT.getTensorsInContainer(e.value),n=this.transform(e.value),r=iT.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let a of t)iT.isTensorInList(a,r)||a.dispose();return!0}},fY=class extends tY{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){let e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}};!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(eY||(eY={}));var mY=class extends tY{constructor(e,t=eY.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0,r=await GX(this.iterators,(function(e){return e instanceof tY?{value:e.next().then((e=>(t++,e.done&&n++,e.value))),recurse:!1}:{value:null,recurse:!0}}));if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case eY.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case eY.SHORTEST:return{value:null,done:!0};case eY.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},gY=class extends tY{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new YX(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},bY=class extends gY{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=WX.alea(n||fC.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}},yY=class{constructor(){this.size=null}batch(e,t=!0){let n,r=this;return fC.assert(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),n=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),vY((async()=>(await r.iterator()).columnMajorBatch(e,t,kY)),n)}concatenate(e){let t,n=this;return t=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,vY((async()=>(await n.iterator()).concatenate(await e.iterator())),t)}filter(e){let t,n=this;return t=this.size===1/0?1/0:null,vY((async()=>(await n.iterator()).filter((t=>G$((()=>e(t)))))),t)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return vY((async()=>(await t.iterator()).map((t=>G$((()=>e(t)))))),this.size)}mapAsync(e){let t=this;return vY((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return vY((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){let t,n=this;return t=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,vY((async()=>function(e,t){return new fY(e,t)}(JX((async()=>({value:await n.iterator(),done:!1}))).take(e))),t)}skip(e){let t,n=this;return t=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,vY((async()=>(await n.iterator()).skip(e)),t)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=BX.alea(t||fC.now().toString());return vY((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){let t,n=this;return t=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,vY((async()=>(await n.iterator()).take(e)),t)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};function vY(e,t=null){return new class extends yY{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function xY(e){return vY((async()=>ZX(e)),e.length)}function wY(e){if(!qX(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return vY((async()=>{let t=await GX(e,(e=>{if(e instanceof yY)return{value:e.iterator(),recurse:!1};if(qX(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")}));return function(e,t=eY.FAIL){return new mY(e,t)}(t,eY.SHORTEST)}),t)}function kY(e){return null===e?null:function(e){return null==e||function(e){return null===e||"object"!=typeof e&&"function"!=typeof e}(e)||Array.isArray(e)||"object"==typeof e&&e instanceof QC||fC.isTypedArray(e)}(e[0])?{value:SY(e),recurse:!1}:{value:null,recurse:!0}}function SY(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof QC?bF(e):zT(e)}yY.MAX_BUFFER_SIZE=1e4;var IY=class extends yY{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e)))}},NY='"',CY=Symbol("out"),TY=Symbol("field"),$Y=Symbol("quote"),EY=Symbol("quoteafterquote"),_Y=Symbol("quoteinquote"),AY=class extends yY{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&fC.assert(e.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce(((e,t)=>(e[t]=e[t]+1||1,e)),{}),n=Object.keys(t).filter((e=>t[e]>1));if(fC.assert(0===n.length,(()=>"Duplicate column names found: "+n.toString())),this.columnConfigs)for(let r of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(r))throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new IY(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(fC.assert(null==t.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map((e=>this.makeDataElement(e)))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let i=this.fullColumnNames[a],o=this.columnConfigs?this.columnConfigs[i]:null;if(!this.configuredColumnsOnly||o){let s=t[a],l=null;if(""===s)if(o&&void 0!==o.default)l=o.default;else{if(o&&(o.required||o.isLabel))throw new Error(`Required column ${i} is empty in this line: ${e}`);l=void 0}else{let e=Number(s);if(isNaN(e))l=o&&"bool"===o.dtype?this.getBoolean(s):s;else if(o&&o.dtype)switch(o.dtype){case"float32":default:l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(s)}else l=e}o&&o.isLabel?r[i]=l:n[i]=l}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e,t=!0){let n=[],r=0,a=e.length,i=CY;for(let o=0;o<a;o++)switch(i){case CY:switch(e.charAt(o)){case NY:r=o+1,i=$Y;break;case this.delimiter:if(r=o+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),i=CY;break;default:i=TY,r=o}break;case TY:e.charAt(o)===this.delimiter&&(n.push(e.substring(r,o)),i=CY,r=o+1);break;case $Y:e.charAt(o)===NY&&(i=EY);break;case EY:switch(e.charAt(o)){case this.delimiter:n.push(e.substring(r,o-1)),i=CY,r=o+1;break;case NY:i=$Y;break;default:i=_Y}break;case _Y:e.charAt(o)===NY&&(i=$Y)}if(i===EY?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},RY=class extends tY{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!Rk().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let t=new RY(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(Ep){throw new Error(`Error thrown while initializing video stream: ${Ep.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise((r=>{let a=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(a),r({freqDataQueue:e,timeDataQueue:t}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach(((e,r)=>n.set(e,r*t))),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(fC.sizeFromShape(t));return n.set(e,n.length-e.length),zT(n,t)}},FY=class extends tY{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=wF([0],"int32"),this.webcamConfig.centerCrop){let e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,a=n+e,i=t+r;this.cropBox=kF([r,n,i,a],[1,4])}else this.cropBox=kF([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!Rk().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}let n=new FY(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&fC.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(kp){throw kp.message=`Error thrown while initializing video stream: ${kp.message}`,kp}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(kp){console.log(kp),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=qM.fromPixels(this.webcamVideoElement)}catch(Fp){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(Fp)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(Fp){throw new Error(`Error thrown cropping the video: ${Fp.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return G$((()=>{let t,n=rA(M$(e,"float32"),0);t=oM.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=t.shape;return zE(t,r.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((e=>e.stop()));try{this.webcamVideoElement.srcObject=null}catch(kp){console.log(kp),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},DY=class{},MY=class extends tY{split(e){return new OY(this,e)}},OY=class extends MY{constructor(e,t){super(),this.upstream=e,this.impl=new zY(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},zY=class extends pY{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},PY=class extends tY{decodeUTF8(){return new LY(this)}},LY=class extends MY{constructor(e){super(),this.upstream=e,this.impl=new BY(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},BY=class extends pY{constructor(e){if(super(),this.upstream=e,Rk().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=Sw();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e,t,n=await this.upstream.next();return!n.done&&(e=n.value,t=Rk().get("IS_BROWSER")?this.decoder.decode(e,{stream:!0}):this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(t),!0)}},WY=class extends PY{constructor(e,t={}){super(),this.file=e,this.options=t,fC.assert(e instanceof Uint8Array||!!Rk().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise(((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=n=>{let a=r.result;if(a instanceof ArrayBuffer&&(a=new Uint8Array(a)),!(a instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(a)},r.onabort=e=>t(new Error("Aborted")),r.onerror=e=>t(new Error(e.type));let a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n})),done:!1}}},VY=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function UY(e){return"string"==typeof e&&"file://"===e.slice(0,7)}var jY=class extends DY{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(UY(this.input)&&Rk().get("IS_NODE")){let e=Iw();this.input=e.readFileSync(this.input.slice(7))}return new WY(this.input,this.options)}},HY=class extends DY{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return UY(this.url)?new jY(this.url,this.fileOptions).iterator():async function(e,t={},n){let r,a;"string"==typeof e?r=e:(r=e.url,a=VY(e));let i=await(n||fC.fetch)(r,a);if(i.ok){let e=new Uint8Array(await i.arrayBuffer());return new WY(e,t)}throw new Error(i.statusText)}(this.url,this.fileOptions)}};function GY(e,t={}){return new AY(new HY(e),t)}function qY(e){let t=JX(e);return vY((async()=>t))}function KY(e){return vY((async()=>{let t=await e();return JX((()=>t.next()))}))}async function XY(e,t){return FY.create(e,t)}async function YY(e){return RY.create(e)}var QY="4.7.0";function ZY(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&fC.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}var JY=zz.whereImpl,eQ=class extends Fw{nextDataId(){return eQ.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Rw(this,U$())}write(e,t,n){this.firstUse&&(this.firstUse=!1,Rk().get("IS_NODE")&&AO.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&fC.isString(n[0])){let a=n.map((e=>fC.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){let e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return AO.mergeRealAndImagArrays(e,t)}return fC.convertBackendValuesAndArrayBuffer(this.data.get(e).values,t)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>fC.decodeString(e)));return D$(e.shape,e.dtype,n)}catch(Ep){throw new Error("Failed to decode encoded string bytes into utf-8")}return D$(e.shape,e.dtype,t)}makeOutput(e,t,n){return U$().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=fC.now();return e(),{kernelMs:fC.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){ZY([e],"where");let t=this.readSync(e.dataId);return JY(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};eQ.nextDataId=0;var tQ={};function nQ(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}uw(tQ,{addImpl:()=>bQ,bincountImpl:()=>wQ,bincountReduceImpl:()=>kQ,bitwiseAndImpl:()=>SQ,castImpl:()=>pQ,ceilImpl:()=>EQ,concatImpl:()=>RQ,equalImpl:()=>FQ,expImpl:()=>OQ,expm1Impl:()=>LQ,floorDivImpl:()=>HQ,floorImpl:()=>VQ,gatherNdImpl:()=>KQ,gatherV2Impl:()=>XQ,greaterEqualImpl:()=>JQ,greaterImpl:()=>YQ,lessEqualImpl:()=>iZ,lessImpl:()=>nZ,linSpaceImpl:()=>lZ,logImpl:()=>uZ,maxImpl:()=>pZ,maximumImpl:()=>hZ,minimumImpl:()=>gZ,multiplyImpl:()=>vZ,negImpl:()=>SZ,notEqualImpl:()=>NZ,prodImpl:()=>AZ,raggedGatherImpl:()=>OZ,raggedRangeImpl:()=>PZ,raggedTensorToTensorImpl:()=>UZ,rangeImpl:()=>jZ,rsqrtImpl:()=>HZ,scatterImpl:()=>KZ,sigmoidImpl:()=>XZ,simpleAbsImpl:()=>nQ,sliceImpl:()=>ZZ,sparseFillEmptyRowsImpl:()=>tJ,sparseReshapeImpl:()=>nJ,sparseSegmentReductionImpl:()=>rJ,sqrtImpl:()=>aJ,squaredDifferenceImpl:()=>sJ,staticRegexReplaceImpl:()=>dJ,stridedSliceImpl:()=>hJ,stringNGramsImpl:()=>mJ,stringSplitImpl:()=>bJ,stringToHashBucketFastImpl:()=>yJ,subImpl:()=>vJ,tileImpl:()=>SJ,topKImpl:()=>CJ,transposeImpl:()=>$Z,uniqueImpl:()=>TJ});var rQ={kernelName:zk,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend;ZY(t,"abs");let r=new Float32Array(fC.sizeFromShape(t.shape));return r=nQ(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}};function aQ(e){return(t,n,r,a,i)=>{let o=AO.assertAndGetBroadcastShape(t,n),s=o.length,l=fC.computeStrides(o),u=fC.sizeFromShape(o),d=fC.getTypedArrayFromDType(i,u),c=t.length,p=n.length,h=fC.computeStrides(t),f=fC.computeStrides(n),m=AO.getBroadcastDims(t,o),g=AO.getBroadcastDims(n,o);if(m.length+g.length===0)for(let b=0;b<d.length;++b)d[b]=e(r[b%r.length],a[b%a.length]);else for(let b=0;b<d.length;++b){let t=fC.indexToLoc(b,s,l),n=t.slice(-c);m.forEach((e=>n[e]=0));let i=fC.locToIndex(n,c,h),o=t.slice(-p);g.forEach((e=>o[e]=0));let u=fC.locToIndex(o,p,f);d[b]=e(r[i],a[u])}return[d,o]}}function iQ(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,s=n.makeTensorInfo(r.shape,"complex64");return n.data.get(s.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",i),imag:n.makeTensorInfo(a.shape,"float32",o)},s}var oQ={kernelName:dS,backendName:"cpu",kernelFunc:iQ};function sQ(e,t,n="float32"){if("complex64"===n)return iQ({inputs:{real:sQ(e,t,"float32"),imag:sQ(e,t,"float32")},backend:e});let r=fC.makeZerosTypedArray(fC.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function lQ(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var uQ={kernelName:JS,backendName:"cpu",kernelFunc:lQ};function dQ(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,i=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,i)}var cQ={kernelName:QI,backendName:"cpu",kernelFunc:dQ};function pQ(e,t,n,r){if("int32"===r)return[t,"int32",Int32Array.from(e)];if("bool"===r){let r=fC.toTypedArray([0],n),[a,i]=aQ(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function hQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:i}=r;if("complex64"===i){if("complex64"===a.dtype)return lQ({inputs:{x:a},backend:n});let e=sQ(n,a.shape,a.dtype),t=hQ({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=iQ({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){let e=dQ({inputs:{input:a},backend:n}),t=hQ({inputs:{x:e},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(e),t}if(!fC.hasEncodingLoss(a.dtype,i)){let e=lQ({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:i}}let o=n.data.get(a.dataId).values,[s,l,u]=pQ(o,a.shape,a.dtype,i);return n.makeTensorInfo(s,l,u)}var fQ={kernelName:sS,backendName:"cpu",kernelFunc:hQ};function mQ(e,t,n,r){return null==n?({inputs:n,backend:a})=>{let{a:i,b:o}=n,s=a;ZY([i,o],e);let l=s.data.get(i.dataId).values,u=s.data.get(o.dataId).values,d="string"===i.dtype?AO.fromUint8ToStringArray(l):l,c="string"===i.dtype?AO.fromUint8ToStringArray(u):u,p=r||i.dtype,[h,f]=t(i.shape,o.shape,d,c,p);return s.makeTensorInfo(f,p,h)}:({inputs:e,backend:a})=>{let{a:i,b:o}=e,s=a;if("complex64"===i.dtype||"complex64"===o.dtype){let e=hQ({inputs:{x:i},backend:s,attrs:{dtype:"complex64"}}),t=s.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,l=s.data.get(r.dataId).values,u=s.data.get(a.dataId).values,d=hQ({inputs:{x:o},backend:s,attrs:{dtype:"complex64"}}),c=s.data.get(d.dataId),p=c.complexTensorInfos.real,h=c.complexTensorInfos.imag,f=s.data.get(p.dataId).values,m=s.data.get(h.dataId).values,[g,b,y]=n(i.shape,o.shape,l,u,f,m),v=s.makeTensorInfo(y,"float32",g),x=s.makeTensorInfo(y,"float32",b),w=iQ({inputs:{real:v,imag:x},backend:s});return s.disposeIntermediateTensorInfo(e),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(x),w}{let e=s.data.get(i.dataId).values,n=s.data.get(o.dataId).values,a=r||i.dtype,[l,u]=t(i.shape,o.shape,e,n,a);return s.makeTensorInfo(u,a,l)}}}function gQ(e){return(t,n,r,a,i,o)=>{let s=AO.assertAndGetBroadcastShape(t,n),l=fC.sizeFromShape(s),u=s.length,d=fC.computeStrides(s),c=fC.getTypedArrayFromDType("float32",l),p=fC.getTypedArrayFromDType("float32",l),h=AO.getBroadcastDims(t,s),f=AO.getBroadcastDims(n,s),m=AO.mergeRealAndImagArrays(r,a),g=AO.mergeRealAndImagArrays(i,o),b=t.length,y=fC.computeStrides(t),v=n.length,x=fC.computeStrides(n);if(h.length+f.length===0)for(let w=0;w<c.length;w++){let t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);c[w]=r.real,p[w]=r.imag}else for(let w=0;w<c.length;w++){let t=fC.indexToLoc(w,u,d),n=t.slice(-b);h.forEach((e=>n[e]=0));let r=fC.locToIndex(n,b,y),a=t.slice(-v);f.forEach((e=>a[e]=0));let i=fC.locToIndex(a,v,x),o=e(m[2*r],m[2*r+1],g[2*i],g[2*i+1]);c[w]=o.real,p[w]=o.imag}return[c,p,s]}}var bQ=aQ(((e,t)=>e+t)),yQ=gQ(((e,t,n,r)=>({real:e+n,imag:t+r}))),vQ=mQ(Bk,bQ,yQ),xQ={kernelName:Bk,backendName:"cpu",kernelFunc:vQ};function wQ(e,t,n,r,a){let i=fC.sizeFromShape(r),o=fC.makeZerosTypedArray(a,n);for(let s=0;s<e.length;s++){let n=e[s];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(o[n]+=i>0?t[s]:1)}return o}function kQ(e,t,n,r=!1){let a=e.shape[0],i=e.shape[1],o=D$([a,n],t.dtype);for(let s=0;s<a;s++)for(let a=0;a<i;a++){let i=e.get(s,a);if(i<0)throw new Error("Input x must be non-negative!");i>=n||(r?o.set(1,s,i):t.size>0?o.set(o.get(s,i)+t.get(s,a),s,i):o.set(o.get(s,i)+1,s,i))}return o}var SQ=aQ(((e,t)=>e&t)),IQ=mQ(aS,SQ),NQ={kernelName:aS,backendName:"cpu",kernelFunc:IQ};function CQ(e){return(t,n,r)=>{let a=fC.getArrayFromDType(n,t.length);for(let i=0;i<t.length;++i)a[i]=e(t[i],r);return a}}function TQ(e,t,n){return $Q(e,CQ(t),n)}function $Q(e,t,n){return({inputs:r,attrs:a,backend:i})=>{let{x:o}=r;ZY(o,e);let s,l=i,u=l.data.get(o.dataId).values;if("string"===o.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");s=AO.fromUint8ToStringArray(u)}else s=u;let d=n||o.dtype,c=t(s,d,a);return l.makeTensorInfo(o.shape,d,c)}}var EQ=CQ((e=>Math.ceil(e))),_Q=$Q(lS,EQ),AQ={kernelName:lS,backendName:"cpu",kernelFunc:_Q};function RQ(e,t,n,r){let a=fC.getArrayFromDType(n,fC.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{let n=fC.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{let i="string"===n?AO.fromUint8ToStringArray(e.vals):e.vals,o=0;for(let n=0;n<e.shape[0];++n){let s=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[s+t]=i[o++]}r+=e.shape[1]}))}return a}var FQ=aQ(((e,t)=>e===t?1:0)),DQ=mQ(LS,FQ,null,"bool"),MQ={kernelName:LS,backendName:"cpu",kernelFunc:DQ},OQ=CQ((e=>Math.exp(e))),zQ=$Q(BS,OQ,"float32"),PQ={kernelName:BS,backendName:"cpu",kernelFunc:zQ},LQ=CQ((e=>Math.expm1(e))),BQ=$Q(VS,LQ),WQ={kernelName:VS,backendName:"cpu",kernelFunc:BQ},VQ=CQ((e=>Math.floor(e))),UQ=$Q(GS,VQ),jQ={kernelName:GS,backendName:"cpu",kernelFunc:UQ},HQ=aQ(((e,t)=>Math.floor(e/t))),GQ=mQ(qS,HQ,null,"int32"),qQ={kernelName:qS,backendName:"cpu",kernelFunc:GQ};function KQ(e,t,n,r,a,i,o,s,l){let u=D$([r,i],n);for(let d=0;d<r;d++){let n=[],r=0;for(let t=0;t<a;t++){let i=e[d*a+t];r+=i*o[t],n.push(i)}if(r<0||r>=l/i)throw new Error(`Invalid indices: ${n} does not index into ${s}`);for(let e=0;e<i;e++)u.values[d*i+e]=t.get(...t.indexToLoc(r*i+e))}return u}function XQ(e,t,n){let r=D$(n,e.dtype);for(let a=0;a<r.size;++a){let n=r.indexToLoc(a).slice(),i=n[0],o=n[2],s=t.locToIndex([i,o]);n[2]=t.values[s];let l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[a]=e.values[l])}return r}var YQ=aQ(((e,t)=>e>t?1:0)),QQ=mQ(QS,YQ,null,"bool"),ZQ={kernelName:QS,backendName:"cpu",kernelFunc:QQ},JQ=aQ(((e,t)=>e>=t?1:0)),eZ=mQ(ZS,JQ,null,"bool"),tZ={kernelName:ZS,backendName:"cpu",kernelFunc:eZ},nZ=aQ(((e,t)=>e<t?1:0)),rZ=mQ(oI,nZ,null,"bool"),aZ={kernelName:oI,backendName:"cpu",kernelFunc:rZ},iZ=aQ(((e,t)=>e<=t?1:0)),oZ=mQ(sI,iZ,null,"bool"),sZ={kernelName:sI,backendName:"cpu",kernelFunc:oZ};function lZ(e,t,n){let r=(t-e)/(n-1),a=fC.makeZerosTypedArray(n,"float32");a[0]=e;for(let i=1;i<a.length;i++)a[i]=a[i-1]+r;return a}var uZ=CQ((e=>Math.log(e))),dZ=$Q(uI,uZ),cZ={kernelName:uI,backendName:"cpu",kernelFunc:dZ};function pZ(e,t,n,r){let a=fC.getTypedArrayFromDType(r,fC.sizeFromShape(n));for(let i=0;i<a.length;++i){let n=i*t,r=e[n];for(let a=0;a<t;++a){let t=e[n+a];(Number.isNaN(t)||t>r)&&(r=t)}a[i]=r}return a}var hZ=aQ(((e,t)=>Math.max(e,t))),fZ=mQ(wI,hZ),mZ={kernelName:wI,backendName:"cpu",kernelFunc:fZ},gZ=aQ(((e,t)=>Math.min(e,t))),bZ=mQ(EI,gZ),yZ={kernelName:EI,backendName:"cpu",kernelFunc:bZ},vZ=aQ(((e,t)=>e*t)),xZ=gQ(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),wZ=mQ(FI,vZ,xZ),kZ={kernelName:FI,backendName:"cpu",kernelFunc:wZ};function SZ(e,t,n){let r=fC.createScalarValue(-1,n);return vZ([],t,r,e,n)}var IZ={kernelName:DI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t;ZY(r,"neg");let a=n.data.get(r.dataId).values,[i,o]=SZ(a,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}},NZ=aQ(((e,t)=>e!==t?1:0)),CZ=mQ(MI,NZ,null,"bool"),TZ={kernelName:MI,backendName:"cpu",kernelFunc:CZ};function $Z(e,t,n,r,a){let i=t.length,o=fC.sizeFromShape(t),s=fC.computeStrides(t),l=fC.computeStrides(a),u=fC.getTypedArrayFromDType(n,fC.sizeFromShape(a));for(let d=0;d<o;++d){let t=fC.indexToLoc(d,i,s),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];u[fC.locToIndex(n,i,l)]=e[d]}return u}function EZ(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:i}=n;ZY(a,"transpose");let o=a.shape.length,s=new Array(o);for(let u=0;u<s.length;u++)s[u]=a.shape[i[u]];let l=$Z(r.data.get(a.dataId).values,a.shape,a.dtype,i,s);return{dataId:r.write(l,s,a.dtype),shape:s,dtype:a.dtype}}var _Z={kernelName:UN,backendName:"cpu",kernelFunc:EZ};function AZ(e,t,n,r){let[a,i]=AO.computeOutAndReduceShapes(e,r),o=sT(t,"int32"),s=fC.makeZerosTypedArray(fC.sizeFromShape(a),o),l=fC.sizeFromShape(i);for(let u=0;u<s.length;++u){let e=u*l,t=1;for(let r=0;r<l;++r)t*=n[e+r];s[u]=t}return{outVals:s,outShape:a,outDtype:o}}var RZ={kernelName:GI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:o}=r;ZY(a,"prod");let s=a.shape.length,l=fC.parseAxisParam(i,a.shape),u=AO.getAxesPermutation(l,s),d=l,c=a,p=[];null!=u&&(c=EZ({inputs:{x:a},backend:n,attrs:{perm:u}}),p.push(c),d=AO.getInnerMostAxes(d.length,s));let h=n.data.get(c.dataId).values,{outVals:f,outShape:m,outDtype:g}=AZ(c.shape,c.dtype,h,d),b=m;return o&&(b=AO.expandShapeToKeepDim(m,l)),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(b,g,f)}};function FZ(e,t,n,r){let a=[],i=0,o=t.length-1+n.length,s=new Array(o).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){let r=e[n],a=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let e=t[u+1];for(let t=1;t<l+1;++t)s[u].push(t*e)}for(let u=0;u<e.length;++u){let r=e[u],o=e[u]+1;for(let e=0;e<n.length;++e){let a=n[e],i=e+t.length-1;if(i>=0){let e=s[i],t=e[e.length-1]-a[r];for(let n=r;n<o;++n)s[i].push(a[n+1]+t)}r=a[r],o=a[o]}o!==r&&(a.push([r,o]),i+=o-r)}return{outSplits:s,valueSlices:a,numValues:i}}function DZ(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function MZ(e,t,n,r,a){let i=t.slice();i[0]=a;let o=fC.getArrayFromDType(n,fC.sizeFromShape(i)),s=e.length;return function(e,t,n,r,a,i){let o=DZ(t,2)[1],s=DZ(i,2)[1],l=0;for(let u of n)for(let t=u[0];t<u[1];++t){for(let n=0;n<r;++n)a[l*s+n]=e[t*o+n];++l}}(e,t,r,0===s?0:s/t[0],o,i),[o,i]}function OZ(e,t,n,r,a,i,o,s){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){let a=fC.indexToLoc(r,t.length,fC.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${e} is not in [0, ${n})`)}}))}(i,o,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");let l=r[0],{outSplits:u,valueSlices:d,numValues:c}=FZ(i,o,e,l),p=function(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,a=fC.getArrayFromDType("int32",r);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(u),h=MZ(n,r,a,d,c);return[p,h[0],h[1]]}var zZ=2147483647;function PZ(e,t,n,r,a,i,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");let s=0===t.length,l=0===a.length,u=0===o.length,d=[];s||d.push(t[0]),l||d.push(a[0]),u||d.push(o[0]);for(let g=1;g<d.length;++g)if(d[g]!==d[g-1])throw new Error("starts, limits, and deltas must have the same shape");let c=0===d.length?1:d[0],p=fC.getArrayFromDType("int32",c+1);p[0]=0;for(let g=0;g<c;++g){let t,n=s?e[0]:e[g],a=l?r[0]:r[g],o=u?i[0]:i[g];if(0===o)throw new Error("Requires delta != 0");if(o>0&&a<n||o<0&&a>n)t=0;else if(t=Math.ceil(Math.abs((a-n)/o)),t>zZ)throw new Error(`Requires ((limit - start) / delta) <= ${zZ}`);p[g+1]=p[g]+t}let h=p[c],f=fC.getArrayFromDType(n,h),m=0;for(let g=0;g<c;++g){let t=p[g+1]-p[g],n=s?e[0]:e[g],r=u?i[0]:i[g];for(let e=0;e<t;++e)f[m++]=n,n+=r}return[p,f]}var LZ=AO.RowPartitionType,BZ=class{constructor(e,t,n,r,a,i,o,s,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=s,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=AO.getRowPartitionTypesHelper(u),this.raggedRank=AO.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===LZ.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===LZ.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case LZ.VALUE_ROWIDS:return BZ.getMaxWidthValueRowID(t);case LZ.ROW_SPLITS:return BZ.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${LZ[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){let t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){let t=e.length;if(0===t)return 0;let n=0,r=e[0],a=0;for(let i=1;i<t;++i){let t=e[i];t!==r&&(r=t,a=Math.max(i-n,a),n=i)}return Math.max(t-n,a)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return VZ(e,n)}calculateOutputSize(e){let t=this.valuesShape,n=this.defaultValueShape;AO.validateDefaultValueShape(n,t);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=AO.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);a[0]<0&&(a[0]=e);for(let i=1;i<=this.raggedRank;++i)a[i]<0&&(a[i]=this.getMaxWidth(i));return a}calculateFirstParentOutputIndex(e,t,n){let r=Math.min(e,n),a=[],i=0;for(let o=0;o<r;++o,i+=t)a.push(i);for(let o=r;o<e;++o)a.push(-1);return fC.assert(a.length===e,(()=>"Final length of result must be equal to firstDimension.")),a}calculateOutputIndexRowSplit(e,t,n,r){let a=e.length,i=[];for(let o=0;o<a-1;++o){let a=e[o+1]-e[o],s=Math.min(r,a),l=t[o];-1===l&&(s=0);for(let e=0;e<s;++e)i.push(l),l+=n;for(let e=0;e<a-s;++e)i.push(-1)}if(a>0&&i.length!==e[a-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,t,n,r){let a=e.length,i=[];if(0===a)return[];let o=0,s=e[0];if(s>=t.length)throw new Error(`Got currentValueRowId=${s}, which is not less than ${t.length}`);let l=t[s];i.push(l);for(let u=1;u<a;++u){let a=e[u];if(a===s)l>=0&&(++o,o<r?l+=n:l=-1);else{if(o=0,s=a,a>=t.length)throw new Error(`Got nextValueRowId=${a} which is not less than ${t.length}`);l=t[a]}i.push(l)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,t,n,r){let a=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case LZ.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,n,r);case LZ.ROW_SPLITS:if(a.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,n,r);default:throw new Error(`Unsupported partition type: ${LZ[i]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case LZ.FIRST_DIM_SIZE:return e[0];case LZ.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case LZ.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${LZ[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let i=n.length-2;i>=0;--i)n[i]=n[i+1]*t[i+1];let r=VZ(t,!1),a=fC.getArrayFromDType(this.valuesDType,fC.sizeFromShape(r));if(n[0]*t[0]>0){let i=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)i=this.calculateOutputIndex(e-1,i,n[e],t[e]);this.setOutput(this.raggedRank,i,a,r)}return[r,a]}setOutput(e,t,n,r){if(0===n.length)return;let a=this.values,i=n,o=r.slice();o=o.slice(e+1);let s=fC.sizeFromShape(o),l=t.length,u=this.defaultValue;if(u.length!==s&&1!==u.length){let e=this.defaultValueShape;G$((()=>{let t=zE(u,e);u=t_(t,o).dataSync()}))}let d=0,c=0,p=0;for(let h=0;h<=l;++h){let e=h<l?t[h]:-1;if(e!==p){if(c<p){let e=a.subarray(d*s);WZ(i.subarray(c*s),e,(p-c)*s)}if(h>=l){let t=n.length;e=Math.floor(t/s)}if(e>p)if(1===this.defaultValue.length)i.subarray(p*s,e*s).fill(this.defaultValue[0]),p=e;else for(;e>p;)WZ(i.slice(p*s),u,s),++p;e<0?(d=h+1,c=p):(d=h,c=p,p=c+1)}else++p}}};function WZ(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function VZ(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function UZ(e,t,n,r,a,i,o,s,l,u){return new BZ(e,t,n,r,a,i,o,s,l,u).compute()}function jZ(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return fC.makeZerosTypedArray(0,r);let a=Math.abs(Math.ceil((t-e)/n)),i=fC.makeZerosTypedArray(a,r);t<e&&1===n&&(n=-1),i[0]=e;for(let o=1;o<i.length;o++)i[o]=i[o-1]+n;return i}var HZ=CQ((e=>1/Math.sqrt(e))),GZ=$Q(lN,HZ),qZ={kernelName:lN,backendName:"cpu",kernelFunc:GZ};function KZ(e,t,n,r,a,i,o,s,l,u){let d=[r/a,a],c=e.values,p=t.values;if(0===r)return D$(n,t.dtype);let h=l instanceof KC?l:D$(d,t.dtype);"string"==typeof l||"number"==typeof l?h.values.fill(l):"boolean"==typeof l&&h.values.fill(+l);for(let f=0;f<i;f++){let e=[],i=0;for(let t=0;t<o;t++){let n=c[f*o+t];e.push(n),i+=n*s[t]}if(i<0||i>=r/a)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<a;n++)u?h.values[i*a+n]+=p[f*a+n]:h.values[i*a+n]=0===t.rank?p[0]:p[f*a+n]}return h}var XZ=CQ((e=>1/(1+Math.exp(-e)))),YZ=TQ(yN,(e=>1/(1+Math.exp(-e)))),QZ={kernelName:yN,backendName:"cpu",kernelFunc:YZ};function ZZ(e,t,n,r,a){let i=iO.isSliceContinous(r,t,n),o=fC.sizeFromShape(n),s=fC.computeStrides(r);if(i){let n=iO.computeFlatOffset(t,s);return"string"===a?e.slice(n,n+o):e.subarray(n,n+o)}let l=D$(r,a,"string"===a?AO.fromUint8ToStringArray(e):e),u=D$(n,a);for(let d=0;d<u.size;++d){let e=u.indexToLoc(d),n=e.map(((e,n)=>e+t[n]));u.set(l.get(...n),...e)}return"string"===a?AO.fromStringArrayToUint8(u.values):u.values}function JZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:i,size:o}=r;ZY(a,"slice");let[s,l]=iO.parseSliceParams(a,i,o);iO.assertParamsValid(a,s,l);let u=ZZ(n.data.get(a.dataId).values,s,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,u)}var eJ={kernelName:fN,backendName:"cpu",kernelFunc:JZ};function tJ(e,t,n,r,a,i,o){let s=t[0],l=i[0],u=new Array(l),d=new Array(s),c=t[1];if(0===l){if(0!==s)throw new Error(AO.getSparseFillEmptyRowsIndicesDenseShapeMismatch(s));return[fC.getArrayFromDType(n,0),[0,c],fC.getArrayFromDType(a,0),u,d]}let p=!0,h=0,f=new Array(l).fill(0);for(let g=0;g<s;++g){let t=e[g*c];if(t<0)throw new Error(AO.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,t));if(t>=l)throw new Error(AO.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,t,l));++f[t],p=p&&t>=h,h=t}let m=!0;for(let g=0;g<l;++g){let e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&p){let t=e,n=r;for(let e=0;e<s;++e)d[e]=e;return[t,[s,c],n,u,d]}{let t=f[l-1],i=fC.getArrayFromDType(n,t*c),p=fC.getArrayFromDType(a,t),h=new Array(l).fill(0);for(let n=0;n<s;++n){let t=e[n*c],a=h[t],o=(0===t?0:f[t-1])+a;h[t]++;for(let r=0;r<c;++r)i[o*c+r]=e[n*c+r];p[o]=r[n],d[n]=o}for(let e=0;e<l;++e)if(0===h[e]){let t=0===e?0:f[e-1];i[t*c+0]=e;for(let e=1;e<c;++e)i[t*c+e]=0;p[t]=o}return[i,[t,c],p,u,d]}}function nJ(e,t,n,r,a){let i=fC.sizeFromShape(r),o=t[0],s=a.length,l=[],u=1,d=-1;for(let m=0;m<s;++m){let e=a[m];if(-1===e){if(-1!==d)throw new Error(AO.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(d,m));d=m,l.push(1)}else{if(e<0)throw new Error(AO.getSparseReshapeNegativeOutputDimErrorMessage(m,e));u*=e,l.push(e)}}if(-1!==d){if(u<=0)throw new Error(AO.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let e=Math.trunc(i/u);if(u*e!==i)throw new Error(AO.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[d]=e}if(fC.sizeFromShape(l)!==i)throw new Error(AO.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let c=r.length,p=[];if(c>0){p[c-1]=1;for(let e=c-2;e>=0;--e)p[e]=p[e+1]*r[e+1]}let h=[];if(s>0){h[s-1]=1;for(let e=s-2;e>=0;--e)h[e]=h[e+1]*l[e+1]}let f=fC.getArrayFromDType(n,o*s);for(let m=0;m<o;++m){let t=0;for(let n=0;n<c;++n)t+=e[m*c+n]*p[n];for(let e=0;e<s;++e)f[m*s+e]=Math.trunc(t/h[e]),t%=h[e]}return[f,[o,s],l]}function rJ(e,t,n,r,a,i=!1,o=0){let s=r.length,l=[t[0],e.length/t[0]],u=l[1],d=s>0?a[s-1]+1:0;if(d<0)throw new Error(AO.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=t.slice();c[0]=d;let p=c.reduce(((e,t)=>e*t),1),h=fC.getArrayFromDType(n,p);if(0===s)return d>0&&h.fill(o),[h,c];if(d<=0)throw new Error(AO.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,b=a[f];for(;;){let t=0;if(m<s){if(t=a[m],b===t){++m;continue}if(b>=t)throw new Error(AO.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=d)throw new Error(AO.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,d));b>g&&h.fill(o,g*u,b*u);for(let n=f;n<m;++n){let t=r[n];if(t<0||t>=l[0])throw new Error(AO.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,r[n],l[0]));for(let n=0;n<u;n++)h[b*u+n]+=e[t*u+n]}if(i)for(let e=0;e<u;e++)h[b*u+e]/=m-f;if(f=m,++m,g=b+1,b=t,m>s)break}return g<d&&h.fill(o,g*u,d*u),[h,c]}var aJ=CQ((e=>Math.sqrt(e))),iJ=TQ(xN,(e=>Math.sqrt(e))),oJ={kernelName:xN,backendName:"cpu",kernelFunc:iJ},sJ=aQ(((e,t)=>{let n=e-t;return n*n})),lJ=mQ(_N,sJ),uJ={kernelName:_N,backendName:"cpu",kernelFunc:lJ},dJ=CQ(((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)})),cJ=$Q(RN,dJ),pJ={kernelName:RN,backendName:"cpu",kernelFunc:cJ};function hJ(e,t,n,r){let a=D$(e,t.dtype);for(let i=0;i<a.size;i++){let e=a.indexToLoc(i),o=new Array(e.length);for(let t=0;t<o.length;t++)o[t]=e[t]*n[t]+r[t];a.set(t.get(...o),...e)}return a}var fJ=class{constructor(e,t,n,r,a,i){this.separator=fC.encodeString(e),this.nGramWidths=t,this.leftPad=fC.encodeString(n),this.rightPad=fC.encodeString(r),this.padWidth=a,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,i){for(let o=0;o<a;++o){let s=this.getPadWidth(i),l=Math.max(0,s-o),u=Math.max(0,s-(a-(o+1))),d=i-(l+u),c=t+(l>0?0:o-s),p=0;p+=l*this.leftPad.length;for(let t=0;t<d;++t)p+=e[c+t].length;p+=u*this.rightPad.length,p+=(l+u+d-1)*this.separator.length,n[r+o]=new Uint8Array(p);let h=n[r+o],f=0,m=e=>e.forEach((e=>h[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<d-1;++t)m(e[c+t]),m(this.separator);if(d>0){m(e[c+d-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}let a=r-1,i=fC.getArrayFromDType("int32",r);if(0===n||0===r){let e=new Array(n);for(let t=0;t<=a;++t)i[t]=0;return[e,i]}i[0]=0;for(let s=1;s<=a;++s){let e=t[s]-t[s-1],n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),i[s]=i[s-1]+n}let o=new Array(i[a]);for(let s=0;s<a;++s){let n=t[s],r=i[s];if(this.nGramWidths.forEach((a=>{let i=t[s+1]-t[s],l=this.getNumNGrams(i,a);this.createNGrams(e,n,o,r,l,a),r+=l})),this.preserveShort&&r===i[s]){let a=t[s+1]-t[s];if(0===a)continue;let i=a+2*this.padWidth,l=1;this.createNGrams(e,n,o,r,l,i)}}return[o,i]}};function mJ(e,t,n,r,a,i,o,s){return new fJ(n,r,a,i,o,s).compute(e,t)}function gJ(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){let a=t[0],i=e.indexOf(a);for(;-1!==i;){let t=e.subarray(0,i);(!n||0!==t.length)&&r.push(t),i=(e=e.subarray(i+1)).indexOf(a)}return void((!n||0!==e.length)&&r.push(e))}let a=0;for(let i=0;i<e.length+1;i++)if(i===e.length||-1!==t.indexOf(e[i])){let t=e.subarray(a,i);(!n||0!==t.length)&&r.push(t),a=i+1}}function bJ(e,t,n){let r=e.length,a=[],i=0,o=0,s=new Array(r);for(let p=0;p<r;++p){let r=a.length;gJ(e[p],t,n,a);let l=a.length-r;s[p]=l,i+=l,o=Math.max(o,l)}let l=fC.getArrayFromDType("int32",2*i),u=new Array(i),d=[r,o],c=0;for(let p=0;p<r;++p)for(let e=0;e<s[p];++e)l[2*c]=p,l[2*c+1]=e,u[c]=a[c],++c;return[l,u,d]}function yJ(e,t){let n=fC.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=fC.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var vJ=aQ(((e,t)=>e-t)),xJ=gQ(((e,t,n,r)=>({real:e-n,imag:t-r}))),wJ=mQ(zN,vJ,xJ),kJ={kernelName:zN,backendName:"cpu",kernelFunc:wJ};function SJ(e,t){let n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];let r=D$(n,e.dtype);for(let a=0;a<r.values.length;++a){let t=r.indexToLoc(a),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];let i=e.locToIndex(n);r.values[a]=e.values[i]}return r}var IJ=(e,t)=>{let n=t.value-e.value;return 0===n?e.index-t.index:n};function NJ(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let a=r-n+1,i=t-n+1,o=Math.log(a),s=.5*Math.exp(2*o/3),l=.5*Math.sqrt(o*s*(a-s)/a)*Math.sign(i-a/2);NJ(e,t,Math.max(n,Math.floor(t-i*s/a+l)),Math.min(r,Math.floor(t+(a-i)*s/a+l)))}let a=e[t],i=n,o=r;for(fC.swap(e,n,t),IJ(e[r],a)>0&&fC.swap(e,n,r);i<o;){for(fC.swap(e,i,o),i++,o--;IJ(e[i],a)<0;)i+=1;for(;IJ(e[o],a)>0;)o-=1}0===IJ(e[n],a)?fC.swap(e,n,o):(o+=1,fC.swap(e,o,r)),o<=t&&(n=o+1),t<=o&&(r=o-1)}}function CJ(e,t,n,r,a){let i=t[t.length-1],[o,s]=[e.length/i,i],l=fC.getTypedArrayFromDType(n,o*r),u=fC.getTypedArrayFromDType("int32",o*r);for(let c=0;c<o;c++){let t=c*s,n=e.subarray(t,t+s),i=new Array(n.length);n.forEach(((e,t)=>i[t]={value:e,index:t})),r<i.length&&(NJ(i,r),i=i.slice(0,r)),a&&i.sort(IJ);let o=c*r,d=l.subarray(o,o+r),p=u.subarray(o,o+r);for(let e=0;e<r;e++)d[e]=i[e].value,p[e]=i[e].index}let d=t.slice();return d[d.length-1]=r,[D$(d,n,l),D$(d,"int32",u)]}function TJ(e,t,n,r){let a=fC.parseAxisParam(t,n)[0],i=[1,n[0],1];for(let f=0;f<a;f++)i[0]*=n[f];i[1]=n[a];for(let f=a+1;f<n.length;f++)i[2]*=n[f];let o=new Map,s=new Int32Array(n[a]),l=new KC(i,r,e),u=[],d=1===i[0]&&1===i[2];for(let f=0;f<n[a];f++){let t;if(d)t=e[f].toString();else{let e=[];for(let t=0;t<i[0];t++)for(let n=0;n<i[2];n++)e.push(l.get(t,f,n));t=e.join(",")}let n=o.get(t);if(null!=n)s[f]=n;else{let e=o.size;o.set(t,e),s[f]=e,u.push(f)}}let c=i.slice();c[1]=o.size;let p=new KC(c,r);u.forEach(((e,t)=>{for(let n=0;n<i[0];n++)for(let r=0;r<i[2];r++)p.set(l.get(n,e,r),n,t,r)}));let h=n.slice();return h[a]=c[1],{outputValues:p.values,outputShape:h,indices:s}}var $J="4.7.0";nE("cpu",(()=>new eQ),1);var EJ=TQ(OS,(e=>e>=0?e:Math.exp(e)-1)),_J={kernelName:OS,backendName:"cpu",kernelFunc:EJ};function AJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:i}=r;ZY([a],"leakyRelu");let o=fC.sizeFromShape(a.shape),s=n.data.get(a.dataId).values,l=fC.getTypedArrayFromDType("float32",o);for(let u=0;u<s.length;u++)l[u]=s[u]<0?i*s[u]:s[u];return n.makeTensorInfo(a.shape,"float32",l)}var RJ={kernelName:iI,backendName:"cpu",kernelFunc:AJ},FJ=aQ(((e,t)=>e<0?t*e:e));function DJ(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;ZY([r,a],"prelu");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,[s,l]=FJ(r.shape,a.shape,i,o,"float32");return n.makeTensorInfo(l,"float32",s)}var MJ={kernelName:HI,backendName:"cpu",kernelFunc:DJ},OJ=TQ(JI,(e=>Math.max(0,e))),zJ={kernelName:JI,backendName:"cpu",kernelFunc:OJ},PJ=TQ(iN,(e=>Math.min(Math.max(0,e),6))),LJ={kernelName:iN,backendName:"cpu",kernelFunc:PJ};function BJ(e,t,n,r,a){if("linear"===n)return lQ({inputs:{x:t},backend:e});if("relu"===n)return OJ({inputs:{x:t},backend:e});if("elu"===n)return EJ({inputs:{x:t},backend:e});if("relu6"===n)return PJ({inputs:{x:t},backend:e});if("prelu"===n)return DJ({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return AJ({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return YZ({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function WJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:i}=r,o=fC.sizeFromShape(a.shape),s=fC.inferFromImplicitShape(i,o),l=fC.sizeFromShape(s);fC.assert(o===l,(()=>`The new shape (${s}) has ${l} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(a.dataId);let u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){let e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=s,t.shape=s}return{dataId:a.dataId,shape:s,dtype:a.dtype}}var VJ={kernelName:eN,backendName:"cpu",kernelFunc:WJ};function UJ(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:i}=t,{transposeA:o,transposeB:s}=r;ZY([a,i],"matMul");let l=a.shape.length,u=i.shape.length,d=o?a.shape[l-2]:a.shape[l-1],c=s?i.shape[u-1]:i.shape[u-2],p=o?a.shape[l-1]:a.shape[l-2],h=s?i.shape[u-2]:i.shape[u-1],f=a.shape.slice(0,-2),m=i.shape.slice(0,-2),g=fC.sizeFromShape(f),b=fC.sizeFromShape(m),y=N_.assertAndGetBroadcastShape(a.shape.slice(0,-2),i.shape.slice(0,-2)).concat([p,h]);fC.assert(d===c,(()=>`Error in matMul: inner shapes (${d}) and (${c}) of Tensors with shapes ${a.shape} and ${i.shape} and transposeA=${o} and transposeB=${s} must match.`));let v=s?[b,h,c]:[b,c,h],x=WJ({inputs:{x:a},backend:n,attrs:{shape:o?[g,d,p]:[g,p,d]}}),w=WJ({inputs:{x:i},backend:n,attrs:{shape:v}}),k=o?x.shape[1]:x.shape[2],S=o?x.shape[2]:x.shape[1],I=s?w.shape[1]:w.shape[2],N=Math.max(g,b),C=n.data.get(x.dataId).values,T=n.data.get(w.dataId).values,$=fC.computeStrides(x.shape),E=fC.computeStrides(w.shape),[_,A,R]=o?[$[0],1,$[1]]:[$[0],$[1],1],[F,D,M]=s?[1,E[1],E[0]]:[E[1],1,E[0]],O=S*I,z=D$([N,S,I],x.dtype),P=z.values,L=n.blockSize;for(let B=0;B<N;B++){let e=B%g,t=B%b;for(let n=0;n<S;n+=L){let r=Math.min(n+L,S);for(let a=0;a<I;a+=L){let i=Math.min(a+L,I);for(let o=0;o<k;o+=L){let s=Math.min(o+L,k);for(let l=n;l<r;l++)for(let n=a;n<i;n++){let r=0;for(let a=o;a<s;a++)r+=C[e*_+l*A+a*R]*T[a*F+n*D+t*M];P[B*O+(l*I+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(y,z.dtype,z.values)}var jJ={kernelName:tS,backendName:"cpu",kernelFunc:UJ},HJ={kernelName:ZN,backendName:"cpu",kernelFunc:function(e){let t,n,r,{inputs:a,backend:i,attrs:o}=e,{a:s,b:l,bias:u,preluActivationWeights:d}=a,{transposeA:c,transposeB:p,activation:h,leakyreluAlpha:f}=o,m=[];t=UJ({inputs:{a:s,b:l},attrs:{transposeA:c,transposeB:p},backend:i}),u&&(n=vQ({inputs:{a:t,b:u},backend:i}),m.push(t),t=n),h&&(r=BJ(i,t,h,d,f),m.push(t),t=r);for(let g of m)i.disposeIntermediateTensorInfo(g);return t}},GJ=TQ(Pk,(e=>Math.acos(e))),qJ={kernelName:Pk,backendName:"cpu",kernelFunc:GJ},KJ=TQ(Lk,(e=>Math.acosh(e))),XJ={kernelName:Lk,backendName:"cpu",kernelFunc:KJ},YJ={kernelName:Wk,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,r=t;ZY(t,"addN");let a=r.map((e=>n.data.get(e.dataId).values)),i=D$(r[0].shape,r[0].dtype),o=i.values;for(let s=0;s<r.length;s++){let e=a[s];for(let t=0;t<o.length;t++)o[t]+=e[t]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}},QJ={kernelName:Vk,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:o}=r;ZY(a,"all");let s=fC.parseAxisParam(i,a.shape),l=s,u=AO.getAxesPermutation(l,a.shape.length),d=a;null!=u&&(d=EZ({inputs:{x:a},backend:n,attrs:{perm:u}}),l=AO.getInnerMostAxes(l.length,a.shape.length)),AO.assertAxesAreInnerMostDims("all",l,d.shape.length);let[c,p]=AO.computeOutAndReduceShapes(d.shape,l),h=fC.sizeFromShape(p),f=fC.makeZerosTypedArray(fC.sizeFromShape(c),d.dtype),m=n.data.get(d.dataId).values;for(let b=0;b<f.length;++b){let e=b*h,t=m[e];for(let n=0;n<h;++n){let r=m[e+n];t=t&&r}f[b]=t}null!=u&&n.disposeIntermediateTensorInfo(d);let g=n.makeTensorInfo(c,d.dtype,f);if(o){let e=WJ({inputs:{x:g},backend:n,attrs:{shape:AO.expandShapeToKeepDim(c,s)}});return n.disposeIntermediateTensorInfo(g),e}return g}},ZJ={kernelName:Uk,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:o}=r;ZY(a,"any");let s=fC.parseAxisParam(i,a.shape),l=s,u=AO.getAxesPermutation(l,a.shape.length),d=a;null!=u&&(d=EZ({inputs:{x:a},backend:n,attrs:{perm:u}}),l=AO.getInnerMostAxes(l.length,a.shape.length)),AO.assertAxesAreInnerMostDims("any",l,d.shape.length);let[c,p]=AO.computeOutAndReduceShapes(d.shape,l),h=fC.sizeFromShape(p),f=fC.makeZerosTypedArray(fC.sizeFromShape(c),d.dtype),m=n.data.get(d.dataId).values;for(let b=0;b<f.length;++b){let e=b*h,t=m[e];for(let n=0;n<h;++n){let r=m[e+n];t=t||r}f[b]=t}null!=u&&n.disposeIntermediateTensorInfo(d);let g=n.makeTensorInfo(c,d.dtype,f);if(o){let e=WJ({inputs:{x:g},backend:n,attrs:{shape:AO.expandShapeToKeepDim(c,s)}});return n.disposeIntermediateTensorInfo(g),e}return g}},JJ={kernelName:jk,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i}=r;ZY(a,"argMax");let o=fC.parseAxisParam(i,a.shape),s=AO.getAxesPermutation(o,a.shape.length),l=a,u=[];null!=s&&(l=EZ({inputs:{x:a},backend:n,attrs:{perm:s}}),u.push(l),o=AO.getInnerMostAxes(o.length,l.shape.length)),o=[o[0]],AO.assertAxesAreInnerMostDims("argMax",o,l.shape.length);let[d,c]=AO.computeOutAndReduceShapes(l.shape,o),p=fC.sizeFromShape(d),h=fC.makeZerosTypedArray(p,"int32"),f=fC.sizeFromShape(c),m=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a>t&&(t=a,n=r)}h[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(d,"int32",h)}},e0={kernelName:Hk,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i}=r;ZY(a,"argMin");let o=fC.parseAxisParam(i,a.shape),s=AO.getAxesPermutation(o,a.shape.length),l=a,u=[];null!=s&&(l=EZ({inputs:{x:a},backend:n,attrs:{perm:s}}),u.push(l),o=AO.getInnerMostAxes(o.length,l.shape.length)),o=[o[0]],AO.assertAxesAreInnerMostDims("argMin",o,l.shape.length);let[d,c]=AO.computeOutAndReduceShapes(l.shape,o),p=fC.sizeFromShape(d),h=fC.makeZerosTypedArray(p,"int32"),f=fC.sizeFromShape(c),m=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a<t&&(t=a,n=r)}h[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(d,"int32",h)}},t0=TQ(Gk,(e=>Math.asin(e))),n0={kernelName:Gk,backendName:"cpu",kernelFunc:t0},r0=TQ(qk,(e=>Math.asinh(e))),a0={kernelName:qk,backendName:"cpu",kernelFunc:r0},i0=TQ(Kk,(e=>Math.atan(e))),o0={kernelName:Kk,backendName:"cpu",kernelFunc:i0},s0=aQ(((e,t)=>Math.atan2(e,t))),l0=mQ(Yk,s0),u0={kernelName:Yk,backendName:"cpu",kernelFunc:l0},d0=TQ(Xk,(e=>Math.atanh(e))),c0={kernelName:Xk,backendName:"cpu",kernelFunc:d0};function p0(e,t,n,r,a,i){let o=a.strideHeight,s=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,d=a.effectiveFilterHeight,c=a.effectiveFilterWidth,p=a.padInfo.top,h=a.padInfo.left,f="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=D$(a.outShape,n),g=m.values,b=a.outShape[1]*a.outShape[2]*a.outShape[3],y=a.outShape[2]*a.outShape[3],v=a.outShape[3];for(let x=0;x<a.batchSize;++x){let t=x*b,n=x*r[0];for(let m=0;m<a.inChannels;++m)for(let b=0;b<a.outHeight;++b){let x=b*o-p,w=Math.max(0,x),k=Math.min(a.inHeight,d+x),S=t+b*y;for(let t=0;t<a.outWidth;++t){let o=t*s-h,d=Math.max(0,o),p=Math.min(a.inWidth,c+o),b=f,y=0,x=0;for(let t=w;t<k;t+=l){let a=n+t*r[1];for(let t=d;t<p;t+=u){let n=e[a+t*r[2]+m];"max"===i&&n>b?b=n:"avg"===i&&(y+=n,x++)}if(isNaN(b))break}g[S+t*v+m]="avg"===i?y/x:b}}}return m}function h0(e,t,n,r,a=!1,i=!1){let o=D$(r.outShape,"int32"),s=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,d=r.dilationWidth,c=r.effectiveFilterHeight,p=r.effectiveFilterWidth,h=r.padInfo.top,f=r.padInfo.left,m=D$(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){let n=t*s-h,b=n;for(;b<0;)b+=u;let y=Math.min(r.inHeight,c+n);for(let s=0;s<r.outWidth;++s){let c=s*l-f,h=c;for(;h<0;)h+=d;let v=Math.min(r.inWidth,p+c),x=Number.NEGATIVE_INFINITY,w=-1;for(let t=b;t<y;t+=u){let o=t-n;for(let n=h;n<v;n+=d){let s=n-c,l=m.get(g,t,n,e);l>x&&(x=l,w=a?i?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:o*p+s)}}o.set(w,g,t,s,e)}}return o}function f0(e,t,n,r,a,i){let o=a.strideDepth,s=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,d=a.dilationHeight,c=a.dilationWidth,p=a.effectiveFilterDepth,h=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,b=a.padInfo.left,y="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=D$(a.outShape,n),x=v.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],S=a.outShape[3]*a.outShape[4],I=a.outShape[4];for(let N=0;N<a.batchSize;++N){let t=N*w,n=N*r[0];for(let v=0;v<a.inChannels;++v)for(let w=0;w<a.outDepth;++w){let N=w*o-m,C=N;for(;C<0;)C+=u;let T=Math.min(a.inDepth,p+N),$=t+w*k;for(let t=0;t<a.outHeight;++t){let o=t*s-g,p=o;for(;p<0;)p+=d;let m=Math.min(a.inHeight,h+o),w=$+t*S;for(let t=0;t<a.outWidth;++t){let o=t*l-b,s=o;for(;s<0;)s+=c;let h=Math.min(a.inWidth,f+o),g=w+t*I,k=y,S=0,N=0;for(let t=C;t<T;t+=u){let a=n+t*r[1];for(let t=p;t<m;t+=d){let n=a+t*r[2];for(let t=s;t<h;t+=c){let a=e[n+t*r[3]+v];if("max"===i&&a>k?k=a:"avg"===i&&(S+=a,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===i?S/Math.max(N,1):k}}}}return v}var m0={kernelName:Qk,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;ZY(a,"avgPool");let{filterSize:i,strides:o,pad:s,dimRoundingMode:l}=r;fC.assert(AO.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));let u,d=AO.computePool2DInfo(a.shape,i,o,1,s,l);if(1===d.filterWidth&&1===d.filterHeight&&fC.arraysEqual(d.inShape,d.outShape))u=lQ({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=fC.computeStrides(a.shape),r=p0(e,a.shape,a.dtype,t,d,"avg");u=n.makeTensorInfo(d.outShape,a.dtype,r.values)}return u}},g0={kernelName:Jk,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:o,pad:s,dimRoundingMode:l,dataFormat:u}=r;ZY(a,"avgPool3d");let d=AO.computePool3DInfo(a.shape,i,o,1,s,l,u),c=f0(n.data.get(a.dataId).values,a.shape,a.dtype,fC.computeStrides(a.shape),d,"avg");return n.makeTensorInfo(c.shape,"float32",c.values)}},b0={kernelName:eS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:o,strides:s,pad:l,dimRoundingMode:u}=r;ZY([a,i],"avgPool3DGrad");let d=AO.computePool3DInfo(i.shape,o,s,1,l,u),c=d.strideDepth,p=d.strideHeight,h=d.strideWidth,f=d.filterDepth,m=d.filterHeight,g=d.filterWidth,b=d.dilationDepth,y=d.dilationHeight,v=d.dilationWidth,x=d.effectiveFilterDepth,w=d.effectiveFilterHeight,k=d.effectiveFilterWidth,S=x-1-d.padInfo.front,I=k-1-d.padInfo.left,N=w-1-d.padInfo.top,C=D$(i.shape,"float32"),T=1/(f*m*g),$=n.bufferSync(a);for(let E=0;E<d.batchSize;++E)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inDepth;++t)for(let n=0;n<d.inHeight;++n)for(let r=0;r<d.inWidth;++r){let a=t-S,i=n-N,o=r-I,s=0;for(let t=0;t<x;t+=b){let n=(a+t)/c;if(!(n<0||n>=d.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=y){let r=(i+t)/p;if(!(r<0||r>=d.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=v){let a=(o+t)/h;a<0||a>=d.outWidth||Math.floor(a)!==a||(s+=$.get(E,n,r,a,e))}}}C.set(s*T,E,t,n,r,e)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}},y0={kernelName:Zk,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,o=i;ZY([a,i],"avgPoolGrad");let{filterSize:s,strides:l,pad:u}=r,d=AO.computePool2DInfo(o.shape,s,l,1,u),c=d.strideHeight,p=d.strideWidth,h=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,b=d.effectiveFilterHeight,y=d.effectiveFilterWidth,v=y-1-d.padInfo.left,x=b-1-d.padInfo.top,w=D$(o.shape,"float32"),k=1/(h*f),S=n.data.get(a.dataId).values,I=D$(a.shape,"float32",S);for(let N=0;N<d.batchSize;++N)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){let r=t-x,a=n-v,i=0;for(let t=0;t<b;t+=m){let n=(r+t)/c;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let t=0;t<y;t+=g){let r=(a+t)/p;r<0||r>=d.outWidth||Math.floor(r)!==r||(i+=I.get(N,n,r,e))}}w.set(i*k,N,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},v0={kernelName:KS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:i,offset:o,mean:s,variance:l}=t;fC.assert(s.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),fC.assert(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),fC.assert(null==i||s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),ZY([a,s,l,i,o],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);let d=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,p=n.data.get(l.dataId).values,h=i?n.data.get(i.dataId).values:new Float32Array([1]),f=o?n.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(d.length),g=f.length,b=h.length,y=p.length,v=c.length,x=0,w=0,k=0,S=0;for(let I=0;I<d.length;++I)m[I]=f[x++]+(d[I]-c[w++])*h[k++]/Math.sqrt(p[S++]+u),x>=g&&(x=0),w>=v&&(w=0),k>=b&&(k=0),S>=y&&(S=0);return n.makeTensorInfo(a.shape,a.dtype,m)}},x0={kernelName:nS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,crops:o}=r;ZY([a],"batchToSpaceND");let s=i.reduce(((e,t)=>e*t)),l=AO.getReshaped(a.shape,i,s),u=AO.getPermuted(l.length,i.length),d=AO.getReshapedPermuted(a.shape,i,s),c=AO.getSliceBeginCoords(o,i.length),p=AO.getSliceSize(d,o,i.length),h=WJ({inputs:{x:a},backend:n,attrs:{shape:l}}),f=EZ({inputs:{x:h},backend:n,attrs:{perm:u}}),m=WJ({inputs:{x:f},backend:n,attrs:{shape:d}}),g=JZ({inputs:{x:m},backend:n,attrs:{begin:c,size:p}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}},w0={kernelName:rS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:i}=t,{size:o}=r,s=wQ(n.data.get(a.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,s)}},k0={kernelName:oS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,s=AO.assertAndGetBroadcastShape(Array.from(i),Array.from(o));return n.makeTensorInfo([s.length],"int32",Int32Array.from(s))}},S0=TQ(uS,((e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),I0={kernelName:uS,backendName:"cpu",kernelFunc:S0},N0={kernelName:cS,backendName:"cpu",kernelFunc:e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(fC.sizeFromShape(t.shape)),a=n.data.get(t.dataId),i=a.complexTensorInfos.real,o=a.complexTensorInfos.imag,s=n.data.get(i.dataId).values,l=n.data.get(o.dataId).values;for(let u=0;u<s.length;u++){let e=s[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")}};function C0(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,i=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,i)}var T0={kernelName:tI,backendName:"cpu",kernelFunc:C0};function $0(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,i=fC.parseAxisParam(a,t[0].shape)[0],o=t.map((e=>e.shape));AO.assertParamsConsistent(o,i);let s=AO.computeOutShape(t.map((e=>e.shape)),i);if(0===fC.sizeFromShape(s))return n.makeTensorInfo(s,t[0].dtype,[]);let l=t.filter((e=>fC.sizeFromShape(e.shape)>0));if(1===l.length)return lQ({inputs:{x:l[0]},backend:n});if("complex64"===l[0].dtype){let e=l.map((e=>dQ({inputs:{input:e},backend:n}))),t=l.map((e=>C0({inputs:{input:e},backend:n}))),r=$0({inputs:e,backend:n,attrs:{axis:i}}),a=$0({inputs:t,backend:n,attrs:{axis:i}}),o=iQ({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),o}let u=l.map((e=>{let t=[-1,fC.sizeFromShape(e.shape.slice(i))];return WJ({inputs:{x:e},backend:n,attrs:{shape:t}})})),d=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));s=AO.computeOutShape(u.map((e=>e.shape)),1);let c=1===u[0].shape[0],p=RQ(d,s,t[0].dtype,c),h=AO.computeOutShape(l.map((e=>e.shape)),i),f=n.makeTensorInfo(h,t[0].dtype,p);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var E0={kernelName:pS,backendName:"cpu",kernelFunc:$0};function _0(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:o,pad:s,dataFormat:l,dilations:u,dimRoundingMode:d}=r;ZY([a,i],"conv2d");let c=AO.convertConv2DDataFormat(l),p=AO.computeConv2DInfo(a.shape,i.shape,o,u,s,d,!1,c),h=p.filterHeight,f=p.filterWidth,m=p.dilationHeight,g=p.dilationWidth,b=p.padInfo.left,y=p.padInfo.top,v="channelsLast"===p.dataFormat,x=new KC(p.outShape,a.dtype),w=fC.computeStrides(a.shape),k=fC.computeStrides(i.shape),S=w[0],I=v?w[1]:w[2],N=v?w[2]:1,C=v?1:w[1],T=x.strides[0],$=v?x.strides[1]:x.strides[2],E=v?x.strides[2]:1,_=v?1:x.strides[1],A=n.data.get(a.dataId).values,R=n.data.get(i.dataId).values,F=x.values;for(let D=0;D<p.batchSize;++D){let e=D*S,t=D*T;for(let n=0;n<p.outHeight;++n){let r=t+n*$,a=n*p.strideHeight-y;for(let t=0;t<h;++t){let n=a+t*m;if(n<0||n>=p.inHeight)continue;let i=t*k[0],o=e+n*I;for(let e=0;e<p.outWidth;++e){let t=r+e*E,n=e*p.strideWidth-b;for(let e=0;e<f;++e){let r=n+e*g;if(r<0||r>=p.inWidth)continue;let a=o+r*N,s=i+e*k[1];for(let e=0;e<p.inChannels;++e){let n=A[a+e*C];for(let e=0;e<p.outChannels;++e)F[t+e*_]+=n*R[s+e];s+=p.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,F)}var A0={kernelName:hS,backendName:"cpu",kernelFunc:_0},R0={kernelName:fS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:o,pad:s,dataFormat:l,dimRoundingMode:u,filterShape:d}=r;ZY([a,i],"conv2dBackpropFilter");let c=AO.convertConv2DDataFormat(l),p=AO.computeConv2DInfo(a.shape,d,o,1,s,u,!1,c),{strideHeight:h,strideWidth:f,filterHeight:m,filterWidth:g}=p,b="channelsLast"===p.dataFormat,y=new KC(p.filterShape,"float32"),v=p.padInfo.left,x=p.padInfo.top,w=n.data.get(a.dataId).values,k=n.data.get(i.dataId).values,S=new KC(a.shape,a.dtype,w),I=new KC(i.shape,i.dtype,k);for(let N=0;N<m;++N){let e=Math.max(0,Math.ceil((x-N)/h)),t=Math.min(p.outHeight,(p.inHeight+x-N)/h);for(let n=0;n<g;++n){let r=Math.max(0,Math.ceil((v-n)/f)),a=Math.min(p.outWidth,(p.inWidth+v-n)/f);for(let i=0;i<p.inChannels;++i)for(let o=0;o<p.outChannels;++o){let s=0;for(let l=0;l<p.batchSize;++l)for(let u=e;u<t;++u){let e=N+u*h-x;for(let t=r;t<a;++t){let r=n+t*f-v;s+=b?S.get(l,e,r,i)*I.get(l,u,t,o):S.get(l,i,e,r)*I.get(l,o,u,t)}}y.set(s,N,n,i,o)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},F0={kernelName:mS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{inputShape:o,strides:s,pad:l,dataFormat:u,dimRoundingMode:d}=r;ZY([a,i],"conv2dBackpropInput");let c=fC.computeStrides(i.shape),p=fC.computeStrides(a.shape),h=AO.convertConv2DDataFormat(u),f=AO.computeConv2DInfo(o,i.shape,s,1,l,d,!1,h),m=new KC(f.inShape,"float32"),g=m.values,b=n.data.get(a.dataId).values,y=n.data.get(i.dataId).values,[v,x,w]=c,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:N,inHeight:C,inWidth:T,outChannels:$,outHeight:E,outWidth:_,strideHeight:A,strideWidth:R}=f;h=f.dataFormat;let F=S-1-f.padInfo.top,D=I-1-f.padInfo.left,M="channelsLast"===h,O=m.strides[0],z=M?m.strides[1]:m.strides[2],P=M?m.strides[2]:1,L=M?1:m.strides[1],B=p[0],W=M?p[1]:p[2],V=M?p[2]:1,U=M?1:p[1];for(let j=0;j<k;++j)for(let e=0;e<N;++e)for(let t=0;t<C;++t){let n=t-F,r=Math.max(0,Math.ceil(n/A)),a=Math.min(E,(S+n)/A);for(let i=0;i<T;++i){let o=i-D,s=Math.max(0,Math.ceil(o/R)),l=Math.min(_,(I+o)/R),u=0;for(let t=r;t<a;++t){let r=t*A-n;for(let n=s;n<l;++n){let a=B*j+W*t+V*n,i=v*(S-1-r)+x*(I-1-(n*R-o))+w*e;for(let e=0;e<$;++e)u+=b[a+U*e]*y[i+e]}}g[O*j+z*t+P*i+L*e]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},D0={kernelName:gS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:o,pad:s,dilations:l}=r;ZY([a,i],"conv3d");let u=AO.computeConv3DInfo(a.shape,i.shape,o,l,s),{filterDepth:d,filterHeight:c,filterWidth:p,dilationDepth:h,dilationHeight:f,dilationWidth:m,padInfo:g}=u,b=g.front,y=g.left,v=g.top,x=new KC(u.outShape,a.dtype),w=n.data.get(a.dataId).values,k=n.data.get(i.dataId).values,S=x.values,I=fC.computeStrides(a.shape),N=fC.computeStrides(i.shape);for(let C=0;C<u.batchSize;++C){let e=C*I[0],t=C*x.strides[0];for(let n=0;n<u.outDepth;++n){let r=t+n*x.strides[1],a=n*u.strideDepth-b;for(let t=0;t<d;++t){let n=a+t*h;if(n<0||n>=u.inDepth)continue;let i=t*N[0],o=e+n*I[1];for(let e=0;e<u.outHeight;++e){let t=r+e*x.strides[2],n=e*u.strideHeight-v;for(let e=0;e<c;++e){let r=n+e*f;if(r<0||r>=u.inHeight)continue;let a=i+e*N[1],s=o+r*I[2];for(let e=0;e<u.outWidth;++e){let n=t+e*u.outChannels,r=e*u.strideWidth-y;for(let e=0;e<p;++e){let t=r+e*m;if(t<0||t>=u.inWidth)continue;let i=a+e*N[2],o=s+t*u.inChannels,l=i;for(let e=0;e<u.inChannels;++e){let t=w[o+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}},M0={kernelName:bS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:o,pad:s,filterShape:l}=r;ZY([a,i],"conv3dBackpropFilterV2");let u=fC.computeStrides(a.shape),d=fC.computeStrides(i.shape),c=AO.computeConv3DInfo(a.shape,l,o,1,s),p=c.strideDepth,h=c.strideHeight,f=c.strideWidth,m=c.filterDepth,g=c.filterHeight,b=c.filterWidth,y=new KC(c.filterShape,"float32"),v=y.values,[x,w,k,S]=y.strides,I=n.data.get(i.dataId).values,[N,C,T,$]=d,E=n.data.get(a.dataId).values,[_,A,R,F]=u,D=c.padInfo.front,M=c.padInfo.left,O=c.padInfo.top;for(let z=0;z<m;++z){let e=Math.max(0,Math.ceil((D-z)/p)),t=Math.min(c.outDepth,(c.inDepth+D-z)/p),n=z*x;for(let r=0;r<g;++r){let a=Math.max(0,Math.ceil((O-r)/h)),i=Math.min(c.outHeight,(c.inHeight+O-r)/h),o=r*w+n;for(let n=0;n<b;++n){let s=Math.max(0,Math.ceil((M-n)/f)),l=Math.min(c.outWidth,(c.inWidth+M-n)/f),u=n*k+o;for(let o=0;o<c.inChannels;++o){let d=o*S+u;for(let u=0;u<c.outChannels;++u){let m=0;for(let d=0;d<c.batchSize;++d){let c=d*_,g=d*N;for(let d=e;d<t;++d){let e=(z+d*p-D)*A+c,t=d*C+g;for(let d=a;d<i;++d){let a=(r+d*h-O)*R+e,i=d*T+t;for(let e=s;e<l;++e){let t=e*$+i;m+=E[(n+e*f-M)*F+a+o]*I[t+u]}}}}v[d+u]=m}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},O0={kernelName:yS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{pad:o,strides:s,inputShape:l}=r;ZY([a],"conv3dBackpropInputV2");let u=fC.computeStrides(a.shape),d=fC.computeStrides(i.shape),c=AO.computeConv3DInfo(l,i.shape,s,1,o),p=new KC(c.inShape,"float32"),h=p.values,[f,m,g,b]=p.strides,y=n.data.get(a.dataId).values,[v,x,w,k]=u,S=n.data.get(i.dataId).values,[I,N,C,T]=d,{batchSize:$,filterDepth:E,filterHeight:_,filterWidth:A,inChannels:R,inDepth:F,inHeight:D,inWidth:M,outChannels:O,outDepth:z,outHeight:P,outWidth:L,strideDepth:B,strideHeight:W,strideWidth:V}=c,U=E-1-c.padInfo.front,j=_-1-c.padInfo.top,H=A-1-c.padInfo.left;for(let G=0;G<$;++G)for(let e=0;e<R;++e)for(let t=0;t<F;++t){let n=t-U,r=Math.max(0,Math.ceil(n/B)),a=Math.min(z,(E+n)/B);for(let i=0;i<D;++i){let o=i-j,s=Math.max(0,Math.ceil(o/W)),l=Math.min(P,(_+o)/W);for(let u=0;u<M;++u){let d=u-H,c=Math.max(0,Math.ceil(d/V)),p=Math.min(L,(A+d)/V),$=0;for(let t=r;t<a;++t){let r=t*B-n;for(let n=s;n<l;++n){let a=n*W-o;for(let i=c;i<p;++i){let o=v*G+x*t+w*n+k*i,s=I*(E-1-r)+N*(_-1-a)+C*(A-1-(i*V-d))+T*e;for(let e=0;e<O;++e)$+=y[o+e]*S[s+e]}}}h[f*G+m*t+g*i+b*u+e]=$}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}},z0=TQ(vS,(e=>Math.cos(e))),P0={kernelName:vS,backendName:"cpu",kernelFunc:z0},L0=TQ(xS,(e=>Math.cosh(e))),B0={kernelName:xS,backendName:"cpu",kernelFunc:L0},W0={kernelName:SS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:i,boxInd:o}=t,{cropSize:s,method:l,extrapolationValue:u}=r,[d,c,p,h]=a.shape,f=i.shape[0],[m,g]=s,b=D$([f,m,g,h],"float32"),y=n.data.get(i.dataId).values,v=n.data.get(o.dataId).values,x=n.data.get(a.dataId).values,w=fC.computeStrides(a.shape),k=fC.computeStrides(b.shape);for(let S=0;S<f;S++){let e=4*S,t=y[e],n=y[e+1],r=y[e+2],a=y[e+3],i=v[S];if(i>=d)continue;let o=m>1?(r-t)*(c-1)/(m-1):0,s=g>1?(a-n)*(p-1)/(g-1):0;for(let d=0;d<m;d++){let e=m>1?t*(c-1)+d*o:.5*(t+r)*(c-1);if(e<0||e>c-1)for(let t=0;t<g;t++)for(let e=0;e<h;e++){let n=e+t*k[2]+d*k[1]+S*k[0];b.values[n]=u}else if("bilinear"===l){let t=Math.floor(e),r=Math.ceil(e),o=e-t;for(let e=0;e<g;e++){let l=g>1?n*(p-1)+e*s:.5*(n+a)*(p-1);if(l<0||l>p-1){for(let t=0;t<h;t++){let n=t+e*k[2]+d*k[1]+S*k[0];b.values[n]=u}continue}let c=Math.floor(l),f=Math.ceil(l),m=l-c;for(let n=0;n<h;n++){let a=n+c*w[2]+t*w[1]+i*w[0],s=x[a];a=n+f*w[2]+t*w[1]+i*w[0];let l=x[a];a=n+c*w[2]+r*w[1]+i*w[0];let u=x[a];a=n+f*w[2]+r*w[1]+i*w[0];let p=s+(l-s)*m,h=u+(x[a]-u)*m;a=n+e*k[2]+d*k[1]+S*k[0],b.values[a]=p+(h-p)*o}}}else for(let t=0;t<g;++t){let r=g>1?n*(p-1)+t*s:.5*(n+a)*(p-1);if(r<0||r>p-1){for(let e=0;e<h;e++){let n=e+t*k[2]+d*k[1]+S*k[0];b.values[n]=u}continue}let o=Math.round(r),l=Math.round(e);for(let e=0;e<h;e++){let n=e+o*w[2]+l*w[1]+i*w[0],r=e+t*k[2]+d*k[1]+S*k[0];b.values[r]=x[n]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},V0={kernelName:wS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:o,reverse:s}=r;ZY(a,"cumprod");let l=AO.getAxesPermutation([i],a.shape.length),u=a;null!=l&&(u=EZ({inputs:{x:a},backend:n,attrs:{perm:l}}));let d=AO.getInnerMostAxes(1,a.shape.length)[0];if(d!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${d}`);let c=sT(u.dtype,"int32"),p=fC.makeOnesTypedArray(fC.sizeFromShape(u.shape),c),h=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=s?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<h.length;b+=f)for(let e=0;e<f;e++){let t=m(b,e);if(0===e)p[t]=o?1:h[t];else{let n=m(b,e-1);p[t]=o?h[n]*p[n]:h[t]*p[n]}}let g=n.makeTensorInfo(u.shape,c,p);if(null!=l){let e=EZ({inputs:{x:g},backend:n,attrs:{perm:AO.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}},U0={kernelName:kS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:o,reverse:s}=r;ZY(a,"cumsum");let l=AO.getAxesPermutation([i],a.shape.length),u=a;null!=l&&(u=EZ({inputs:{x:a},backend:n,attrs:{perm:l}}));let d=AO.getInnerMostAxes(1,a.shape.length)[0];if(d!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${d}`);let c=sT(u.dtype,"int32"),p=fC.makeZerosTypedArray(fC.sizeFromShape(u.shape),c),h=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=s?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<h.length;b+=f)for(let e=0;e<f;e++){let t=m(b,e);if(0===e)p[t]=o?0:h[t];else{let n=m(b,e-1);p[t]=o?h[n]+p[n]:h[t]+p[n]}}let g=n.makeTensorInfo(u.shape,c,p);if(null!=l){let e=EZ({inputs:{x:g},backend:n,attrs:{perm:AO.getUndoAxesPermutation(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}},j0={kernelName:IS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:i}=t,{size:o,binaryOutput:s}=r;if(1===a.shape.length){let e=wQ(n.data.get(a.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,e)}if(2===a.shape.length){let e=kQ(n.bufferSync(a),n.bufferSync(i),o,s);return n.makeTensorInfo(e.shape,i.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}},H0={kernelName:NS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:i,dataFormat:o}=r;fC.assert("NHWC"===o,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`));let s=a.shape[0],l=a.shape[1],u=a.shape[2],d=a.shape[3],c=l*i,p=u*i,h=d/(i*i),f=n.data.get(a.dataId).values,m=new Float32Array(s*c*p*h),g=0;for(let b=0;b<s;++b)for(let e=0;e<c;++e){let t=Math.floor(e/i),n=e%i;for(let e=0;e<p;++e){let r=Math.floor(e/i),a=(n*i+e%i)*h;for(let e=0;e<h;++e){let n=e+a+d*(r+u*(t+l*b));m[g++]=f[n]}}}return n.makeTensorInfo([s,c,p,h],a.dtype,m)}};function G0(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:o,pad:s,dilations:l,dimRoundingMode:u}=r;ZY([a,i],"depthwiseConv2DNative");let d=fC.computeStrides(a.shape),c=fC.computeStrides(i.shape),p=l;null==p&&(p=[1,1]),fC.assert(AO.eitherStridesOrDilationsAreOne(o,p),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`));let h=AO.computeConv2DInfo(a.shape,i.shape,o,p,s,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:b,padInfo:y}=h,v=y.left,x=y.top,w=h.outChannels/h.inChannels,k=new KC(h.outShape,a.dtype),S=n.data.get(a.dataId).values,I=n.data.get(i.dataId).values,N=k.values;for(let C=0;C<h.batchSize;++C){let e=C*d[0],t=C*k.strides[0];for(let n=0;n<h.outHeight;++n){let r=t+n*k.strides[1],a=n*h.strideHeight-x;for(let t=0;t<f;++t){let n=a+t*g;if(n<0||n>=h.inHeight)continue;let i=t*c[0],o=e+n*d[1];for(let e=0;e<h.outWidth;++e){let t=r+e*k.strides[2],n=e*h.strideWidth-v;for(let e=0;e<m;++e){let r=n+e*b;if(r<0||r>=h.inWidth)continue;let a=i+e*c[1],s=o+r*h.inChannels,l=t,u=a;for(let e=0;e<h.inChannels;++e){let t=S[s+e];for(let e=0;e<w;++e)N[l+e]+=t*I[u+e];l+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var q0={kernelName:CS,backendName:"cpu",kernelFunc:G0},K0={kernelName:TS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:o,dilations:s,pad:l,dimRoundingMode:u,filterShape:d}=r;ZY([a,i],"depthwiseConv2dNativeBackpropFilter");let c=AO.computeConv2DInfo(a.shape,d,o,s,l,u,!0),{strideHeight:p,strideWidth:h,filterHeight:f,filterWidth:m}=c,g=new KC(c.filterShape,"float32"),b=c.padInfo.left,y=c.padInfo.top,v=c.outChannels/c.inChannels,x=n.data.get(a.dataId).values,w=new KC(a.shape,a.dtype,x),k=n.data.get(i.dataId).values,S=new KC(i.shape,i.dtype,k);for(let I=0;I<f;++I){let e=Math.max(0,Math.ceil((y-I)/p)),t=Math.min(c.outHeight,(c.inHeight+y-I)/p);for(let n=0;n<m;++n){let r=Math.max(0,Math.ceil((b-n)/h)),a=Math.min(c.outWidth,(c.inWidth+b-n)/h);for(let i=0;i<c.outChannels;++i){let o=Math.trunc(i/v),s=i%v,l=0;for(let u=0;u<c.batchSize;++u)for(let s=e;s<t;++s){let e=I+s*p-y;for(let t=r;t<a;++t){let r=n+t*h-b;l+=w.get(u,e,r,o)*S.get(u,s,t,i)}}g.set(l,I,n,o,s)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},X0={kernelName:$S,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{strides:o,dilations:s,pad:l,dimRoundingMode:u,inputShape:d}=r;ZY([a,i],"depthwiseConv2DNativeBackpropInput");let c=fC.computeStrides(a.shape),p=fC.computeStrides(i.shape),h=AO.computeConv2DInfo(d,i.shape,o,s,l,u,!0),f=new KC(h.inShape,"float32"),m=f.values,[g,b,y]=f.strides,v=n.data.get(a.dataId).values,[x,w,k]=c,S=n.data.get(i.dataId).values,[I,N,C]=p,{batchSize:T,filterHeight:$,filterWidth:E,inChannels:_,inHeight:A,inWidth:R,outChannels:F,outHeight:D,outWidth:M,strideHeight:O,strideWidth:z}=h,P=$-1-h.padInfo.top,L=E-1-h.padInfo.left,B=F/_;for(let W=0;W<T;++W)for(let e=0;e<_;++e)for(let t=0;t<A;++t){let n=t-P,r=Math.max(0,Math.ceil(n/O)),a=Math.min(D,($+n)/O);for(let i=0;i<R;++i){let o=i-L,s=Math.max(0,Math.ceil(o/z)),l=Math.min(M,(E+o)/z),u=0;for(let t=r;t<a;++t){let r=t*O-n;for(let n=s;n<l;++n){let a=x*W+w*t+k*n,i=I*($-1-r)+N*(E-1-(n*z-o))+C*e;for(let t=0;t<B;++t)u+=v[a+(e*B+t)]*S[i+t]}}m[g*W+b*t+y*i+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},Y0={kernelName:ES,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=fC.sizeFromShape(r.shape),i=n.data.get(r.dataId).values,o=D$([a,a],r.dtype),s=o.values;for(let u=0;u<i.length;u++)s[u*a+u]=i[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,o.dtype,o.values)}},Q0={kernelName:_S,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a}=e,{strides:i,pad:o,dilations:s}=n,l=t,u=l.data.get(r.dataId).values,d=r.shape.length,c=l.data.get(a.dataId).values,p=a.shape.length,{batchSize:h,inHeight:f,inWidth:m,inChannels:g,outHeight:b,outWidth:y,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:C}=AO.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",s),T=fC.sizeFromShape(C),$=C.length,E=fC.getArrayFromDType(r.dtype,T);for(let _=0;_<h;++_)for(let e=0;e<b;++e){let t=e*x-v.top;for(let n=0;n<y;++n){let i=n*w-v.left;for(let o=0;o<g;++o){let s=Number.MIN_SAFE_INTEGER;for(let e=0;e<k;++e){let n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){let l=i+t*N;if(l>=0&&l<m){let i=fC.locToIndex([_,n,l,o],d,fC.computeStrides(r.shape)),h=fC.locToIndex([e,t,o],p,fC.computeStrides(a.shape)),f=u[i]+c[h];f>s&&(s=f)}}}E[fC.locToIndex([_,e,n,o],$,fC.computeStrides(C))]=s}}}return{dataId:l.write(fC.toTypedArray(E,r.dtype),C,r.dtype),shape:C,dtype:r.dtype}}},Z0={kernelName:RS,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:i}=e,{strides:o,pad:s,dilations:l}=n,u=t,d=fC.toNestedArray(r.shape,u.data.get(r.dataId).values),c=fC.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:p,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:k,dilationHeight:S,dilationWidth:I,outShape:N}=AO.computeDilation2DInfo(r.shape,a.shape,o,s,"NHWC",l);fC.assert(i.rank===N.length,(()=>`Error in ${RS}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));let C=fC.toNestedArray(N,u.data.get(i.dataId).values),T=fC.makeZerosNestedTypedArray(a.shape,a.dtype);for(let $=0;$<p;++$)for(let e=0;e<g;++e){let t=e*v-y.top;for(let n=0;n<b;++n){let r=n*x-y.left;for(let a=0;a<m;++a){let i=Number.MIN_SAFE_INTEGER,o=0,s=0;for(let e=0;e<w;++e){let n=t+e*S;if(n>=0&&n<h)for(let t=0;t<k;++t){let l=r+t*I;if(l>=0&&l<f){let r=d[$][n][l][a]+c[e][t][a];r>i&&(i=r,o=e,s=t)}}}T[o][s][a]+=C[$][e][n][a]}}}return{dataId:u.write(fC.toTypedArray(T,r.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},J0={kernelName:AS,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:i}=e,{strides:o,pad:s,dilations:l}=n,u=t,d=fC.toNestedArray(r.shape,u.data.get(r.dataId).values),c=fC.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:p,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:b,padInfo:y,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:k,dilationHeight:S,dilationWidth:I,outShape:N}=AO.computeDilation2DInfo(r.shape,a.shape,o,s,"NHWC",l);fC.assert(i.rank===N.length,(()=>`Error in ${AS}, dy must have the same rank as output ${N.length}, but got ${i.rank}`));let C=fC.toNestedArray(N,u.data.get(i.dataId).values),T=fC.makeZerosNestedTypedArray(r.shape,r.dtype);for(let $=0;$<p;++$)for(let e=0;e<g;++e){let t=e*v-y.top;for(let n=0;n<b;++n){let r=n*x-y.left;for(let a=0;a<m;++a){let i=Number.MIN_SAFE_INTEGER,o=t<0?0:t,s=r<0?0:r;for(let e=0;e<w;++e){let n=t+e*S;if(n>=0&&n<h)for(let t=0;t<k;++t){let l=r+t*I;if(l>=0&&l<f){let r=d[$][n][l][a]+c[e][t][a];r>i&&(i=r,o=n,s=l)}}}T[$][o][s][a]+=C[$][e][n][a]}}}return{dataId:u.write(fC.toTypedArray(T,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},e1={kernelName:FS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{canvas:i,options:o}=r,{contextOptions:s,imageOptions:l}=o||{},u=(null==l?void 0:l.alpha)||1,d=(null==s?void 0:s.contextType)||"2d";if("2d"!==d)throw new Error(`Context type ${s.contextType} is not supported by the CPU backend.`);let c=i.getContext(d,(null==s?void 0:s.contextAttributes)||{});if(null==c)throw new Error(`Could not get the context with ${d} type.`);let[p,h]=a.shape.slice(0,2),f=2===a.shape.length?1:a.shape[2],m=n.data.get(a.dataId).values,g="float32"===a.dtype?255:1,b=new Uint8ClampedArray(h*p*4);for(let v=0;v<p*h;++v){let e=[0,0,0,255*u];for(let n=0;n<f;n++){let t=m[v*f+n];if("float32"===a.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===a.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}let t=4*v;b[t+0]=Math.round(e[0]),b[t+1]=Math.round(e[1]),b[t+2]=Math.round(e[2]),b[t+3]=Math.round(e[3])}i.width=h,i.height=p;let y=new ImageData(b,h,p);return c.putImageData(y,0,0),a}};function t1(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i}=n,{axis:o,keepDims:s}=a;ZY(i,"sum"),t="bool"===i.dtype?hQ({inputs:{x:i},backend:r,attrs:{dtype:"int32"}}):lQ({inputs:{x:i},backend:r});let l=t.shape.length,u=fC.parseAxisParam(o,t.shape),d=AO.getAxesPermutation(u,l),c=u,p=t;null!=d&&(p=EZ({inputs:{x:t},backend:r,attrs:{perm:d}}),c=AO.getInnerMostAxes(c.length,l)),AO.assertAxesAreInnerMostDims("sum",c,p.shape.length);let[h,f]=AO.computeOutAndReduceShapes(p.shape,c),m=sQ(r,h,AO.upcastType(p.dtype,"int32")),g=fC.sizeFromShape(f),b=r.data.get(m.dataId).values,y=r.data.get(p.dataId).values;for(let v=0;v<b.length;++v){let e=v*g,t=0;for(let n=0;n<g;++n)t+=y[e+n];b[v]=t}if(s){let e=m;m=WJ({inputs:{x:m},backend:r,attrs:{shape:AO.expandShapeToKeepDim(m.shape,u)}}),r.disposeIntermediateTensorInfo(e)}return r.disposeIntermediateTensorInfo(t),null!=d&&r.disposeIntermediateTensorInfo(p),m}var n1={kernelName:wN,backendName:"cpu",kernelFunc:t1},r1={kernelName:MS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,i=t,{allDims:o,summedDims:s,idDims:l}=AO.decodeEinsumEquation(a,i.length);AO.checkEinsumDimSizes(o.length,l,i);let{path:u,steps:d}=AO.getEinsumComputePath(s,l),c=d.length,p=null,h=o.length,f=[];for(let m=0;m<c;++m){for(let e of d[m]){let t,{permutationIndices:r,expandDims:a}=AO.getEinsumPermutation(h,l[e]);AO.isIdentityPermutation(r)?t=i[e]:(t=EZ({inputs:{x:i[e]},backend:n,attrs:{perm:r}}),f.push(t));let o=t.shape.slice();for(let e=0;e<a.length;++e)o.splice(a[e],0,1);fC.arraysEqual(t.shape,o)||(t=WJ({inputs:{x:t},backend:n,attrs:{shape:o}}),f.push(t)),null===p?p=t:(p=wZ({inputs:{a:t,b:p},backend:n}),f.push(p))}m<c-1&&(u[m]>=0&&(p=t1({inputs:{x:p},backend:n,attrs:{axis:u[m]-(o.length-h),keepDims:!1}}),f.push(p)),h--)}for(let m of f)m!==p&&n.disposeIntermediateTensorInfo(m);return p}},a1={kernelName:zS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;ZY([r,a],"eluGrad");let i=new Float32Array(fC.sizeFromShape(a.shape)),o=n.data.get(a.dataId).values,s=n.data.get(r.dataId).values;for(let l=0;l<o.length;++l){let e=o[l];i[l]=e>=0?s[l]:s[l]*(e+1)}return n.makeTensorInfo(a.shape,"float32",i)}},i1=AO.ERF_P,o1=AO.ERF_A1,s1=AO.ERF_A2,l1=AO.ERF_A3,u1=AO.ERF_A4,d1=AO.ERF_A5,c1=TQ(PS,(e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+i1*n);return t*(1-((((d1*r+u1)*r+l1)*r+s1)*r+o1)*r*Math.exp(-n*n))})),p1={kernelName:PS,backendName:"cpu",kernelFunc:c1};function h1(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:i}=r,o=a.shape.length,s=a.shape.slice(),l=i;return i<0&&(fC.assert(-(o+1)<=i,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+i+1),s.splice(l,0,1),WJ({inputs:{x:a},backend:n,attrs:{shape:s}})}var f1={kernelName:WS,backendName:"cpu",kernelFunc:h1},m1=aQ(((e,t)=>e/t)),g1=mQ(DS,m1),b1={kernelName:DS,backendName:"cpu",kernelFunc:g1};function y1(e,t,n){let r=e.shape,a=r[0],i=r[1],o=n.data.get(e.dataId),s=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,u=[a,i],d=fC.sizeFromShape(u),c=fC.getTypedArrayFromDType("float32",d),p=fC.getTypedArrayFromDType("float32",d);for(let g=0;g<a;g++){let e=JZ({inputs:{x:s},backend:n,attrs:{begin:[g,0],size:[1,i]}}),r=JZ({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,i]}}),a=iQ({inputs:{real:e,imag:r},backend:n}),{real:o,imag:u}=v1(a,t,n),d=AO.mergeRealAndImagArrays(o,u);for(let t=0;t<i;t++){let e=AO.getComplexWithIndex(d,t);c[g*i+t]=e.real,p[g*i+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}let h=n.makeTensorInfo(u,"float32",c),f=n.makeTensorInfo(u,"float32",p),m=iQ({inputs:{real:h,imag:f},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}function v1(e,t,n){let r=fC.sizeFromShape(e.shape),a=n.data.get(e.dataId),i=n.data.get(a.complexTensorInfos.real.dataId).values,o=n.data.get(a.complexTensorInfos.imag.dataId).values;if(function(e){return 0==(e&e-1)}(r)){let a=x1(i,o,r,t,n),s=[e.shape[0],e.shape[1]];if(t){let e=n.makeTensorInfo(s,"float32",a.real),t=n.makeTensorInfo(s,"float32",a.imag),i=n.makeTensorInfo([],"float32",fC.createScalarValue(r,"float32")),o=lQ({inputs:{x:i},backend:n}),l=b1.kernelFunc({inputs:{a:e,b:i},backend:n}),u=b1.kernelFunc({inputs:{a:t,b:o},backend:n}),d=n.data.get(l.dataId).values,c=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:d,imag:c}}return a}{let e=function(e,t,n){let r=new Float32Array(2*t);for(let a=0;a<t;a++){let i=0,o=0;for(let r=0;r<t;r++){let s=AO.exponent(a*r,t,n),l=AO.getComplexWithIndex(e,r);i+=l.real*s.real-l.imag*s.imag,o+=l.real*s.imag+l.imag*s.real}n&&(i/=t,o/=t),AO.assignToTypedArray(r,i,o,a)}return r}(AO.mergeRealAndImagArrays(i,o),r,t);return AO.splitRealAndImagArrays(e)}}function x1(e,t,n,r,a){if(1===n)return{real:e,imag:t};let i=AO.mergeRealAndImagArrays(e,t),o=n/2,s=AO.complexWithEvenIndex(i),l=s.real,u=s.imag,d=[l.length],c=a.makeTensorInfo(d,"float32",l),p=a.makeTensorInfo(d,"float32",u),h=iQ({inputs:{real:c,imag:p},backend:a}),f=AO.complexWithOddIndex(i),m=f.real,g=f.imag,b=[m.length],y=a.makeTensorInfo(b,"float32",m),v=a.makeTensorInfo(b,"float32",g),x=iQ({inputs:{real:y,imag:v},backend:a}),w=x1(l,u,o,r,a),k=w.real,S=w.imag,I=[k.length],N=a.makeTensorInfo(I,"float32",k),C=a.makeTensorInfo(I,"float32",S),T=iQ({inputs:{real:N,imag:C},backend:a}),$=x1(m,g,o,r,a),E=$.real,_=$.imag,A=[E.length],R=a.makeTensorInfo(A,"float32",E),F=a.makeTensorInfo(A,"float32",_),D=iQ({inputs:{real:R,imag:F},backend:a}),M=AO.exponents(n,r),O=[M.real.length],z=a.makeTensorInfo(O,"float32",M.real),P=a.makeTensorInfo(O,"float32",M.imag),L=iQ({inputs:{real:z,imag:P},backend:a}),B=wZ({inputs:{a:L,b:D},backend:a}),W=vQ({inputs:{a:T,b:B},backend:a}),V=wJ({inputs:{a:T,b:B},backend:a}),U=dQ({inputs:{input:W},backend:a}),j=dQ({inputs:{input:V},backend:a}),H=C0({inputs:{input:W},backend:a}),G=C0({inputs:{input:V},backend:a}),q=$0({inputs:[U,j],backend:a,attrs:{axis:0}}),K=$0({inputs:[H,G],backend:a,attrs:{axis:0}}),X=a.data.get(q.dataId).values,Y=a.data.get(K.dataId).values;return a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(y),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(C),a.disposeIntermediateTensorInfo(T),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(F),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(L),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}var w1={kernelName:US,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t,a=fC.sizeFromShape(r.shape),i=r.shape[r.shape.length-1],o=WJ({inputs:{x:r},backend:n,attrs:{shape:[a/i,i]}}),s=y1(o,!1,n),l=WJ({inputs:{x:s},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(s),l}};function k1(e){let{backend:t,attrs:n}=e,{shape:r,value:a,dtype:i}=n,o=i||fC.inferDtype(a),s=fC.getArrayFromDType(o,fC.sizeFromShape(r));return function(e,t,n){e.fill(t)}(s,a),t.makeTensorInfo(r,o,s)}var S1={kernelName:jS,backendName:"cpu",kernelFunc:k1},I1={kernelName:HS,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,a=n,i=fC.getTypedArrayFromDType(r.dtype,fC.sizeFromShape(r.shape)),[o,s,l,u]=r.shape,d=a.data.get(r.dataId).values;for(let c=0;c<o;c++){let e=c*l*s*u;for(let t=0;t<s;t++){let n=t*(l*u);for(let t=0;t<l;t++){let r=t*u;for(let a=0;a<u;a++){let o=Math.round(l-t-1),s=e+n+r+a,c=d[s];o>=0&&o<l&&(c=d[e+n+o*u+a]),i[s]=c}}}}return{dataId:a.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},N1={kernelName:JN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,bias:o,preluActivationWeights:s}=t,{strides:l,pad:u,dataFormat:d,dilations:c,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=r,m=_0({inputs:{x:a,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:d,dilations:c,dimRoundingMode:p}});if(o){let e=m;if("NCHW"===d&&1===o.shape.length&&1!==o.shape[0]){let e=WJ({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=vQ({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=vQ({inputs:{a:m,b:o},backend:n});n.disposeIntermediateTensorInfo(e)}if(h){let e=m;if("NCHW"===d&&"prelu"===h&&1===s.shape.length&&1!==s.shape[0]){let e=WJ({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}});m=BJ(n,m,h,e,f),n.disposeIntermediateTensorInfo(e)}else m=BJ(n,m,h,s,f);n.disposeIntermediateTensorInfo(e)}return m}},C1={kernelName:eC,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,bias:o,preluActivationWeights:s}=t,{strides:l,pad:u,dataFormat:d,dilations:c,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=r,m=G0({inputs:{x:a,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:d,dilations:c,dimRoundingMode:p}});if(o){let e=m;m=vQ({inputs:{a:m,b:o},backend:n}),n.disposeIntermediateTensorInfo(e)}if(h){let e=m;m=BJ(n,m,h,s,f),n.disposeIntermediateTensorInfo(e)}return m}},T1={kernelName:YS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,i=fC.sizeFromShape(r.shape),o=a.shape,s=o[o.length-1],[l,u,d,c]=AO.prepareAndValidate(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);let p=KQ(n.data.get(a.dataId).values,n.bufferSync(r),r.dtype,u,s,d,c,r.shape,i);return n.makeTensorInfo(l,r.dtype,p.values)}},$1={kernelName:XS,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:i}=t,{axis:o,batchDims:s}=r;ZY([a,i],"gatherV2");let l=fC.parseAxisParam(o,a.shape)[0],u=n.data.get(i.dataId).values,d=a.shape[l];for(let v=0;v<u.length;++v){let e=u[v];fC.assert(e<=d-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${d-1}]`))}let c=s;null==s&&(c=0);let p=fC.sizeFromShape(i.shape),h=AO.segment_util.collectGatherOpShapeInfo(a,i,l,c),f=WJ({inputs:{x:a},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),m=WJ({inputs:{x:i},backend:n,attrs:{shape:[h.batchSize,p/h.batchSize]}}),g=[h.batchSize,h.outerSize,p/h.batchSize,h.sliceSize],b=n.bufferSync(m),y=XQ(n.bufferSync(f),b,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(h.outputShape,y.dtype,y.values)}},E1={kernelName:eI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t,a=fC.sizeFromShape(r.shape),i=r.shape[r.shape.length-1],o=WJ({inputs:{x:r},backend:n,attrs:{shape:[a/i,i]}}),s=y1(o,!0,n),l=WJ({inputs:{x:s},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(s),l}},_1=TQ(nI,(e=>Number.isFinite(e)?1:0),"bool"),A1={kernelName:nI,backendName:"cpu",kernelFunc:_1},R1=TQ(rI,(e=>Math.abs(e)===1/0?1:0),"bool"),F1={kernelName:rI,backendName:"cpu",kernelFunc:R1},D1=TQ(aI,(e=>Number.isNaN(e)?1:0),"bool"),M1={kernelName:aI,backendName:"cpu",kernelFunc:D1},O1={kernelName:lI,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:i}=n,o=lZ(r,a,i);return t.makeTensorInfo([o.length],"float32",o)}},z1=TQ(dI,(e=>Math.log1p(e))),P1={kernelName:dI,backendName:"cpu",kernelFunc:z1},L1=aQ(((e,t)=>e&&t)),B1=mQ(cI,L1,null,"bool"),W1={kernelName:cI,backendName:"cpu",kernelFunc:B1},V1=TQ(pI,(e=>e?0:1),"bool"),U1={kernelName:pI,backendName:"cpu",kernelFunc:V1},j1=aQ(((e,t)=>e||t)),H1=mQ(hI,j1,null,"bool"),G1={kernelName:hI,backendName:"cpu",kernelFunc:H1},q1={kernelName:bI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:i,bias:o,alpha:s,beta:l}=r;ZY(a,"LRN");let u=a.shape[3],d=u-1,c=n.data.get(a.dataId).values,p=fC.sizeFromShape(a.shape),h=new Float32Array(p);function f(e){let t=e%u,n=e-t+Math.max(0,t-i),r=e-t+Math.min(t+i,d),a=0;for(;n<=r;n++){let e=c[n];a+=e*e}return a}for(let m=0;m<p;m++){let e=f(m),t=c[m]*Math.pow(o+s*e,-l);h[m]=t}return n.makeTensorInfo(a.shape,a.dtype,h)}},K1={kernelName:yI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:i,dy:o}=t,{depthRadius:s,bias:l,alpha:u,beta:d}=r;ZY(o,"LRNGrad");let c=fC.sizeFromShape(o.shape),p=o.shape[3],h=n.data.get(o.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(i.dataId).values,g=new Float32Array(c),b=c;for(let y=0;y<b;y++){let e=y%p,t=y-e+Math.max(0,e-s),n=y-e+Math.min(p,e+s+1),r=0;for(let a=t;a<n;a++)r+=Math.pow(f[a],2);r=u*r+l;for(let a=t;a<n;a++){let e=-2*u*d*f[a]*m[y]/r;y===a&&(e+=Math.pow(r,-d)),e*=h[y],g[a]+=e}}return n.makeTensorInfo(o.shape,a.dtype,g)}};function X1(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:i,keepDims:o}=r,s=n,l=a.shape,u=l.length,d=fC.parseAxisParam(i,l),c=d,p=AO.getAxesPermutation(c,u),h=s.data.get(a.dataId).values;if(null!=p){let e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[p[t]];h=$Z(h,l,a.dtype,p,e),c=AO.getInnerMostAxes(c.length,u),l=e}ZY(a,"max"),AO.assertAxesAreInnerMostDims("max",c,u);let[f,m]=AO.computeOutAndReduceShapes(l,c),g=pZ(h,fC.sizeFromShape(m),f,a.dtype),b=s.write(g,f,a.dtype),y=f;return o&&(y=AO.expandShapeToKeepDim(f,d)),{dataId:b,shape:y,dtype:a.dtype}}var Y1={kernelName:xI,backendName:"cpu",kernelFunc:X1},Q1={kernelName:kI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;ZY(a,"maxPool");let{filterSize:i,strides:o,pad:s,dimRoundingMode:l}=r;fC.assert(AO.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));let u,d=AO.computePool2DInfo(a.shape,i,o,1,s,l);if(1===d.filterWidth&&1===d.filterHeight&&fC.arraysEqual(d.inShape,d.outShape))u=lQ({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=fC.computeStrides(a.shape),r=p0(e,a.shape,a.dtype,t,d,"max");u=n.makeTensorInfo(d.outShape,a.dtype,r.values)}return u}},Z1={kernelName:II,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:o,pad:s,dimRoundingMode:l,dataFormat:u}=r;ZY(a,"maxPool3d");let d=AO.computePool3DInfo(a.shape,i,o,1,s,l,u),c=f0(n.data.get(a.dataId).values,a.shape,a.dtype,fC.computeStrides(a.shape),d,"max");return n.makeTensorInfo(c.shape,"float32",c.values)}},J1={kernelName:NI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:o,strides:s,pad:l,dimRoundingMode:u}=r;ZY([a,i],"maxPool3DGrad");let d=AO.computePool3DInfo(i.shape,o,s,1,l,u),c=function(e,t){let n=D$(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,i=t.strideWidth,o=t.dilationDepth,s=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,d=t.effectiveFilterHeight,c=t.effectiveFilterWidth,p=t.padInfo.front,h=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){let y=b*r-p,v=y;for(;v<0;)v+=o;let x=Math.min(t.inDepth,u+y);for(let r=0;r<t.outHeight;++r){let u=r*a-h,p=u;for(;p<0;)p+=s;let w=Math.min(t.inHeight,d+u);for(let a=0;a<t.outWidth;++a){let h=a*i-f,k=h;for(;k<0;)k+=l;let S=Math.min(t.inWidth,c+h),I=Number.NEGATIVE_INFINITY,N=-1;for(let t=v;t<x;t+=o){let n=t-y;for(let r=p;r<w;r+=s){let a=r-u;for(let i=k;i<S;i+=l){let o=i-h,s=e.get(m,t,r,i,g);s>=I&&(I=s,N=n*d*c+a*d+o)}}}n.set(N,m,b,r,a,g)}}}return n}(n.bufferSync(i),d),p=d.strideDepth,h=d.strideHeight,f=d.strideWidth,m=d.dilationDepth,g=d.dilationHeight,b=d.dilationWidth,y=d.effectiveFilterDepth,v=d.effectiveFilterHeight,x=d.effectiveFilterWidth,w=y-1-d.padInfo.front,k=x-1-d.padInfo.left,S=v-1-d.padInfo.top,I=D$(i.shape,"float32"),N=n.bufferSync(a);for(let C=0;C<d.batchSize;++C)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inDepth;++t)for(let n=0;n<d.inHeight;++n)for(let r=0;r<d.inWidth;++r){let a=t-w,i=n-S,o=r-k,s=0;for(let t=0;t<y;t+=m){let n=(a+t)/p;if(!(n<0||n>=d.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=g){let a=(i+r)/h;if(!(a<0||a>=d.outHeight||Math.floor(a)!==a))for(let i=0;i<x;i+=b){let l=(o+i)/f;if(l<0||l>=d.outWidth||Math.floor(l)!==l)continue;let u=y*v*x-1-c.get(C,n,a,l,e)===t*v*x+r*x+i?1:0;0!==u&&(s+=N.get(C,n,a,l,e)*u)}}}I.set(s,C,t,n,r,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}},e2={kernelName:SI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i,output:o}=t,s=i;ZY([i,o],"maxPoolGrad");let{filterSize:l,strides:u,pad:d,dimRoundingMode:c}=r,p=AO.computePool2DInfo(s.shape,l,u,1,d,c),h=n.data.get(s.dataId).values,f=D$(p.outShape,s.dtype,h0(h,s.shape,s.dtype,p).values),m=p.strideHeight,g=p.strideWidth,b=p.dilationHeight,y=p.dilationWidth,v=p.effectiveFilterHeight,x=p.effectiveFilterWidth,w=x-1-p.padInfo.left,k=v-1-p.padInfo.top,S=D$(s.shape,"float32"),I=n.data.get(a.dataId).values,N=D$(a.shape,"float32",I);for(let C=0;C<p.batchSize;++C)for(let e=0;e<p.inChannels;++e)for(let t=0;t<p.inHeight;++t)for(let n=0;n<p.inWidth;++n){let r=t-k,a=n-w,i=0;for(let t=0;t<v;t+=b){let n=(r+t)/m;if(!(n<0||n>=p.outHeight||Math.floor(n)!==n))for(let r=0;r<x;r+=y){let o=(a+r)/g;if(o<0||o>=p.outWidth||Math.floor(o)!==o)continue;let s=v*x-1-f.get(C,n,o,e)===t*x+r?1:0;0!==s&&(i+=N.get(C,n,o,e)*s)}}S.set(i,C,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}},t2={kernelName:CI,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:i,pad:o,includeBatchInIndex:s}=t,l=n;ZY(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,d=AO.computePool2DInfo(r.shape,a,i,[1,1],o),[c,p]=function(e,t,n,r,a){let i=p0(e,0,n,fC.computeStrides(t),a,"max"),o=h0(e,t,n,a,!0,r);return[i.values,o.values]}(u,r.shape,r.dtype,s,d),h=l.write(c,d.outShape,r.dtype),f=l.write(p,d.outShape,r.dtype);return[{dataId:h,shape:d.outShape,dtype:r.dtype},{dataId:f,shape:d.outShape,dtype:"int32"}]}},n2={kernelName:TI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:o}=r,s=fC.parseAxisParam(i,a.shape),l=AO.computeOutAndReduceShapes(a.shape,s)[1],u=fC.sizeFromShape(l),d=[],c=n.makeTensorInfo([],"float32",new Float32Array([u]));d.push(c);let p=hQ({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});d.push(p);let h=g1({inputs:{a:p,b:c},backend:n});d.push(h);let f=t1({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:o}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}},r2={kernelName:$I,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:o}=r;ZY(a,"min");let s=fC.parseAxisParam(i,a.shape),l=s,u=AO.getAxesPermutation(l,a.shape.length),d=a;null!=u&&(d=EZ({inputs:{x:a},backend:n,attrs:{perm:u}}),l=AO.getInnerMostAxes(l.length,a.shape.length)),AO.assertAxesAreInnerMostDims("min",l,d.shape.length);let[c,p]=AO.computeOutAndReduceShapes(d.shape,l),h=fC.sizeFromShape(p),f=fC.makeZerosTypedArray(fC.sizeFromShape(c),d.dtype),m=n.data.get(d.dataId).values;for(let b=0;b<f.length;++b){let e=b*h,t=m[e];for(let n=0;n<h;++n){let r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[b]=t}null!=u&&n.disposeIntermediateTensorInfo(d);let g=n.makeTensorInfo(c,d.dtype,f);if(o){let e=WJ({inputs:{x:g},backend:n,attrs:{shape:AO.expandShapeToKeepDim(c,s)}});return n.disposeIntermediateTensorInfo(g),e}return g}},a2={kernelName:_I,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:i,mode:o}=r;ZY(a,"mirrorPad");let s=i.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=i.map((e=>e[0])),u=i.map(((e,t)=>e[0]+a.shape[t])),d="reflect"===o?0:1,c=n.data.get(a.dataId).values,p=a.shape.length,h=fC.computeStrides(a.shape),f=fC.sizeFromShape(s),m=s.length,g=fC.computeStrides(s),b=fC.getTypedArrayFromDType(a.dtype,f);for(let y=0;y<f;y++){let e=fC.indexToLoc(y,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-d:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+d);e=e.map(((e,t)=>e-l[t]));let t=fC.locToIndex(e,p,h);b[y]=c[t]}return{dataId:n.write(b,s,a.dtype),shape:s,dtype:a.dtype}}},i2=aQ(((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),o2=mQ(AI,i2),s2={kernelName:AI,backendName:"cpu",kernelFunc:o2},l2=dw(kw());function u2(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:i}=r,o=a.shape.length,s=i;if(-1===s&&(s=o-1),s!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${s}`);let l=fC.parseAxisParam([s],a.shape),u=X1({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),d=AO.expandShapeToKeepDim(u.shape,l),c=WJ({inputs:{x:u},backend:n,attrs:{shape:d}}),p=wJ({inputs:{a:a,b:c},backend:n}),h=zQ({inputs:{x:p},backend:n}),f=t1({inputs:{x:h},backend:n,attrs:{axis:l,keepDims:!1}}),m=WJ({inputs:{x:f},backend:n,attrs:{shape:d}}),g=g1({inputs:{a:h,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var d2={kernelName:IN,backendName:"cpu",kernelFunc:u2},c2={kernelName:RI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:i,seed:o,normalized:s}=r;ZY(a,"multinomial");let l=s?a:u2({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],d=l.shape[1],c=n.data.get(l.dataId).values,p=[u,i],h=fC.makeZerosTypedArray(fC.sizeFromShape(p),"int32");for(let f=0;f<u;++f){let e=f*d,t=new Float32Array(d-1);t[0]=c[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+c[e+a];let n=l2.alea(o.toString()),r=f*i;for(let a=0;a<i;++a){let e=n();h[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){h[r+a]=n;break}}}return s||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(p,"int32",h)}},p2=zz.nonMaxSuppressionV3Impl,h2={kernelName:OI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:o,iouThreshold:s,scoreThreshold:l}=r;ZY(a,"NonMaxSuppression");let u=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,{selectedIndices:c}=p2(u,d,o,s,l);return n.makeTensorInfo([c.length],"int32",new Int32Array(c))}},f2=zz.nonMaxSuppressionV4Impl,m2={kernelName:zI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:o,iouThreshold:s,scoreThreshold:l,padToMaxOutputSize:u}=r;ZY(a,"NonMaxSuppressionPadded");let d=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,{selectedIndices:p,validOutputs:h}=f2(d,c,o,s,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}},g2=zz.nonMaxSuppressionV5Impl,b2={kernelName:PI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:o,iouThreshold:s,scoreThreshold:l,softNmsSigma:u}=r;ZY(a,"NonMaxSuppressionWithScore");let d=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,p=o,h=s,f=l,m=u,{selectedIndices:g,selectedScores:b}=g2(d,c,p,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},y2={kernelName:BI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:i,depth:o,onValue:s,offValue:l}=r;ZY(a,"oneHot");let u=fC.sizeFromShape(a.shape),d=new Float32Array(u*o);d.fill(l);let c=n.data.get(a.dataId).values;for(let p=0;p<u;++p)c[p]>=0&&c[p]<o&&(d[p*o+c[p]]=s);return n.makeTensorInfo([...a.shape,o],i,d)}};function v2(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){let e=dQ({inputs:{input:r},backend:n}),t=v2({inputs:{x:e},backend:n}),a=C0({inputs:{input:r},backend:n}),i=v2({inputs:{x:a},backend:n}),o=iQ({inputs:{real:t,imag:i},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),o}return k1({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var x2={kernelName:KN,backendName:"cpu",kernelFunc:v2},w2={kernelName:LI,backendName:"cpu",kernelFunc:function e(t){let{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===a.dtype){let t=dQ({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),i=C0({inputs:{input:a},backend:r}),o=v2({inputs:{x:i},backend:r}),s=iQ({inputs:{real:n,imag:o},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),s}return k1({backend:r,attrs:{shape:a.shape,value:1,dtype:a.dtype}})}};function k2(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return h1({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let i=t[0].shape,o=t[0].dtype;t.forEach((e=>{fC.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),fC.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let s=[],l=t.map((e=>{let t=h1({inputs:{input:e},backend:n,attrs:{dim:a}});return s.push(t),t})),u=$0({inputs:l,backend:n,attrs:{axis:a}});return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}var S2={kernelName:WI,backendName:"cpu",kernelFunc:k2},I2={kernelName:VI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:i,constantValue:o}=r;ZY(a,"pad");let s=i.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=i.map((e=>e[0])),u=n.data.get(a.dataId).values,d=fC.sizeFromShape(a.shape),c=a.shape.length,p=fC.computeStrides(a.shape),h=fC.sizeFromShape(s),f=s.length,m=fC.computeStrides(s),g=fC.getTypedArrayFromDType(a.dtype,h);0!==o&&g.fill(o);for(let b=0;b<d;b++){let e=fC.indexToLoc(b,c,p).map(((e,t)=>e+l[t]));g[fC.locToIndex(e,f,m)]=u[b]}return{dataId:n.write(g,s,a.dtype),shape:s,dtype:a.dtype}}},N2=aQ(((e,t)=>Math.pow(e,t))),C2=mQ(jI,N2),T2={kernelName:jI,backendName:"cpu",kernelFunc:C2},$2={kernelName:qI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:i,indices:o}=t,s=a.map((e=>n.data.get(e.dataId).values)),l=a.map((e=>e.shape)),u=n.data.get(i.dataId).values,d=n.data.get(o.dataId).values,[c,p,h]=OZ(s,l,u,i.shape,i.dtype,d,o.shape),f=c.map((e=>n.makeTensorInfo([e.length],"int32",e))),m=n.makeTensorInfo(h,i.dtype,p);return f.concat([m])}},E2={kernelName:KI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:i}=t,o=n.data.get(r.dataId).values,s=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values,[u,d]=PZ(o,r.shape,r.dtype,s,a.shape,l,i.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([d.length],r.dtype,d)]}},_2={kernelName:XI,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:i,defaultValue:o,rowPartitionTensors:s}=t,{rowPartitionTypes:l}=r,u=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,c=n.data.get(o.dataId).values,p=s.map((e=>n.data.get(e.dataId).values)),h=s.map((e=>e.shape)),[f,m]=UZ(u,a.shape,d,i.shape,i.dtype,c,o.shape,p,h,l);return n.makeTensorInfo(f,i.dtype,m)}},A2={kernelName:YI,backendName:"cpu",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:i,step:o}=n,s=jZ(r,a,o,i);return t.makeTensorInfo([s.length],i,s)}},R2=TQ(ZI,(e=>1/e)),F2={kernelName:ZI,backendName:"cpu",kernelFunc:R2},D2={kernelName:rN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:i,halfPixelCenters:o,size:s}=r;ZY(a,"resizeBilinear");let l=fC.computeStrides(a.shape),[u,d]=s,[c,p,h,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(fC.sizeFromShape([c,u,d,f])),b=[i&&u>1?p-1:p,i&&d>1?h-1:h],y=[i&&u>1?u-1:u,i&&d>1?d-1:d],v=0,x=b[0]/y[0],w=b[1]/y[1];for(let k=0;k<c;k++)for(let e=0;e<u;e++){let t;t=o?x*(e+.5)-.5:x*e;let n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(p-1,Math.ceil(t)),i=k*l[0]+n*l[1],s=k*l[0]+a*l[1];for(let e=0;e<d;e++){let t;t=o?w*(e+.5)-.5:w*e;let n=Math.max(0,Math.floor(t)),a=t-n,u=Math.min(h-1,Math.ceil(t)),d=i+n*l[2],c=s+n*l[2],p=i+u*l[2],b=s+u*l[2];for(let e=0;e<f;e++){let t=m[d+e],n=m[c+e],i=t+(m[p+e]-t)*a,o=i+(n+(m[b+e]-n)*a-i)*r;g[v++]=o}}}return n.makeTensorInfo([c,u,d,f],"float32",g)}},M2={kernelName:aN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:i}=t,{alignCorners:o}=r;ZY([i,a],"resizeBilinearGrad");let s=fC.computeStrides(a.shape),[l,u,d,c]=a.shape,[,p,h]=i.shape,f=new Float32Array(l*u*d*c),m=[o&&p>1?u-1:u,o&&h>1?d-1:d],g=[o&&p>1?p-1:p,o&&h>1?h-1:h],b=m[0]/g[0],y=m[1]/g[1],v=n.data.get(i.dataId).values,x=0;for(let w=0;w<l;w++){let e=w*s[0];for(let t=0;t<p;t++){let n=t*b,r=Math.floor(n),a=Math.min(Math.ceil(n),u-1),i=e+r*s[1],o=e+a*s[1],l=n-r,p=1-l;for(let e=0;e<h;e++){let t=e*y,n=Math.floor(t),r=Math.min(Math.ceil(t),d-1),a=t-n,u=1-a,h=i+n*s[2],m=i+r*s[2],g=o+n*s[2],b=o+r*s[2],w=p*u,k=p*a,S=l*u,I=l*a;for(let e=0;e<c;e++){let t=v[x++];f[h+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[b+e]+=t*I}}}}return n.makeTensorInfo([l,d,u,c],"float32",f)}},O2={kernelName:tN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:i,halfPixelCenters:o,size:s}=r;ZY(a,"resizeNearestNeighbor");let l=fC.computeStrides(a.shape),[u,d]=s,[c,p,h,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(c*u*d*f),b=[i&&u>1?p-1:p,i&&d>1?h-1:h],y=[i&&u>1?u-1:u,i&&d>1?d-1:d],v=b[0]/y[0],x=b[1]/y[1],w=0;for(let k=0;k<c;k++){let e=k*l[0];for(let t=0;t<u;t++){let n=o?v*(t+.5):v*t,r=Math.min(p-1,i?Math.round(n):Math.floor(n));o&&(r=Math.max(0,r));let a=e+r*l[1];for(let e=0;e<d;e++){let t=o?x*(e+.5):x*e,n=Math.min(h-1,i?Math.round(t):Math.floor(t));o&&(n=Math.max(0,n));let r=a+n*l[2];for(let e=0;e<f;e++){let t=m[r+e];g[w++]=t}}}}return n.makeTensorInfo([c,u,d,f],a.dtype,g)}},z2={kernelName:nN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:i}=t,{alignCorners:o}=r;ZY([i,a],"resizeNearestNeighborGrad");let s=fC.computeStrides(a.shape),l=fC.computeStrides(i.shape),[u,d,c,p]=a.shape,[,h,f]=i.shape,m=new Float32Array(u*d*c*p),g=n.data.get(i.dataId).values,b=[o&&h>1?d-1:d,o&&f>1?c-1:c],y=[o&&h>1?h-1:h,o&&f>1?f-1:f],v=b[0]/y[0],x=b[1]/y[1],w=1/v,k=1/x,S=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let N=0;N<u;N++){let e=N*s[0];for(let t=0;t<d;t++){let n=e+t*s[1],r=Math.floor(t*w),a=Math.floor(r-S/2);for(let i=0;i<c;i++){let r=n+i*s[2],u=Math.floor(i*k),b=Math.floor(u-I/2);for(let n=0;n<p;n++){let s=0;for(let r=0;r<S;r++){let u=r+a;if(u<0||u>=h)continue;let p=e+u*l[1],m=u*v;if(t===Math.min(d-1,o?Math.round(m):Math.floor(m)))for(let e=0;e<I;e++){let t=e+b;if(t<0||t>=f)continue;let r=p+t*l[2],a=t*x;i===Math.min(c-1,o?Math.round(a):Math.floor(a))&&(s+=g[r+n])}}m[r+n]=s}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}},P2={kernelName:oN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:i}=r;ZY(a,"reverse");let o=a.shape.length,s=fC.parseAxisParam(i,a.shape);if(0===o)return lQ({inputs:{x:a},backend:n});let l=new KC(a.shape,a.dtype),u=n.bufferSync(a);for(let d=0;d<l.size;d++){let e=l.indexToLoc(d),t=e.slice();s.forEach((e=>t[e]=a.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},L2={kernelName:QN,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:i,center:o}=t,s=n,l=fC.getTypedArrayFromDType(r.dtype,fC.sizeFromShape(r.shape)),[u,d,c,p]=r.shape,[h,f]=AO.getImageCenter(o,d,c),m=Math.sin(a),g=Math.cos(a),b=s.data.get(r.dataId).values;for(let y=0;y<u;y++){let e=y*c*d*p;for(let t=0;t<d;t++){let n=t*(c*p);for(let r=0;r<c;r++){let a=r*p;for(let o=0;o<p;o++){let s=[u,t,r,o],y=s[2],v=s[1],x=(y-h)*g-(v-f)*m,w=(y-h)*m+(v-f)*g;x=Math.round(x+h),w=Math.round(w+f);let k=i;"number"!=typeof i&&(k=3===o?255:i[o]),x>=0&&x<c&&w>=0&&w<d&&(k=b[e+w*(c*p)+x*p+o]),l[e+n+a+o]=k}}}}return{dataId:s.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},B2=TQ(sN,(e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1})),W2={kernelName:sN,backendName:"cpu",kernelFunc:B2},V2={kernelName:uN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:i}=t,{shape:o}=r,{sliceRank:s,numUpdates:l,sliceSize:u,strides:d,outputSize:c}=AO.calculateShapes(i,a,o),p=KZ(n.bufferSync(a),n.bufferSync(i),o,c,u,l,s,d,0,!0);return n.makeTensorInfo(o,p.dtype,p.values)}};function U2(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function j2(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}var H2={kernelName:cN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:i}=t,{side:o}=r,s=function(e,t,n,r,a,i){let o=fC.getArrayFromDType("int32",n*a);for(let s=0;s<n;++s){let n=e.slice(s*r,(s+1)*r),l=s*a;for(let e=0;e<a;++e)o[l+e]="left"===i?U2(n,t[e+l]):j2(n,t[e+l])}return o}(n.data.get(a.dataId).values,n.data.get(i.dataId).values,a.shape[0],a.shape[1],i.shape[1],o);return n.makeTensorInfo(i.shape,"int32",s)}},G2={kernelName:pN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:i}=t;ZY([r,a,i],"select");let o=r.shape.length,s=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values,d=sT(a.dtype,i.dtype),c=fC.makeZerosTypedArray(fC.sizeFromShape(a.shape),d),p=0,h=0===o||o>1||1===a.shape.length?1:fC.sizeFromShape(a.shape.slice(1));for(let f=0;f<s.length;f++)for(let e=0;e<h;e++)1===s[f]?c[p++]=l[f]:c[p++]=u[f];return n.makeTensorInfo(a.shape,d,c)}},q2=AO.SELU_SCALEALPHA,K2=AO.SELU_SCALE,X2=TQ(hN,(e=>e>=0?K2*e:q2*(Math.exp(e)-1))),Y2={kernelName:hN,backendName:"cpu",kernelFunc:X2},Q2=TQ(bN,(e=>e<0?-1:e>0?1:0)),Z2={kernelName:bN,backendName:"cpu",kernelFunc:Q2},J2=TQ(mN,(e=>Math.sin(e))),e3={kernelName:mN,backendName:"cpu",kernelFunc:J2},t3=TQ(gN,(e=>Math.sinh(e))),n3={kernelName:gN,backendName:"cpu",kernelFunc:t3},r3=Math.log(1.1920928955078125e-7)+2,a3=TQ(vN,(e=>{let t,n=e>-r3,r=e<r3,a=Math.exp(e);return t=r?a:n?e:Math.log(1+a),t})),i3={kernelName:vN,backendName:"cpu",kernelFunc:a3},o3={kernelName:kN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,paddings:o}=r;ZY([a],"spaceToBatchND");let s=fC.sizeFromShape(i),l=[[0,0]];l.push(...o);for(let g=1+i.length;g<a.shape.length;++g)l.push([0,0]);let u=I2.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=AO.getReshaped(u.shape,i,s,!1),c=AO.getPermuted(d.length,i.length,!1),p=AO.getReshapedPermuted(u.shape,i,s,!1),h=WJ({inputs:{x:u},backend:n,attrs:{shape:d}}),f=EZ({inputs:{x:h},backend:n,attrs:{perm:c}}),m=WJ({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}},s3={kernelName:NN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:i,defaultValue:o}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);let s=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(i.dataId).values,d=n.data.get(o.dataId).values[0],[c,p,h,f,m]=tJ(s,r.shape,r.dtype,l,a.dtype,u,d);return[n.makeTensorInfo(p,r.dtype,c),n.makeTensorInfo([p[0]],a.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},l3={kernelName:CN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);let o=Array.from(n.data.get(a.dataId).values),s=n.data.get(r.dataId).values,l=Array.from(n.data.get(i.dataId).values),[u,d,c]=nJ(s,r.shape,r.dtype,o,l);return[n.makeTensorInfo(d,r.dtype,u),n.makeTensorInfo([c.length],i.dtype,new Int32Array(c))]}},u3={kernelName:TN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${i.shape}`);if(a.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");let o=n.data.get(r.dataId).values,s=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values,[u,d]=rJ(o,r.shape,r.dtype,s,l,!0);return n.makeTensorInfo(d,r.dtype,u)}},d3={kernelName:$N,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${i.shape}`);if(a.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");let o=n.data.get(r.dataId).values,s=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values,[u,d]=rJ(o,r.shape,r.dtype,s,l);return n.makeTensorInfo(d,r.dtype,u)}},c3={kernelName:EN,backendName:"cpu",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{sparseIndices:i,sparseValues:o,defaultValue:s}=n,{outputShape:l}=a,{sliceRank:u,numUpdates:d,sliceSize:c,strides:p,outputSize:h}=AO.calculateShapes(o,i,l),f=!1,m=r.bufferSync(i);switch(o.dtype){case"bool":t=KZ(m,r.bufferSync(o),l,h,c,d,u,p,!!r.data.get(s.dataId).values[0],f);break;case"float32":case"int32":t=KZ(m,r.bufferSync(o),l,h,c,d,u,p,r.data.get(s.dataId).values[0],f);break;case"string":t=KZ(m,r.bufferSync(o),l,h,c,d,u,p,fC.decodeString(r.data.get(s.dataId).values[0]),f);break;default:throw new Error(`Unsupported type ${o.dtype}`)}return r.makeTensorInfo(l,t.dtype,t.values)}},p3={kernelName:SN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:i,axis:o}=r,s=fC.parseAxisParam(o,a.shape)[0],l=AO.prepareSplitSize(a,i,s),u=new Array(a.shape.length).fill(0),d=a.shape.slice();return l.map((e=>{let t=[...d];t[s]=e;let r=JZ({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[s]+=e,r}))}},h3={kernelName:AN,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;ZY(n,"square");let a=r.data.get(n.dataId).values,i=new Float32Array(a.length);for(let o=0;o<a.length;++o){let e=a[o];i[o]=e*e}return{dataId:r.write(i,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},f3=TQ(XN,((e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),m3={kernelName:XN,backendName:"cpu",kernelFunc:f3},g3={kernelName:FN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:i,end:o,strides:s,beginMask:l,endMask:u,ellipsisMask:d,newAxisMask:c,shrinkAxisMask:p}=r;ZY(a,"stridedSlice");let h,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:b,isSimpleSlice:y,begin:v,end:x,strides:w}=iO.sliceInfo(a.shape,i,o,s,l,u,d,c,p);if(g)h=WJ({inputs:{x:a},backend:n,attrs:{shape:m}});else if(b||y){fC.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));let e=iO.computeOutShape(v,x,w),t=JZ({inputs:{x:a},backend:n,attrs:{begin:v,size:e}});h=WJ({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else{let e=hJ(f,n.bufferSync(a),w,v);h=n.makeTensorInfo(m,e.dtype,e.values)}return h}},b3={kernelName:DN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:i,leftPad:o,rightPad:s,padWidth:l,preserveShortSequences:u}=r,{data:d,dataSplits:c}=t,p=n.data.get(d.dataId).values,h=n.data.get(c.dataId).values,[f,m]=mJ(p,h,a,i,o,s,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(c.shape,"int32",m)]}},y3={kernelName:MN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:i,delimiter:o}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);let s=n.data.get(i.dataId).values,l=n.data.get(o.dataId).values[0],[u,d,c]=bJ(s,l,a),p=d.length;return[n.makeTensorInfo([p,2],"int32",u),n.makeTensorInfo([p],"string",d),n.makeTensorInfo([2],"int32",new Int32Array(c))]}},v3={kernelName:ON,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let o=yJ(n.data.get(i.dataId).values,a);return n.makeTensorInfo(i.shape,"int32",o)}},x3=TQ(PN,(e=>Math.tan(e))),w3={kernelName:PN,backendName:"cpu",kernelFunc:x3},k3=TQ(LN,(e=>Math.tanh(e))),S3={kernelName:dN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n}=e,{tensor:r,indices:a,updates:i}=t,{sliceRank:o,numUpdates:s,sliceSize:l,strides:u,outputSize:d}=AO.calculateShapes(i,a,r.shape),c=n.bufferSync(a),p=n.bufferSync(i),h=n.bufferSync(r),f=KZ(c,p,r.shape,d,l,s,o,u,h,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}},I3={kernelName:BN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:i}=r;ZY(a,"tile");let o=SJ(n.bufferSync(a),i);return n.makeTensorInfo(o.shape,o.dtype,o.values)}},N3={kernelName:WN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:i,sorted:o}=r;ZY(a,"topk");let s=n.data.get(a.dataId).values,[l,u]=CJ(s,a.shape,a.dtype,i,o);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}},C3={kernelName:VN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:i}=t,{interpolation:o,fillMode:s,fillValue:l,outputShape:u}=n,[d,c,p,h]=a.shape,[f,m]=null!=u?u:[c,p],g=[d,f,m,h],b=fC.computeStrides(a.shape),y=b[0],v=b[1],x=b[2],w=fC.computeStrides(g),k=w[0],S=w[1],I=w[2],N=fC.getTypedArrayFromDType(a.dtype,fC.sizeFromShape(g));N.fill(l);let C=r.data.get(a.dataId).values,T=r.data.get(i.dataId).values;for(let $=0;$<d;++$){let e=1===i.shape[0]?T:T.subarray(8*$,8*$+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<h;++r){let a,i=e[6]*n+e[7]*t+1;if(0===i)continue;let u=(e[0]*n+e[1]*t+e[2])/i,d=(e[3]*n+e[4]*t+e[5])/i,h=T3(u,p,s),f=T3(d,c,s);switch(o){case"nearest":a=E3(C,c,p,y,v,x,$,f,h,r,l);break;case"bilinear":a=_3(C,c,p,y,v,x,$,f,h,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}N[$*k+t*S+n*I+r]=a}return r.makeTensorInfo(g,a.dtype,N)}return{dataId:r.write(N,g,a.dtype),shape:a.shape,dtype:a.dtype}}};function T3(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{let e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return fC.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{let e=t-1;n-=t*Math.trunc(n/e)}return fC.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return fC.clamp(0,e,t-1)}(e,t);default:return function(e,t){return e}(e)}}function $3(e,t,n,r,a,i,o,s,l,u,d){return 0<=s&&s<t&&0<=l&&l<n?e[o*r+s*a+l*i+u]:d}function E3(e,t,n,r,a,i,o,s,l,u,d){return $3(e,t,n,r,a,i,o,Math.round(s),Math.round(l),u,d)}function _3(e,t,n,r,a,i,o,s,l,u,d){let c=Math.floor(s),p=Math.floor(l),h=c+1,f=p+1;return(h-s)*((f-l)*$3(e,t,n,r,a,i,o,c,p,u,d)+(l-p)*$3(e,t,n,r,a,i,o,c,f,u,d))+(s-c)*((f-l)*$3(e,t,n,r,a,i,o,h,p,u,d)+(l-p)*$3(e,t,n,r,a,i,o,h,f,u,d))}var A3={kernelName:jN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:i}=t;ZY(i,"unique");let o=r.data.get(i.dataId).values,{outputValues:s,outputShape:l,indices:u}=TJ(o,a,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,s),r.makeTensorInfo([u.length],"int32",u)]}},R3={kernelName:HN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:i}=r;i<0&&(i+=a.shape.length);let o=a.shape.length,s=a.shape[i],l=new Array(o-1),u=0;for(let h=0;h<o;h++)h!==i&&(l[u++]=a.shape[h]);let d=new Array(o).fill(0),c=a.shape.slice();c[i]=1;let p=new Array(s);for(let h=0;h<p.length;h++){d[i]=h;let e=JZ({inputs:{x:a},backend:n,attrs:{begin:d,size:c}});p[h]=WJ({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return p}},F3={kernelName:GN,backendName:"cpu",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:i}=t,{numSegments:o}=r;ZY(a,"unsortedSegmentSum");let s=[],l=[],u=a.shape.length-i.shape.length,d=i;for(let p=0;p<u;++p){let e=h1({inputs:{input:d},backend:n,attrs:{dim:p+1}});d=e,l.push(e)}for(let p=0;p<o;++p){let e=fC.createScalarValue(p,"int32"),t=n.makeTensorInfo([],"int32",e),r=DQ({inputs:{a:t,b:d},backend:n}),i=hQ({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),o=wZ({inputs:{a:i,b:a},backend:n}),u=t1({inputs:{x:o},backend:n,attrs:{axis:0,keepDims:!1}});s.push(u),l.push(t),l.push(r),l.push(i),l.push(o),l.push(u)}let c=k2({inputs:s,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},D3=[HJ,rQ,qJ,XJ,xQ,YJ,QJ,ZJ,JJ,e0,n0,a0,o0,u0,c0,m0,g0,b0,y0,jJ,v0,x0,w0,NQ,k0,fQ,AQ,I0,oQ,N0,E0,A0,R0,F0,D0,M0,O0,P0,B0,W0,V0,U0,j0,H0,q0,K0,X0,Y0,Q0,Z0,J0,e1,r1,_J,a1,MQ,p1,PQ,f1,WQ,w1,S1,I1,jQ,qQ,N1,C1,T1,$1,ZQ,tZ,uQ,E1,T0,A1,F1,M1,RJ,aZ,sZ,O1,cZ,P1,W1,U1,G1,q1,K1,Y1,mZ,Q1,Z1,J1,e2,t2,n2,r2,yZ,a2,s2,c2,kZ,IZ,h2,m2,b2,TZ,y2,w2,S2,I2,T2,MJ,RZ,$2,E2,_2,A2,cQ,b1,F2,zJ,LJ,VJ,D2,M2,O2,z2,P2,L2,W2,qZ,V2,H2,G2,Y2,QZ,Z2,e3,n3,eJ,d2,i3,o3,s3,l3,u3,d3,c3,p3,oJ,h3,uJ,pJ,m3,g3,b3,y3,v3,kJ,n1,w3,{kernelName:LN,backendName:"cpu",kernelFunc:k3},S3,I3,N3,C3,_Z,A3,R3,F3,x2];for(let e of D3)lC(e);var M3={};uw(M3,{assertNotComplex:()=>j4,bindCanvasToFramebuffer:()=>x4,bindColorTextureToFramebuffer:()=>w4,bindTextureToProgramUniformSampler:()=>v4,bindTextureUnit:()=>m4,bindVertexBufferToProgramAttribute:()=>f4,callAndCheck:()=>q3,canBeRepresented:()=>Y3,createFragmentShader:()=>e4,createFramebuffer:()=>h4,createProgram:()=>i4,createStaticIndexBuffer:()=>u4,createStaticVertexBuffer:()=>l4,createTexture:()=>c4,createVertexShader:()=>J3,getBatchDim:()=>T4,getExtensionOrThrow:()=>Z3,getFramebufferErrorMessage:()=>I4,getMaxTexturesInShader:()=>O4,getNumChannels:()=>d4,getProgramUniformLocation:()=>y4,getProgramUniformLocationOrThrow:()=>b4,getRowsCols:()=>$4,getShapeAs3D:()=>E4,getTextureShapeFromLogicalShape:()=>_4,getWebGLDisjointQueryTimerVersion:()=>z4,getWebGLErrorMessage:()=>Q3,getWebGLMaxTextureSize:()=>F4,hasExtension:()=>P4,isCapableOfRenderingToFloatTexture:()=>B4,isDownloadFloatTextureEnabled:()=>W4,isReshapeFree:()=>R4,isWebGLFenceEnabled:()=>U4,isWebGLVersionEnabled:()=>L4,linkProgram:()=>o4,logShaderSourceAndInfoLog:()=>a4,resetMaxTextureSize:()=>D4,resetMaxTexturesInShader:()=>M4,unbindColorTextureFromFramebuffer:()=>k4,unbindTextureUnit:()=>g4,validateFramebuffer:()=>S4,validateProgram:()=>s4,validateTextureSize:()=>p4});var O3,z3,P3,L3={},B3={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function W3(e,t){L3[e]=t}function V3(e,t){if(!(e in L3)||null!=t){let n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=null==t?function(e){if(!Rk().getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete L3[e]}),!1),Rk().getBool("SOFTWARE_WEBGL_ENABLED")&&(B3.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",B3)||n.getContext("experimental-webgl",B3):n.getContext("webgl2",B3)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;L3[e]=n}let n=L3[e];return null==n||n.isContextLost()?(delete L3[e],V3(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),L3[e])}function U3(e,t){return[t,e]}function j3(e){let t=fC.sizeFromShape(e),n=Math.ceil(t/4);return fC.sizeToSquarishShape(n)}function H3(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function G3(e,t){let n,r,a,i,o,s,l,u,d,c,p=e;return 2===Rk().getNumber("WEBGL_VERSION")?(n=p.R32F,r=p.R16F,a=p.RGBA16F,i=p.RGBA32F,o=p.RED,l=4,u=1,d=p.HALF_FLOAT,c=p.FLOAT,s=p.RGBA8):(n=e.RGBA,r=e.RGBA,a=e.RGBA,i=p.RGBA,o=e.RGBA,l=4,u=4,d=null!=t?t.HALF_FLOAT_OES:null,c=e.FLOAT,s=e.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:s,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:c}}function q3(e,t){let n=t();return Rk().getBool("DEBUG")&&function(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+Q3(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(O3||(O3={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(z3||(z3={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(P3||(P3={}));var K3=5.96e-8,X3=65504;function Y3(e){return!!(Rk().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||K3<Math.abs(e)&&Math.abs(e)<X3)}function Q3(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Z3(e,t){return N4(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function J3(e,t){let n=N4(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(q3(e,(()=>e.shaderSource(n,t))),q3(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function e4(e,t){let n=N4(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(q3(e,(()=>e.shaderSource(n,t))),q3(e,(()=>e.compileShader(n))),Rk().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw a4(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var t4,n4,r4=/ERROR: [0-9]+:([0-9]+):/g;function a4(e,t){let n=r4.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);let r=+n[1],a=e.split("\n"),i=a.length.toString().length+2,o=a.map(((e,t)=>fC.rightPad((t+1).toString(),i)+e)),s=0;for(let c=0;c<o.length;c++)s=Math.max(o[c].length,s);let l=o.slice(0,r-1),u=o.slice(r-1,r),d=o.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${fC.rightPad(u[0],s)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}function i4(e){return N4(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function o4(e,t){if(q3(e,(()=>e.linkProgram(t))),!Rk().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function s4(e,t){if(q3(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function l4(e,t){let n=N4(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return q3(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),q3(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function u4(e,t){let n=N4(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return q3(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),q3(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function d4(){return 2===Rk().getNumber("WEBGL_VERSION")?1:4}function c4(e){return N4(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function p4(e,t){let n=Rk().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}function h4(e){return N4(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function f4(e,t,n,r,a,i,o){let s=e.getAttribLocation(t,n);return-1!==s&&(q3(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),q3(e,(()=>e.vertexAttribPointer(s,a,e.FLOAT,!1,i,o))),q3(e,(()=>e.enableVertexAttribArray(s))),!0)}function m4(e,t,n){C4(e,n),q3(e,(()=>e.activeTexture(e.TEXTURE0+n))),q3(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function g4(e,t){C4(e,t),q3(e,(()=>e.activeTexture(e.TEXTURE0+t))),q3(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function b4(e,t,n){return N4(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function y4(e,t,n){return e.getUniformLocation(t,n)}function v4(e,t,n,r){q3(e,(()=>m4(e,t,r))),q3(e,(()=>e.uniform1i(n,r)))}function x4(e){q3(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),q3(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),q3(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function w4(e,t,n){q3(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),q3(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function k4(e,t){q3(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),q3(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function S4(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+I4(e,t))}function I4(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function N4(e,t,n){let r=q3(e,(()=>t()));if(null==r)throw new Error(n);return r}function C4(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)}function T4(e,t=2){return fC.sizeFromShape(e.slice(0,e.length-t))}function $4(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function E4(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[T4(e),...$4(e)]),t}function _4(e,t=!1){let n=Rk().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Rk().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&Rk().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,e=e.map(((t,n)=>n>=e.length-2?fC.nearestLargerEven(e[n]):e[n])),1===e.length&&(e=[2,e[0]])),2!==e.length&&(e=fC.squeezeShape(e).newShape);let a=fC.sizeFromShape(e),i=null;e.length<=1&&a<=n?i=[1,a]:2===e.length&&e[0]<=n&&e[1]<=n?i=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?i=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?i=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?i=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(i=[e[0],e[1]*e[2]*e[3]]);let o=null!=i&&Math.max(...i)>r&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(null==i||o)if(t){let t=T4(e),n=2,r=2;e.length&&([n,r]=$4(e)),a=t*(n/2)*(r/2),i=fC.sizeToSquarishShape(a).map((e=>2*e))}else i=fC.sizeToSquarishShape(a);return i}function A4(e){return e%2==0}function R4(e,t){if(e=e.slice(-2),t=t.slice(-2),fC.arraysEqual(e,t)||!e.length||!t.length||0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||A4(n)&&A4(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&A4(e[0])&&A4(t[0])}function F4(e){if(null==t4){let t=V3(e);t4=t.getParameter(t.MAX_TEXTURE_SIZE)}return t4}function D4(){t4=null}function M4(){n4=null}function O4(e){if(null==n4){let t=V3(e);n4=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,n4)}function z4(e){if(0===e)return 0;let t,n=V3(e);return t=P4(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:P4(n,"EXT_disjoint_timer_query")?1:0,t}function P4(e,t){return null!=e.getExtension(t)}function L4(e){try{if(null!=V3(e))return!0}catch(Fp){return console.log("Error when getting WebGL context: ",Fp),!1}return!1}function B4(e){if(0===e)return!1;let t=V3(e);if(1===e){if(!P4(t,"OES_texture_float"))return!1}else if(!P4(t,"EXT_color_buffer_float"))return!1;return V4(t)}function W4(e){if(0===e)return!1;let t=V3(e);if(1!==e){if(P4(t,"EXT_color_buffer_float"))return V4(t);let e="EXT_color_buffer_half_float";if(P4(t,e)){let n=t.getExtension(e);return function(e,t){let n=G3(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let a=1,i=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,a,i,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(o),s}(t,n)}return!1}return!(!P4(t,"OES_texture_float")||!P4(t,"WEBGL_color_buffer_float"))&&V4(t)}function V4(e){let t=G3(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),a}function U4(e){return 2===e&&null!=V3(e).fenceSync}function j4(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&fC.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}var H4=Rk();function G4(){let e,t,n,r,a,i,o,s,l,u;return 2===Rk().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",i="outputColor",o="out vec4 outputColor;",s=Rk().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",i="gl_FragColor",o="",s="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:i,defineOutput:o,defineSpecialNaN:s,defineSpecialInf:l,defineRound:u}}function q4(e,t,n="index"){let r=fC.computeStrides(t);return r.map(((t,a)=>`int ${e[a]} = ${n} / ${t}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`};`)).join("")}function K4(e,t,n="index"){let r=fC.computeStrides(t);return r.map(((t,a)=>`int ${e[a]} = ${n} / outShapeStrides[${a}]; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`};`)).join("")}function X4(e,t,n="index"){let r=function(e,t){let n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let i=n-3;i>=0;--i)a[i]=`(${a[i+1]} * ${r[i+1]})`;return a}(e.map(((e,t)=>t)),t);return r.map(((t,a)=>`int ${e[a]} = ${n} / ${r[a]}; ${a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${r[a]}`:`index -= ${e[a]} * ${r[a]}`};`)).join("")}function Y4(e){let t=fC.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}H4.registerFlag("HAS_WEBGL",(()=>H4.getNumber("WEBGL_VERSION")>0)),H4.registerFlag("WEBGL_VERSION",(()=>L4(2)?2:L4(1)?1:0)),H4.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),H4.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===H4.get("WEBGL_VERSION"))),H4.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),H4.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),H4.registerFlag("WEBGL_PACK",(()=>H4.getBool("HAS_WEBGL"))),H4.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>H4.getBool("WEBGL_PACK"))),H4.registerFlag("WEBGL_PACK_CLIP",(()=>H4.getBool("WEBGL_PACK"))),H4.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>H4.getBool("WEBGL_PACK"))),H4.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>H4.getBool("WEBGL_PACK"))),H4.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>H4.getBool("WEBGL_PACK"))),H4.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>H4.getBool("WEBGL_PACK"))),H4.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>H4.getBool("WEBGL_PACK"))),H4.registerFlag("WEBGL_PACK_REDUCE",(()=>H4.getBool("WEBGL_PACK"))),H4.registerFlag("WEBGL_LAZILY_UNPACK",(()=>H4.getBool("WEBGL_PACK"))),H4.registerFlag("WEBGL_CONV_IM2COL",(()=>H4.getBool("WEBGL_PACK"))),H4.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>F4(H4.getNumber("WEBGL_VERSION")))),H4.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>O4(H4.getNumber("WEBGL_VERSION")))),H4.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{let e=H4.getNumber("WEBGL_VERSION");return 0===e?0:z4(e)})),H4.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>H4.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!ST.isMobile())),H4.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>B4(H4.getNumber("WEBGL_VERSION")))),H4.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!H4.getBool("WEBGL_FORCE_F16_TEXTURES")&&H4.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),H4.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>W4(H4.getNumber("WEBGL_VERSION")))),H4.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>U4(H4.getNumber("WEBGL_VERSION")))),H4.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>H4.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),H4.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),H4.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>ST.isMobile()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),H4.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),H4.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),H4.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),H4.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),H4.registerFlag("WEBGL_EXP_CONV",(()=>!1)),H4.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>H4.getBool("IS_TEST"))),H4.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),H4.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),H4.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),H4.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));var Q4="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:Z4}=AO;function J4(e,t,n){let r=[];if(e.forEach((e=>{let t=fC.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){let{uniformShape:t}=u5(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));let a,i,o=r.join("\n"),s=e.map((e=>function(e,t,n=!1,r){let a="";a+=n?t5(e,r):e5(e,r);let i=e.shapeInfo.logicalShape,o=t.logicalShape;return i.length<=o.length&&(a+=n?function(e,t){let n,r=e.name,a=r.charAt(0).toUpperCase()+r.slice(1),i="get"+a+"AtOutCoords",o=e.shapeInfo.logicalShape.length,s=t.logicalShape.length,l=Z4(e.shapeInfo.logicalShape,t.logicalShape),u=l5(s),d=s-o,c=["x","y","z","w","u","v"];n=0===o?"":s<2&&l.length>=1?"coords = 0;":l.map((e=>`coords.${c[e+d]} = 0;`)).join("\n");let p="";p=s<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${c[t+d]}`)).join(", ");let h="return outputValue;",f=1===fC.sizeFromShape(e.shapeInfo.logicalShape),m=1===fC.sizeFromShape(t.logicalShape);if(1!==o||f||m){if(f&&!m)h=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){let e=o-2,t=o-1;l.indexOf(e)>-1&&l.indexOf(t)>-1?h="return vec4(outputValue.x);":l.indexOf(e)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(t)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}}else h="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${i}() {\n      ${u} coords = getOutputCoords();\n      ${n}\n      vec4 outputValue = get${a}(${p});\n      ${h}\n    }\n  `}(e,t):function(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",i=t.texShape,o=e.shapeInfo.texShape,s=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&s===l&&null==e.shapeInfo.flatOffset&&fC.arraysEqual(o,i))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;let u,d=l5(l),c=Z4(e.shapeInfo.logicalShape,t.logicalShape),p=l-s,h=["x","y","z","w","u","v"];u=0===s?"":l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${h[e+p]} = 0;`)).join("\n");let f="";return f=l<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+p]}`)).join(", "),`\n    float ${a}() {\n      ${d} coords = getOutputCoords();\n      ${u}\n      return get${r}(${f});\n    }\n  `}(e,t)),a}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),l=t.texShape,u=G4(),d=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u),c=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${n5}\n    ${r5}\n    ${a5}\n  `}(u);return t.isPacked?(a=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(fC.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;let a=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),i=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),i=a*Math.ceil(e[e.length-2]/2),o=i,s="",l="b, r, c";for(let u=2;u<e.length-1;u++)o*=e[e.length-u-1],s=`\n      int b${u} = index / ${o};\n      index -= b${u} * ${o};\n    `+s,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${s}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,l,n.enableShapeUniforms),i=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(a=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){return fC.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${K4(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;let r=q4(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${K4(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;let r=q4(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){let n=q4(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){let n=q4(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,l,n.enableShapeUniforms),i=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),n.packedInputs&&(c+=i5),[c,d,i,o,a,s,n.userCode].join("\n")}function e5(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,i]=e.shapeInfo.texShape;if(1===a&&1===i)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let o=o5(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;let[s,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${s}, ${l}, ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${s5(e)}\n      }\n    `;let a=e.shapeInfo.texShape,i=a[0],o=a[1];if(1===o&&1===i)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let s=o5(n);return 1===o?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${s}) + 0.5) / ${i}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${s}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${s}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${s});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${o}, index + ${s});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape;if(null!=i&&fC.arraysEqual(n,i)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;let e=i[0];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}let{newShape:o,keptDims:s}=fC.squeezeShape(n),l=o;if(l.length<n.length){let n=["row","col"];return`\n      ${e5(d5(e,l),t)}\n      float ${a}(int row, int col) {\n        return ${a}(${c5(n,s)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${s5(e)}\n      }\n    `;let u=i[0],d=i[1],c=o5(r);return 1===d?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${c}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${c}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${c}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${c};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${c};\n    vec2 uv = uvFromFlat(${u}, ${d}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[1]*n[2],o=n[2],{newShape:s,keptDims:l}=fC.squeezeShape(n),u=s;if(u.length<n.length){let n=["row","col","depth"];return`\n        ${e5(d5(e,u),t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${c5(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${o}, 1)));\n        ${s5(e)}\n      }\n    `;let d=e.shapeInfo.texShape,c=d[0],p=d[1],h=e.shapeInfo.flatOffset;if(p===i&&null==h)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${p}.0, ${c}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(p===o&&null==h)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;let f=o5(r);return t?`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${o} + depth + ${f};\n        vec2 uv = uvFromFlat(${c}, ${p}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n[3],o=n[2]*i,s=n[1]*o,{newShape:l,keptDims:u}=fC.squeezeShape(n);if(l.length<n.length){let n=["row","col","depth","depth2"];return`\n      ${e5(d5(e,l),t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${c5(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${s}, ${o}, ${i}, 1)));\n        ${s5(e)}\n      }\n    `;let d=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,p=c[0],h=c[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(h===s&&null==d)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(h===i&&null==d)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${p}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;let b=o5(r);return t?`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${b});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${s} + col * ${o} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${p}, ${h}, index + ${b});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],i=t[3]*a,o=t[2]*i,s=t[1]*o,{newShape:l,keptDims:u}=fC.squeezeShape(t);if(l.length<t.length){let t=["row","col","depth","depth2","depth3"];return`\n      ${e5(d5(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${c5(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${s}, ${o}, ${i}, ${a})) +\n          depth3;\n        ${s5(e)}\n      }\n    `;let d=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,p=c[0],h=c[1];if(h===s&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${i}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(h===a&&null==d)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let f=o5(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${s} + col * ${o} + depth * ${i} +\n          depth2 * ${a} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${p}, ${h}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:i}=fC.squeezeShape(t);if(a.length<t.length){let t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${e5(d5(e,a))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${c5(t,i)});\n      }\n    `}let o=t[5],s=t[4]*o,l=t[3]*s,u=t[2]*l,d=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${u}, ${l}, ${s})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${s5(e)}\n      }\n    `;let c=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,h=p[0],f=p[1];if(f===d&&null==c)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${s}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===o&&null==c)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let m=o5(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${u} + depth * ${l} +\n          depth2 * ${s} + depth3 * ${o} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function t5(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=G4();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,i=G4();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `;let o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape,o=i[0],s=i[1],l=G4();if(null!=i&&fC.arraysEqual(n,i))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}.0, ${o}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;let u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],d=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${d}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===n[0]){let r=[1,2],i=["b","row","col"];return`\n        ${t5(d5(e,n.slice(1)),t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${c5(i,r)});\n        }\n      `}let s=G4();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${s.texture2D}(${r}, uv);\n    }\n  `;let l=o[0],u=o[1],d=Math.ceil(n[2]/2),c=d*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c}, ${d}, b, row, col);\n      return ${s.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=G4();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;let i=e.shapeInfo.logicalShape,o=i.length,s=e.shapeInfo.texShape,l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=l[0],d=l[1],c=Math.ceil(i[o-1]/2),p=c*Math.ceil(i[o-2]/2),h="int b, int row, int col",f=`b * ${p} + (row / 2) * ${c} + (col / 2)`;for(let m=2;m<o-1;m++)h=`int b${m}, `+h,p*=i[o-m-1],f=`b${m} * ${p} + `+f;return`\n    vec4 ${r}(${h}) {\n      int index = ${f};\n      int texR = index / ${d};\n      int texC = index - texR * ${d};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}var n5="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",r5="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",a5="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",i5="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function o5(e){return`offset${e}`}function s5(e){let t=e.name,n=fC.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function l5(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function u5(e,t,n){let{newShape:r,keptDims:a}=fC.squeezeShape(t),i=t.length,o=e&&3===i&&1===t[0],s=o?t.slice(1):r,l=!e&&i>1&&!fC.arraysEqual(t,n)&&r.length<i||o;return{useSqueezeShape:l,uniformShape:l?s:t,keptDims:a}}function d5(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function c5(e,t){return t.map((t=>e[t])).join(", ")}function p5(e,t,n){let r,a,i,o=[],s=[],l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===Rk().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));let d=!1;for(let c of t.variableNames){let r={name:c,uniform:e.getUniformLocation(n,c,d),offset:e.getUniformLocation(n,`offset${c}`,d)};t.enableShapeUniforms&&(r.shape=e.getUniformLocation(n,`${c}Shape`,d),r.texShape=e.getUniformLocation(n,`${c}TexShape`,d)),o.push(r)}if(t.enableShapeUniforms&&(r=e.getUniformLocation(n,"outShape",d),i=e.getUniformLocation(n,"outShapeStrides",d),a=e.getUniformLocation(n,"outTexShape",d)),t.customUniforms)for(let c of t.customUniforms)s.push(e.getUniformLocation(n,c.name,d));return{variablesLocations:o,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:r,outShapeStridesLocation:i,outTexShapeLocation:a}}function h5(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{let r=e.logicalShape,a=t[n],i=a.shape;if(!fC.arraysEqual(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(e.isUniform&&a.isUniform)return;let o=e.texShape,s=a.isUniform?null:a.texData.texShape;if(!fC.arraysEqual(o,s))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${s} must match`)}))}function f5(e){return Rk().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var m5={R:0,G:1,B:2,A:3},g5=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=G4();this.outputShape=e,this.enableShapeUniforms=f5(this.outputShape.length);let a="result";t&&(a="floor(result * 255. + 0.5)");let i="";for(let o=0;o<n.length;o++){let e=n[o];i+=`\n          if(offset == ${o}) {\n            result = values[${m5[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Y4(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${i}\n        }\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}},b5={};function y5(e){let t=G4();return J3(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function v5(e){return l4(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function x5(e){return u4(e,new Uint16Array([0,1,2,2,1,3]))}function w5(e,t,n,r,a,i){p4(t,n);let o=c4(e),s=e.TEXTURE_2D;return q3(e,(()=>e.bindTexture(s,o))),q3(e,(()=>e.texParameteri(s,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),q3(e,(()=>e.texParameteri(s,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),q3(e,(()=>e.texParameteri(s,e.TEXTURE_MIN_FILTER,e.NEAREST))),q3(e,(()=>e.texParameteri(s,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===Rk().getNumber("WEBGL_VERSION")?q3(e,(()=>e.texImage2D(s,0,r,t,n,0,a,i,null))):q3(e,(()=>e.texStorage2D(s,1,r,t,n))),q3(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:o,texShape:[n,t]}}function k5(e){return e.internalFormatFloat}function S5(e,t,n,r){let[a,i]=U3(t,n);return w5(e,a,i,k5(r),r.textureFormatFloat,e.FLOAT)}function I5(e){return e.internalFormatHalfFloat}function N5(e,t,n,r){let[a,i]=U3(t,n);return w5(e,a,i,I5(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function C5(e){return e.downloadTextureFormat}function T5(e,t,n,r){let[a,i]=U3(t,n);return w5(e,a,i,C5(r),e.RGBA,e.UNSIGNED_BYTE)}function $5(e){return e.internalFormatPackedFloat}function E5(e,t,n,r){let[a,i]=H3(t,n);return w5(e,a,i,$5(r),e.RGBA,e.FLOAT)}function _5(e){return e.internalFormatPackedHalfFloat}function A5(e,t,n,r){let[a,i]=H3(t,n);return w5(e,a,i,_5(r),e.RGBA,r.textureTypeHalfFloat)}function R5(e,t,n){return q3(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),f4(e,t,"clipSpacePos",n,3,20,0)&&f4(e,t,"uv",n,2,20,12)}function F5(e,t,n,r,a,i){let o,s,l;q3(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(o=new Uint8Array(n*r*4),s=e.UNSIGNED_BYTE,l=e.RGBA):(o=new Float32Array(n*r*4),s=e.FLOAT,l=i.internalFormatPackedFloat),o.set(a),2===Rk().getNumber("WEBGL_VERSION")?q3(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,s,o))):q3(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,s,o))),q3(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function D5(e,t,n){q3(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===Rk().getNumber("WEBGL_VERSION")?q3(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):q3(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===Rk().getNumber("WEBGL_VERSION")?q3(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):q3(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),q3(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function M5(e,t,n,r){let a=e.createBuffer();q3(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a)));let i=16*t*n;return q3(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ))),q3(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),q3(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),a}function O5(e,t,n){let r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function z5(e,t,n,r){let[a,i]=U3(t,n),o=new Uint8Array(function(e,t){return e*t}(t*n,4));return q3(e,(()=>e.readPixels(0,0,a,i,r.downloadTextureFormat,e.UNSIGNED_BYTE,o))),new Float32Array(o.buffer)}function P5(e,t,n,r,a,i,o,s){let l=e,u=new Float32Array(function(e,t){let[n,r]=H3(e,t);return n*r*4}(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function L5(e,t,n){let r=new Float32Array(t*n*4);return q3(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}uw(b5,{bindVertexProgramAttributeStreams:()=>R5,createBufferFromOutputTexture:()=>M5,createFloat16MatrixTexture:()=>N5,createFloat16PackedMatrixTexture:()=>A5,createFloat32MatrixTexture:()=>S5,createIndexBuffer:()=>x5,createPackedMatrixTexture:()=>E5,createUnsignedBytesMatrixTexture:()=>T5,createVertexBuffer:()=>v5,createVertexShader:()=>y5,downloadByteEncodedFloatMatrixFromOutputTexture:()=>z5,downloadFloat32MatrixFromBuffer:()=>O5,downloadMatrixFromPackedOutputTexture:()=>L5,downloadPackedMatrixFromBuffer:()=>P5,getInternalFormatForFloat16MatrixTexture:()=>I5,getInternalFormatForFloat16PackedMatrixTexture:()=>_5,getInternalFormatForFloat32MatrixTexture:()=>k5,getInternalFormatForPackedMatrixTexture:()=>$5,getInternalFormatForUnsignedBytesMatrixTexture:()=>C5,uploadDenseMatrixToTexture:()=>F5,uploadPixelDataToTexture:()=>D5});var B5=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=Rk().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,W3(t,e)):this.gl=V3(t),e=this.gl,2===Rk().getNumber("WEBGL_VERSION")){let t=e;this.createVertexArray=()=>q3(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>q3(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>q3(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>q3(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){let t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>q3(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>q3(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>q3(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>q3(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Rk().getNumber("WEBGL_VERSION")){let e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=Z3(this.gl,e),P4(this.gl,t))this.textureHalfFloatExtension=Z3(this.gl,t);else if(Rk().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),P4(this.gl,r))this.colorBufferHalfFloatExtension=Z3(this.gl,r);else if(Rk().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",P4(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!P4(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=v5(this.gl),this.indexBuffer=x5(this.gl),this.framebuffer=h4(this.gl),this.textureConfig=G3(this.gl,this.textureHalfFloatExtension)}get debug(){return Rk().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;q3(e,(()=>e.finish())),q3(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),q3(e,(()=>e.deleteFramebuffer(this.framebuffer))),q3(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),q3(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),q3(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),S5(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),N5(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),T5(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),D5(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),F5(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),A5(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),E5(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(k4(this.gl,this.framebuffer),this.outputTexture=null),q3(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>z5(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,i){return P5(this.gl,e,0,0,0,a,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return O5(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=M5(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Rk().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else Rk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Rk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>L5(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();let t=this.gl;null==this.vertexShader&&(this.vertexShader=y5(t));let n=i4(t);q3(t,(()=>t.attachShader(n,this.vertexShader))),q3(t,(()=>t.attachShader(n,e))),o4(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&s4(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;q3(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),R5(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(q3(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&s4(this.gl,this.program),q3(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?b4(this.gl,e,t):y4(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),q3(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),v4(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=H3(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&s4(this.gl,this.program),S4(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}q3(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),q3(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Z3(this.gl,2===Rk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Rk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Rk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await fC.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,Rk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,Rk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){let t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{let t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){let t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{let t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){let e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){let{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Rk().platform&&(n=Rk().platform.setTimeoutCustom.bind(Rk().platform)),fC.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),w4(this.gl,e,this.framebuffer),this.debug&&S4(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(w4(this.gl,this.outputTexture,this.framebuffer),this.debug&&S4(this.gl)):k4(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;w4(r,e,this.framebuffer),this.debug&&S4(r),this.outputTexture=e,q3(r,(()=>r.viewport(0,0,t,n))),q3(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),q3(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}},{addImpl:W5,bincountImpl:V5,bincountReduceImpl:U5,bitwiseAndImpl:j5,castImpl:H5,ceilImpl:G5,concatImpl:q5,equalImpl:K5,expImpl:X5,expm1Impl:Y5,floorImpl:Q5,gatherNdImpl:Z5,gatherV2Impl:J5,greaterImpl:e6,greaterEqualImpl:t6,lessImpl:n6,lessEqualImpl:r6,linSpaceImpl:a6,logImpl:i6,maxImpl:o6,maximumImpl:s6,minimumImpl:l6,multiplyImpl:u6,negImpl:d6,notEqualImpl:c6,prodImpl:p6,raggedGatherImpl:h6,raggedRangeImpl:f6,raggedTensorToTensorImpl:m6,rangeImpl:g6,rsqrtImpl:b6,scatterImpl:y6,sigmoidImpl:v6,simpleAbsImpl:x6,sliceImpl:w6,sparseFillEmptyRowsImpl:k6,sparseReshapeImpl:S6,sparseSegmentReductionImpl:I6,sqrtImpl:N6,staticRegexReplaceImpl:C6,stridedSliceImpl:T6,stringNGramsImpl:$6,stringSplitImpl:E6,stringToHashBucketFastImpl:_6,subImpl:A6,tileImpl:R6,topKImpl:F6,transposeImpl:D6,uniqueImpl:M6}=tQ;function O6(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function z6(e,t){return 1===t?[e]:O6(e,t)}var P6=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=f5(this.outputShape.length);let n="";for(let r=0;r<4;r++){let e="thisRC = rc;";r%2==1&&(e+="thisRC.z += 1;"),r>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}this.userCode=`\n      ${function(e,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?X4(["r","c","d"],"inputShape"):q4(["r","c","d"],e)}\n      return ivec3(r, c, d);\n    }\n  `}(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Y4(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}};function L6(e,t,n,r,a){let i,o=function(e,t){switch(e){case P3.PACKED_2X2_FLOAT32:return $5(t);case P3.PACKED_2X2_FLOAT16:return _5(t);case P3.UNPACKED_FLOAT32:return k5(t);case P3.UNPACKED_FLOAT16:return I5(t);case P3.PACKED_4X1_UNSIGNED_BYTE:return C5(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);if(a){let[t,n]=H3(e[0],e[1]);i=t*n}else{let[t,n]=U3(e[0],e[1]);i=t*n}let s=function(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,o);return i*s}function B6(e,t){if(e===z3.UPLOAD)return P3.PACKED_2X2_FLOAT32;if(e===z3.RENDER||null==e)return function(e){return Rk().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?P3.PACKED_2X2_FLOAT32:P3.UNPACKED_FLOAT32:e?P3.PACKED_2X2_FLOAT16:P3.UNPACKED_FLOAT16}(t);if(e===z3.DOWNLOAD||e===z3.PIXELS)return P3.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function W6(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var V6=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=f5(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},U6="if (isnan(x)) return x;",j6="return x;",H6="return abs(x);",G6="return (x >= 0.0) ? x : (exp(x) - 1.0);",q6=U6+"\n  return (x < 0.0) ? 0.0 : x;\n",K6=U6+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",X6="return x;",Y6="return 1.0 / (1.0 + exp(-1.0 * x));",Q6="return x;",Z6="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",J6="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",e8="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",t8="return 1.0 / (1.0 + exp(-1.0 * x));",n8=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=f5(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},r8=zz.whereImpl,a8={},i8=Rk().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),o8=class extends Fw{nextDataId(){return o8.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Rk().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof B5)t=e;else{let n=V3(Rk().getNumber("WEBGL_VERSION"),e);t=new B5(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let e=V3(Rk().getNumber("WEBGL_VERSION"));t=new B5(e),this.binaryCache=function(e){return e in a8||(a8[e]={}),a8[e]}(Rk().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=B6(t,n),a=W6(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);let i,o=L6(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();let e=this.freeTextures[a].pop();return this.usedTextures[a].push(e),e}return r===P3.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===P3.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===P3.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===P3.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===P3.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;let a=B6(n,r),i=W6(t,a,r);i in this.freeTextures||(this.freeTextures[i]=[]);let o=L6(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),s=Rk().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==s&&this._numBytesAllocated>s?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;let l=this.usedTextures[i],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(let e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}(this.gpgpu),this.numMBBeforeWarning=null==Rk().global.screen?1024:Rk().global.screen.height*Rk().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Rw(this,U$())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,a,i){let o=this.makeTensorInfo(t,n),s=this.texData.get(o.dataId);s.isPacked=!1,s.texture={texture:e,texShape:[r,a]},s.texShape=[r,a];let l=E4(t),u=new g5(l,!1,i),d=this.runWebGLProgram(u,[o],n,[[r,a]]);return d.shape=t,s.texture=null,this.disposeIntermediateTensorInfo(o),d.dataId}write(e,t,n){if((Rk().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Rk().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:z3.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,r,a){if(Rk().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:z3.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:i,shape:o,isPacked:s}=t;if(null!=i){let t;t=s?new n8(o,X6):new V6(o,X6);let n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;let l,u,d=null!=this.activeTimers;if(d&&(l=fC.now()),"complex64"===r){let e=this.readSync(a.real.dataId),t=this.readSync(a.imag.dataId);u=AO.mergeRealAndImagArrays(e,t)}else u=this.getValuesFromTexture(e);return d&&(this.downloadWaitMs+=fC.now()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){let t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}let t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:i,complexTensorInfos:o,isPacked:s}=t;if(null!=a){let t;t=s?new n8(r,X6):new V6(r,X6);let n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:i}],i),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(Rk().getBool("DEBUG")&&!Rk().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Rk().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,d=null;if("complex64"!==i&&Rk().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);let t=this.texData.get(l.dataId);d=this.gpgpu.createBufferFromTexture(t.texture.texture,...j3(r))}if(this.pendingRead.set(e,[]),"complex64"!==i&&await this.gpgpu.createAndWaitForFence(),"complex64"===i){let e=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),t=e[0],n=e[1];u=AO.mergeRealAndImagArrays(t,n)}else if(null==d)u=this.getValuesFromTexture(e);else{let e=fC.sizeFromShape(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(d,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=d){let e=this.gpgpu.gl;q3(e,(()=>e.deleteBuffer(d)))}let c=this.convertAndCacheOnCPU(e,u),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach((e=>e(c))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&U$().removeDataId(e,this),this.pendingDeletes--),c}readToGPU(e,t={}){let n=this.texData.get(e),{values:r,shape:a,slice:i,dtype:o,isPacked:s,texture:l}=n;if("complex64"===o)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=i){let n;n=s?new n8(a,X6):new V6(a,X6);let r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:o}],o),i=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),i}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=this.decode(e,t.customTexShape),d=U$().makeTensorFromTensorInfo(u),c=this.texData.get(u.dataId);return Object.assign({tensorRef:d},c.texture)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>fC.decodeString(e)));return D$(e.shape,e.dtype,n)}catch(Ep){throw new Error("Failed to decode encoded string bytes into utf-8")}return D$(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){let n=e[t];if(!Y3(n))throw Rk().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=fC.sizeFromShape(t);if(Rk().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let n=this.decode(e),r=this.texData.get(n.dataId),i=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...j3(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),i}let i=Rk().getBool("WEBGL_PACK")&&!0===r,o=i?E4(t):t,s=i?new class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=z3.DOWNLOAD;let t=G4();this.outputShape=e,this.userCode=`\n      ${Q4}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}(o):new class{constructor(e){this.variableNames=["A"],this.outTexUsage=z3.DOWNLOAD;let t=G4();this.outputShape=e,this.userCode=`\n      ${Q4}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}(o),l=this.runWebGLProgram(s,[{shape:o,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),d}timerAvailable(){return Rk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let a=fC.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),i=fC.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Rk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let e=await Promise.all(a);o.kernelMs=fC.sum(e),o.getExtraProfileInfo=()=>e.map(((e,t)=>({name:i[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Rk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:fC.now(),endMs:null}}endTimer(e){return Rk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=fC.now(),e)}async getQueryTime(e){if(Rk().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:a,isPacked:i,slice:o}=this.texData.get(e),s=o&&o.origDataId||e,l=this.dataRefCount.get(s);l>1?this.dataRefCount.set(s,l-1):(this.dataRefCount.delete(s),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,i)));let u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=i8){return Rk().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&fC.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){AO.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return r8(e.shape,t)}packedUnaryOp(e,t,n){let r=new n8(e.shape,t),a=this.compileAndRun(r,[e],n);return U$().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){let t=x6(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Rk().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,H6,e.dtype);let t=new V6(e.shape,H6),n=this.compileAndRun(t,[e]);return U$().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&fC.isString(n[0])){let a=n.map((e=>fC.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return U$().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=f5(this.outputShape.length);let t=e.length,n=z6("rc",t),r=l5(t),a=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),i=n.slice(-2),o=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=f5(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{let e=z6("rc",this.rank),t=l5(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){let t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){let n=[T4(e.shape),...$4(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[T4(t),...$4(t)],i=new P6(a,n),o=[n],s=this.runWebGLProgram(i,[r],e.dtype,o,!0);return{dataId:s.dataId,shape:t,dtype:s.dtype}}decode(e,t){let n=this.texData.get(e),{isPacked:r,shape:a,dtype:i}=n;if(null!=t){let e=fC.sizeFromShape(a),n=t[0]*t[1]*4;fC.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}let o,s=E4(a);o=r?new class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=O3.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=G4();this.outputShape=e,this.enableShapeUniforms=f5(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?K4(["r","c","d"],e):q4(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}(s):new class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=O3.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=G4();this.outputShape=e,this.enableShapeUniforms=f5(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?K4(["r","c","d"],e):q4(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}(s);let l=[null!=t?t:j3(s)];return{dtype:i,shape:a,dataId:this.runWebGLProgram(o,[{shape:s,dtype:i,dataId:e}],i,l,!0,t).dataId}}runWebGLProgram(e,t,n,r,a=!1,i){let o=this.makeTensorInfo(e.outputShape,n),s=this.texData.get(o.dataId);if(e.packedOutput&&(s.isPacked=!0),e.outPackingScheme===O3.DENSE){let t=null!=i?i:j3(e.outputShape);s.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(s.usage=e.outTexUsage),0===fC.sizeFromShape(o.shape))return s.values=fC.getTypedArrayFromDType(o.dtype,0),o;let l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&fC.sizeFromShape(t.shape)<=Rk().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!R4(n.shape,t.shape)){let e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(o.dataId);let d,c={shape:o.shape,texData:s,isUniform:!1},p=function(e,t,n){let r="";t.concat(n).forEach((t=>{let a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){let i=t.texData.texShape,{useSqueezeShape:o,uniformShape:s,keptDims:l}=u5(e.packedInputs,t.shape,i),u="",d="",c="";if(1===s.length&&e.packedInputs){let e=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==s.length||e.packedInputs){if(s.length>2&&!e.packedInputs){let e=fC.computeStrides(s);c=`${e[0]===i[1]}_${e[e.length-1]===i[1]}`}}else d=`${s[0]>1}_${s[1]>1}`;let p=t.shape.length,h=2===s.length&&fC.arraysEqual(t.shape,i),f=1===fC.sizeFromShape(t.shape),m=AO.getBroadcastDims(t.shape,n.shape),g=!e.packedInputs&&p===n.shape.length&&fC.arraysEqual(i,n.texData.texShape),b=e.packedInputs||s.length>2?"":`${i[0]>1}_${i[1]>1}`;r+=`${p}_${g}_${o?l:""}_${s.length}_${f}_${m}_${h}_${u}_${d}_${c}_${b}_${a}`}else{let e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));let a=e.userCode,i=e.constructor.name;return i+="_"+r+"_"+a+`${Rk().getNumber("WEBGL_VERSION")}`,i}(e,u,c),h=this.getAndSaveBinary(p,(()=>function(e,t,n,r){let a=n.map(((e,n)=>{let r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),i=a.map((e=>e.shapeInfo)),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},s=J4(a,o,t),l=e4(e.gl,s),u=e.createProgram(l);return Rk().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:s,webGLProgram:u,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:s,webGLProgram:u,inShapeInfos:i,outShapeInfo:o},p5(e,t,u)))}(this.gpgpu,e,u,c))),f=null!=this.activeTimers;f&&(d=this.startTimer()),Rk().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,a){t.program.enableShapeUniforms||(h5(t.inShapeInfos,n),h5([t.outShapeInfo],[r]));let i=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):e.setOutputMatrixTexture(i.texture,o[0],o[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===Rk().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let r=n[l],{uniform:a,offset:i,shape:o,texShape:s}=t.variablesLocations[l];if(o){let{uniformShape:n}=u5(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(o,new Int32Array(n));break;case 2:e.gl.uniform2iv(o,new Int32Array(n));break;case 3:e.gl.uniform3iv(o,new Int32Array(n));break;case 4:e.gl.uniform4iv(o,new Int32Array(n))}}if(s&&e.gl.uniform2i(s,r.texData.texShape[0],r.texData.texShape[1]),null!=a){if(r.isUniform){if(fC.sizeFromShape(r.shape)<2)e.gl.uniform1f(a,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}continue}null!=r.texData.slice&&null!=i&&e.gl.uniform1i(i,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,a,l)}}let s=t.outShapeLocation;if(s)switch(r.shape.length){case 1:e.gl.uniform1iv(s,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(s,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(s,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(s,new Int32Array(r.shape))}if(t.outShapeStridesLocation){let n=fC.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let l=0;l<t.program.customUniforms.length;++l){let n=t.program.customUniforms[l],r=t.customUniformLocations[l],i=a[l];if("float"===n.type)e.gl.uniform1fv(r,i);else if("vec2"===n.type)e.gl.uniform2fv(r,i);else if("vec3"===n.type)e.gl.uniform3fv(r,i);else if("vec4"===n.type)e.gl.uniform4fv(r,i);else if("int"===n.type)e.gl.uniform1iv(r,i);else if("ivec2"===n.type)e.gl.uniform2iv(r,i);else if("ivec3"===n.type)e.gl.uniform3iv(r,i);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,i)}}e.executeProgram()}(this.gpgpu,h,u,c,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),f&&(d=this.endTimer(d),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(d)}));let m=Rk().get("WEBGL_FLUSH_THRESHOLD");if(m>0){let e=fC.now();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!Rk().getBool("WEBGL_LAZILY_UNPACK")&&s.isPacked&&!1===a){let e=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),e}return o}compileAndRun(e,t,n,r,a=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Rk().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=G$((()=>{if(!Rk().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=Rk().getBool("DEBUG");Rk().set("DEBUG",!1);let t=this.abs(X_(1e-8)).dataSync()[0];if(Rk().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:i,usage:o,isPacked:s}=t;if(null!=i)return;let l,u=null!=this.activeTimers;u&&(l=fC.now());let d=t.texShape;if(null==d&&(d=_4(n,s),t.texShape=d),null!=a){let e,i=E4(n),o=d[1],c=d[0],p=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(s||!p)&&([o,c]=H3(d[0],d[1])),e=s?new class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=G4();this.outputShape=e,this.enableShapeUniforms=f5(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let t=0;t<=1;t++){let a=2*i+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${i};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Y4(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}}(i,p):new g5(i,p);let h=p?[c,o]:d,f=this.makeTensorInfo(h,r),m=this.texData.get(f.dataId);m.usage=p?z3.PIXELS:z3.UPLOAD,m.texShape=h,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),o,c,a);let g=[[c,o]],b=!0,y=this.runWebGLProgram(e,[f],r,g,b),v=this.texData.get(y.dataId);t.texShape=v.texShape,t.isPacked=v.isPacked,t.usage=v.usage,Rk().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=v.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),u&&(this.uploadWaitMs+=fC.now()-l)}else{let e=this.acquireTexture(d,o,r,s);t.texture=e}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){let n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){let e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*fC.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(Rp){throw Rp}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await EO(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(a4(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:s}=p5(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.outShapeLocation=i,e.outShapeStridesLocation=o,e.outTexShapeLocation=s}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";let{texture:r,height:a,width:i,channels:o}=e,s=U$().backend;if(!s.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let l=s.writeTexture(r,t,n,a,i,o);return U$().makeTensorFromDataId(l,t,n,s)}};o8.nextDataId=0;var s8="4.7.0";function l8(){Rk().set("WEBGL_FORCE_F16_TEXTURES",!0)}ST.isBrowser()&&nE("webgl",(()=>new o8),2);var u8={forceHalfFloat:l8},d8="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",c8=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=AO.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=f5(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}},p8="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n",h8=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=AO.assertAndGetBroadcastShape(t,n);let a=this.outputShape.length;this.enableShapeUniforms=f5(a);let i="";if(r)if(0===a||1===fC.sizeFromShape(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${l5(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?i+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":i+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{let e=z6("coords",a);this.enableShapeUniforms?i+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:i+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}};function f8(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var m8={kernelName:JS,backendName:"webgl",kernelFunc:f8};function g8(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,i=n.makeTensorInfo(r.shape,"complex64"),o=n.texData.get(i.dataId),s=f8({inputs:{x:r},backend:n}),l=f8({inputs:{x:a},backend:n});return o.complexTensorInfos={real:s,imag:l},i}var b8={kernelName:dS,backendName:"webgl",kernelFunc:g8},y8="return (a < 0.) ? b * a : a;",v8="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",x8={kernelName:iI,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:i}=r,o=n.makeTensorInfo([],"float32",fC.createScalarValue(i,"float32")),s=Rk().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new h8(v8,a.shape,o.shape):new c8(y8,a.shape,o.shape),l=n.runWebGLProgram(s,[a,o],"float32");return n.disposeIntermediateTensorInfo(o),l}},w8="return (a < 0.) ? b * a : a;",k8="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",S8={kernelName:HI,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,i=Rk().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new h8(k8,r.shape,a.shape):new c8(w8,r.shape,a.shape);return n.runWebGLProgram(i,[r,a],"float32")}},I8="if (isnan(x)) return x;";function N8({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:i})=>{let o,{x:s}=a,l=i,u=r||s.dtype;if(l.shouldExecuteOnCPU([s])&&null!=n){let e=l.texData.get(s.dataId),t=n(e.values,u);return l.makeTensorInfo(s.shape,u,t)}return o=Rk().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new n8(s.shape,t):new V6(s.shape,e),l.runWebGLProgram(o,[s],u)}}function C8({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:i}){return({inputs:o,backend:s})=>{let{a:l,b:u}=o,d=s;if(r&&"complex64"===l.dtype){let t=d.texData.get(l.dataId),n=d.texData.get(u.dataId),[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{let[n,r]=t,a={dataId:n.dataId,dtype:n.dtype,shape:l.shape},i={dataId:r.dataId,dtype:r.dtype,shape:u.shape},o=new c8(e,l.shape,u.shape);return d.runWebGLProgram(o,[a,i],sT(n.dtype,r.dtype))})),i=g8({inputs:{real:r,imag:a},backend:d});return d.disposeIntermediateTensorInfo(r),d.disposeIntermediateTensorInfo(a),i}let c,p=i||sT(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||d.shouldExecuteOnCPU([l,u]))&&null!=a){let e=d.texData.get(l.dataId).values,t=d.texData.get(u.dataId).values,n="string"===l.dtype?AO.fromUint8ToStringArray(e):e,r="string"===l.dtype?AO.fromUint8ToStringArray(t):t,[i,o]=a(l.shape,u.shape,n,r,p),s=d.makeTensorInfo(o,p);return d.texData.get(s.dataId).values=i,s}return c=Rk().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new h8(t,l.shape,u.shape,n):new c8(e,l.shape,u.shape),d.runWebGLProgram(c,[l,u],p)}}function T8(e,t=!1){if("linear"===e)return t?Q6:j6;if("relu"===e)return t?J6:q6;if("elu"===e)return t?Z6:G6;if("relu6"===e)return t?e8:K6;if("prelu"===e)return t?k8:w8;if("leakyrelu"===e)return t?v8:y8;if("sigmoid"===e)return t?t8:Y6;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var $8=class{constructor(e,t,n,r=!1,a=!1,i=!1,o=null,s=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=f5(this.outputShape.length);let u=r?e[1]:e[2],d=Math.ceil(u/2),c=r?"i * 2, rc.y":"rc.y, i * 2",p=a?"rc.z, i * 2":"i * 2, rc.z",h=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";o&&(m=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`:`vec4 activation(vec4 x) {\n          ${o}\n        }`,g="result = activation(result);");let b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",v="rc.x";e[0]<t[0]?y=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(v=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${y};\n        int batchB = ${v};\n        for (int i = 0; i < ${d}; i++) {\n          vec4 a = getMatrixA(batchA, ${c});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${f[0]});\n          result += (${h[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}},E8={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},_8=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=AO.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}},A8="return a * b;";function R8(e){let t,{inputs:n,backend:r}=e,{a:a,b:i}=n,o=AO.upcastType(a.dtype,i.dtype);if("complex64"===a.dtype){let e=r.texData.get(a.dataId),t=r.texData.get(i.dataId),n=new _8(E8.REAL,a.shape,i.shape),o=new _8(E8.IMAG,a.shape,i.shape),s=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:i.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:i.shape}],l=r.runWebGLProgram(n,s,"float32"),u=r.runWebGLProgram(o,s,"float32"),d=g8({inputs:{real:l,imag:u},backend:r});return r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(u),d}if(r.shouldExecuteOnCPU([a,i])){let e=r.texData.get(a.dataId),t=r.texData.get(i.dataId),[n,s]=u6(a.shape,i.shape,e.values,t.values,o),l=r.makeTensorInfo(s,o);return r.texData.get(l.dataId).values=n,l}return t=Rk().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new h8(A8,a.shape,i.shape):new c8(A8,a.shape,i.shape),r.runWebGLProgram(t,[a,i],o)}var F8={kernelName:FI,backendName:"webgl",kernelFunc:R8};function D8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:i}=r,o=n,s=fC.sizeFromShape(a.shape),l=fC.inferFromImplicitShape(i,s),u=fC.sizeFromShape(l);fC.assert(s===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`));let d=o.texData.get(a.dataId);return!d.isPacked||R4(a.shape,l)||null!==d.texture&&R4(d.shape,l)?(o.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):function(e,t,n){let r=[T4(e.shape),...$4(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},i=[T4(t),...$4(t)],o=new P6(i,r),s=[r],l=n.runWebGLProgram(o,[a],e.dtype,s,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(a,l,o)}var M8={kernelName:eN,backendName:"webgl",kernelFunc:D8},O8=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:i}=e;this.outputShape=[r,i];let o=4*Math.floor(n/4),s=n%4,l="sumValue += dot(values, ones);";if(null!=t){let e=1/t;l=`sumValue += dot(values * ${fC.isInt(e)?e.toPrecision(2):e}, ones);`}let u="";a%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===s}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===s}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===s}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}},z8=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:i}=e;this.outputShape=[r,i];let o="0.0",s="";"prod"===t?o="1.0":"min"===t?(o="1.0 / 1e-20",s="min"):"max"===t&&(o="-1.0 / 1e-20",s="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");let u=4*Math.floor(n/4),d=n%4,c=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${s}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${s}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,p="vec4";"all"===t?(o="1.0",c="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===t&&(o="0.0",c="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let h="";a%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${c}\n        } else if (${2===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${c}\n        } else if (${3===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${c}\n        }\n        setOutput(${l});\n      }\n    `}};function P8(e,t,n,r){let a=function(e){let t=[];for(;0===t.length||1!==t[t.length-1].outSize;){let n=t.length?t[t.length-1].outSize:e[1],r=AO.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape),i=e;for(let o=0;o<a.length;o++){let s,l,{inSize:u,windowSize:d,outSize:c}=a[o];s="mean"===n?0===o?new O8({windowSize:d,inSize:u,batchSize:e.shape[0],outSize:c},u):new O8({windowSize:d,inSize:u,batchSize:e.shape[0],outSize:c}):new z8({windowSize:d,inSize:u,batchSize:e.shape[0],outSize:c},n),l=i,i=r.runWebGLProgram(s,[i],t),l.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(l)}return i}var L8=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.rank=n.length;let r=l5(this.rank),a=function(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}},B8=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=l5(this.rank),a=O6("rc",this.rank),i=new Array(this.rank);for(let u=0;u<t.length;u++)i[t[u]]=a[u];let o=`vec2(${i.slice(-2).join()})`,s=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${s}) {\n        result[1] = ${l};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${s}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}};function W8(e,t,n){let r=Rk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new B8(e.shape,t):new L8(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function V8(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:o}=r;return function(e,t,n,r){let a=t,i=e.shape.length,o=fC.parseAxisParam(a,e.shape),s=o,l=AO.getAxesPermutation(s,i),u=null!=l,d=e;u&&(d=W8(e,l,r),s=AO.getInnerMostAxes(s.length,i)),AO.assertAxesAreInnerMostDims("sum",s,i);let[c,p]=AO.computeOutAndReduceShapes(d.shape,s),h=c;n&&(h=AO.expandShapeToKeepDim(c,o));let f=fC.sizeFromShape(p),m=D8({inputs:{x:d},attrs:{shape:[fC.sizeFromShape(e.shape)/f,f]},backend:r}),g=P8(m,lT(e.dtype),"sum",r),b=D8({inputs:{x:g},attrs:{shape:h},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(d),b}(a,i,o,n)}var U8={kernelName:wN,backendName:"webgl",kernelFunc:V8};function j8(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i}=n,{perm:o}=a,s=r,l=i.shape.length,u=new Array(l);for(let d=0;d<u.length;d++)u[d]=i.shape[o[d]];if(s.shouldExecuteOnCPU([i])){let e=s.texData.get(i.dataId).values,n=D6(e,i.shape,i.dtype,o,u);t=s.makeTensorInfo(u,i.dtype),s.texData.get(t.dataId).values=n}else t=W8(i,o,s);return t}var H8={kernelName:UN,backendName:"webgl",kernelFunc:j8},G8=1e3;function q8({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:s=0,activation:l=null}){let u=e.shape.length,d=t.shape.length,c=n?e.shape[u-2]:e.shape[u-1],p=r?t.shape[d-1]:t.shape[d-2],h=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[d-2]:t.shape[d-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),b=fC.sizeFromShape(m),y=fC.sizeFromShape(g),v=N_.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,f]);fC.assert(c===p,(()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));let x,w=n?[b,c,h]:[b,h,c],k=r?[y,f,p]:[y,p,f],S=D8({inputs:{x:e},backend:a,attrs:{shape:w}}),I=D8({inputs:{x:t},backend:a,attrs:{shape:k}}),N=[S,I],C=Math.max(b,y),T=n?S.shape[1]:S.shape[2],$=null!=i,E=null!=o,_="leakyrelu"===l,A=null!=l?T8(l,!0):null;if((1===h||1===f)&&T>G8&&!1===($||E||_||null!=A)){let e=S,t=I;n&&(e=j8({inputs:{x:S},backend:a,attrs:{perm:[0,2,1]}}),N.push(e)),r&&(t=j8({inputs:{x:I},backend:a,attrs:{perm:[0,2,1]}}),N.push(t));let i=1===f,o=e;1!==f&&(o=D8({inputs:{x:e},backend:a,attrs:{shape:[C,T,1]}}),N.push(o));let s=1===f?2:1,l=t;i&&(l=D8({inputs:{x:t},backend:a,attrs:{shape:[C,1,T]}}),N.push(l));let u=R8({inputs:{a:o,b:l},backend:a});x=V8({inputs:{x:u},backend:a,attrs:{axis:s,keepDims:!0}}),N.push(u)}else{let l=sT(e.dtype,t.dtype),u=new $8(w,k,[C,h,f],n,r,$,A,E,_),d=[S,I];if(null!=i&&d.push(i),E&&d.push(o),_){let e=a.makeTensorInfo([],"float32",fC.createScalarValue(s,"float32"));d.push(e),N.push(e)}x=a.runWebGLProgram(u,d,l)}let R=D8({inputs:{x:x},backend:a,attrs:{shape:v}});N.push(x);for(let F of N)a.disposeIntermediateTensorInfo(F);return R}var K8={kernelName:ZN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:i,bias:o,preluActivationWeights:s}=t,{transposeA:l,transposeB:u,activation:d,leakyreluAlpha:c}=r;return q8({a:a,b:i,transposeA:l,transposeB:u,backend:n,bias:o,preluActivationWeights:s,leakyreluAlpha:c,activation:d})}},X8="return abs(x);",Y8={kernelName:zk,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){let e=r.texData.get(a.dataId),t=x6(e.values);return r.makeTensorInfo(a.shape,a.dtype,t)}return t=Rk().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new n8(a.shape,X8):new V6(a.shape,X8),r.runWebGLProgram(t,[a],a.dtype)}},Q8=N8({opSnippet:U6+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),Z8={kernelName:Pk,backendName:"webgl",kernelFunc:Q8},J8=N8({opSnippet:U6+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),e7={kernelName:Lk,backendName:"webgl",kernelFunc:J8},t7="return a + b;",n7=C8({opSnippet:t7,packedOpSnippet:t7,supportsComplex:!0,cpuKernelImpl:W5}),r7={kernelName:Bk,backendName:"webgl",kernelFunc:n7},a7={kernelName:Wk,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r}=t,a=n;if(1===a.length)return f8({inputs:{x:a[0]},backend:r});if(a.length>Rk().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let t=Math.floor(a.length/2),n=e({inputs:a.slice(0,t),backend:r}),i=e({inputs:a.slice(t),backend:r});return e({inputs:[n,i],backend:r})}let i=a.map((e=>e.dtype)).reduce(((e,t)=>sT(e,t))),o=a.map((e=>e.shape)),s=Rk().getBool("WEBGL_PACK")?new class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}(a[0].shape,o):new class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}(a[0].shape,o);return r.runWebGLProgram(s,a,i)}},i7={kernelName:Vk,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:o}=r,s=a.shape.length,l=fC.parseAxisParam(i,a.shape),u=l,d=AO.getAxesPermutation(u,s),c=a;null!=d&&(c=j8({inputs:{x:a},backend:n,attrs:{perm:d}}),u=AO.getInnerMostAxes(u.length,s)),AO.assertAxesAreInnerMostDims("all",u,s);let p,[h,f]=AO.computeOutAndReduceShapes(c.shape,u),m=D8({inputs:{x:c},backend:n,attrs:{shape:[-1,fC.sizeFromShape(f)]}}),g=P8(m,m.dtype,"all",n);return p=D8(o?{inputs:{x:g},backend:n,attrs:{shape:AO.expandShapeToKeepDim(h,l)}}:{inputs:{x:g},backend:n,attrs:{shape:h}}),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(c),p}},o7={kernelName:Uk,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:o}=r,s=a.shape.length,l=fC.parseAxisParam(i,a.shape),u=l,d=AO.getAxesPermutation(u,s),c=a;null!=d&&(c=j8({inputs:{x:a},backend:n,attrs:{perm:d}}),u=AO.getInnerMostAxes(u.length,s)),AO.assertAxesAreInnerMostDims("any",u,s);let p,[h,f]=AO.computeOutAndReduceShapes(c.shape,u),m=D8({inputs:{x:c},backend:n,attrs:{shape:[-1,fC.sizeFromShape(f)]}}),g=P8(m,m.dtype,"any",n);return p=D8(o?{inputs:{x:g},backend:n,attrs:{shape:AO.expandShapeToKeepDim(h,l)}}:{inputs:{x:g},backend:n,attrs:{shape:h}}),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(c),p}},s7=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:a,outSize:i}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,i];let o="max"===t?">":"<",s=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${s};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${o} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}},l7=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,fC.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));let a=e[e.length-1],i=Math.ceil(a/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");let o,s,l=this.outputShape,u=l.length,d=l5(u),c=z6("coords",u);if(1===i){s=u+1;let e=l5(s);o=`\n        ${e} sourceLocR = ${e}(${c.join()}, 0);\n        ++${c[u-1]};\n        ${e} sourceLocG = ${e}(${c.join()}, 0);\n        ++${c[u-2]};\n        ${e} sourceLocA = ${e}(${c.join()}, 0);\n        --${c[u-1]};\n        ${e} sourceLocB = ${e}(${c.join()}, 0);\n        --${c[u-2]};`}else s=u,o=`\n        ${d} sourceLocR = coords;\n        ++${c[u-1]};\n        ${d} sourceLocG = coords;\n        ++${c[u-2]};\n        ${d} sourceLocA = coords;\n        --${c[u-1]};\n        ${d} sourceLocB = coords;\n        --${c[u-2]};`;let p=["x","y","z","w","u","v"].slice(0,s),h="."+p[s-1],f=p.map((e=>"int "+e)),m=z6("sourceLocR",s-1).concat("inIdx.r"),g=z6("sourceLocG",s-1).concat("inIdx.g"),b=z6("sourceLocB",s-1).concat("inIdx.b"),y=z6("sourceLocA",s-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${d} coords = getOutputCoords();\n        bool hasNextCol = ${c[u-1]} < ${l[u-1]-1};\n        bool hasNextRow = ${c[u-2]} < ${l[u-2]-1};\n        ${o}\n        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},\n          sourceLocB${h}, sourceLocA${h}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}};function u7(e,t,n,r=null){let a=t.shape[0],i=t.shape[1];null!=r&&(a=r.shape[0],i=r.shape[1]);let o=AO.computeOptimalWindowSize(i),s={windowSize:o,inSize:i,batchSize:a,outSize:Math.ceil(i/o)},l=new s7(s,n,null==r),u=[t];null!=r&&u.push(r);let d=e.runWebGLProgram(l,u,"int32");if(1===d.shape[1])return d;let c=u7(e,t,n,d);return e.disposeIntermediateTensorInfo(d),c}function d7(e,t,n,r=null){let a=null!=r?r.shape:t.shape,i=a[a.length-1],o=AO.computeOptimalWindowSize(i),s=new l7(a,o,n,null==r),l=null==r?[t]:[t,r],u=e.runWebGLProgram(s,l,"int32");if(u.shape.length===t.shape.length){let r=d7(e,t,n,u);return e.disposeIntermediateTensorInfo(u),r}return u}function c7(e,t,n,r){let a=[n];if(AO.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!Rk().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let n=[],i=e.texData.get(t.dataId),o=t;null!==i&&i.isPacked&&(o=e.unpackTensor(t),n.push(o));let[s,l]=AO.computeOutAndReduceShapes(o.shape,a),u=fC.sizeFromShape(l),d=D8({inputs:{x:o},backend:e,attrs:{shape:[-1,u]}});n.push(d);let c=u7(e,d,r);n.push(c);let p=D8({inputs:{x:c},backend:e,attrs:{shape:s}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),p}return d7(e,t,r)}var p7={kernelName:jk,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i}=r,o=fC.parseAxisParam(i,a.shape),s=AO.getAxesPermutation(o,a.shape.length),l=a,u=[];null!=s&&(l=j8({inputs:{x:a},backend:n,attrs:{perm:s}}),u.push(l),o=AO.getInnerMostAxes(o.length,l.shape.length)),AO.assertAxesAreInnerMostDims("argMax",[o[0]],l.shape.length);let d=c7(n,l,o[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},h7={kernelName:Hk,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i}=r,o=fC.parseAxisParam(i,a.shape),s=AO.getAxesPermutation(o,a.shape.length),l=a,u=[];null!=s&&(l=j8({inputs:{x:a},backend:n,attrs:{perm:s}}),u.push(l),o=AO.getInnerMostAxes(o.length,l.shape.length)),AO.assertAxesAreInnerMostDims("argMin",[o[0]],l.shape.length);let d=c7(n,l,o[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},f7=N8({opSnippet:U6+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),m7={kernelName:Gk,backendName:"webgl",kernelFunc:f7},g7=N8({opSnippet:U6+"return log(x + sqrt(x * x + 1.0));"}),b7={kernelName:qk,backendName:"webgl",kernelFunc:g7},y7=N8({opSnippet:U6+"\n  return atan(x);\n"}),v7={kernelName:Kk,backendName:"webgl",kernelFunc:y7},x7=C8({opSnippet:d8+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+p8+"\n  return result;\n"}),w7={kernelName:Yk,backendName:"webgl",kernelFunc:x7},k7=N8({opSnippet:U6+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),S7={kernelName:Xk,backendName:"webgl",kernelFunc:k7},I7=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,o=e.strideHeight,s=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,d=e.effectiveFilterHeight,c=e.effectiveFilterWidth,p=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;let f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,b="0.0";if(f||(b="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${s});\n        const ivec2 pads = ivec2(${p}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${c};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:g:`wR * ${c} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let y=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(y="avgValue / max(count, 1.0)");let v=4*Math.floor(i/4),x=i%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${s});\n      const ivec2 pads = ivec2(${p}, ${h});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${y});\n      }\n    `}},N7=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,o=e.strideDepth,s=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,d=e.dilationHeight,c=e.dilationWidth,p=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;let y="avg"===t,v="0.0";if(y||(v="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${s}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${c}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");let w=4*Math.floor(i/4),k=i%4,S=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${s}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${b});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${c};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${c}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${c}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${c}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${c}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${c}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${c}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${x});\n      }\n    `}},C7={kernelName:Qk,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;j4(a,"avgPool");let{filterSize:i,strides:o,pad:s,dimRoundingMode:l}=r;fC.assert(AO.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));let u=AO.computePool2DInfo(a.shape,i,o,1,s,l);if(1===u.filterWidth&&1===u.filterHeight&&fC.arraysEqual(u.inShape,u.outShape))return f8({inputs:{x:a},backend:n});let d=new I7(u,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}},T7={kernelName:Jk,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:o,pad:s,dimRoundingMode:l,dataFormat:u}=r,d=AO.computePool3DInfo(a.shape,i,o,[1,1,1],s,l,u),c=new N7(d,"avg",!1);return n.runWebGLProgram(c,[a],"float32")}},$7={kernelName:eS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,o=i,{filterSize:s,strides:l,pad:u,dimRoundingMode:d}=r,c=AO.computePool3DInfo(o.shape,s,l,[1,1,1],u,d),p=new class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,d=e.effectiveFilterDepth,c=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=d-1-e.padInfo.front,f=c-1-e.padInfo.top,m=p-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(c);return n.runWebGLProgram(p,[a],o.dtype)}},E7={kernelName:Zk,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,o=i;j4([a,i],"avgPoolGrad");let{filterSize:s,strides:l,pad:u}=r,d=AO.computePool2DInfo(o.shape,s,l,1,u),c=new class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i=e.dilationHeight,o=e.dilationWidth,s=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=s-1-e.padInfo.top,d=l-1-e.padInfo.left,c=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${d});\n      const float avgMultiplier = float(${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n            wR += ${i}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${o}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(d);return n.runWebGLProgram(c,[a],o.dtype)}},_7={kernelName:tS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:i}=t,{transposeA:o,transposeB:s}=r;return q8({a:a,b:i,transposeA:o,transposeB:s,backend:n})}},A7={kernelName:KS,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:a,variance:i,offset:o,scale:s}=e;fC.assert(a.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),fC.assert(null==o||a.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),fC.assert(null==s||a.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);let u=[r,a,i],d=null;null!=o&&(d=o.shape,u.push(o));let c=null;null!=s&&(c=s.shape,u.push(s));let p=Rk().getBool("WEBGL_PACK_NORMALIZATION")?new class{constructor(e,t,n,r,a,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],AO.assertAndGetBroadcastShape(e,t),AO.assertAndGetBroadcastShape(e,n);let o="vec4(0.0)";null!=r&&(AO.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let s="vec4(1.0)";null!=a&&(AO.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${s};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}(r.shape,a.shape,i.shape,d,c,l):new class{constructor(e,t,n,r,a,i){this.outputShape=[],this.variableNames=["x","mean","variance"],AO.assertAndGetBroadcastShape(e,t),AO.assertAndGetBroadcastShape(e,n);let o="0.0";null!=r&&(AO.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let s="1.0";null!=a&&(AO.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),s="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${s};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}(r.shape,a.shape,i.shape,d,c,l);return t.runWebGLProgram(p,u,u[0].dtype)}},R7=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=l5(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n,r=function(e){if(1===e)return"sourceLoc";if(e<=6)return F7.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);n=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${F7[t]} = start[${t}] + coords.${F7[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${n}\n        setOutput(getSource(${r}));\n      }\n    `}},F7=["x","y","z","w","u","v"],D7=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=l5(this.rank),n=z6("coords",this.rank),r=z6("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${a})`,o=`\n      result.x = ${i};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${i};\n        --${r[this.rank-1]};\n      }\n    `,s=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${i};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${o}\n        ${s}\n        setOutput(result);\n      }\n    `}};function M7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:i,size:o}=r,[s,l]=iO.parseSliceParams(a,i,o);if(iO.assertParamsValid(a,s,l),0===fC.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){let e=n.texData.get(a.dataId),t=w6(e.values,s,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}let{isPacked:u}=n.texData.get(a.dataId),d=iO.isSliceContinous(a.shape,s,l);if(u||!d){let e=Rk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new D7(l):new R7(l),t=[s];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),function(e,t,n,r){let a=r.texData.get(e.dataId),i=r.makeTensorInfo(n,e.dtype),o=r.texData.get(i.dataId);Object.assign(o,a),o.refCount=1,o.shape=n,o.dtype=e.dtype;let s=iO.computeFlatOffset(t,fC.computeStrides(e.shape));a.slice&&(s+=a.slice.flatOffset),o.slice={flatOffset:s,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),i}(a,s,l,n)}var O7={kernelName:fN,backendName:"webgl",kernelFunc:M7},z7={kernelName:nS,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,crops:o}=r;fC.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));let s=i.reduce(((e,t)=>e*t)),l=AO.getReshaped(a.shape,i,s),u=AO.getPermuted(l.length,i.length),d=AO.getReshapedPermuted(a.shape,i,s),c=AO.getSliceBeginCoords(o,i.length),p=AO.getSliceSize(d,o,i.length),h=[],f=D8({inputs:{x:a},backend:n,attrs:{shape:l}}),m=j8({inputs:{x:f},backend:n,attrs:{perm:u}}),g=D8({inputs:{x:m},backend:n,attrs:{shape:d}}),b=M7({inputs:{x:g},backend:n,attrs:{begin:c,size:p}});return h.push(f),h.push(m),h.push(g),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},P7={kernelName:rS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:i}=t,{size:o}=r,s=n.readSync(a.dataId),l=n.readSync(i.dataId),u=V5(s,l,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,u)}},L7={kernelName:aS,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{a:a,b:i}=n,o=Rk().getBool("WEBGL_PACK_BINARY_OPERATIONS"),s=Rk().getNumber("WEBGL_VERSION");if(r.shouldExecuteOnCPU([a,i])||1===s){let e=r.texData.get(a.dataId).values,t=r.texData.get(i.dataId).values,[n,o]=j5(a.shape,i.shape,e,t,a.dtype),s=r.makeTensorInfo(o,a.dtype);return r.texData.get(s.dataId).values=n,s}return t=o?new h8("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",a.shape,i.shape,!1):new c8("\n  return float(int(a.r) & int(b.r));\n",a.shape,i.shape),r.runWebGLProgram(t,[a,i],a.dtype)}},B7={kernelName:oS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,i=n.readSync(r.dataId),o=n.readSync(a.dataId),s=AO.assertAndGetBroadcastShape(Array.from(i),Array.from(o));return n.makeTensorInfo([s.length],"int32",Int32Array.from(s))}},W7=C8({opSnippet:"return float(a != b);",cpuKernelImpl:c6,dtype:"bool"}),V7={kernelName:MI,backendName:"webgl",kernelFunc:W7};function U7(e){let{inputs:t,backend:n}=e,{input:r}=t;return f8({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}var j7={kernelName:QI,backendName:"webgl",kernelFunc:U7},H7="return float(int(x));",G7={kernelName:sS,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r,attrs:a}=t,{x:i}=n,{dtype:o}=a;if("complex64"===o){if("complex64"===i.dtype)return f8({inputs:{x:i},backend:r});let t=qA(i.shape),n=e({inputs:{x:i},backend:r,attrs:{dtype:"float32"}}),a=g8({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),a}if("complex64"===i.dtype){let t=U7({inputs:{input:i},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:o}});return r.disposeIntermediateTensorInfo(t),n}if(!fC.hasEncodingLoss(i.dtype,o)){let e=f8({inputs:{x:i},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:o}}if(r.shouldExecuteOnCPU([i])){let e=r.texData.get(i.dataId).values,[t,n,a]=H5(e,i.shape,i.dtype,o);return r.makeTensorInfo(t,n,a)}if("int32"===o)return function(e,t){let n=new V6(e.shape,H7),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(i,r);if("bool"===o){let e=r.makeTensorInfo([],"bool",fC.getTypedArrayFromDType("bool",1)),t=W7({inputs:{a:i,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${o}`)}},q7="return ceil(x);",K7=N8({opSnippet:q7,packedOpSnippet:q7,cpuKernelImpl:G5}),X7={kernelName:lS,backendName:"webgl",kernelFunc:K7},Y7={kernelName:uS,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i}=n,{clipValueMin:o,clipValueMax:s}=a;t=Rk().getBool("WEBGL_PACK_CLIP")?new class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}(i.shape):new class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}(i.shape);let l=[[o],[s]];return r.runWebGLProgram(t,[i],i.dtype,l)}};function Q7(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}var Z7={kernelName:cS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),i=new class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}(r.shape),o=[Q7(r,a.complexTensorInfos.real),Q7(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(i,o,o[0].dtype)}},J7=class{constructor(e){this.outputShape=[],this.outputShape=AO.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));let t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){let e=t[i-1];n.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${e}));`)}let r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}},e9=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=AO.computeOutShape(e,t);let n=this.outputShape,r=n.length,a=l5(r),i=z6("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));let s=new Array(e.length-1);s[0]=e[0][t];for(let f=1;f<s.length;f++)s[f]=s[f-1]+e[f][t];let l=o[t],u=o.slice(-2),d=o.join(),c=`if (${l} < ${s[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${u.join()}));\n        }`;for(let f=1;f<s.length;f++){let e=s[f-1];c+=`\n        if (${l} < ${s[f]}  && ${l} >= ${s[f-1]}) {\n          return getChannel(\n            getT${f}(${t9(o,l,e)}),\n            vec2(${t9(u,l,e)}));\n        }`}let p=s.length,h=s[s.length-1];c+=`\n        return getChannel(\n          getT${p}(${t9(o,l,h)}),\n          vec2(${t9(u,l,h)}));`,this.userCode=`\n      float getValue(${o.map((e=>"int "+e))}) {\n        ${c}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[r-1]} = ${i[r-1]} + 1;\n        if (${i[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[r-2]} = ${i[r-2]} + 1;\n        if (${i[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[r-1]} = ${i[r-1]} - 1;\n        if (${i[r-2]} < ${n[r-2]} &&\n            ${i[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}};function t9(e,t,n){let r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function n9(e){let{inputs:t,backend:n}=e,{input:r}=t;return f8({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}var r9={kernelName:tI,backendName:"webgl",kernelFunc:n9};function a9(e,t,n){let r=e[0].dtype;if("complex64"===r){let r=e.map((e=>U7({inputs:{input:e},backend:n}))),a=e.map((e=>n9({inputs:{input:e},backend:n}))),i=a9(r,t,n),o=a9(a,t,n),s=g8({inputs:{real:i,imag:o},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),s}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){let a=e.map((e=>{let r=[-1,fC.sizeFromShape(e.shape.slice(t))];return D8({inputs:{x:e},backend:n,attrs:{shape:r}})})),i=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),o=AO.computeOutShape(a.map((e=>e.shape)),1),s=1===a[0].shape[0],l=q5(i,o,r,s),u=AO.computeOutShape(e.map((e=>e.shape)),t),d=n.makeTensorInfo(u,r,l);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}let i=e.filter((e=>fC.sizeFromShape(e.shape)>0)),o=Rk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(1===i.length){let t=o?new V6(e[0].shape,X6):new n8(e[0].shape,X6);return n.runWebGLProgram(t,e,r)}let s=Rk().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>s){let e=[];for(let a=0;a<i.length;a+=s){let r=i.slice(a,a+s);e.push(a9(r,t,n))}let r=a9(e,t,n);for(let t of e)n.disposeIntermediateTensorInfo(t);return r}if(o){let e=new e9(i.map((e=>e.shape)),t);return n.runWebGLProgram(e,i,r)}let{tensors2D:l,outShape:u}=function(e,t,n){let r=AO.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>D8({inputs:{x:e},attrs:{shape:[-1,fC.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:r}}(i,t,n),d=new J7(l.map((e=>e.shape))),c=n.runWebGLProgram(d,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));let p=D8({inputs:{x:c},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(c),p}function i9(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,i=fC.parseAxisParam(a,t[0].shape)[0],o=t.map((e=>e.shape));AO.assertParamsConsistent(o,i);let s=AO.computeOutShape(t.map((e=>e.shape)),i);if(0===fC.sizeFromShape(s))return n.makeTensorInfo(s,t[0].dtype,[]);let l=t.filter((e=>fC.sizeFromShape(e.shape)>0));return 1===l.length?f8({inputs:{x:l[0]},backend:n}):a9(l,i,n)}var o9={kernelName:pS,backendName:"webgl",kernelFunc:i9},s9=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let i=e.padInfo.top,o=e.padInfo.left,s=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,d=e.dilationWidth,c=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,b=m?2:3,y=m?3:1,v="",x="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");let w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${s}, ${l});\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${x}\n        setOutput(result);\n      }\n    `}},l9=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=f5(this.outputShape.length);let i=e.padInfo.left,o=e.strideWidth,s=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,d=u,c="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)c+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;c+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let m=0;m<u;m++)c+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;c+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(d+1)/2;m++){let t=2*m;if(c+=`\n           xC = xCCorner + ${t*s};\n           `,1===o){if(t<u&&(i%2==1?(c+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,c+=1===s&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):c+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<u)){let e=i%2==0?fC.nearestLargerEven(s):s;s%2==0&&i%2==1||s%2!=0&&i%2!=1?(c+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,c+=s>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):c+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<u&&(i%2==1?(c+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<u&&(c+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(c+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<u&&(c+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<u&&(c+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<u&&(c+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}c+="\n     }\n   ",c+="\n     }\n   ",c+="\n     }\n   ";let p="",h="";n&&(p=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,h="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${p}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${c}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${h}\n         setOutput(result);\n       }\n     `}},u9=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=f5(this.outputShape.length);let{dataFormat:n}=t,r=G4(),a="channelsLast"===n,i=a?1:2,o=a?2:3,s=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${u};\n\n          ${s}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${i}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${o}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}};function d9(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function c9({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:s=null}){let l,u=e.shape,d=r.texData.get(e.dataId),c=n.inChannels,p=u[0]*u[1]*u[2],h=n.outChannels,f="channelsLast"===n.dataFormat,m=[];if(null!=i){let e=d9(i.shape,f);null!=e&&(i=D8({inputs:{x:i},backend:r,attrs:{shape:e}}),m.push(i))}if(null!=a){let e=d9(a.shape,f);null!=e&&(a=D8({inputs:{x:a},backend:r,attrs:{shape:e}}),m.push(a))}if((1!==p&&1!==h||!(c>G8))&&d.isPacked&&f&&null!=d.texture&&u[2]%2!=0&&fC.arraysEqual(d.shape.slice(-3),u.slice(-3))){let c=u[0]*u[1]*(u[2]+1),p={dataId:e.dataId,shape:[1,c,n.inChannels],dtype:e.dtype},h=d.shape;d.shape=d.shape.slice(),d.shape[d.shape.length-2]++,fC.assert(R4(d.shape,p.shape),(()=>`packed reshape ${d.shape} to ${p.shape} isn't free`));let f=D8({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});m.push(f);let g=q8({a:p,b:f,backend:r,transposeA:!1,transposeB:!1,bias:a,activation:s,preluActivationWeights:i,leakyreluAlpha:o}),b=r.texData.get(g.dataId);fC.assert(b.isPacked,(()=>"batchMatMul result is expected to be packed")),d.shape=h,b.shape=n.outShape,l=f8({inputs:{x:g},backend:r}),l.shape=n.outShape,m.push(g)}else{let u=n.outHeight*n.outWidth,d=D8({inputs:{x:e},backend:r,attrs:{shape:f?[n.batchSize,u,n.inChannels]:[n.batchSize,n.inChannels,u]}}),c=D8({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),p=q8({a:f?d:c,b:f?c:d,transposeA:!f,transposeB:!1,backend:r,bias:a,activation:s,preluActivationWeights:i,leakyreluAlpha:o});l=D8({inputs:{x:p},backend:r,attrs:{shape:n.outShape}}),m.push(d),m.push(c),m.push(p)}for(let g of m)r.disposeIntermediateTensorInfo(g);return l}function p9({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:s=null}){let{filterWidth:l,filterHeight:u,inChannels:d,outWidth:c,outHeight:p,dataFormat:h}=n,f="channelsLast"===h,m=l*u*d,g=p*c,b=[n.batchSize,m,g],y=[];if(null!=i){let e=d9(i.shape,f);null!=e&&(i=D8({inputs:{x:i},backend:r,attrs:{shape:e}}),y.push(i))}if(null!=a){let e=d9(a.shape,f);null!=e&&(a=D8({inputs:{x:a},backend:r,attrs:{shape:e}}),y.push(a))}let v=D8({inputs:{x:t},backend:r,attrs:{shape:[1,m,fC.sizeFromShape(t.shape)/m]}});y.push(v);let x=new u9(b,n),w=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],k=r.runWebGLProgram(x,[e],"float32",w),S=D8({inputs:{x:k},backend:r,attrs:{shape:b}});y.push(k),y.push(S);let I=null!=a,N=null!=i,C="leakyrelu"===s,T=s?T8(s,!0):null,$=new $8(f?S.shape:v.shape,f?v.shape:S.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],!0,!1,I,T,N,C),E=f?[S,v]:[v,S];if(a&&E.push(a),N&&E.push(i),C){let e=r.makeTensorInfo([],"float32",fC.createScalarValue(o,"float32"));E.push(e),y.push(e)}let _=r.runWebGLProgram($,E,"float32"),A=D8({inputs:{x:_},backend:r,attrs:{shape:n.outShape}});y.push(_);for(let R of y)r.disposeIntermediateTensorInfo(R);return A}var h9,f9={kernelName:hS,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i,filter:o}=n,{strides:s,pad:l,dataFormat:u,dilations:d,dimRoundingMode:c}=a,p=AO.convertConv2DDataFormat(u),h=AO.computeConv2DInfo(i.shape,o.shape,s,d,l,c,!1,p);if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===p&&Rk().getBool("WEBGL_EXP_CONV")){let e=new l9(h),n=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];t=r.runWebGLProgram(e,[i,o],"float32",n)}else if(Rk().getBool("WEBGL_CONV_IM2COL"))t=p9({x:i,filter:o,convInfo:h,backend:r});else{let e=new s9(h);t=r.runWebGLProgram(e,[i,o],"float32")}else t=c9({x:i,filter:o,convInfo:h,backend:r});let f=D8({inputs:{x:t},backend:r,attrs:{shape:h.outShape}});return r.disposeIntermediateTensorInfo(t),f}},m9={kernelName:fS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:o,pad:s,dataFormat:l,dimRoundingMode:u,filterShape:d}=r,c=AO.convertConv2DDataFormat(l),p=AO.computeConv2DInfo(a.shape,d,o,1,s,u,!1,c),h=new class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,i="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${i?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(p);return n.runWebGLProgram(h,[a,i],"float32")}},g9={kernelName:mS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{inputShape:o,strides:s,pad:l,dataFormat:u,dimRoundingMode:d}=r,c=AO.convertConv2DDataFormat(u),p=AO.computeConv2DInfo(o,i.shape,s,1,l,d,!1,c);if(Rk().getBool("WEBGL_PACK")&&"channelsLast"===c){let e=[[p.strideHeight,p.strideWidth]],t=new class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=f5(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,a=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}(p);return n.runWebGLProgram(t,[a,i],"float32",e)}{let e=new class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i="channelsLast"===e.dataFormat,o=t-1-e.padInfo.top,s=n-1-e.padInfo.left,l=i?1:2,u=i?2:3,d=i?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${d}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(p);return n.runWebGLProgram(e,[a,i],"float32")}}},b9={kernelName:gS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:o,pad:s,dilations:l}=r,u=AO.computeConv3DInfo(a.shape,i.shape,o,l,s),d=new class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,d=e.filterDepth,c=e.filterHeight,p=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${i}, ${o});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${s};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${c}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(u);return n.runWebGLProgram(d,[a,i],"float32")}},y9={kernelName:bS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:o,pad:s,filterShape:l}=r,u=AO.computeConv3DInfo(a.shape,l,o,1,s),d=new class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,i=e.padInfo.top,o=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${i};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${o};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(u);return n.runWebGLProgram(d,[a,i],"float32")}},v9={kernelName:yS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{pad:o,strides:s,inputShape:l}=r,u=AO.computeConv3DInfo(l,i.shape,s,1,o),d=new class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,s=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${s}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${o}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(u);return n.runWebGLProgram(d,[a,i],"float32")}},x9=N8({opSnippet:I8+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${p8}\n  return result;\n`}),w9={kernelName:vS,backendName:"webgl",kernelFunc:x9},k9=N8({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),S9={kernelName:xS,backendName:"webgl",kernelFunc:k9},I9={kernelName:SS,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:i,boxInd:o}=t,{cropSize:s,method:l,extrapolationValue:u}=r,d=new class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,o,s,l]=e,[u]=t,[d,c]=n;this.outputShape=[u,d,c,l];let p="bilinear"===r?1:0,[h,f]=[o-1+".0",s-1+".0"],[m,g,b]=d>1?[""+(o-1)/(d-1),"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[y,v,x]=c>1?[""+(s-1)/(c-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}(a.shape,i.shape,s,l,u);return n.runWebGLProgram(d,[a,i,o],"float32")}};!function(e){e.Prod="*",e.Sum="+"}(h9||(h9={}));var N9=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,i=this.op===h9.Prod?"1.0":"0.0",o=n?i:`getX(${C9(a,"coords",this.op)})`,s=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=r?"end != "+(s-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${s}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${l5(a)} coords = getOutputCoords();\n        int end = ${T9(a,"coords",this.op)};\n        float val = ${o};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${T9(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${C9(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}};function C9(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function T9(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function $9(e,t,n,r,a,i){let o=t.shape.length,s=AO.getAxesPermutation([r],o),l=t;null!=s&&(l=j8({inputs:{x:t},backend:n,attrs:{perm:s}}));let u=AO.getInnerMostAxes(1,o)[0];if(u!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let d=l.shape[u],c=f8({inputs:{x:l},backend:n});for(let p=0;p<=Math.ceil(Math.log2(d))-1;p++){let t=new N9(e,l.shape,!1,i),r=[[p]],a=c;c=n.runWebGLProgram(t,[c],c.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){let t=new N9(e,l.shape,a,i),r=c;c=n.runWebGLProgram(t,[c],c.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=s){let e=j8({inputs:{x:c},backend:n,attrs:{perm:AO.getUndoAxesPermutation(s)}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),e}return c}var E9={kernelName:wS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:o,reverse:s}=r;return $9(h9.Prod,a,n,i,o,s)}},_9={kernelName:kS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:o,reverse:s}=r;return $9(h9.Sum,a,n,i,o,s)}},A9={kernelName:IS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:i}=t,{size:o,binaryOutput:s}=r;if(1===a.shape.length){let e=n.readSync(a.dataId),t=n.readSync(i.dataId),r=V5(e,t,i.dtype,i.shape,o);return n.makeTensorInfo([o],i.dtype,r)}if(2===a.shape.length){let e=n.bufferSync(a),t=n.bufferSync(i),r=U5(e,t,o,s);return n.makeTensorInfo(r.shape,i.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}},R9={kernelName:NS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:i,dataFormat:o}=r,s=a.shape[0],l=("NHWC"===o?a.shape[1]:a.shape[2])*i,u=("NHWC"===o?a.shape[2]:a.shape[3])*i,d=("NHWC"===o?a.shape[3]:a.shape[1])/(i*i),c="NHWC"===o?[s,l,u,d]:[s,d,l,u],p=new class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}(c,i,o);return n.runWebGLProgram(p,[a],a.dtype)}},F9=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=f5(this.outputShape.length);let i=e.filterHeight,o=e.filterWidth,s=e.outChannels/e.inChannels,l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");let d=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${u}\n        setOutput(result);\n      }\n    `}},D9=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=f5(this.outputShape.length);let i=e.outChannels/e.inChannels,o=e.padInfo.left,s=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,d=e.filterWidth,c=d,p="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<d;g++)p+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;p+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<d;g++)p+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;p+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(c+1)/2;g++){let e=2*g;if(p+=`\n          xC = xCCorner + ${e*l};\n          `,1===s){if(e<d&&(o%2==1?(p+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,p+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):p+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<d)){let t=o%2==0?fC.nearestLargerEven(l):l;l%2==0&&o%2==1||l%2!=0&&o%2!=1?(p+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,p+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):p+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<d&&(o%2==1?(p+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<d&&(p+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(p+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<d&&(p+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<d&&(p+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<d&&(p+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}p+="\n    }\n  ",p+="\n      }\n    ";let h="",f="";n&&(h=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${h}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${p}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}},M9={kernelName:CS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:o,pad:s,dilations:l,dimRoundingMode:u}=r,d=l;null==d&&(d=[1,1]),fC.assert(AO.eitherStridesOrDilationsAreOne(o,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`));let c,p=AO.computeConv2DInfo(a.shape,i.shape,o,d,s,u,!0);c=Rk().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels==1?new D9(p):new F9(p);let h=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return n.runWebGLProgram(c,[a,i],"float32",h)}},O9={kernelName:TS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:o,dilations:s,pad:l,dimRoundingMode:u,filterShape:d}=r,c=AO.computeConv2DInfo(a.shape,d,o,s,l,u,!0),p=new class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${i} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(c);return n.runWebGLProgram(p,[a,i],"float32")}},z9={kernelName:$S,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{strides:o,dilations:s,pad:l,dimRoundingMode:u,inputShape:d}=r,c=AO.computeConv2DInfo(d,i.shape,o,s,l,u,!0),p=new class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${s}; dm++) {\n              int d2 = d1 * ${s} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(c);return n.runWebGLProgram(p,[a,i],"float32")}},P9={kernelName:ES,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],i=fC.sizeFromShape(r.shape),o=D8({inputs:{x:r},backend:n,attrs:{shape:[i]}}),s=new class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}(i),l=n.runWebGLProgram(s,[o],o.dtype),u=D8({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}},L9={kernelName:_S,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i,filter:o}=n,{strides:s,pad:l,dilations:u}=a,d=AO.computeDilation2DInfo(i.shape,o.shape,s,l,"NHWC",u),c=new class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:i,filterHeight:o,filterWidth:s,dilationHeight:l,dilationWidth:u}=e,{top:d,left:c}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${i});\n      const ivec2 pads = ivec2(${d}, ${c});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${o}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${s}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}(d);t=r.runWebGLProgram(c,[i,o],"float32");let p=D8({inputs:{x:t},backend:r,attrs:{shape:d.outShape}});return r.disposeIntermediateTensorInfo(t),p}},B9={kernelName:MS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,i=t,{allDims:o,summedDims:s,idDims:l}=AO.decodeEinsumEquation(a,i.length);AO.checkEinsumDimSizes(o.length,l,i);let{path:u,steps:d}=AO.getEinsumComputePath(s,l),c=d.length,p=null,h=o.length,f=[];for(let m=0;m<c;++m){for(let e of d[m]){let t,{permutationIndices:r,expandDims:a}=AO.getEinsumPermutation(h,l[e]);AO.isIdentityPermutation(r)?t=i[e]:(t=j8({inputs:{x:i[e]},backend:n,attrs:{perm:r}}),f.push(t));let o=t.shape.slice();for(let e=0;e<a.length;++e)o.splice(a[e],0,1);fC.arraysEqual(t.shape,o)||(t=D8({inputs:{x:t},backend:n,attrs:{shape:o}}),f.push(t)),null===p?p=t:(p=R8({inputs:{a:t,b:p},backend:n}),f.push(p))}m<c-1&&(u[m]>=0&&(p=V8({inputs:{x:p},backend:n,attrs:{axis:u[m]-(o.length-h),keepDims:!1}}),f.push(p)),h--)}for(let m of f)m!==p&&n.disposeIntermediateTensorInfo(m);return p}},W9=N8({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),V9={kernelName:OS,backendName:"webgl",kernelFunc:W9},U9={kernelName:zS,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,i=Rk().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new h8("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,a.shape):new c8("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,a.shape);return n.runWebGLProgram(i,[r,a],r.dtype)}},j9=C8({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:K5}),H9={kernelName:LS,backendName:"webgl",kernelFunc:j9},G9=N8({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${AO.ERF_P};\n  float a1 = ${AO.ERF_A1};\n  float a2 = ${AO.ERF_A2};\n  float a3 = ${AO.ERF_A3};\n  float a4 = ${AO.ERF_A4};\n  float a5 = ${AO.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),q9={kernelName:PS,backendName:"webgl",kernelFunc:G9},K9=N8({opSnippet:I8+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:X5,dtype:"float32"}),X9={kernelName:BS,backendName:"webgl",kernelFunc:K9};function Y9(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:i}=t,o=i.shape.length,s=i.shape.slice(),l=a;return a<0&&(fC.assert(-(o+1)<=a,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+a+1),s.splice(l,0,1),D8({inputs:{x:i},backend:r,attrs:{shape:s}})}var Q9={kernelName:WS,backendName:"webgl",kernelFunc:Y9},Z9="return exp(x) - 1.0;",J9=N8({opSnippet:Z9,packedOpSnippet:Z9,cpuKernelImpl:Y5}),eee={kernelName:VS,backendName:"webgl",kernelFunc:J9},tee=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let a,i=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=n?`${r}.0`:"1.0";if("real"===e)a="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${i};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}};function nee(e,t,n){let r=n.texData.get(e.dataId),a=fC.sizeFromShape(e.shape),i=e.shape[e.shape.length-1],o=D8({inputs:{x:e},backend:n,attrs:{shape:[a/i,i]}}),s=o.shape,l=new tee("real",s,t),u=new tee("imag",s,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:s},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:s}],c=n.runWebGLProgram(l,d,"float32"),p=n.runWebGLProgram(u,d,"float32"),h=g8({inputs:{real:c,imag:p},backend:n});n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p);let f=D8({inputs:{x:h},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(h),f}var ree={kernelName:US,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t;return nee(r,!1,n)}},aee=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}};function iee(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:i}=n;if(i=i||fC.inferDtype(a),"string"===i){let e=fC.getArrayFromDType(i,fC.sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,i,e)}{let e=new aee(r,a),n=[[a]];return t.runWebGLProgram(e,[],i,n)}}var oee,see={kernelName:jS,backendName:"webgl",kernelFunc:iee},lee={kernelName:HS,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,a=new class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}(n.shape);return r.runWebGLProgram(a,[n],n.dtype)}},uee="return floor(x);",dee=N8({opSnippet:uee,packedOpSnippet:uee,cpuKernelImpl:Q5}),cee={kernelName:GS,backendName:"webgl",kernelFunc:dee},pee=C8({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),hee={kernelName:qS,backendName:"webgl",kernelFunc:pee},fee={kernelName:YN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:i}=r,o="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,s="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,u]=o?[a.videoWidth,a.videoHeight]:[a.width,a.height],d=[u,l],c=[u,l,i];if(s||o){let e=Rk().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==oee||e!==mee)&&(mee=e,oee=document.createElement("canvas").getContext("2d",{willReadFrequently:mee})),oee.canvas.width=l,oee.canvas.height=u,oee.drawImage(a,0,0,l,u),a=oee.canvas}let p=n.makeTensorInfo(d,"int32");n.texData.get(p.dataId).usage=z3.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId),a);let h=Rk().getBool("WEBGL_PACK")?new class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=G4(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}(c):new class{constructor(e){this.variableNames=["A"];let t=G4(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}(c),f=n.runWebGLProgram(h,[p],"int32");return n.disposeData(p.dataId),f}},mee=Rk().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU"),gee={kernelName:JN,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i,filter:o,bias:s,preluActivationWeights:l}=n,{strides:u,pad:d,dataFormat:c,dilations:p,dimRoundingMode:h,activation:f,leakyreluAlpha:m}=a,g=AO.convertConv2DDataFormat(c),b=AO.computeConv2DInfo(i.shape,o.shape,u,p,d,h,!1,g),y=[],v=null!=s,x=null!=l,w="leakyrelu"===f,k=()=>{let e=[i,o],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){let t=D8({inputs:{x:e},backend:r,attrs:{shape:[e.shape[0],1,1]}});return y.push(t),t}return e};if(v&&e.push(t(s,c)),x&&e.push(t(l,c)),w){let t=r.makeTensorInfo([],"float32",fC.createScalarValue(m,"float32"));e.push(t),y.push(t)}return e};if(1!==b.filterHeight||1!==b.filterWidth||1!==b.dilationHeight||1!==b.dilationWidth||1!==b.strideHeight||1!==b.strideWidth||"SAME"!==b.padInfo.type&&"VALID"!==b.padInfo.type)if(b.strideWidth<=2&&"channelsLast"===g&&Rk().getBool("WEBGL_EXP_CONV")){let e=f?T8(f,!0):null,n=new l9(b,v,e,x,w),a=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],i=k();t=r.runWebGLProgram(n,i,"float32",a)}else if(Rk().getBool("WEBGL_CONV_IM2COL"))t=p9({x:i,filter:o,convInfo:b,backend:r,bias:s,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else{let e=f?T8(f,!1):null,n=new s9(b,v,e,x,w),a=k();t=r.runWebGLProgram(n,a,"float32")}else t=c9({x:i,filter:o,convInfo:b,backend:r,bias:s,activation:f,preluActivationWeights:l,leakyreluAlpha:m});let S=D8({inputs:{x:t},backend:r,attrs:{shape:b.outShape}});return y.push(t),y.forEach((e=>r.disposeIntermediateTensorInfo(e))),S}},bee={kernelName:eC,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,bias:o,preluActivationWeights:s}=t,{strides:l,pad:u,dilations:d,dimRoundingMode:c,activation:p,leakyreluAlpha:h}=r,f=[],m=d;null==m&&(m=[1,1]),fC.assert(AO.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));let g,b=AO.computeConv2DInfo(a.shape,i.shape,l,m,u,c,!0),y=Rk().getBool("WEBGL_PACK_DEPTHWISECONV")&&b.strideWidth<=2&&b.outChannels/b.inChannels==1,v=p?T8(p,y):null,x=[a,i],w=null!=o,k=null!=s,S="leakyrelu"===p;if(w&&x.push(o),k&&x.push(s),S){let e=n.makeTensorInfo([],"float32",fC.createScalarValue(h,"float32"));x.push(e),f.push(e)}g=y?new D9(b,w,v,k,S):new F9(b,w,v,k,S);let I=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],N=n.runWebGLProgram(g,x,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}},yee={kernelName:YS,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,i=a.shape,o=i[i.length-1],s=fC.sizeFromShape(r.shape),[l,u,d,c]=AO.prepareAndValidate(r,a),p=D8({inputs:{x:a},backend:n,attrs:{shape:[u,o]}}),h=D8({inputs:{x:r},backend:n,attrs:{shape:[fC.sizeFromShape(r.shape)/d,d]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){let e=n.readSync(a.dataId),t=n.bufferSync(r),i=Z5(e,t,r.dtype,u,o,d,c,r.shape,s);return n.makeTensorInfo(l,r.dtype,i.values)}let f=new class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let a=l5(n.length),i="\n    int index;";for(let o=0;o<this.sliceDim;o++)i+=`\n          index = round(getIndices(coords[0], ${o}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};\n          flattenIndex += index * ${this.strides[o]};`;this.userCode=`\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${i}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}(o,c,[u,d],r.shape),m=n.runWebGLProgram(f,[h,p],h.dtype),g=D8({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),g}},vee=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=l5(this.rank),r=function(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<e.length;a++)2===a?r.push("index"):r.push(`${n[a]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}};function xee(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:i}=t,{axis:o,batchDims:s}=r,l=fC.parseAxisParam(o,a.shape)[0];if(Rk().get("DEBUG")){let e=n.readSync(i.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){let r=e[n];fC.assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}let u=AO.segment_util.collectGatherOpShapeInfo(a,i,l,s),d=fC.sizeFromShape(i.shape),c=[],p=D8({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),h=D8({inputs:{x:i},backend:n,attrs:{shape:[u.batchSize,d/u.batchSize]}});c.push(p),c.push(h);let f=[u.batchSize,u.outerSize,d/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,i])||"string"===a.dtype){let e=n.bufferSync(h),t=n.bufferSync(p),r=J5(t,e,f);return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}let m=new vee(p.shape,f),g=n.runWebGLProgram(m,[p,h],p.dtype);c.push(g);let b=D8({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}var wee={kernelName:XS,backendName:"webgl",kernelFunc:xee},kee=C8({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:e6,dtype:"bool"}),See={kernelName:QS,backendName:"webgl",kernelFunc:kee},Iee=C8({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:t6}),Nee={kernelName:ZS,backendName:"webgl",kernelFunc:Iee},Cee={kernelName:eI,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{input:r}=t;return nee(r,!0,n)}},Tee=N8({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),$ee={kernelName:nI,backendName:"webgl",kernelFunc:Tee},Eee=N8({opSnippet:"return float(isinf(x));",dtype:"bool"}),_ee={kernelName:rI,backendName:"webgl",kernelFunc:Eee},Aee=N8({opSnippet:"return float(isnan(x));",dtype:"bool"}),Ree={kernelName:aI,backendName:"webgl",kernelFunc:Aee},Fee=C8({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:n6,dtype:"bool"}),Dee={kernelName:oI,backendName:"webgl",kernelFunc:Fee},Mee=C8({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:r6,dtype:"bool"}),Oee={kernelName:sI,backendName:"webgl",kernelFunc:Mee},zee={kernelName:lI,backendName:"webgl",kernelFunc:function(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:i}=n,o=a6(r,a,i);return t.makeTensorInfo([o.length],"float32",o)}},Pee=N8({opSnippet:I8+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:i6}),Lee={kernelName:uI,backendName:"webgl",kernelFunc:Pee},Bee=N8({opSnippet:I8+"\n  return log(1.0 + x);\n"}),Wee={kernelName:dI,backendName:"webgl",kernelFunc:Bee},Vee=C8({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Uee={kernelName:cI,backendName:"webgl",kernelFunc:Vee},jee=N8({opSnippet:"return float(!(x >= 1.0));"}),Hee={kernelName:pI,backendName:"webgl",kernelFunc:jee},Gee=C8({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),qee={kernelName:hI,backendName:"webgl",kernelFunc:Gee},Kee={kernelName:bI,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:i,bias:o,alpha:s,beta:l}=r,u=Rk().getBool("WEBGL_PACK_NORMALIZATION")?new class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=t,o=e[3]-1;this.outputShape=e;let s,l=`float(${n}) + float(${r}) * sum`;s=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${s};\n        setOutput(result);\n      }\n    `}}(a.shape,i,o,s,l):new class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];let i=t,o=e[3]-1;this.outputShape=e;let s,l=`float(${n}) + float(${r}) * sum`;s=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${s};\n        setOutput(val);\n      }\n    `}}(a.shape,i,o,s,l);return n.runWebGLProgram(u,[a],a.dtype)}},Xee={kernelName:yI,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:i,dy:o}=t,{depthRadius:s,bias:l,alpha:u,beta:d}=r,c=new class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}(a.shape,s,l,u,d);return n.runWebGLProgram(c,[a,i,o],a.dtype)}};function Yee(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:i,keepDims:o}=r,s=a.shape.length,l=fC.parseAxisParam(i,a.shape),u=l,d=AO.getAxesPermutation(u,s),c=null!=d,p=n.shouldExecuteOnCPU([a]),h=a;if(c){if(p){let e=n.texData.get(h.dataId).values,t=new Array(s);for(let n=0;n<t.length;n++)t[n]=a.shape[d[n]];let r=D6(e,a.shape,a.dtype,d,t);h=n.makeTensorInfo(t,a.dtype),n.texData.get(h.dataId).values=r}else h=W8(a,d,n);u=AO.getInnerMostAxes(u.length,s)}AO.assertAxesAreInnerMostDims("max",u,s);let f,[m,g]=AO.computeOutAndReduceShapes(h.shape,u),b=m;if(o&&(b=AO.expandShapeToKeepDim(m,l)),p){let e=n.texData.get(h.dataId).values,t=o6(e,fC.sizeFromShape(g),b,a.dtype);f=n.makeTensorInfo(b,a.dtype),n.texData.get(f.dataId).values=t}else f=function(e,t,n,r){let a=fC.sizeFromShape(t),i=D8({inputs:{x:e},attrs:{shape:[fC.sizeFromShape(e.shape)/a,a]},backend:r}),o=P8(i,e.dtype,"max",r),s=D8({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),s}(h,g,b,n);return c&&n.disposeIntermediateTensorInfo(h),f}var Qee={kernelName:xI,backendName:"webgl",kernelFunc:Yee},Zee=C8({opSnippet:d8+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+p8+"\n  return result;\n",cpuKernelImpl:s6}),Jee={kernelName:wI,backendName:"webgl",kernelFunc:Zee},ete={kernelName:kI,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;j4(a,"maxPool");let{filterSize:i,strides:o,pad:s,dimRoundingMode:l}=r;fC.assert(AO.eitherStridesOrDilationsAreOne(o,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`));let u=AO.computePool2DInfo(a.shape,i,o,1,s,l);if(1===u.filterWidth&&1===u.filterHeight&&fC.arraysEqual(u.inShape,u.outShape))return f8({inputs:{x:a},backend:n});let d=new I7(u,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}},tte={kernelName:II,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:o,pad:s,dataFormat:l,dimRoundingMode:u}=r,d=AO.computePool3DInfo(a.shape,i,o,[1,1,1],s,u,l),c=new N7(d,"max",!1);return n.runWebGLProgram(c,[a],a.dtype)}},nte={kernelName:NI,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,o=i,{filterSize:s,strides:l,pad:u,dimRoundingMode:d}=r,c=AO.computePool3DInfo(o.shape,s,l,[1,1,1],u,d),p=new N7(c,"max",!0),h=n.runWebGLProgram(p,[o],o.dtype),f=new class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,i=e.dilationHeight,o=e.dilationWidth,s=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,d=s-1-e.padInfo.front,c=l-1-e.padInfo.top,p=u-1-e.padInfo.left,h=s*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${d}, ${c}, ${p});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${s};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${i}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${o}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(c),m=n.runWebGLProgram(f,[a,h],o.dtype);return n.disposeIntermediateTensorInfo(h),m}},rte={kernelName:SI,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i,output:o}=t,s=i;j4([i,o],"maxPoolGrad");let{filterSize:l,strides:u,pad:d,dimRoundingMode:c}=r,p=AO.computePool2DInfo(s.shape,l,u,1,d,c),h=new I7(p,"max",!0),f=n.runWebGLProgram(h,[s],s.dtype),m=new class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,i=e.effectiveFilterWidth,o=a-1-e.padInfo.top,s=i-1-e.padInfo.left,l=a*i-1;this.userCode=`\n      const ivec2 pads = ivec2(${o}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}(p),g=n.runWebGLProgram(m,[a,f],s.dtype);return n.disposeIntermediateTensorInfo(f),g}},ate={kernelName:CI,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:i,pad:o,includeBatchInIndex:s}=t,l=n;fC.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));let u=[1,1];fC.assert(AO.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let d=AO.computePool2DInfo(r.shape,a,i,u,o),[c,p]=function(e,t,n,r){let a=new I7(n,"max",!1),i=r.runWebGLProgram(a,[e],"float32");return a=new I7(n,"max",!0,!0,t),[i,r.runWebGLProgram(a,[e],"float32")]}(r,s,d,l);return[c,p]}},ite={kernelName:TI,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:a,axis:i}=t,o=n,s=r.shape.length,l=fC.parseAxisParam(i,r.shape),u=l,d=AO.getAxesPermutation(u,s),c=null!=d,p=o.shouldExecuteOnCPU([r]),h=[],f=r;if(c){if(p){let e=o.texData.get(f.dataId).values,t=new Array(s);for(let a=0;a<t.length;a++)t[a]=r.shape[d[a]];let n=D6(e,r.shape,r.dtype,d,t);f=o.makeTensorInfo(t,r.dtype),o.texData.get(f.dataId).values=n}else f=W8(r,d,o);h.push(f),u=AO.getInnerMostAxes(u.length,s)}AO.assertAxesAreInnerMostDims("sum",u,s);let[m,g]=AO.computeOutAndReduceShapes(f.shape,u),b=m;a&&(b=AO.expandShapeToKeepDim(m,l));let y=function(e,t,n,r){let a=fC.sizeFromShape(t),i=D8({inputs:{x:e},attrs:{shape:[fC.sizeFromShape(e.shape)/a,a]},backend:r}),o=P8(i,"float32","mean",r),s=D8({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),s}(f,g,b,o);for(let v of h)o.disposeIntermediateTensorInfo(v);return y}},ote={kernelName:$I,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,keepDims:o}=r,s=a.shape.length,l=fC.parseAxisParam(i,a.shape),u=l,d=AO.getAxesPermutation(u,s),c=a;null!=d&&(c=j8({inputs:{x:a},backend:n,attrs:{perm:d}}),u=AO.getInnerMostAxes(u.length,a.shape.length)),AO.assertAxesAreInnerMostDims("min",u,s);let p,[h,f]=AO.computeOutAndReduceShapes(c.shape,u),m=D8({inputs:{x:c},backend:n,attrs:{shape:[-1,fC.sizeFromShape(f)]}}),g=P8(m,m.dtype,"min",n);return p=D8(o?{inputs:{x:g},backend:n,attrs:{shape:AO.expandShapeToKeepDim(h,l)}}:{inputs:{x:g},backend:n,attrs:{shape:h}}),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),null!=d&&n.disposeIntermediateTensorInfo(c),p}},ste=C8({opSnippet:d8+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+p8+"\n  return result;\n",cpuKernelImpl:l6}),lte={kernelName:EI,backendName:"webgl",kernelFunc:ste},ute={kernelName:_I,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:a,mode:i}=n,o=Rk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=l5(r),i=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),s=z6("rc",r),l=z6("source",r),u=`${s[r-1]} < ${this.outputShape[r-1]}`,d=1===r?"source":`vec2(${l.slice(-2).join()})`,c="reflect"===n?0:1,p="";if(1===r){let e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${c};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${c};\n        }\n        source -= start;\n      `;p=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${d});\n        ${s[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${d});\n        }\n      `}else{let e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${c}) +\n                gte * ((end - 1) * 2 - source + ${c});\n        source -= start;\n      `;p=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${d});\n        ${s[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${s[r-2]} += 1;\n        if(${s[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${d});\n          ${s[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${i});\n      const ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}(r.shape,a,i):new class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=l5(r),i=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${i});\n      ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${s}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}(r.shape,a,i);return t.runWebGLProgram(o,[r],r.dtype)}},dte=C8({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+p8+"\n  return result;\n"}),cte={kernelName:AI,backendName:"webgl",kernelFunc:dte},pte=C8({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),hte={kernelName:DS,backendName:"webgl",kernelFunc:pte},fte="return a - b;",mte=C8({opSnippet:fte,packedOpSnippet:fte,supportsComplex:!0,cpuKernelImpl:A6}),gte={kernelName:zN,backendName:"webgl",kernelFunc:mte};function bte(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:i}=r,o=fC.parseAxisParam([i],a.shape),s=Yee({inputs:{x:a},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=AO.expandShapeToKeepDim(s.shape,o),u=D8({inputs:{x:s},backend:n,attrs:{shape:l}}),d=mte({inputs:{a:a,b:u},backend:n}),c=K9({inputs:{x:d},backend:n}),p=V8({inputs:{x:c},backend:n,attrs:{axis:o,keepDims:!1}}),h=D8({inputs:{x:p},backend:n,attrs:{shape:l}}),f=pte({inputs:{a:c,b:h},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(h),f}var yte={kernelName:IN,backendName:"webgl",kernelFunc:bte},vte={kernelName:RI,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:i,seed:o,normalized:s}=r,l=s?a:bte({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=l.shape[0],d=l.shape[1],c=new class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}(u,d,i),p=[[o]],h=n.runWebGLProgram(c,[l],"int32",p);return s||n.disposeIntermediateTensorInfo(l),h}},xte=U6+"\n  return -x;\n",wte={kernelName:DI,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])){let e=r.texData.get(a.dataId),[t,n]=d6(e.values,a.shape,a.dtype);return r.makeTensorInfo(n,a.dtype,t)}return t=Rk().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new n8(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new V6(a.shape,xte),r.runWebGLProgram(t,[a],a.dtype)}},kte=zz.nonMaxSuppressionV3Impl,Ste={kernelName:OI,backendName:"webgl",kernelFunc:function(e){AO.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:o,iouThreshold:s,scoreThreshold:l}=r,u=n.readSync(a.dataId),d=n.readSync(i.dataId),{selectedIndices:c}=kte(u,d,o,s,l);return n.makeTensorInfo([c.length],"int32",new Int32Array(c))}},Ite=zz.nonMaxSuppressionV4Impl,Nte={kernelName:zI,backendName:"webgl",kernelFunc:function(e){AO.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:o,iouThreshold:s,scoreThreshold:l,padToMaxOutputSize:u}=r,d=n.readSync(a.dataId),c=n.readSync(i.dataId),{selectedIndices:p,validOutputs:h}=Ite(d,c,o,s,l,u);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}},Cte=zz.nonMaxSuppressionV5Impl,Tte={kernelName:PI,backendName:"webgl",kernelFunc:function(e){AO.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:i}=t,{maxOutputSize:o,iouThreshold:s,scoreThreshold:l,softNmsSigma:u}=r,d=n.readSync(a.dataId),c=n.readSync(i.dataId),p=o,h=s,f=l,m=u,{selectedIndices:g,selectedScores:b}=Cte(d,c,p,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},$te={kernelName:BI,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:i,depth:o,onValue:s,offValue:l}=r,u=fC.sizeFromShape(a.shape),d=new class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}(u,o,s,l),c=D8({inputs:{x:a},backend:n,attrs:{shape:[u]}}),p=n.runWebGLProgram(d,[c],i);n.disposeIntermediateTensorInfo(c);let h=D8({inputs:{x:p},backend:n,attrs:{shape:[...a.shape,o]}});return n.disposeIntermediateTensorInfo(p),h}};function Ete(e){let{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){let e=U7({inputs:{input:r},backend:n}),t=Ete({inputs:{x:e},backend:n}),a=n9({inputs:{input:r},backend:n}),i=Ete({inputs:{x:a},backend:n}),o=g8({inputs:{real:t,imag:i},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),o}return iee({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}var _te={kernelName:KN,backendName:"webgl",kernelFunc:Ete},Ate={kernelName:LI,backendName:"webgl",kernelFunc:function e(t){let{inputs:n,backend:r}=t,{x:a}=n;if("string"===a.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===a.dtype){let t=U7({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r}),i=n9({inputs:{input:a},backend:r}),o=Ete({inputs:{x:i},backend:r}),s=g8({inputs:{real:n,imag:o},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),s}return iee({attrs:{shape:a.shape,dtype:a.dtype,value:1},backend:r})}},Rte={kernelName:WI,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return Y9({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let i=t[0].shape,o=t[0].dtype;t.forEach((e=>{fC.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),fC.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let s=[],l=t.map((e=>{let t=Y9({inputs:{input:e},backend:n,attrs:{dim:a}});return s.push(t),t})),u=i9({inputs:l,backend:n,attrs:{axis:a}});return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},Fte=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:i,constantValue:o}=r;if(0===fC.sizeFromShape(a.shape)){let e=i.map(((e,t)=>e[0]+a.shape[t]+e[1]));return iee({backend:n,attrs:{shape:e,value:o,dtype:a.dtype}})}let s=Rk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=l5(r),i=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),s=z6("rc",r),l=z6("source",r),u=`${s[r-1]} < ${this.outputShape[r-1]}`,d=1===r?"source":`vec2(${l.slice(-2).join()})`,c=[`${a} rc = outputLoc;`,`${s[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${s[r-2]} += 1;\n       if(${s[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${s[r-1]} += 1;\n         if(${u}) {`],p=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="";for(let f=0,m=1===r?2:4;f<m;f++)h+=`\n        ${c[f]}\n        if (${p}) {\n          result[${f}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${d});\n        }\n      `;h+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${i});\n      const ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}(a.shape,i,o):new class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=l5(r),i=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${i});\n      ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${s}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}(a.shape,i,o),l=[[o]];return n.runWebGLProgram(s,[a],a.dtype,l)},Dte={kernelName:VI,backendName:"webgl",kernelFunc:Fte},Mte=C8({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+p8+"\n  return result;\n"}),Ote={kernelName:jI,backendName:"webgl",kernelFunc:Mte},zte={kernelName:GI,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i}=n,{axis:o,keepDims:s}=a,l=i.shape.length,u=[],d=fC.parseAxisParam(o,i.shape),c=d,p=AO.getAxesPermutation(c,l),h=i;if(null!=p&&(h=j8({inputs:{x:i},backend:r,attrs:{perm:p}}),c=AO.getInnerMostAxes(c.length,l),u.push(h)),AO.assertAxesAreInnerMostDims("prod",c,l),r.shouldExecuteOnCPU([h])){let e=r.texData.get(h.dataId).values,{outVals:n,outShape:a,outDtype:i}=p6(h.shape,h.dtype,e,c);t=r.makeTensorInfo(a,i,n)}else{let[e,n]=AO.computeOutAndReduceShapes(h.shape,c),a=fC.sizeFromShape(n),o=D8({inputs:{x:h},backend:r,attrs:{shape:[-1,a]}}),s=P8(o,lT(i.dtype),"prod",r);t=D8({inputs:{x:s},backend:r,attrs:{shape:e}}),u.push(o),u.push(s)}if(s){u.push(t);let e=AO.expandShapeToKeepDim(t.shape,d);t=D8({inputs:{x:t},backend:r,attrs:{shape:e}})}return u.forEach((e=>r.disposeIntermediateTensorInfo(e))),t}},Pte={kernelName:qI,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:a,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:s}=r,l=a.map((e=>n.readSync(e.dataId))),u=a.map((e=>e.shape)),d=n.readSync(i.dataId),c=n.readSync(o.dataId),[p,h,f]=h6(l,u,d,i.shape,i.dtype,c,o.shape,s),m=p.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,i.dtype,h);return m.concat([g])}},Lte={kernelName:KI,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{starts:r,limits:a,deltas:i}=t,o=n.readSync(r.dataId),s=n.readSync(a.dataId),l=n.readSync(i.dataId),[u,d]=f6(o,r.shape,r.dtype,s,a.shape,l,i.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([d.length],r.dtype,d)]}},Bte={kernelName:XI,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{shape:a,values:i,defaultValue:o,rowPartitionTensors:s}=t,{rowPartitionTypes:l}=r,u=n.readSync(a.dataId),d=n.readSync(i.dataId),c=n.readSync(o.dataId),p=s.map((e=>n.readSync(e.dataId))),h=s.map((e=>e.shape)),[f,m]=m6(u,a.shape,d,i.shape,i.dtype,c,o.shape,p,h,l);return n.makeTensorInfo(f,i.dtype,m)}},Wte=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:i,dtype:o}=n,s=g6(r,a,i,o);return t.makeTensorInfo([s.length],o,s)},Vte={kernelName:YI,backendName:"webgl",kernelFunc:Wte},Ute=N8({opSnippet:"return 1.0 / x;"}),jte={kernelName:ZI,backendName:"webgl",kernelFunc:Ute},Hte=N8({opSnippet:U6+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Gte={kernelName:JI,backendName:"webgl",kernelFunc:Hte},qte=N8({opSnippet:U6+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Kte={kernelName:iN,backendName:"webgl",kernelFunc:qte},Xte={kernelName:rN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:i,halfPixelCenters:o,size:s}=r,[l,u]=s,d=Rk().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,o,s,l]=e;this.outputShape=[i,t,n,l];let u,d=[r&&t>1?o-1:o,r&&n>1?s-1:s],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${d[0]/c[0]},\n          ${d[1]/c[1]},\n          ${d[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${s}.0,\n                                     ${s}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}(a.shape,l,u,i,o):new class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[i,o,s,l]=e;this.outputShape=[i,t,n,l];let u,d=[r&&t>1?o-1:o,r&&n>1?s-1:s],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${d[0]/c[0]},\n          ${d[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${s}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}(a.shape,l,u,i,o);return n.runWebGLProgram(d,[a],"float32")}},Yte={kernelName:aN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:i}=t,{alignCorners:o}=r,s=new class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,i,o]=e,s=[n&&i>1?r-1:r,n&&o>1?a-1:a],l=[n&&i>1?i-1:i,n&&o>1?o-1:o],u=s[0]/l[0],d=s[1]/l[1],c=1/u,p=1/d,h=2*Math.ceil(c)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${c});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}(i.shape,a.shape,o);return n.runWebGLProgram(s,[i],i.dtype)}},Qte={kernelName:tN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:i,halfPixelCenters:o,size:s}=r,[l,u]=s,d=Rk().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,o,s,l]=e;this.outputShape=[i,t,n,l];let u,d=[r&&t>1?o-1:o,r&&n>1?s-1:s],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],p=r?"0.5":"0.0";u=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${d[0]/c[0]},\n          ${d[1]/c[1]},\n          ${d[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${s}.0,\n                                     ${s}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}(a.shape,l,u,i,o):new class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[i,o,s,l]=e;this.outputShape=[i,t,n,l];let u,d=[r&&t>1?o-1:o,r&&n>1?s-1:s],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],p=r?"0.5":"0.0";u=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${d[0]/c[0]},\n          ${d[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${s}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}(a.shape,l,u,i,o);return n.runWebGLProgram(d,[a],a.dtype)}},Zte={kernelName:nN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:i}=t,{alignCorners:o}=r,s=new class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,i,o]=e,s=[n&&i>1?r-1:r,n&&o>1?a-1:a],l=[n&&i>1?i-1:i,n&&o>1?o-1:o],u=s[0]/l[0],d=s[1]/l[1],c=1/u,p=1/d,h=2*Math.ceil(c)+2,f=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${c});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${s[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${s[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}(i.shape,a.shape,o);return n.runWebGLProgram(s,[i],i.dtype)}},Jte={kernelName:oN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:i}=r,o=a.shape.length,s=fC.parseAxisParam(i,a.shape);if(0===o)return f8({inputs:{x:a},backend:n});let l=Rk().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=z6("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,o=l5(n);function s(n){let r=e.map(((r,a)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(a,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return s(e)}(r.slice())};\n          if(${a}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",s(e)}(r.slice())};\n          }\n          if(${i}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",s(e)}(r.slice())};\n            if(${a}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",s(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}(a.shape,s):new class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);let r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),a=l5(n);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}(a.shape,s);return n.runWebGLProgram(l,[a],a.dtype)}},ene={kernelName:QN,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:i,center:o}=t,s=n,l=new class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let a="";a="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}(r.shape,i),[u,d]=AO.getImageCenter(o,r.shape[1],r.shape[2]),c=[[u,d,Math.sin(a),Math.cos(a)]];return s.runWebGLProgram(l,[r],r.dtype,c)}},tne=N8({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),nne={kernelName:sN,backendName:"webgl",kernelFunc:tne},rne=N8({opSnippet:"return inversesqrt(x);",cpuKernelImpl:b6}),ane={kernelName:lN,backendName:"webgl",kernelFunc:rne},ine=class{constructor(e,t,n,r,a,i,o=!0,s=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let l=l5(a.length),u=l5(i.length),d="";1===n?d="i":2===n&&(d="i, j");let c=`getIndices(${d})`,p="";1===r?p="i":2===r&&(p="i, coords[1]");let h=`getUpdates(${p})`,f="";s&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides";this.userCode=`\n        ${l} strides = ${l}(${a});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${g};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(${m}, sum, float(found)));\n        }\n      `}},one={kernelName:uN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:i}=t,{shape:o}=r,{sliceRank:s,numUpdates:l,sliceSize:u,strides:d,outputSize:c}=AO.calculateShapes(i,a,o),p=[c/u,u];if(0===c)return n.makeTensorInfo(o,a.dtype);let h,f=D8({inputs:{x:a},backend:n,attrs:{shape:[l,s]}}),m=D8({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));h=Rk().getBool("WEBGL_PACK")?new class{constructor(e,t,n,r,a,i,o=!0,s=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;let l=l5(a.length),u=l5(i.length),d="";1===n?d="i":2===n&&(d="i, j");let c=`getIndices(${d})`,p="";1===r?p="i":2===r&&(p="i, coords[1]");let h=`getUpdates(${p})`,f="";s&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides",b=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${l} strides = ${l}(${a});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${c});\n              flattenedIndex += index.xz * ${g};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${b};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${h};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${m}, sum, found));\n        }\n      `}}(l,s,f.shape.length,m.shape.length,d,p):new ine(l,s,f.shape.length,m.shape.length,d,p);let b=n.runWebGLProgram(h,[m,f,g],m.dtype),y=D8({inputs:{x:b},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),y}},sne={kernelName:cN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:i}=t,{side:o}=r,s=new class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=2===Rk().getNumber("WEBGL_VERSION")?"while (left < right) {":a,o="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${i}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${o} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}(a.shape[0],a.shape[1],i.shape[1],o),l=[[a.shape[1]]];return n.runWebGLProgram(s,[a,i],"int32",l)}},lne={kernelName:pN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:i}=t,o=new class{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{let n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],o=[];for(let r=0;r<t.length;r++)o.push(`${n[r]}`),r<e&&i.push(`${n[r]}`);r=i.join(),a=o.join()}let i=l5(n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}}(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(o,[r,a,i],sT(a.dtype,i.dtype))}},une=N8({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${AO.SELU_SCALEALPHA};\n  float scale = ${AO.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),dne={kernelName:hN,backendName:"webgl",kernelFunc:une},cne=N8({opSnippet:I8+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:v6}),pne={kernelName:yN,backendName:"webgl",kernelFunc:cne},hne=N8({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),fne={kernelName:bN,backendName:"webgl",kernelFunc:hne},mne=N8({opSnippet:I8+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${p8}\n  return result;\n`}),gne={kernelName:mN,backendName:"webgl",kernelFunc:mne},bne=N8({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),yne={kernelName:gN,backendName:"webgl",kernelFunc:bne},vne=N8({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),xne={kernelName:vN,backendName:"webgl",kernelFunc:vne},wne={kernelName:kN,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,paddings:o}=r;fC.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));let s=i.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...o);for(let b=1+i.length;b<a.shape.length;++b)l.push([0,0]);let u=[],d=Fte({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=AO.getReshaped(d.shape,i,s,!1),p=AO.getPermuted(c.length,i.length,!1),h=AO.getReshapedPermuted(d.shape,i,s,!1),f=D8({inputs:{x:d},backend:n,attrs:{shape:c}}),m=j8({inputs:{x:f},backend:n,attrs:{perm:p}}),g=D8({inputs:{x:m},backend:n,attrs:{shape:h}});return u.push(d),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}},kne={kernelName:NN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:i,defaultValue:o}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);let s=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(i.dataId),d=n.readSync(o.dataId)[0],[c,p,h,f,m]=k6(s,r.shape,r.dtype,l,a.dtype,u,d);return[n.makeTensorInfo(p,r.dtype,c),n.makeTensorInfo([p[0]],a.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},Sne={kernelName:CN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);let o=Array.from(n.readSync(a.dataId)),s=n.readSync(r.dataId),l=Array.from(n.readSync(i.dataId)),[u,d,c]=S6(s,r.shape,r.dtype,o,l);return[n.makeTensorInfo(d,r.dtype,u),n.makeTensorInfo([c.length],i.dtype,new Int32Array(c))]}},Ine={kernelName:TN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${i.shape}`);let o=n.readSync(r.dataId),s=n.readSync(a.dataId),l=n.readSync(i.dataId),[u,d]=I6(o,r.shape,r.dtype,s,l,!0);return n.makeTensorInfo(d,r.dtype,u)}},Nne={kernelName:$N,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${i.shape}`);let o=n.readSync(r.dataId),s=n.readSync(a.dataId),l=n.readSync(i.dataId),[u,d]=I6(o,r.shape,r.dtype,s,l);return n.makeTensorInfo(d,r.dtype,u)}},Cne={kernelName:EN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:i,defaultValue:o}=t,{outputShape:s}=r,{sliceRank:l,numUpdates:u,sliceSize:d,strides:c,outputSize:p}=AO.calculateShapes(i,a,s);if("string"===i.dtype){let e=n.bufferSync(a),t=n.bufferSync(i),r=fC.decodeString(n.readSync(o.dataId)[0]),h=y6(e,t,s,p,d,u,l,c,r,!1);return n.makeTensorInfo(s,h.dtype,h.values)}let h=new ine(u,l,a.shape.length,i.shape.length,c,[p,1],!1),f=n.runWebGLProgram(h,[i,a,o],i.dtype),m=D8({inputs:{x:f},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(f),m}},Tne={kernelName:SN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:i,axis:o}=r,s=fC.parseAxisParam(o,a.shape)[0],l=AO.prepareSplitSize(a,i,s),u=a.shape.length,d=new Array(u).fill(0),c=a.shape.slice();return l.map((e=>{let t=[...c];t[s]=e;let r=M7({inputs:{x:a},backend:n,attrs:{begin:d,size:t}});return d[s]+=e,r}))}},$ne="return sqrt(x);",Ene=N8({opSnippet:$ne,packedOpSnippet:$ne,cpuKernelImpl:N6}),_ne={kernelName:xN,backendName:"webgl",kernelFunc:Ene},Ane=N8({opSnippet:"return x * x;"}),Rne={kernelName:AN,backendName:"webgl",kernelFunc:Ane},Fne="return (a - b) * (a - b);",Dne=C8({opSnippet:Fne,packedOpSnippet:Fne}),Mne={kernelName:_N,backendName:"webgl",kernelFunc:Dne},One={kernelName:RN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");let i=n.readSync(a.dataId),o=AO.fromUint8ToStringArray(i),s=C6(o,"string",r);return n.makeTensorInfo(a.shape,"string",s)}},zne={kernelName:XN,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){let{x:r}=e,a=U6+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,i=new V6(r.shape,a);return n.runWebGLProgram(i,[r],r.dtype)}},Pne={kernelName:FN,backendName:"webgl",kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:i}=n,{begin:o,end:s,strides:l,beginMask:u,endMask:d,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:h}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:b,isSimpleSlice:y,begin:v,end:x,strides:w}=iO.sliceInfo(i.shape,o,s,l,u,d,c,p,h);if(g)t=D8({inputs:{x:i},backend:r,attrs:{shape:m}});else if(b||y){fC.assert(i.shape.length>=1,(()=>`Input must have rank at least 1, got: ${i.shape.length}`));let e=iO.computeOutShape(v,x,w),n=M7({inputs:{x:i},backend:r,attrs:{begin:v,size:e}});t=D8({inputs:{x:n},backend:r,attrs:{shape:m}}),r.disposeIntermediateTensorInfo(n)}else if(r.shouldExecuteOnCPU([i])){let e=r.readSync(i.dataId),n=D$(i.shape,i.dtype,e),a=T6(f,n,w,v);t=r.makeTensorInfo(m,i.dtype,a.values)}else{let e=new class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,a=l5(n.length),i=l5(n.length),o="";if(1===r)o="coords * strides + begin";else{let e=0;o=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}(v,w,f);t=r.runWebGLProgram(e,[i],i.dtype)}let k=D8({inputs:{x:t},backend:r,attrs:{shape:m}});return r.disposeIntermediateTensorInfo(t),k}},Lne={kernelName:DN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:i,leftPad:o,rightPad:s,padWidth:l,preserveShortSequences:u}=r,{data:d,dataSplits:c}=t,p=n.readSync(d.dataId),h=n.readSync(c.dataId),[f,m]=$6(p,h,a,i,o,s,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(c.shape,"int32",m)]}},Bne={kernelName:MN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:i,delimiter:o}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);let s=n.readSync(i.dataId),l=n.readSync(o.dataId)[0],[u,d,c]=E6(s,l,a),p=d.length;return[n.makeTensorInfo([p,2],"int32",u),n.makeTensorInfo([p],"string",d),n.makeTensorInfo([2],"int32",new Int32Array(c))]}},Wne={kernelName:ON,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let o=n.readSync(i.dataId),s=_6(o,a);return n.makeTensorInfo(i.shape,"int32",s)}},Vne=N8({opSnippet:"return tan(x);"}),Une={kernelName:PN,backendName:"webgl",kernelFunc:Vne},jne=N8({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Hne={kernelName:LN,backendName:"webgl",kernelFunc:jne},Gne={kernelName:dN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:a,indices:i,updates:o}=t,{sliceRank:s,numUpdates:l,sliceSize:u,strides:d,outputSize:c}=AO.calculateShapes(o,i,a.shape),p=[c/u,u];if(0===c)return n.makeTensorInfo(a.shape,i.dtype);let h=D8({inputs:{x:i},backend:n,attrs:{shape:[l,s]}}),f=D8({inputs:{x:o},backend:n,attrs:{shape:[l,u]}}),m=D8({inputs:{x:a},backend:n,attrs:{shape:p}}),g=new ine(l,s,h.shape.length,f.shape.length,d,p,!1,!0),b=n.runWebGLProgram(g,[f,h,m],m.dtype),y=D8({inputs:{x:b},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),y}},qne=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[i]*t[i];this.outputShape=n,this.rank=n.length;let r=l5(this.rank),a=function(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}};function Kne(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:i}=r;if("string"===a.dtype||a.shape.length>5){let e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>fC.decodeString(e))):e,r=D$(a.shape,a.dtype,t),o=R6(r,i);return n.makeTensorInfo(o.shape,o.dtype,o.values)}let o=new qne(a.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}var Xne={kernelName:BN,backendName:"webgl",kernelFunc:Kne},Yne=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}};function Qne(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function Zne(e){let t=1;for(;t<e;)t*=2;return t}var Jne,ere,tre,nre={kernelName:WN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:i,sorted:o}=r,s=Rk().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Rk().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,d=u[u.length-1];if(n.shouldExecuteOnCPU([a])||d<s||i>l){let e=n.readSync(a.dataId),[t,r]=F6(e,u,a.dtype,i,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===i)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===d)return[a,iee({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let c=n.texData.get(a.dataId),p=null!==c&&c.isPacked,h=p?n.unpackTensor(a):a,f=fC.sizeFromShape(u)/d,m=D8({inputs:{x:h},attrs:{shape:[f,d]},backend:n});p&&Qne(n,h);let g=Zne(i),b=Zne(d),y=null,v=()=>null===y?[m,m]:[m,y],x=(e,t,r)=>{let a=v(),i=new class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}(r),o=[[d],[null===y?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],s=y;y=n.runWebGLProgram(i,a,"int32",o),Qne(n,s)};for(let N=1;N<g;N*=2){let e=2*N;for(let t=N;t>=1;t/=2)x(e,t,[f,b])}for(let N=b;N>g;N/=2){let e=v(),t=new Yne([f,N/2]),r=[[d],[null===y?1:0],[g]],a=y;y=n.runWebGLProgram(t,e,"int32",r),Qne(n,a);let i=g/2,o=2*i;for(let n=i;n>=1;n/=2)x(o,n,y.shape)}let w=y;y=M7({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,i]}}),Qne(n,w);let k=xee({inputs:{x:m,indices:y},backend:n,attrs:{axis:1,batchDims:1}});Qne(n,m);let S=u.slice(0,-1);S.push(i),w=y,y=D8({inputs:{x:y},attrs:{shape:S},backend:n}),Qne(n,w);let I=k;return k=D8({inputs:{x:k},attrs:{shape:S},backend:n}),Qne(n,I),[k,y]}},rre={kernelName:VN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:i}=t,{interpolation:o,fillMode:s,fillValue:l,outputShape:u}=r,[d,c,p,h]=a.shape,[f,m]=null!=u?u:[c,p],g=[d,f,m,h],b=new class{constructor(e,t,n,r,a,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let o,s="nearest"===n?1:2;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${s} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}(c,p,o,s,l,g);return n.runWebGLProgram(b,[a,i],"float32")}},are={kernelName:jN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:i}=t;j4(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let o=r.readSync(i.dataId),{outputValues:s,outputShape:l,indices:u}=M6(o,a,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,s),r.makeTensorInfo([u.length],"int32",u)]}},ire={kernelName:HN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:i}=r;i<0&&(i+=a.shape.length);let o=a,s=o.shape.length,l=a.shape[i],u=new Array(s-1),d=0;for(let m=0;m<s;m++)m!==i&&(u[d++]=o.shape[m]);let c=[],p=new Array(s).fill(0),h=o.shape.slice();h[i]=1;let f=new Array(l);for(let m=0;m<f.length;m++){p[i]=m;let e=M7({inputs:{x:o},backend:n,attrs:{begin:p,size:h}}),t=D8({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,c.push(e)}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}},ore={kernelName:GN,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:i}=t,{numSegments:o}=r,s=a.shape.length,l=[],u=0,d=AO.getAxesPermutation([u],s),c=a;null!=d&&(c=j8({inputs:{x:a},backend:n,attrs:{perm:d}}),l.push(c),u=AO.getInnerMostAxes(1,s)[0]);let p=AO.segment_util.computeOutShape(c.shape,u,o),h=fC.sizeFromShape([c.shape[u]]),f=D8({inputs:{x:c},backend:n,attrs:{shape:[-1,h]}});l.push(f);let m=lT(a.dtype),g=(e,t,r,a,i)=>{let o=e.shape[0],s=e.shape[1],u=AO.segment_util.segOpComputeOptimalWindowSize(s,i),d={windowSize:u,inSize:s,batchSize:o,numSegments:i},c=new class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,a=e.inSize,i=e.numSegments,o=i*Math.ceil(a/n);this.outputShape=[r,o];let s=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ",d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let c="";a%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${c}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${s}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${s};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}(d,t),p=n.compileAndRun(c,[e,r],a);if(l.push(p),p.shape[1]===i)return p;let h=Wte({backend:n,attrs:{start:0,stop:i,step:1,dtype:"float32"}}),f=Kne({inputs:{x:h},backend:n,attrs:{reps:[s/u]}});return l.push(h),l.push(f),g(p,t,f,a,i)},b=D8({inputs:{x:g(f,"unsortedSegmentSum",i,m,o)},backend:n,attrs:{shape:p}}),y=b;if(null!=d){l.push(b);let e=AO.getUndoAxesPermutation(d);y=j8({inputs:{x:y},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}},sre=[K8,Y8,Z8,e7,r7,a7,i7,o7,p7,h7,m7,b7,v7,w7,S7,C7,T7,$7,E7,_7,A7,z7,P7,L7,B7,G7,X7,Y7,b8,Z7,o9,f9,m9,g9,b9,y9,v9,w9,S9,I9,E9,_9,A9,R9,M9,O9,z9,P9,L9,B9,V9,U9,H9,q9,X9,Q9,eee,ree,see,lee,cee,hee,fee,gee,bee,yee,wee,See,Nee,m8,Cee,r9,$ee,_ee,Ree,x8,Dee,Oee,zee,Lee,Wee,Uee,Hee,qee,Kee,Xee,Qee,Jee,ete,tte,nte,rte,ate,ite,ote,lte,ute,cte,vte,F8,wte,Ste,Nte,Tte,V7,$te,Ate,Rte,Dte,Ote,S8,zte,Pte,Lte,Bte,Vte,j7,hte,jte,Gte,Kte,M8,Xte,Yte,Qte,Zte,Jte,ene,nne,ane,one,sne,lne,dne,pne,fne,gne,yne,O7,yte,xne,wne,kne,Sne,Ine,Nne,Cne,Tne,_ne,Rne,Mne,One,zne,Pne,Lne,Bne,Wne,gte,U8,Une,Hne,Gne,Xne,nre,rre,H8,are,ire,ore,_te];for(let e of sre)lC(e);!function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"}(Jne||(Jne={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"}(ere||(ere={}));var lre={kernelName:ZN,backendName:"wasm",setupFunc:function(e){tre=e.wasm.cwrap(ZN,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:i,bias:o,preluActivationWeights:s}=t;if("float32"!==a.dtype||"float32"!==i.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:d,leakyreluAlpha:c}=r,p=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(i.dataId).id,f=0;if(null!=o){let e=n.dataIdMap.get(o.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);f=e.id}let m=null==s?0:n.dataIdMap.get(s.dataId).id,g=ere[d];if(null==g)throw new Error(`${d} activation not yet supported for FusedConv2D in the wasm backend.`);let b=l?a.shape[2]:a.shape[1],y=u?i.shape[1]:i.shape[2],v=N_.assertAndGetBroadcastShape(a.shape.slice(0,-2),i.shape.slice(0,-2)),x=n.makeOutput([...v,b,y],a.dtype),w=n.dataIdMap.get(x.dataId).id,k=new Uint8Array(new Int32Array(a.shape).buffer),S=new Uint8Array(new Int32Array(i.shape).buffer);return tre(p,k,a.shape.length,h,S,i.shape.length,l,u,g,f,m,c||0,w),x}};function ure(e,t){let n;return{kernelName:e,backendName:"wasm",setupFunc:function(t){n=t.wasm.cwrap(e,null,["number","number","number"])},kernelFunc:function(e){let{backend:r,inputs:{x:a}}=e,i=r.dataIdMap.get(a.dataId).id,o=r.makeOutput(a.shape,t||a.dtype),s=r.dataIdMap.get(o.dataId).id;return 0===fC.sizeFromShape(o.shape)||n(i,Jne[a.dtype],s),o}}}var dre=ure(zk),cre=ure(Pk),pre=ure(Lk);function hre(e,t,n){let r;return{kernelName:e,backendName:"wasm",setupFunc:function(t){r=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:a}=e,{a:i,b:o}=a,s=t.dataIdMap.get(i.dataId).id,l=t.dataIdMap.get(o.dataId).id,u=null!=n?n:i.dtype,d=AO.assertAndGetBroadcastShape(i.shape,o.shape),c=t.makeOutput(d,u);if(0===fC.sizeFromShape(d))return c;let p=new Uint8Array(new Int32Array(i.shape).buffer),h=new Uint8Array(new Int32Array(o.shape).buffer),f=t.dataIdMap.get(c.dataId).id;return r(s,p,i.shape.length,l,h,o.shape.length,Jne[i.dtype],f),c}}}var fre,mre=hre(Bk),gre={kernelName:Wk,backendName:"wasm",setupFunc:function(e){fre=e.wasm.cwrap(Wk,null,["array","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(0===fC.sizeFromShape(r.shape))return r;let a=t.map((e=>n.dataIdMap.get(e.dataId).id)),i=new Uint8Array(new Int32Array(a).buffer),o=n.dataIdMap.get(r.dataId).id;return fre(i,a.length,Jne[r.dtype],o),r}};function bre(e){let{inputs:{x:t},backend:n}=e;if("string"===t.dtype)return zT(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var yre,vre={kernelName:JS,backendName:"wasm",kernelFunc:bre};function xre(e){let{inputs:t,backend:n,attrs:r}=e,[a,i]=function(e,t){let n=[],r=[];for(let a=0;a<e.length;++a)1!==e[a]&&n.push(e[a]),1!==e[t[a]]&&r.push(t[a]);for(let a=0;a<r.length;++a){let e=-1;for(let t=0;t<r.length;++t)r[t]>=a&&(-1===e||r[e]>r[t])&&(e=t);r[e]=a}return[n,r]}(t.x.shape,r.perm),o=!0;for(let f=0;f<i.length;f++)i[f]!==f&&(o=!1);let s=function(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(o){let e=bre({inputs:t,backend:n});return e.shape=s,e}let u=n.makeOutput(s,l.dtype),d=n.dataIdMap.get(l.dataId).id,c=n.dataIdMap.get(u.dataId).id,p=new Uint8Array(new Int32Array(i).buffer),h=new Uint8Array(new Int32Array(l.shape).buffer);return yre(d,h,l.shape.length,Jne[l.dtype],c,p,i.length),u}var wre,kre={kernelName:UN,backendName:"wasm",kernelFunc:xre,setupFunc:function(e){yre=e.wasm.cwrap(UN,null,["number","array","number","number","number","array","number"])}};function Sre(e,t,n){let r=e.shape,a=e.shape.length,i=fC.parseAxisParam(t,r),o=i,s=AO.getAxesPermutation(o,a),l=null,u=!1;if(null!=s){let t=new Array(a);for(let e=0;e<t.length;e++)t[e]=r[s[e]];o=AO.getInnerMostAxes(o.length,a),l=xre({inputs:{x:e},attrs:{perm:s},backend:n});let i=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==i&&(u=!0)}return{transposed:l,originalAxes:i,axes:o,inputWasTransposed:u}}var Ire,Nre={kernelName:Vk,backendName:"wasm",setupFunc:function(e){wre=e.wasm.cwrap(Vk,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:o}=n,s=t.dataIdMap.get(o.dataId).id,l=o,{transposed:u,axes:d,originalAxes:c,inputWasTransposed:p}=Sre(o,a,t);p&&(l=u,s=t.dataIdMap.get(u.dataId).id);let h=l.shape.length;AO.assertAxesAreInnerMostDims("all",d,h);let[f,m]=AO.computeOutAndReduceShapes(l.shape,d),g=fC.sizeFromShape(m),b=t.makeOutput(f,o.dtype);if(0!==fC.sizeFromShape(l.shape)){let e=t.dataIdMap.get(b.dataId).id;wre(s,g,e)}if(p&&t.disposeData(u.dataId),i){let e=AO.expandShapeToKeepDim(b.shape,c);b.shape=e}return b}},Cre={kernelName:Uk,backendName:"wasm",setupFunc:function(e){Ire=e.wasm.cwrap(Uk,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:o}=n,s=t.dataIdMap.get(o.dataId).id,l=o,{transposed:u,axes:d,originalAxes:c,inputWasTransposed:p}=Sre(o,a,t);p&&(l=u,s=t.dataIdMap.get(u.dataId).id);let h=l.shape.length;AO.assertAxesAreInnerMostDims("any",d,h);let[f,m]=AO.computeOutAndReduceShapes(l.shape,d),g=fC.sizeFromShape(m),b=t.makeOutput(f,o.dtype);if(0!==fC.sizeFromShape(l.shape)){let e=t.dataIdMap.get(b.dataId).id;Ire(s,g,e)}if(p&&t.disposeData(u.dataId),i){let e=AO.expandShapeToKeepDim(b.shape,c);b.shape=e}return b}};function Tre(e){let t;return{kernelName:e,backendName:"wasm",setupFunc:function(n){t=n.wasm.cwrap(e,null,["number","number","number","number","number"])},kernelFunc:function(e){let{backend:n,inputs:r,attrs:a}=e,{axis:i}=a,{x:o}=r,s=n.dataIdMap.get(o.dataId).id,l=s,u=o,{transposed:d,axes:c,inputWasTransposed:p}=Sre(o,i,n);if(p){let e=n.dataIdMap.get(d.dataId).id;e!==s&&(u=d,l=e)}let h=u.shape.slice(0,-1),f=n.makeOutput(h,"int32"),m=n.dataIdMap.get(f.dataId).id,g=fC.sizeFromShape(f.shape),b=u.shape[c[0]];return t(l,Jne[u.dtype],g,b,m),p&&n.disposeData(d.dataId),f}}}var $re,Ere,_re,Are,Rre=Tre(jk),Fre=Tre(Hk),Dre=ure(Gk),Mre=ure(qk),Ore=ure(Kk),zre=hre(Yk),Pre=ure(Xk),Lre={kernelName:Qk,backendName:"wasm",setupFunc:function(e){$re=e.wasm.cwrap(Qk,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,i=r.dataIdMap.get(a.dataId).id,{filterSize:o,strides:s,pad:l,dimRoundingMode:u}=n,d=AO.computePool2DInfo(a.shape,o,s,1,l,u),c=d.filterHeight,p=d.filterWidth,h=d.padInfo.top,f=d.padInfo.right,m=d.padInfo.bottom,g=d.padInfo.left,b=d.strideHeight,y=d.strideWidth,v=d.inChannels;if("channelsLast"!==d.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);if(1!==d.dilationWidth||1!==d.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${d.dilationHeight}, ${d.dilationWidth}].`);let x=r.makeOutput(d.outShape,"float32"),w=r.dataIdMap.get(x.dataId).id;return $re(i,a.shape[0],a.shape[1],a.shape[2],c,p,h,f,m,g,b,y,v,w),x}},Bre={kernelName:Jk,backendName:"wasm",setupFunc:function(e){Ere=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:o,pad:s,dimRoundingMode:l,dataFormat:u}=r,d=AO.computePool3DInfo(a.shape,i,o,1,s,l,u),c=n.makeOutput(d.outShape,a.dtype);return Ere(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inChannels,d.inDepth,d.inHeight,d.inWidth,d.outDepth,d.outHeight,d.outWidth,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),c}},Wre={kernelName:eS,backendName:"wasm",setupFunc:function(e){_re=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:o,strides:s,pad:l,dimRoundingMode:u}=r,d=AO.computePool3DInfo(i.shape,o,s,1,l,u),c=n.makeOutput(i.shape,i.dtype);return _re(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inChannels,d.inDepth,d.inHeight,d.inWidth,d.outDepth,d.outHeight,d.outWidth,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left,d.filterDepth,d.filterHeight,d.filterWidth),c}},Vre={kernelName:Zk,backendName:"wasm",setupFunc:function(e){Are=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:o,strides:s,pad:l}=r,u=AO.computePool2DInfo(i.shape,o,s,1,l),d=n.makeOutput(i.shape,i.dtype);return Are(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left,u.filterHeight,u.filterWidth),d}};function Ure(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,i=fC.sizeFromShape(r.shape),o=fC.inferFromImplicitShape(a,i);return fC.assert(i===fC.sizeFromShape(o),(()=>`new shape: ${o}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:o,dtype:r.dtype}}var jre,Hre={kernelName:eN,backendName:"wasm",kernelFunc:Ure},Gre={kernelName:tS,backendName:"wasm",setupFunc:function(e){jre=e.wasm.cwrap(tS,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:i}=t,{transposeA:o,transposeB:s}=r;if("float32"!==a.dtype||"float32"!==i.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=a.shape.length,u=i.shape.length,d=o?a.shape[l-2]:a.shape[l-1],c=s?i.shape[u-1]:i.shape[u-2],p=o?a.shape[l-1]:a.shape[l-2],h=s?i.shape[u-2]:i.shape[u-1],f=a.shape.slice(0,-2),m=i.shape.slice(0,-2),g=fC.sizeFromShape(f),b=fC.sizeFromShape(m),y=N_.assertAndGetBroadcastShape(a.shape.slice(0,-2),i.shape.slice(0,-2)).concat([p,h]);fC.assert(d===c,(()=>`Error in matMul: inner shapes (${d}) and (${c}) of Tensors with shapes ${a.shape} and ${i.shape} and transposeA=${o} and transposeB=${s} must match.`));let v=s?[b,h,c]:[b,c,h],x=Ure({inputs:{x:a},backend:n,attrs:{shape:o?[g,d,p]:[g,p,d]}}),w=Ure({inputs:{x:i},backend:n,attrs:{shape:v}}),k=n.dataIdMap.get(x.dataId).id,S=n.dataIdMap.get(w.dataId).id,I=o?x.shape[2]:x.shape[1],N=s?w.shape[1]:w.shape[2],C=Math.max(g,b),T=n.makeOutput([C,I,N],x.dtype),$=n.dataIdMap.get(T.dataId).id,E=new Uint8Array(new Int32Array(x.shape).buffer),_=new Uint8Array(new Int32Array(w.shape).buffer);return jre(k,E,x.shape.length,S,_,w.shape.length,o,s,$),n.disposeData(x.dataId),n.disposeData(w.dataId),T.shape=y,T}};function qre(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[i,o]=iO.parseSliceParams(t,n,r),s=iO.isSliceContinous(t.shape,i,o),l=a.readSync(t.dataId),u=a.makeOutput(o,t.dtype),d=fC.computeStrides(t.shape),c=a.dataIdMap.get(u.dataId);if(s){let e=iO.computeFlatOffset(i,d);return"string"===t.dtype?c.stringBytes=l.slice(e,e+fC.sizeFromShape(o)):a.typedArrayFromHeap(u).set(l.subarray(e,e+fC.sizeFromShape(o))),u}if("string"===t.dtype){let e=ZZ(l,i,o,t.shape,t.dtype);return c.stringBytes=e,u}let p=a.typedArrayFromHeap(u),h=t.shape.length;if(2===h)!function(e,t,n,r,a){let i=0,o=r[0],s=r[1],l=o+a[0];for(let u=o;u<l;u++){let r=u*t+s;n.set(e.subarray(r,r+a[1]),i),i+=a[1]}}(l,d[0],p,i,o);else if(3===h)!function(e,t,n,r,a,i){let o=0,s=a[0],l=a[1],u=a[2],d=s+i[0],c=l+i[1];for(let p=s;p<d;p++)for(let a=l;a<c;a++){let s=p*t+a*n+u;r.set(e.subarray(s,s+i[2]),o),o+=i[2]}}(l,d[0],d[1],p,i,o);else if(4===h)!function(e,t,n,r,a,i,o){let s=0,l=i[0],u=i[1],d=i[2],c=l+o[0],p=u+o[1],h=d+o[2],f=i[3];for(let m=l;m<c;m++)for(let i=u;i<p;i++)for(let l=d;l<h;l++){let u=m*t+i*n+l*r+f;a.set(e.subarray(u,u+o[3]),s),s+=o[3]}}(l,d[0],d[1],d[2],p,i,o);else{let e=ZZ(l,i,o,t.shape,t.dtype);p.set(e)}return u}var Kre,Xre={kernelName:fN,backendName:"wasm",kernelFunc:qre},Yre={kernelName:nS,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,crops:o}=r,s=i.reduce(((e,t)=>e*t)),l=AO.getReshaped(a.shape,i,s),u=AO.getPermuted(l.length,i.length),d=AO.getReshapedPermuted(a.shape,i,s),c=AO.getSliceBeginCoords(o,i.length),p=AO.getSliceSize(d,o,i.length),h=Ure({inputs:{x:a},backend:n,attrs:{shape:l}}),f=xre({inputs:{x:h},backend:n,attrs:{perm:u}}),m=qre({inputs:{x:Ure({inputs:{x:f},backend:n,attrs:{shape:d}})},backend:n,attrs:{begin:c,size:p}});return n.disposeData(h.dataId),n.disposeData(f.dataId),n.disposeData(h.dataId),m}},Qre={kernelName:rS,backendName:"wasm",setupFunc:function(e){Kre=e.wasm.cwrap(rS,null,["number","number","boolean","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:i}=n,{size:o}=r,s=0!==i.shape.reduce(((e,t)=>e*t),1),l=1===a.shape.length?[o]:[a.shape[0],o],u=t.makeOutput(l,i.dtype);function d(e){return t.dataIdMap.get(e.dataId).id}return Kre(d(a),o,s,d(i),Jne[i.dtype],d(u)),u}},Zre=hre(aS),Jre={kernelName:oS,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,i=n.typedArrayFromHeap(r),o=n.typedArrayFromHeap(a),s=AO.assertAndGetBroadcastShape(Array.from(i),Array.from(o));return n.makeOutput([s.length],"int32",void 0,new Int32Array(s))}};function eae(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),i=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(i),a}var tae,nae={kernelName:sS,backendName:"wasm",kernelFunc:eae},rae=ure(lS),aae={kernelName:uS,backendName:"wasm",setupFunc:function(e){tae=e.wasm.cwrap(uS,null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:i,clipValueMax:o}=r,s=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(l.dataId).id;return tae(s,i,o,u),l}};function iae(e){let{inputs:t,backend:n}=e,r=fC.parseAxisParam(e.attrs.axis,t[0].shape)[0],a=t.map((e=>e.shape));AO.assertParamsConsistent(a,r);let i=AO.computeOutShape(t.map((e=>e.shape)),r),o=t.filter((e=>fC.sizeFromShape(e.shape)>0));if(1===o.length)return bre({inputs:{x:o[0]},backend:n});let s=n.makeOutput(i,t[0].dtype);if(0===fC.sizeFromShape(i))return s;if("string"===o[0].dtype){let e=o.map((e=>{let t=[-1,fC.sizeFromShape(e.shape.slice(r))];return Ure({inputs:{x:e},backend:n,attrs:{shape:t}})})),a=e.map((e=>({vals:n.readSync(e.dataId),shape:e.shape})));i=AO.computeOutShape(e.map((e=>e.shape)),1);let l=1===e[0].shape[0],u=RQ(a,i,t[0].dtype,l),d=AO.computeOutShape(o.map((e=>e.shape)),r);return s.shape=d,n.dataIdMap.get(s.dataId).stringBytes=AO.fromStringArrayToUint8(u),e.forEach((e=>n.disposeData(e.dataId))),s}let l=fC.sizeFromShape(o[0].shape.slice(0,r)),u=0,d=o.map((e=>{let t=fC.sizeFromShape(e.shape.slice(r));return u+=t,t})),c=o.map((e=>n.typedArrayFromHeap(e))),p=n.typedArrayFromHeap(s);for(let h=0;h<l;h++){let e=h*u;for(let t=0;t<c.length;t++){let n=d[t],r=h*n,a=c[t].subarray(r,r+n);p.set(a,e),e+=n}}return s}var oae,sae,lae,uae,dae,cae,pae,hae={kernelName:pS,backendName:"wasm",kernelFunc:iae},fae={kernelName:hS,backendName:"wasm",setupFunc:function(e){oae=e.wasm.cwrap(hS,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:i}=t,o=r.dataIdMap.get(a.dataId).id,s=r.dataIdMap.get(i.dataId).id,{strides:l,dilations:u,pad:d,dimRoundingMode:c,dataFormat:p}=n,h=AO.convertConv2DDataFormat(p),f=AO.computeConv2DInfo(a.shape,i.shape,l,u,d,c,!1,h),m=f.filterHeight,g=f.filterWidth,b=f.padInfo.top,y=f.padInfo.right,v=f.padInfo.bottom,x=f.padInfo.left,w=f.dilationHeight,k=f.dilationWidth,S=f.strideHeight,I=f.strideWidth,N=f.inChannels,C=f.outChannels,T="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let $=r.makeOutput(f.outShape,"float32"),E=r.dataIdMap.get($.dataId).id;return oae(o,a.shape[0],a.shape[1],a.shape[2],s,m,g,b,y,v,x,T,w,k,S,I,N,C,E),$}},mae={kernelName:mS,backendName:"wasm",setupFunc:function(e){sae=e.wasm.cwrap(mS,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:i}=n,{strides:o,pad:s,dataFormat:l,dimRoundingMode:u,inputShape:d}=r,c=AO.convertConv2DDataFormat(l),p=AO.computeConv2DInfo(d,i.shape,o,1,s,u,!1,c),{batchSize:h,filterHeight:f,filterWidth:m,inChannels:g,inHeight:b,inWidth:y,outChannels:v,outHeight:x,outWidth:w,strideHeight:k,strideWidth:S}=p,I=f-1-p.padInfo.top,N=m-1-p.padInfo.left,C="channelsLast"===p.dataFormat,T=fC.computeStrides(p.inShape),$=fC.computeStrides(a.shape),[E,_,A]=fC.computeStrides(i.shape),R=T[0],F=C?T[1]:T[2],D=C?T[2]:1,M=C?1:T[1],O=$[0],z=C?$[1]:$[2],P=C?$[2]:1,L=C?1:$[1],B=t.makeOutput(p.inShape,"float32"),W=t.dataIdMap.get(B.dataId).id,V=t.dataIdMap.get(a.dataId).id,U=t.dataIdMap.get(i.dataId).id;return sae(V,U,h,f,m,b,y,g,x,w,v,k,S,I,N,E,_,A,R,F,D,M,O,z,P,L,W),B}},gae={kernelName:gS,backendName:"wasm",setupFunc:function(e){lae=e.wasm.cwrap(gS,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:o,pad:s,dilations:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor x must have dtype float32, got ${a.dtype}`);if("float32"!==i.dtype)throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);let u=AO.computeConv3DInfo(a.shape,i.shape,o,l,s),d=n.makeOutput(u.outShape,a.dtype);return lae(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),d}},bae={kernelName:bS,backendName:"wasm",setupFunc:function(e){uae=e.wasm.cwrap(bS,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:i}=t,{strides:o,pad:s,filterShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==i.dtype)throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);let u=AO.computeConv3DInfo(a.shape,l,o,1,s),d=n.makeOutput(u.filterShape,i.dtype);return uae(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),d}},yae={kernelName:yS,backendName:"wasm",setupFunc:function(e){dae=e.wasm.cwrap(yS,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:i}=t,{pad:o,strides:s,inputShape:l}=r;if("float32"!==a.dtype)throw new Error(`Tensor dy must have dtype float32, got ${a.dtype}`);if("float32"!==i.dtype)throw new Error(`Tensor filter must have dtype float32, got ${i.dtype}`);let u=AO.computeConv3DInfo(l,i.shape,s,1,o),d=n.makeOutput(u.inShape,a.dtype);return dae(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(d.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),d}},vae=ure(vS),xae=ure(xS);!function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"}(cae||(cae={}));var wae,kae,Sae,Iae,Nae,Cae,Tae,$ae,Eae,_ae,Aae={kernelName:SS,backendName:"wasm",setupFunc:function(e){pae=e.wasm.cwrap(SS,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{method:i,extrapolationValue:o,cropSize:s}=a,{image:l,boxes:u,boxInd:d}=r,c=u.shape[0],[p,h]=s,f=[c,p,h,l.shape[3]],m=n.dataIdMap.get(l.dataId);"float32"!==l.dtype&&(t=eae({backend:n,inputs:{x:l},attrs:{dtype:"float32"}}),m=n.dataIdMap.get(t.dataId));let g=m.id,b=n.dataIdMap.get(u.dataId).id,y=n.dataIdMap.get(d.dataId).id,v=n.makeOutput(f,"float32"),x=n.dataIdMap.get(v.dataId).id,w=new Uint8Array(new Int32Array(l.shape).buffer);return pae(g,b,y,c,w,p,h,cae[i],o,x),null!=t&&n.disposeData(t.dataId),v}},Rae={kernelName:wS,backendName:"wasm",setupFunc:function(e){wae=e.wasm.cwrap(wS,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:o,reverse:s}=r,l=a.shape.length;fC.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`));let u=AO.getAxesPermutation([i],l),d=a;null!==u&&(d=xre({inputs:{x:a},attrs:{perm:u},backend:n}));let c=AO.getInnerMostAxes(1,l)[0];AO.assertAxesAreInnerMostDims("cumprod",[c],l);let p=n.makeOutput(d.shape,d.dtype),h=d.shape[c],f=n.dataIdMap.get(d.dataId).id,m=n.dataIdMap.get(p.dataId).id;wae(f,o?1:0,s?1:0,h,m,Jne[a.dtype]);let g=p;return null!==u&&(g=xre({inputs:{x:p},attrs:{perm:AO.getUndoAxesPermutation(u)},backend:n}),n.disposeData(d.dataId),n.disposeData(p.dataId)),g}},Fae={kernelName:kS,backendName:"wasm",setupFunc:function(e){kae=e.wasm.cwrap(kS,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:i,exclusive:o,reverse:s}=r,l=a.shape.length;fC.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`));let u=AO.getAxesPermutation([i],l),d=a;null!==u&&(d=xre({inputs:{x:a},attrs:{perm:u},backend:n}));let c=AO.getInnerMostAxes(1,l)[0];AO.assertAxesAreInnerMostDims("cumsum",[c],l);let p=n.makeOutput(d.shape,d.dtype),h=d.shape[c],f=n.dataIdMap.get(d.dataId).id,m=n.dataIdMap.get(p.dataId).id;kae(f,o?1:0,s?1:0,h,m,Jne[a.dtype]);let g=p;return null!==u&&(g=xre({inputs:{x:p},attrs:{perm:AO.getUndoAxesPermutation(u)},backend:n}),n.disposeData(d.dataId),n.disposeData(p.dataId)),g}},Dae={kernelName:IS,backendName:"wasm",setupFunc:function(e){Sae=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,weights:i}=n,{size:o,binaryOutput:s}=r,l=0!==i.shape.reduce(((e,t)=>e*t),1),u=1===a.shape.length?[o]:[a.shape[0],o],d=t.makeOutput(u,i.dtype);function c(e){return t.dataIdMap.get(e.dataId).id}return Sae(c(a),new Uint8Array(new Int32Array(a.shape).buffer),a.shape.length,o,l,c(i),Jne[i.dtype],s,c(d)),d}},Mae={kernelName:NS,backendName:"wasm",setupFunc:function(e){Iae=e.wasm.cwrap(NS,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:i,dataFormat:o}=r,s=a.shape[0],l=("NHWC"===o?a.shape[1]:a.shape[2])*i,u=("NHWC"===o?a.shape[2]:a.shape[3])*i,d=("NHWC"===o?a.shape[3]:a.shape[1])/(i*i),c="NHWC"===o?[s,l,u,d]:[s,d,l,u],p=t.makeOutput(c,"float32"),h=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(fC.computeStrides(a.shape)).buffer),m=new Uint8Array(new Int32Array(c).buffer),g=new Uint8Array(new Int32Array(fC.computeStrides(c)).buffer),b=t.dataIdMap.get(p.dataId).id;return Iae(h,i,"NHWC"===o?1:0,f,a.shape.length-1,m,g,c.length,b),p}},Oae={kernelName:CS,backendName:"wasm",setupFunc:function(e){Nae=e.wasm.cwrap(CS,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:i}=t,o=r.dataIdMap.get(a.dataId).id,s=r.dataIdMap.get(i.dataId).id,{strides:l,dilations:u,pad:d,dimRoundingMode:c}=n,p=null==u?[1,1]:u,h=AO.computeConv2DInfo(a.shape,i.shape,l,p,d,c,!0),f=h.filterHeight,m=h.filterWidth,g=h.padInfo.top,b=h.padInfo.right,y=h.padInfo.bottom,v=h.padInfo.left,x=h.dilationHeight,w=h.dilationWidth,k=h.strideHeight,S=h.strideWidth,I=h.inChannels,N=h.outChannels,C="SAME"===h.padInfo.type?1:0;if("channelsLast"!==h.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);let T=r.makeOutput(h.outShape,"float32"),$=r.dataIdMap.get(T.dataId).id;return Nae(o,a.shape[0],a.shape[1],a.shape[2],s,f,m,g,b,y,v,C,x,w,k,S,I,N,$),T}},zae={kernelName:ES,backendName:"wasm",setupFunc:function(e){Cae=e.wasm.cwrap("Diag",null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r}=t,a=fC.sizeFromShape(r.shape),i=n.makeOutput([...r.shape,...r.shape],r.dtype);return Cae(n.dataIdMap.get(r.dataId).id,Jne[r.dtype],a,n.dataIdMap.get(i.dataId).id),i}},Pae={kernelName:_S,backendName:"wasm",setupFunc:function(e){Tae=e.wasm.cwrap(_S,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i}=t,{strides:o,pad:s,dilations:l}=r;if(a.dtype!==i.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${a.dtype} and ${i.dtype}`);let u=AO.computeDilation2DInfo(a.shape,i.shape,o,s,"NHWC",l),d=n.makeOutput(u.outShape,a.dtype);return Tae(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,Jne[a.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),d}},Lae={kernelName:RS,backendName:"wasm",setupFunc:function(e){$ae=e.wasm.cwrap(RS,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,dy:o}=t,{strides:s,pad:l,dilations:u}=r;if(a.dtype!==i.dtype||a.dtype!==o.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${i.dtype}, and ${o.dtype}`);let d=AO.computeDilation2DInfo(a.shape,i.shape,s,l,"NHWC",u),c=n.makeOutput(i.shape,i.dtype);return $ae(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(o.dataId).id,n.dataIdMap.get(c.dataId).id,Jne[a.dtype],d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.filterHeight,d.filterWidth,d.padInfo.top,d.padInfo.left),c}},Bae={kernelName:AS,backendName:"wasm",setupFunc:function(e){Eae=e.wasm.cwrap(AS,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:i,dy:o}=t,{strides:s,pad:l,dilations:u}=r;if(a.dtype!==i.dtype||a.dtype!==o.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${a.dtype}, ${i.dtype}, and ${o.dtype}`);let d=AO.computeDilation2DInfo(a.shape,i.shape,s,l,"NHWC",u),c=n.makeOutput(a.shape,a.dtype);return Eae(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(o.dataId).id,n.dataIdMap.get(c.dataId).id,Jne[a.dtype],d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.filterHeight,d.filterWidth,d.padInfo.top,d.padInfo.left),c}},Wae=ure(OS),Vae={kernelName:zS,backendName:"wasm",setupFunc:function(e){_ae=e.wasm.cwrap(zS,null,["number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t,i=n.makeOutput(a.shape,"float32"),o=e=>n.dataIdMap.get(e.dataId).id;return _ae(o(a),o(r),o(i)),i}},Uae=hre(LS,0,"bool"),jae=ure(PS),Hae=ure(BS,"float32");function Gae(e){let{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:i}=n,o=a.shape.length,s=a.shape.slice(),l=i;return i<0&&(fC.assert(-(o+1)<=i,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+i+1),s.splice(l,0,1),Ure({inputs:{x:a},backend:r,attrs:{shape:s}})}var qae={kernelName:WS,backendName:"wasm",kernelFunc:Gae},Kae=ure(VS,"float32");function Xae(e){let{attrs:{shape:t,value:n,dtype:r},backend:a}=e,i=a.makeOutput(t,r);return a.typedArrayFromHeap(i).fill(n),i}var Yae,Qae,Zae,Jae,eie,tie,nie,rie,aie,iie,oie,sie,lie,uie,die,cie,pie,hie,fie,mie,gie={kernelName:jS,backendName:"wasm",kernelFunc:Xae},bie={kernelName:HS,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,[s,l,u,d]=r.shape;return Yae(i,s,l,u,d,o),a},setupFunc:function(e){Yae=e.wasm.cwrap(HS,null,["number","number","number","number","number","number"])}},yie=ure(GS),vie=hre(qS),xie={kernelName:KS,backendName:"wasm",setupFunc:function(e){Qae=e.wasm.cwrap(KS,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:i,mean:o,variance:s,offset:l,scale:u}=n,d=t.dataIdMap.get(i.dataId).id,c=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(s.dataId).id,h=null!=l?t.dataIdMap.get(l.dataId).id:0,f=null!=u?t.dataIdMap.get(u.dataId).id:0,m=t.makeOutput(i.shape,i.dtype);if(0===fC.sizeFromShape(i.shape))return m;let g=t.dataIdMap.get(m.dataId).id;return Qae(d,c,p,h,f,a,g),m}},wie={kernelName:JN,backendName:"wasm",setupFunc:function(e){Zae=e.wasm.cwrap(JN,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:i,bias:o,preluActivationWeights:s}=t,{strides:l,pad:u,dilations:d,dataFormat:c,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=n,m=AO.computeConv2DInfo(a.shape,i.shape,l,d,u,p),g=ere[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);let b=r.dataIdMap.get(a.dataId).id,y=r.dataIdMap.get(i.dataId).id,v=m.outChannels,x=0;if(null!=o){let e=r.dataIdMap.get(o.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==v)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${v})`);x=e.id}let w=m.filterHeight,k=m.filterWidth,S=m.padInfo.top,I=m.padInfo.right,N=m.padInfo.bottom,C=m.padInfo.left,T=m.dilationHeight,$=m.dilationWidth,E=m.strideHeight,_=m.strideWidth,A=m.inChannels,R="SAME"===m.padInfo.type?1:0,F=m.batchSize,D=m.inHeight,M=m.inWidth;if("NHWC"!==c)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),z=r.dataIdMap.get(O.dataId).id,P=null==s?0:r.dataIdMap.get(s.dataId).id;return Zae(b,F,D,M,y,w,k,x,S,I,N,C,R,T,$,E,_,A,v,g,P,f||0,z),O}},kie={kernelName:eC,backendName:"wasm",setupFunc:function(e){Jae=e.wasm.cwrap(eC,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:i,bias:o,preluActivationWeights:s}=t,{strides:l,pad:u,dilations:d,dataFormat:c,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=n,m=AO.computeConv2DInfo(a.shape,i.shape,l,d,u,p,!0),g=ere[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let b=r.dataIdMap.get(a.dataId).id,y=r.dataIdMap.get(i.dataId).id,v=m.outChannels,x=0;if(null!=o){let e=r.dataIdMap.get(o.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==v)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${v})`);x=e.id}let w=m.filterHeight,k=m.filterWidth,S=m.padInfo.top,I=m.padInfo.right,N=m.padInfo.bottom,C=m.padInfo.left,T=m.dilationHeight,$=m.dilationWidth,E=m.strideHeight,_=m.strideWidth,A=m.inChannels,R="SAME"===m.padInfo.type?1:0,F=m.batchSize,D=m.inHeight,M=m.inWidth;if("NHWC"!==c)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),z=r.dataIdMap.get(O.dataId).id,P=null==s?0:r.dataIdMap.get(s.dataId).id;return Jae(b,F,D,M,y,w,k,x,S,I,N,C,R,T,$,E,_,A,v,g,P,f||0,z),O}},Sie={kernelName:YS,backendName:"wasm",setupFunc:function(e){eie=e.wasm.cwrap(YS,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(e){let{backend:t,inputs:n}=e,{params:r,indices:a}=n,[i,o,s,l]=rO.prepareAndValidate(r,a),u=t.makeOutput(i,r.dtype);if(0===o)return u;let d=a.shape,c=d[d.length-1],p=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(u.dataId).id;return eie(p,Jne[r.dtype],h,o,c,s,f,m),u}},Iie={kernelName:XS,backendName:"wasm",setupFunc:function(e){tie=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,indices:i}=n,{axis:o,batchDims:s}=r,l=fC.parseAxisParam(o,a.shape)[0],u=t.readSync(i.dataId),d=a.shape[l];for(let S=0;S<u.length;++S){let e=u[S];fC.assert(e<=d-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${d-1}]`))}let c=AO.segment_util.collectGatherOpShapeInfo(a,i,l,s),p=Ure({inputs:{x:a},attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]},backend:t}),h=fC.sizeFromShape(i.shape),f=Ure({inputs:{x:i},attrs:{shape:[c.batchSize,h/c.batchSize]},backend:t}),m=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize],g=t.makeOutput(m,a.dtype);if(0===fC.sizeFromShape(a.shape))return g;let b=p.shape.length-1,y=t.dataIdMap.get(p.dataId).id,v=t.dataIdMap.get(f.dataId).id,x=t.dataIdMap.get(g.dataId).id,w=new Uint8Array(new Int32Array(fC.computeStrides(p.shape)).buffer),k=new Uint8Array(new Int32Array(fC.computeStrides(m)).buffer);return tie(y,Jne[a.dtype],w,b,v,c.batchSize,k,x),t.disposeData(p.dataId),t.disposeData(f.dataId),g.shape=c.outputShape,g}},Nie=hre(QS,0,"bool"),Cie=hre(ZS,0,"bool"),Tie=ure(nI,"bool"),$ie=ure(rI,"bool"),Eie=ure(aI,"bool"),_ie={kernelName:iI,backendName:"wasm",setupFunc:function(e){nie=e.wasm.cwrap(iI,null,["number","number","number","number"])},kernelFunc:function(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,i=r.makeOutput(t.shape,"float32");if(0!==fC.sizeFromShape(t.shape)){let e=r.dataIdMap.get(i.dataId).id;nie(a,Jne[t.dtype],n,e)}return i}},Aie=hre(oI,0,"bool"),Rie=hre(sI,0,"bool"),Fie={kernelName:lI,backendName:"wasm",setupFunc:function(e){rie=e.wasm.cwrap(lI,null,["number","number","number","number"])},kernelFunc:function(e){let{attrs:t,backend:n}=e,{start:r,stop:a,num:i}=t,o=Math.floor(i),s=n.makeOutput([o],"float32");return rie(n.dataIdMap.get(s.dataId).id,r,a,o),s}},Die=ure(uI),Mie=ure(dI),Oie=hre(cI,0,"bool"),zie=ure(pI),Pie=hre(hI,0,"bool"),Lie=hre(fI,0,"bool"),Bie={kernelName:bI,backendName:"wasm",setupFunc:function(e){aie=e.wasm.cwrap(bI,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:i,bias:o,alpha:s,beta:l}=r;if("float32"!==a.dtype)throw new Error("LRN error: x must have dtype float32");let u=n.makeOutput(a.shape,a.dtype);return aie(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(u.dataId).id,a.shape[3],i,o,s,l),u}},Wie={kernelName:yI,backendName:"wasm",setupFunc:function(e){iie=e.wasm.cwrap(yI,null,["number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:i,dy:o}=t,{depthRadius:s,bias:l,alpha:u,beta:d}=r;if("float32"!==a.dtype||"float32"!==i.dtype||"float32"!==o.dtype)throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let c=n.makeOutput(a.shape,a.dtype);return iie(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(o.dataId).id,n.dataIdMap.get(c.dataId).id,o.shape[3],s,l,u,d),c}},Vie={kernelName:xI,backendName:"wasm",setupFunc:function(e){oie=e.wasm.cwrap(xI,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:i}=r,{x:o}=n,s=t.dataIdMap.get(o.dataId).id,l=o,{transposed:u,axes:d,originalAxes:c,inputWasTransposed:p}=Sre(o,a,t);p&&(l=u,s=t.dataIdMap.get(u.dataId).id);let h=l.shape.length;AO.assertAxesAreInnerMostDims("max",d,h);let[f,m]=AO.computeOutAndReduceShapes(l.shape,d),g=fC.sizeFromShape(m),b=t.makeOutput(f,o.dtype);if(0!==fC.sizeFromShape(l.shape)){let e=t.dataIdMap.get(b.dataId).id;oie(s,Jne[o.dtype],g,e)}if(p&&t.disposeData(u.dataId),i){let e=AO.expandShapeToKeepDim(b.shape,c);b.shape=e}return b}},Uie=hre(wI),jie={kernelName:kI,backendName:"wasm",setupFunc:function(e){sie=e.wasm.cwrap(kI,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,i=r.dataIdMap.get(a.dataId).id;fC.assert("float32"===a.dtype,(()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`));let{filterSize:o,strides:s,pad:l,dimRoundingMode:u}=n,d=AO.computePool2DInfo(a.shape,o,s,1,l,u),c=d.filterHeight,p=d.filterWidth,h=d.padInfo.top,f=d.padInfo.right,m=d.padInfo.bottom,g=d.padInfo.left,b=d.dilationHeight,y=d.dilationWidth,v=d.strideHeight,x=d.strideWidth,w=d.inChannels,k=d.outChannels;if("channelsLast"!==d.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);let S=r.makeOutput(d.outShape,"float32"),I=r.dataIdMap.get(S.dataId).id;return sie(i,a.shape[0],a.shape[1],a.shape[2],c,p,h,f,m,g,b,y,v,x,w,k,I),S}},Hie={kernelName:II,backendName:"wasm",setupFunc:function(e){lie=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:o,pad:s,dimRoundingMode:l,dataFormat:u}=r,d=AO.computePool3DInfo(a.shape,i,o,1,s,l,u),c=n.makeOutput(d.outShape,a.dtype);return lie(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inChannels,d.inDepth,d.inHeight,d.inWidth,d.outDepth,d.outHeight,d.outWidth,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),c}},Gie={kernelName:NI,backendName:"wasm",setupFunc:function(e){uie=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:o,strides:s,pad:l,dimRoundingMode:u}=r,d=AO.computePool3DInfo(i.shape,o,s,1,l,u),c=n.makeOutput(i.shape,i.dtype);return uie(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inChannels,d.inDepth,d.inHeight,d.inWidth,d.outDepth,d.outHeight,d.outWidth,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),c}},qie={kernelName:SI,backendName:"wasm",setupFunc:function(e){die=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:i}=t,{filterSize:o,strides:s,pad:l,dimRoundingMode:u}=r,d=AO.computePool2DInfo(i.shape,o,s,1,l,u),c=n.makeOutput(i.shape,i.dtype);return die(n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.top,d.padInfo.left),c}},Kie={kernelName:CI,backendName:"wasm",setupFunc:function(e){cie=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:i,strides:o,pad:s,includeBatchInIndex:l}=r;fC.assert(4===a.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`));let u=[1,1];fC.assert(AO.eitherStridesOrDilationsAreOne(o,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`));let d=AO.computePool2DInfo(a.shape,i,o,[1,1],s),c=n.makeOutput(d.outShape,a.dtype),p=n.makeOutput(d.outShape,"int32");return cie(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,n.dataIdMap.get(p.dataId).id,Jne[a.dtype],l,d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.top,d.padInfo.left),[c,p]}},Xie={kernelName:TI,backendName:"wasm",setupFunc:function(e){pie=e.wasm.cwrap(TI,null,["number, number, number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:o}=n,s=t.dataIdMap.get(o.dataId).id,l=s,u=o,{transposed:d,axes:c,originalAxes:p,inputWasTransposed:h}=Sre(o,a,t),f=c;if(h){let e=t.dataIdMap.get(d.dataId).id;e!==s&&(u=d,l=e,f=AO.getInnerMostAxes(f.length,u.shape.length))}AO.assertAxesAreInnerMostDims("mean",f,u.shape.length);let[m,g]=AO.computeOutAndReduceShapes(u.shape,f),b=fC.sizeFromShape(g),y=u;"float32"!==u.dtype&&(y=eae({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(y.dataId).id);let v=t.makeOutput(m,"float32");if(0!==fC.sizeFromShape(u.shape)){let e=t.dataIdMap.get(v.dataId).id;pie(l,b,e)}if(h&&t.disposeData(d.dataId),i){let e=AO.expandShapeToKeepDim(v.shape,p);v.shape=e}return"float32"!==u.dtype&&t.disposeData(y.dataId),v}},Yie={kernelName:$I,backendName:"wasm",setupFunc:function(e){hie=e.wasm.cwrap($I,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:o}=n,s=t.dataIdMap.get(o.dataId).id,l=s,u=o,{transposed:d,axes:c,originalAxes:p,inputWasTransposed:h}=Sre(o,a,t);if(h){let e=t.dataIdMap.get(d.dataId).id;e!==s&&(u=d,l=e)}let f=u.shape.length;AO.assertAxesAreInnerMostDims("min",c,f);let[m,g]=AO.computeOutAndReduceShapes(u.shape,c),b=fC.sizeFromShape(g),y=t.makeOutput(m,u.dtype);if(0!==fC.sizeFromShape(u.shape)){let e=t.dataIdMap.get(y.dataId).id;hie(l,Jne[o.dtype],b,e)}if(h&&t.disposeData(d.dataId),i){let e=AO.expandShapeToKeepDim(y.shape,p);y.shape=e}return y}},Qie=hre(EI);!function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"}(fie||(fie={}));var Zie,Jie={kernelName:_I,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,i=r.map(((e,n)=>e[0]+t.shape[n]+e[1])),o=n.dataIdMap.get(t.dataId).id,s=n.makeOutput(i,t.dtype),l=n.dataIdMap.get(s.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),d=r.map((e=>e[0])),c=r.map((e=>e[1])),p=new Uint8Array(new Int32Array(d).buffer),h=new Uint8Array(new Int32Array(c).buffer);return mie(o,u,t.shape.length,Jne[t.dtype],p,h,fie[a],l),s},setupFunc:function(e){mie=e.wasm.cwrap(_I,null,["number","array","number","number","array","array","number","number"])}};function eoe(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,i=t.makeOutput(n.shape,n.dtype),o=t.dataIdMap.get(i.dataId).id,s=n.shape[r],l=fC.sizeFromShape(n.shape)/s;return 0===fC.sizeFromShape(i.shape)||Zie(a,o,s,l),i}var toe,noe,roe={kernelName:IN,backendName:"wasm",setupFunc:function(e){Zie=e.wasm.cwrap(IN,null,["number","number","number","number"])},kernelFunc:eoe},aoe={kernelName:RI,backendName:"wasm",setupFunc:function(e){toe=e.wasm.cwrap(RI,null,["number","number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:i,seed:o,normalized:s}=r;if("float32"!==a.dtype)throw new Error(`Tensor logits must have dtype float32, got ${a.dtype}`);let l=s?a:eoe({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),[u,d]=l.shape,c=n.makeOutput([u,i],"int32");return toe(n.dataIdMap.get(l.dataId).id,u,d,i,o,n.dataIdMap.get(c.dataId).id),s||n.disposeData(l.dataId),c}},ioe=hre(AI),ooe=hre(FI),soe=ure(DI);function loe(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],i=n[2],o=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:i,pValidOutputs:o}}var uoe,doe,coe,poe,hoe,foe,moe,goe,boe,yoe,voe,xoe,woe,koe,Soe,Ioe,Noe,Coe,Toe,$oe={kernelName:OI,backendName:"wasm",setupFunc:function(e){noe=e.wasm.cwrap(OI,"number",["number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:i,scoreThreshold:o}=r,{boxes:s,scores:l}=n,u=t.dataIdMap.get(s.dataId).id,d=t.dataIdMap.get(l.dataId).id,c=noe(u,d,i,a,o),{pSelectedIndices:p,selectedSize:h,pSelectedScores:f,pValidOutputs:m}=loe(t,c);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([h],"int32",p)}},Eoe={kernelName:zI,backendName:"wasm",setupFunc:function(e){uoe=e.wasm.cwrap(zI,"number",["number","number","number","number","number","bool"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:i,scoreThreshold:o,padToMaxOutputSize:s}=r,{boxes:l,scores:u}=n,d=t.dataIdMap.get(l.dataId).id,c=t.dataIdMap.get(u.dataId).id,p=uoe(d,c,i,a,o,s),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=loe(t,p);return t.wasm._free(m),[t.makeOutput([f],"int32",h),t.makeOutput([],"int32",g)]}},_oe={kernelName:PI,backendName:"wasm",setupFunc:function(e){doe=e.wasm.cwrap(PI,"number",["number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:i,scoreThreshold:o,softNmsSigma:s}=r,{boxes:l,scores:u}=n,d=t.dataIdMap.get(l.dataId).id,c=t.dataIdMap.get(u.dataId).id,p=doe(d,c,i,a,o,s),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=loe(t,p);return t.wasm._free(g),[t.makeOutput([f],"int32",h),t.makeOutput([f],"float32",m)]}},Aoe=hre(MI,0,"bool"),Roe={kernelName:BI,backendName:"wasm",setupFunc:function(e){coe=e.wasm.cwrap(BI,null,["number","number","number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{dtype:i,depth:o,onValue:s,offValue:l}=r,u=n.makeOutput([...a.shape,o],i),d=n.dataIdMap.get(u.dataId).id,c=n.dataIdMap.get(a.dataId).id;return coe(c,o,s,l,d),u}},Foe={kernelName:LI,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}},Doe={kernelName:WI,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return Gae({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let i=t[0].shape,o=t[0].dtype;t.forEach((e=>{fC.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),fC.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let s=[],l=t.map((e=>{let t=Gae({inputs:{input:e},backend:n,attrs:{dim:a}});return s.push(t),t})),u=iae({inputs:l,backend:n,attrs:{axis:a}});return s.forEach((e=>n.disposeData(e.dataId))),u}},Moe={kernelName:VI,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,i=r.map(((e,n)=>e[0]+t.shape[n]+e[1]));if(0===fC.sizeFromShape(t.shape))return Xae({backend:n,attrs:{shape:i,value:a,dtype:t.dtype}});let o=n.dataIdMap.get(t.dataId).id,s=n.makeOutput(i,t.dtype),l=n.dataIdMap.get(s.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),d=r.map((e=>e[0])),c=r.map((e=>e[1])),p=new Uint8Array(new Int32Array(d).buffer),h=new Uint8Array(new Int32Array(c).buffer);return poe(o,u,t.shape.length,Jne[t.dtype],p,h,a,l),s},setupFunc:function(e){poe=e.wasm.cwrap(VI,null,["number","array","number","number","array","array","number","number"])}},Ooe=hre(jI),zoe={kernelName:HI,backendName:"wasm",setupFunc:function(e){hoe=e.wasm.cwrap(HI,null,["number","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,s=i,l=r,u=l;"float32"!==l.dtype&&(u=eae({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),s=n.dataIdMap.get(u.dataId).id);let d=n.makeOutput(r.shape,"float32"),c=n.dataIdMap.get(d.dataId).id;return hoe(s,o,c),"float32"!==l.dtype&&n.disposeData(u.dataId),d}},Poe={kernelName:GI,backendName:"wasm",setupFunc:function(e){foe=e.wasm.cwrap(GI,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:o}=n,s=t.dataIdMap.get(o.dataId).id,l=s,u=o,{transposed:d,axes:c,originalAxes:p,inputWasTransposed:h}=Sre(o,a,t),f=c;if(h){let e=t.dataIdMap.get(d.dataId).id;e!==s&&(u=d,l=e,f=AO.getInnerMostAxes(f.length,u.shape.length))}AO.assertAxesAreInnerMostDims("prod",f,u.shape.length);let[m,g]=AO.computeOutAndReduceShapes(u.shape,f),b=fC.sizeFromShape(g),y=t.makeOutput(m,u.dtype);if(0!==fC.sizeFromShape(u.shape)){let e=t.dataIdMap.get(y.dataId).id;foe(l,b,Jne[y.dtype],e)}if(h&&t.disposeData(d.dataId),i){let e=AO.expandShapeToKeepDim(y.shape,p);y.shape=e}return y}},Loe={kernelName:YI,backendName:"wasm",kernelFunc:e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:i,dtype:o}=n,s=jZ(r,a,i,o),l=t.makeOutput([s.length],o);return t.typedArrayFromHeap(l).set(s),l}},Boe=hre(DS),Woe=ure(ZI),Voe=ure(JI),Uoe=ure(iN),joe={kernelName:rN,backendName:"wasm",setupFunc:function(e){moe=e.wasm.cwrap(rN,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{images:i}=r,{alignCorners:o,halfPixelCenters:s,size:l}=a,[u,d]=l,[c,p,h,f]=i.shape,m=[c,u,d,f],g=n.dataIdMap.get(i.dataId);"float32"!==g.dtype&&(t=eae({backend:n,inputs:{x:i},attrs:{dtype:"float32"}}),g=n.dataIdMap.get(t.dataId));let b=g.id,y=n.makeOutput(m,"float32");if(0===fC.sizeFromShape(i.shape))return y;let v=n.dataIdMap.get(y.dataId).id;return moe(b,c,p,h,f,u,d,o?1:0,s?1:0,v),null!=t&&n.disposeData(t.dataId),y}},Hoe={kernelName:aN,backendName:"wasm",setupFunc:function(e){goe=e.wasm.cwrap(aN,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{images:i,dy:o}=n,{alignCorners:s}=a,l=r.makeOutput(i.shape,"float32"),u=r.dataIdMap.get(i.dataId);return"float32"!==u.dtype&&(t=eae({backend:r,inputs:{x:i},attrs:{dtype:"float32"}}),u=r.dataIdMap.get(t.dataId)),goe(r.dataIdMap.get(i.dataId).id,r.dataIdMap.get(o.dataId).id,r.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(i.shape).buffer),new Uint8Array(new Int32Array(o.shape).buffer),s),null!=t&&r.disposeData(t.dataId),l}},Goe={kernelName:tN,backendName:"wasm",setupFunc:function(e){boe=e.wasm.cwrap(tN,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{images:a}=n,{alignCorners:i,halfPixelCenters:o,size:s}=r,[l,u]=s,[d,c,p,h]=a.shape,f=[d,l,u,h],m=t.makeOutput(f,"float32");if(0===fC.sizeFromShape(a.shape))return m;let g,b=t.dataIdMap.get(a.dataId);"float32"!==b.dtype&&(g=eae({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),b=t.dataIdMap.get(g.dataId));let y=b.id,v=t.dataIdMap.get(m.dataId).id;return boe(y,d,c,p,h,l,u,i?1:0,o?1:0,v),null!=g&&t.disposeData(g.dataId),m}},qoe={kernelName:nN,backendName:"wasm",setupFunc:function(e){yoe=e.wasm.cwrap(nN,null,["number","number","number","array","array","boolean"])},kernelFunc:function(e){let t,{inputs:n,backend:r,attrs:a}=e,{images:i,dy:o}=n,{alignCorners:s}=a,l=r.makeOutput(i.shape,"float32"),u=r.dataIdMap.get(i.dataId);return"float32"!==u.dtype&&(t=eae({backend:r,inputs:{x:i},attrs:{dtype:"float32"}}),u=r.dataIdMap.get(t.dataId)),yoe(r.dataIdMap.get(i.dataId).id,r.dataIdMap.get(o.dataId).id,r.dataIdMap.get(l.dataId).id,new Uint8Array(new Int32Array(i.shape).buffer),new Uint8Array(new Int32Array(o.shape).buffer),s),null!=t&&r.disposeData(t.dataId),l}},Koe={kernelName:oN,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:i}=r,o=fC.parseAxisParam(i,a.shape);if(0===a.shape.length)return bre({inputs:{x:a},backend:n});let s=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(s.dataId).id,d=new Uint8Array(new Int32Array(o).buffer),c=new Uint8Array(new Int32Array(a.shape).buffer);voe(l,d,o.length,c,a.shape.length,u);let p=Ure({inputs:{x:s},attrs:{shape:a.shape},backend:n});return n.disposeData(s.dataId),p},setupFunc:function(e){voe=e.wasm.cwrap(oN,null,["number","array","number","array","number","number"])}},Xoe={kernelName:QN,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:i,fillValue:o,center:s}=r,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(a.dataId).id,d=n.dataIdMap.get(l.dataId).id,[c,p,h,f]=a.shape,[m,g]=AO.getImageCenter(s,p,h),b="number"==typeof o?[o,o,o,0===o?0:255]:[...o,255],y=new Uint8Array(new Int32Array(b).buffer);return xoe(u,c,p,h,f,i,m,g,y,b.length,d),l},setupFunc:function(e){xoe=e.wasm.cwrap(QN,null,["number","number","number","number","number","number","number","number","array","number","number"])}},Yoe=ure(sN),Qoe=ure(lN),Zoe={kernelName:uN,backendName:"wasm",setupFunc:function(e){woe=e.wasm.cwrap(uN,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:i}=n,{shape:o}=r,s=t.makeOutput(o,i.dtype);if(0===fC.sizeFromShape(o))return s;let{sliceRank:l,numUpdates:u,sliceSize:d,strides:c,outputSize:p}=TF.calculateShapes(i,a,o),h=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=new Uint8Array(new Int32Array(c).buffer),g=t.dataIdMap.get(s.dataId).id;return woe(h,f,Jne[i.dtype],l,u,d,m,p,g),s}},Joe={kernelName:cN,backendName:"wasm",setupFunc:function(e){koe=e.wasm.cwrap(cN,null,["number","number","number","number","number","number","bool","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:i}=t,{side:o}=r;if(a.dtype!==i.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${a.dtype} and ${i.dtype}`);let s=n.makeOutput(i.shape,"int32");function l(e){return n.dataIdMap.get(e.dataId).id}return koe(l(a),l(i),a.shape[0],a.shape[1],i.shape[1],Jne[a.dtype],"left"===o,l(s)),s}},ese={kernelName:pN,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:i}=t,o=n.dataIdMap.get(r.dataId).id,s=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(i.dataId).id,u=n.makeOutput(a.shape,a.dtype),d=n.dataIdMap.get(u.dataId).id,c=r.shape.length,p=a.shape.length,h=0===c||c>1||1===p?1:fC.sizeFromShape(a.shape.slice(1));return Soe(o,s,l,h,d),u},setupFunc:function(e){Soe=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}},tse=ure(hN),nse={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(e){Ioe=e.wasm.cwrap(yN,null,["number","number"])},kernelFunc:function(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(a.dataId).id;return 0===fC.sizeFromShape(a.shape)||Ioe(r,i),a}},rse=ure(bN),ase=ure(mN),ise=ure(gN),ose=ure(vN),sse={kernelName:kN,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:i,paddings:o}=r,s=fC.sizeFromShape(i),l=[[0,0]];l.push(...o);for(let g=1+i.length;g<a.shape.length;++g)l.push([0,0]);let u=Moe.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=AO.getReshaped(u.shape,i,s,!1),c=AO.getPermuted(d.length,i.length,!1),p=AO.getReshapedPermuted(u.shape,i,s,!1),h=Ure({inputs:{x:u},backend:n,attrs:{shape:d}}),f=xre({inputs:{x:h},backend:n,attrs:{perm:c}}),m=Ure({inputs:{x:f},backend:n,attrs:{shape:p}});return n.disposeData(u.dataId),n.disposeData(h.dataId),n.disposeData(f.dataId),m}},lse={kernelName:NN,backendName:"wasm",setupFunc:function(e){Noe=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r}=e,{indices:a,values:i,denseShape:o,defaultValue:s}=r,l=a.shape[0],u=a.shape[1],d=n.readSync(o.dataId)[0],c=[l+d,u],p=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(i.dataId).id,f=n.dataIdMap.get(s.dataId).id,m=n.makeOutput(c,a.dtype),g=n.dataIdMap.get(m.dataId).id,b=n.makeOutput(c.slice(0,1),i.dtype),y=n.dataIdMap.get(b.dataId).id,v=n.makeOutput([d],"bool"),x=n.dataIdMap.get(v.dataId).id,w=n.makeOutput([l],a.dtype),k=n.dataIdMap.get(w.dataId).id,S=n.makeOutput([4],"int32"),I=n.dataIdMap.get(S.dataId).id,N=Noe(p,h,Jne[i.dtype],l,d,u,f,g,y,x,k,I),C=n.readSync(S.dataId);switch(C[0]){case 1:t=AO.getSparseFillEmptyRowsIndicesDenseShapeMismatch(C[1]);break;case 2:t=AO.getSparseFillEmptyRowsNegativeIndexErrorMessage(C[1],C[2]);break;case 3:t=AO.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(C[1],C[2],C[3]);break;default:t=""}if(n.disposeData(S.dataId),t)throw n.disposeData(m.dataId),n.disposeData(b.dataId),n.disposeData(v.dataId),n.disposeData(w.dataId),new Error(t);let T=m,$=b;return N!==c[0]&&(T=qre({inputs:{x:m},attrs:{begin:0,size:[N,u]},backend:n}),$=qre({inputs:{x:b},attrs:{begin:0,size:N},backend:n}),n.disposeData(m.dataId),n.disposeData(b.dataId)),[T,$,v,w]}},use={kernelName:CN,backendName:"wasm",setupFunc:function(e){Coe=e.wasm.cwrap(CN,null,["number","number","number","number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:i}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);let o=t.dataIdMap.get(r.dataId).id,s=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(i.dataId).id,u=r.shape[0],d=fC.sizeFromShape(i.shape),c=t.makeOutput([u,d],r.dtype),p=t.dataIdMap.get(c.dataId).id,h=t.makeOutput([d],i.dtype),f=t.dataIdMap.get(h.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;Coe(o,s,l,u,p,f,g);let b,y=t.readSync(m.dataId);switch(y[0]){case 0:b=AO.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1],y[2]);break;case 1:b=AO.getSparseReshapeNegativeOutputDimErrorMessage(y[1],y[2]);break;case 2:b=AO.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(h.dataId));b=AO.getSparseReshapeInputOutputMultipleErrorMessage(e,n);break}case 4:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(h.dataId));b=AO.getSparseReshapeInputOutputMismatchErrorMessage(e,n);break}default:b=""}if(t.disposeData(m.dataId),b)throw t.disposeData(c.dataId),t.disposeData(h.dataId),new Error(b);return[c,h]}};function dse(e){Toe=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function cse(e,t){let{backend:n,inputs:r}=e,{data:a,indices:i,segmentIds:o}=r,s=i.shape[0],l=n.readSync(o.dataId,s-1,s)[0],u=s>0?l+1:0;if(u<0)throw new Error(AO.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=a.shape.slice();d[0]=u;let c=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(i.dataId).id,h=n.dataIdMap.get(o.dataId).id,f=n.makeOutput(d,a.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),b=n.dataIdMap.get(g.dataId).id;Toe(c,Jne[a.dtype],a.shape[0],p,h,m,b,t,0);let y,v=n.readSync(g.dataId);switch(v[0]){case 0:y=AO.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:y=AO.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:y=AO.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(v[1],v[2]);break;case 3:y=AO.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v[1],v[2],v[3]);break;default:y=""}if(n.disposeData(g.dataId),y)throw n.disposeData(f.dataId),new Error(y);return f}var pse,hse,fse,mse,gse,bse,yse,vse,xse={kernelName:TN,backendName:"wasm",setupFunc:dse,kernelFunc:function(e){return cse(e,!0)}},wse={kernelName:$N,backendName:"wasm",setupFunc:dse,kernelFunc:function(e){return cse(e,!1)}},kse={kernelName:EN,backendName:"wasm",setupFunc:function(e){pse=e.wasm.cwrap(EN,null,["number","number","number","number","number","number","number","number","array","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:a,sparseValues:i,defaultValue:o}=n,{outputShape:s}=r,l=t.makeOutput(s,o.dtype);if(0===fC.sizeFromShape(s))return l;let{sliceRank:u,numUpdates:d,sliceSize:c,strides:p,outputSize:h}=AO.calculateShapes(i,a,s),f=t.dataIdMap.get(a.dataId).id,m=t.dataIdMap.get(i.dataId).id,g=t.dataIdMap.get(o.dataId).id,b=new Uint8Array(new Int32Array(p).buffer),y=t.dataIdMap.get(l.dataId).id;return pse(f,m,i.shape.length,g,Jne[o.dtype],u,d,c,b,h,y),l}},Sse={kernelName:SN,backendName:"wasm",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:i,axis:o}=n,s=fC.parseAxisParam(o,a.shape)[0],l=AO.prepareSplitSize(a,i,s),u=new Array(a.shape.length).fill(0),d=a.shape.slice();return l.map((e=>{let t=[...d];t[s]=e;let n=qre({inputs:{x:a},attrs:{begin:u,size:t},backend:r});return u[s]+=e,n}))}},Ise=ure(xN),Nse=ure(AN),Cse=hre(_N),Tse={kernelName:XN,backendName:"wasm",setupFunc:function(e){hse=e.wasm.cwrap(XN,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,s=t.makeOutput(i.shape,i.dtype),l=t.dataIdMap.get(s.dataId).id;return hse(o,a,Jne[i.dtype],l),s}},$se={kernelName:FN,backendName:"wasm",setupFunc:function(e){fse=e.wasm.cwrap(FN,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{x:i}=r,{begin:o,end:s,strides:l,beginMask:u,endMask:d,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:h}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:b,isSimpleSlice:y,begin:v,end:x,strides:w}=iO.sliceInfo(i.shape,o,s,l,u,d,c,p,h);if(g)t=Ure({inputs:{x:i},backend:n,attrs:{shape:m}});else if(b||y){fC.assert(i.shape.length>=1,(()=>`Input must have rank at least 1, got: ${i.shape.length}`));let e=iO.computeOutShape(v,x,w),r=qre({inputs:{x:i},backend:n,attrs:{begin:v,size:e}});t=Ure({inputs:{x:r},backend:n,attrs:{shape:m}}),n.disposeData(r.dataId)}else{let e=n.makeOutput(f,"float32"),r=n.dataIdMap.get(i.dataId).id,a=new Uint8Array(new Int32Array(fC.computeStrides(i.shape)).buffer),o=new Uint8Array(new Int32Array(v).buffer),s=new Uint8Array(new Int32Array(x).buffer),l=new Uint8Array(new Int32Array(w).buffer),u=new Uint8Array(new Int32Array(f).buffer),d=new Uint8Array(new Int32Array(fC.computeStrides(f)).buffer),c=n.dataIdMap.get(e.dataId).id;fse(r,a,i.shape.length,o,s,l,u,d,f.length,c),t=Ure({inputs:{x:e},backend:n,attrs:{shape:m}}),n.disposeData(e.dataId)}return t}},Ese={kernelName:DN,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{data:a,dataSplits:i}=n,{separator:o,nGramWidths:s,leftPad:l,rightPad:u,padWidth:d,preserveShortSequences:c}=r,p=t.readSync(a.dataId),h=t.readSync(i.dataId),[f,m]=mJ(p,h,o,s,l,u,d,c),g=t.makeOutput([f.length],"string");t.dataIdMap.get(g.dataId).stringBytes=f;let b=t.makeOutput(i.shape,"int32");return t.typedArrayFromHeap(b).set(m),[g,b]}},_se={kernelName:MN,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{input:a,delimiter:i}=n,{skipEmpty:o}=r,s=t.readSync(a.dataId),l=t.readSync(i.dataId),[u,d,c]=bJ(s,l[0],o),p=d.length,h=t.makeOutput([p,2],"int32");t.typedArrayFromHeap(h).set(u);let f=t.makeOutput([p],"string");t.dataIdMap.get(f.dataId).stringBytes=d;let m=t.makeOutput([2],"int32");return t.typedArrayFromHeap(m).set(c),[h,f,m]}},Ase={kernelName:ON,backendName:"wasm",kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{input:a}=n,{numBuckets:i}=r,o=yJ(t.readSync(a.dataId),i),s=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(s).set(o),s}},Rse=hre(zN),Fse={kernelName:wN,backendName:"wasm",setupFunc:function(e){mse=e.wasm.cwrap(wN,null,["number","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:i}=r,{x:o}=n,s=t.dataIdMap.get(o.dataId).id,l=s,u=o,{transposed:d,axes:c,originalAxes:p,inputWasTransposed:h}=Sre(o,a,t),f=c;if(h){let e=t.dataIdMap.get(d.dataId).id;e!==s&&(u=d,l=e,f=AO.getInnerMostAxes(f.length,u.shape.length))}AO.assertAxesAreInnerMostDims("sum",f,u.shape.length);let[m,g]=AO.computeOutAndReduceShapes(u.shape,f),b=fC.sizeFromShape(g),y=t.makeOutput(m,u.dtype);if(0!==fC.sizeFromShape(u.shape)){let e=t.dataIdMap.get(y.dataId).id;mse(l,b,Jne[y.dtype],e)}if(h&&t.disposeData(d.dataId),i){let e=AO.expandShapeToKeepDim(y.shape,p);y.shape=e}return y}},Dse=ure(PN),Mse=ure(LN),Ose={kernelName:dN,backendName:"wasm",setupFunc:function(e){gse=e.wasm.cwrap(dN,null,["number","number","number","number","number","number","array","number","number","number"])},kernelFunc:function(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:a,indices:i,updates:o}=n,s=t.makeOutput(a.shape,a.dtype);if(0===fC.sizeFromShape(a.shape))return s;let{sliceRank:l,numUpdates:u,sliceSize:d,strides:c,outputSize:p}=TF.calculateShapes(o,i,a.shape),h=t.dataIdMap.get(i.dataId).id,f=t.dataIdMap.get(o.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=new Uint8Array(new Int32Array(c).buffer),b=t.dataIdMap.get(s.dataId).id;return gse(h,f,Jne[o.dtype],l,u,d,g,p,b,m),s}},zse={kernelName:BN,backendName:"wasm",setupFunc:function(e){bse=e.wasm.cwrap(BN,null,["number","array","number","array","number","number"])},kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,i=n.dataIdMap.get(a.dataId).id,{reps:o}=r,s=new Array(a.shape.length);for(let p=0;p<s.length;p++)s[p]=a.shape[p]*o[p];let l=new Uint8Array(new Int32Array(a.shape).buffer),u=new Uint8Array(new Int32Array(s).buffer),d=n.makeOutput(s,a.dtype),c=n.dataIdMap.get(d.dataId).id;return bse(i,l,a.shape.length,u,s.length,Jne[d.dtype],c),d}},Pse={kernelName:WN,backendName:"wasm",setupFunc:function(e){yse=e.wasm.cwrap(WN,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:a,sorted:i}=n,o=t.dataIdMap.get(r.dataId).id,s=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=a;let u=t.makeOutput(l,r.dtype),d=t.dataIdMap.get(u.dataId).id,c=t.makeOutput(l,"int32"),p=t.dataIdMap.get(c.dataId).id;return yse(o,s,r.shape.length,Jne[r.dtype],a,i,d,p),[u,c]}},Lse={kernelName:VN,backendName:"wasm",setupFunc:function(e){vse=e.wasm.cwrap(VN,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])},kernelFunc:function(e){let t,{backend:n,inputs:r,attrs:a}=e,{image:i,transforms:o}=r,{interpolation:s,fillMode:l,fillValue:u,outputShape:d}=a,[c,p,h,f]=i.shape,[m,g]=null!=d?d:[p,h],b=[c,m,g,f],y=new Uint8Array(new Int32Array(fC.computeStrides(i.shape)).buffer),v=new Uint8Array(new Int32Array(fC.computeStrides(b)).buffer),x=n.makeOutput(b,i.dtype),w=n.dataIdMap.get(x.dataId).id,k=n.dataIdMap.get(i.dataId).id,S=n.dataIdMap.get(o.dataId).id,I="nearest"===s?1:2;switch(l){case"constant":default:t=1;break;case"reflect":t=2;break;case"wrap":t=3;break;case"nearest":t=4}return vse(k,S,o.shape[0]>1,c,m,g,f,h,p,y,i.shape.length-1,v,b.length-1,I,t,u,w),x}},Bse={kernelName:jN,backendName:"wasm",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:i}=t,{outputValues:o,outputShape:s,indices:l}=TJ(r.readSync(i.dataId),a,i.shape,i.dtype);return[r.makeOutput(s,i.dtype,void 0,o),r.makeOutput([l.length],"int32",void 0,l)]}},Wse={kernelName:HN,backendName:"wasm",kernelFunc:function(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:i}=r;i<0&&(i+=a.shape.length);let o=a.shape[i],s=a.shape.length,l=new Array(s-1),u=0;for(let h=0;h<s;h++)h!==i&&(l[u++]=a.shape[h]);let d=new Array(o),c=new Array(s).fill(0),p=a.shape.slice();p[i]=1;for(let h=0;h<d.length;h++)c[i]=h,d[h]=qre({inputs:{x:a},attrs:{begin:c,size:p},backend:n});return d.map((({dataId:e,dtype:t})=>({dataId:e,dtype:t,shape:l})))}},Vse={kernelName:KN,backendName:"wasm",kernelFunc:function(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}},Use=[lre,dre,cre,pre,mre,gre,Nre,Cre,Rre,Fre,Dre,Mre,Ore,zre,Pre,Lre,Vre,Bre,Wre,Gre,Yre,Qre,Zre,Jre,nae,rae,aae,hae,fae,mae,gae,bae,yae,vae,xae,Aae,Rae,Fae,Dae,Mae,Oae,zae,Pae,Lae,Bae,Wae,Vae,Uae,jae,Hae,qae,Kae,gie,bie,yie,vie,xie,wie,kie,Sie,Iie,Nie,Cie,vre,Tie,$ie,Eie,_ie,Aie,Rie,Fie,Mie,Die,Oie,zie,Pie,Lie,Bie,Wie,Vie,Uie,jie,Hie,Gie,qie,Kie,Xie,Yie,Qie,Jie,aoe,ioe,ooe,soe,$oe,Eoe,_oe,Aoe,Roe,Foe,Doe,Moe,Ooe,zoe,Poe,Loe,Boe,Woe,Voe,Uoe,Hre,joe,Hoe,Goe,qoe,Koe,Xoe,Yoe,Qoe,Zoe,Joe,ese,tse,nse,rse,ase,ise,Xre,roe,ose,sse,lse,use,xse,wse,kse,Sse,Ise,Nse,Cse,Tse,$se,Ese,_se,Ase,Rse,Fse,Dse,Mse,Ose,zse,Pse,Lse,kre,Bse,Wse,Vse];for(let e of Use)lC(e);var jse=Rk();jse.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(kp){return!1}})),jse.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(jse.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(kp){return!1}}));var Hse=dw(Ew()),Gse=dw(_w()),qse=dw(Aw()),Kse=Hse.default||Hse,Xse=qse.default||qse,Yse=class extends Fw{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(sle),lle=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new Rw(this,U$())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=fC.now();return e(),{kernelMs:fC.now()-t}}move(e,t,n,r,a){let i=this.dataIdNextNumber++;if("string"===r){let o=t;return void this.dataIdMap.set(e,{id:i,stringBytes:o,shape:n,dtype:r,memoryOffset:null,refCount:a})}let o=fC.sizeFromShape(n),s=o*fC.bytesPerElement(r),l=this.wasm._malloc(s)>>>0;this.dataIdMap.set(e,{id:i,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(i,o,l),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,s),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:a,shape:i,stringBytes:o}=this.dataIdMap.get(e);if("string"===a)return null!=t&&0!==t||!(null==n||n>=o.length)?o.slice(t,n):o;t=t||0,n=n||fC.sizeFromShape(i);let s=fC.bytesPerElement(a);return function(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}(this.wasm.HEAPU8.slice(r+t*s,r+n*s).buffer,a)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let a;if(null==n)a=this.write(null!=r?r:null,e,t);else{let r=this.dataIdNextNumber++;a={id:r},this.dataIdMap.set(a,{id:r,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=fC.sizeFromShape(e);this.wasm.tfjs.registerTensor(r,i,n)}return{dataId:a,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(n),i=fC.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,a,i);case"int32":return new Int32Array(r,a,i);case"bool":return new Uint8Array(r,a,i);default:throw new Error(`Unknown dtype ${t}`)}}};function Qse(e,t,n){if(null!=ele)return ele;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),null!=nle&&null!=nle[r]?nle[r]:n+r}async function Zse(){let[e,t]=await Promise.all([Rk().getAsync("WASM_HAS_SIMD_SUPPORT"),Rk().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((n,r)=>{let a={locateFile:(n,r)=>{if(n.endsWith(".worker.js")){let e=Gse.wasmWorkerContents.replace(/\n/g,"\\n"),t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return n.endsWith(".wasm")?Qse(e,t,null!=tle?tle:r):r+n}};ale&&(a.instantiateWasm=function(e){return(t,n)=>(fC.fetch(e,{credentials:"same-origin"}).then((r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then((e=>{WebAssembly.instantiate(e,t).then((e=>{n(e.instance,e.module)}))}))})),{})}(Qse(e,t,null!=tle?tle:"")));let i,o=!1;a.onAbort=()=>{o||rle||(rle=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},t&&e&&null==ele?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+Kse.toString()],{type:"text/javascript"}),i=Kse(a)):i=Xse(a),i.then((e=>{o=!0,rle=!1,e.tfjs={init:e.cwrap("init",null,[]),initWithThreadsCount:e.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:e.cwrap("get_threads_count","number",[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",null,["number"]),dispose:e.cwrap("dispose",null,[])},n({wasm:e})})).catch(r)}))}var Jse=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],ele=null,tle=null,nle={},rle=!1,ale=!1;function ile(e,t=!1){if(W$("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),rle)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");ele=e,ale=t}function ole(e,t=!1){if(rle)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)tle=e;else{nle=e;let t=Jse.filter((e=>null==nle[e]));if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}ale=t}var sle=-1,lle=-1;function ule(e){sle=e}function dle(){if(-1===lle)throw new Error("WASM backend not initialized.");return lle}var cle="4.7.0";nE("wasm",(async()=>{let{wasm:e}=await Zse();return new Yse(e)}),2);var ple="4.7.0",hle={tfjs:ple,"tfjs-core":ple,"tfjs-converter":"4.7.0","tfjs-backend-cpu":"4.7.0","tfjs-backend-webgl":"4.7.0","tfjs-backend-wasm":"4.7.0"};function fle(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach((({x:n,y:r},a)=>{let i=t[a];e.moveTo(i.x,i.y),e.lineTo(n,r)})),n){let n=t[t.length-1],r=t[0];if(!n||!r)return;e.moveTo(n.x,n.y),e.lineTo(r.x,r.y)}e.stroke()}tw({},{AnchorPosition:()=>nue,DrawBox:()=>oue,DrawBoxOptions:()=>iue,DrawFaceLandmarks:()=>Kue,DrawFaceLandmarksOptions:()=>que,DrawTextField:()=>aue,DrawTextFieldOptions:()=>rue,drawContour:()=>fle,drawDetections:()=>sue,drawFaceExpressions:()=>jue,drawFaceLandmarks:()=>Xue}),tw({},{computeReshapedDimensions:()=>Nle,getCenterPoint:()=>Cle,isDimensions:()=>Ile,isEven:()=>kle,isFloat:()=>wle,isTensor:()=>gle,isTensor1D:()=>ble,isTensor2D:()=>yle,isTensor3D:()=>vle,isTensor4D:()=>xle,isValidNumber:()=>$le,isValidProbablitiy:()=>Ele,range:()=>Tle,round:()=>Sle});var mle=class{constructor(e,t){if(!$le(e)||!$le(t))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:e,height:t})}`);this._width=e,this._height=t}get width(){return this._width}get height(){return this._height}reverse(){return new mle(1/this.width,1/this.height)}};function gle(e,t){return e instanceof QC&&e.shape.length===t}function ble(e){return gle(e,1)}function yle(e){return gle(e,2)}function vle(e){return gle(e,3)}function xle(e){return gle(e,4)}function wle(e){return e%1!=0}function kle(e){return e%2==0}function Sle(e,t=2){let n=10**t;return Math.floor(e*n)/n}function Ile(e){return e&&e.width&&e.height}function Nle({width:e,height:t},n){let r=n/Math.max(t,e);return new mle(Math.round(e*r),Math.round(t*r))}function Cle(e){return e.reduce(((e,t)=>e.add(t)),new _le(0,0)).div(new _le(e.length,e.length))}function Tle(e,t,n){return Array(e).fill(0).map(((e,r)=>t+r*n))}function $le(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||0===e}function Ele(e){return $le(e)&&e>=0&&e<=1}var _le=class{constructor(e,t){this._x=e,this._y=t}get x(){return this._x}get y(){return this._y}add(e){return new _le(this.x+e.x,this.y+e.y)}sub(e){return new _le(this.x-e.x,this.y-e.y)}mul(e){return new _le(this.x*e.x,this.y*e.y)}div(e){return new _le(this.x/e.x,this.y/e.y)}abs(){return new _le(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new _le(Math.floor(this.x),Math.floor(this.y))}},Ale=class{static isRect(e){return!!e&&[e.x,e.y,e.width,e.height].every($le)}static assertIsValidBox(e,t,n=!1){if(!Ale.isRect(e))throw new Error(`${t} - invalid box: ${JSON.stringify(e)}, expected object with properties x, y, width, height`);if(!n&&(e.width<0||e.height<0))throw new Error(`${t} - width (${e.width}) and height (${e.height}) must be positive numbers`)}constructor(e,t=!0){let n=e||{},r=[n.left,n.top,n.right,n.bottom].every($le),a=[n.x,n.y,n.width,n.height].every($le);if(!a&&!r)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(n)}`);let[i,o,s,l]=a?[n.x,n.y,n.width,n.height]:[n.left,n.top,n.right-n.left,n.bottom-n.top];Ale.assertIsValidBox({x:i,y:o,width:s,height:l},"Box.constructor",t),this._x=i,this._y=o,this._width=s,this._height=l}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new _le(this.left,this.top)}get topRight(){return new _le(this.right,this.top)}get bottomLeft(){return new _le(this.left,this.bottom)}get bottomRight(){return new _le(this.right,this.bottom)}round(){let[e,t,n,r]=[this.x,this.y,this.width,this.height].map((e=>Math.round(e)));return new Ale({x:e,y:t,width:n,height:r})}floor(){let[e,t,n,r]=[this.x,this.y,this.width,this.height].map((e=>Math.floor(e)));return new Ale({x:e,y:t,width:n,height:r})}toSquare(){let{x:e,y:t,width:n,height:r}=this,a=Math.abs(n-r);return n<r&&(e-=a/2,n+=a),r<n&&(t-=a/2,r+=a),new Ale({x:e,y:t,width:n,height:r})}rescale(e){let t=Ile(e)?e.width:e,n=Ile(e)?e.height:e;return new Ale({x:this.x*t,y:this.y*n,width:this.width*t,height:this.height*n})}pad(e,t){let[n,r,a,i]=[this.x-e/2,this.y-t/2,this.width+e,this.height+t];return new Ale({x:n,y:r,width:a,height:i})}clipAtImageBorders(e,t){let{x:n,y:r,right:a,bottom:i}=this,o=Math.max(n,0),s=Math.max(r,0),l=a-o,u=i-s,d=Math.min(l,e-o),c=Math.min(u,t-s);return new Ale({x:o,y:s,width:d,height:c}).floor()}shift(e,t){let{width:n,height:r}=this,a=this.x+e,i=this.y+t;return new Ale({x:a,y:i,width:n,height:r})}padAtBorders(e,t){let n=this.width+1,r=this.height+1,a=n,i=r,o=this.left,s=this.top,l=this.right,u=this.bottom;return l>t&&(a=-l+t+n,l=t),u>e&&(i=-u+e+r,u=e),o<1&&(i=2-o,o=1),s<1&&(i=2-s,s=1),{dy:1,edy:i,dx:1,edx:a,y:s,ey:u,x:o,ex:l,w:n,h:r}}calibrate(e){return new Ale({left:this.left+e.left*this.width,top:this.top+e.top*this.height,right:this.right+e.right*this.width,bottom:this.bottom+e.bottom*this.height}).toSquare().round()}},Rle=class extends Ale{constructor(e,t,n,r,a=!1){super({left:e,top:t,right:n,bottom:r},a)}},Fle=class{constructor(e,t,n,r,a){this._imageDims=new mle(a.width,a.height),this._score=e,this._classScore=t,this._className=n,this._box=new Ale(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new Ale(this._box).rescale(this.imageDims.reverse())}forSize(e,t){return new Fle(this.score,this.classScore,this.className,this.relativeBox,{width:e,height:t})}},Dle=class extends Fle{constructor(e,t,n){super(e,e,"",t,n)}forSize(e,t){let{score:n,relativeBox:r,imageDims:a}=super.forSize(e,t);return new Dle(n,r,a)}};function Mle(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left))*Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top));return n?r/(e.area+t.area-r):r/Math.min(e.area,t.area)}function Ole(e,t){return G$((()=>{let[n,r,a]=t,i=r_([...e.shape.slice(0,3),1],n,"float32"),o=r_([...e.shape.slice(0,3),1],r,"float32"),s=r_([...e.shape.slice(0,3),1],a,"float32"),l=BE([i,o,s],3);return RA(e,l)}))}function zle(e){return 1/(1+Math.exp(-e))}var Ple,Lle=class extends Ale{constructor(e,t,n,r,a=!1){super({x:e,y:t,width:n,height:r},a)}},Ble=class{constructor(e,t,n=new _le(0,0)){let{width:r,height:a}=t;this._imgDims=new mle(r,a),this._shift=n,this._positions=e.map((e=>e.mul(new _le(r,a)).add(n)))}get shift(){return new _le(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map((e=>e.sub(this._shift).div(new _le(this.imageWidth,this.imageHeight))))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new _le(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let n=e instanceof Dle?e.box.floor():new Ale(e);return this.shiftBy(n.x,n.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,a=e=>r.sub(e).magnitude(),i=(a(t)+a(n))/2,o=Math.floor(i/.45),s=Cle(e),l=Math.floor(Math.max(0,s.x-.5*o)),u=Math.floor(Math.max(0,s.y-.43*o));return new Lle(l,u,Math.min(o,this.imageWidth+l),Math.min(o,this.imageHeight+u))}alignMinBbox(e){let t=function(e){let t=e.map((e=>e.x)),n=e.map((e=>e.y)),r=t.reduce(((e,t)=>t<e?t:e),1/0),a=n.reduce(((e,t)=>t<e?t:e),1/0),i=t.reduce(((e,t)=>e<t?t:e),0),o=n.reduce(((e,t)=>e<t?t:e),0);return new Rle(r,a,i,o)}(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},Wle=class extends Ble{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(Cle)}},Vle=class{constructor(e,t){this._label=e,this._distance=t}get label(){return this._label}get distance(){return this._distance}toString(e=!0){return`${this.label}${e?` (${Sle(this.distance)})`:""}`}},Ule=class{constructor(e,t){if("string"!=typeof e)throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");if(!Array.isArray(t)||t.some((e=>!(e instanceof Float32Array))))throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");this._label=e,this._descriptors=t}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map((e=>Array.from(e)))}}static fromJSON(e){let t=e.descriptors.map((e=>new Float32Array(e)));return new Ule(e.label,t)}};function jle(e){return e.detection instanceof Dle}function Hle(e,t){return{...e,detection:t}}function Gle(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D:CanvasRenderingContext2D,Image:HTMLImageElement,ImageData:ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function qle(){return"object"==typeof global&&"undefined"!=typeof process&&null!=process.versions&&null!=process.versions.node}function Kle(e){let t="";if(!e&&qle())try{e=ew("fs")}catch(ut){t=ut.toString()}return{readFile:e?t=>new Promise(((n,r)=>{e.readFile(t,((e,t)=>e?r(e):n(t)))})):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function Xle(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,r=global.fetch,a=Kle();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},createImageElement:()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},createVideoElement:()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},fetch:r,...a}}function Yle(){return"object"==typeof window&&"undefined"!=typeof document&&"undefined"!=typeof HTMLImageElement&&"undefined"!=typeof HTMLCanvasElement&&"undefined"!=typeof HTMLVideoElement&&"undefined"!=typeof ImageData&&"undefined"!=typeof CanvasRenderingContext2D}function Qle(e){Ple=e}function Zle(){return Yle()?Qle(Gle()):qle()?Qle(Xle()):null}var Jle={getEnv:function(){if(!Ple)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return Ple},setEnv:Qle,initialize:Zle,createBrowserEnv:Gle,createFileSystem:Kle,createNodejsEnv:Xle,monkeyPatch:function(e){if(Ple||Zle(),!Ple)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=Ple.Canvas,Image:n=Ple.Image}=e;Ple.Canvas=t,Ple.Image=n,Ple.createCanvasElement=e.createCanvasElement||(()=>new t),Ple.createImageElement=e.createImageElement||(()=>new n),Ple.ImageData=e.ImageData||Ple.ImageData,Ple.Video=e.Video||Ple.Video,Ple.fetch=e.fetch||Ple.fetch,Ple.readFile=e.readFile||Ple.readFile},isBrowser:Yle,isNodejs:qle};function eue(e){return Jle.isNodejs()||"string"!=typeof e?e:document.getElementById(e)}function tue(e){let{Canvas:t,CanvasRenderingContext2D:n}=Jle.getEnv();if(e instanceof n)return e;let r=eue(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let a=r.getContext("2d",{willReadFrequently:!0});if(!a)throw new Error("resolveContext2d - canvas 2d context is null");return a}Zle();var nue=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(nue||{}),rue=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:a,fontStyle:i,padding:o}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=i||"Georgia",this.padding=o||4}},aue=class{constructor(e,t,n={}){this.text="string"==typeof e?[e]:e instanceof aue?e.text:e,this.anchor=t,this.options=new rue(n)}measureWidth(e){let{padding:t}=this.options;return this.text.map((t=>e.measureText(t).width)).reduce(((e,t)=>e<t?t:e),0)+2*t}measureHeight(){let{fontSize:e,padding:t}=this.options;return this.text.length*e+2*t}getUpperLeft(e,t){let{anchorPosition:n}=this.options,r="BOTTOM_RIGHT"===n||"TOP_RIGHT"===n,a="BOTTOM_LEFT"===n||"BOTTOM_RIGHT"===n,i=this.measureWidth(e),o=this.measureHeight(),s=r?this.anchor.x-i:this.anchor.x,l=a?this.anchor.y-o:this.anchor.y;if(t){let{width:e,height:n}=t;return{x:Math.max(Math.min(s,e-i),0),y:Math.max(Math.min(l,n-o),0)}}return{x:s,y:l}}draw(e){let t=eue(e),n=tue(t),{backgroundColor:r,fontColor:a,fontSize:i,fontStyle:o,padding:s}=this.options;n.font=`${i}px ${o}`;let l=this.measureWidth(n),u=this.measureHeight();n.fillStyle=r;let d=this.getUpperLeft(n,t);n.fillRect(d.x,d.y,l,u),n.fillStyle=a,this.text.forEach(((e,t)=>{let r=s+d.x,a=s+d.y+(t+1)*i;n.fillText(e,r,a)}))}},iue=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:r,drawLabelOptions:a}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let i={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new rue({...i,...a})}},oue=class{constructor(e,t={}){this.box=new Ale(e),this.options=new iue(t)}draw(e){let t=tue(e),{boxColor:n,lineWidth:r}=this.options,{x:a,y:i,width:o,height:s}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(a,i,o,s);let{label:l}=this.options;l&&new aue([l],{x:a-r/2,y:i},this.options.drawLabelOptions).draw(e)}};function sue(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof Dle?t.score:jle(t)?t.detection.score:void 0,r=t instanceof Dle?t.box:jle(t)?t.detection.box:new Ale(t),a=n?`${Sle(n)}`:void 0;new oue(r,{label:a}).draw(e)}))}function lue(e){let{Image:t,Video:n}=Jle.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function uue(e){let{Image:t,Video:n}=Jle.getEnv();return e instanceof t?new mle(e.naturalWidth,e.naturalHeight):e instanceof n?new mle(e.videoWidth,e.videoHeight):new mle(e.width,e.height)}function due({width:e,height:t}){let{createCanvasElement:n}=Jle.getEnv(),r=n();return r.width=e,r.height=t,r}function cue(e,t){let{ImageData:n}=Jle.getEnv();if(!(e instanceof n||lue(e)))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:a}=t||uue(e),i=due({width:r,height:a});return e instanceof n?tue(i).putImageData(e,0,0):tue(i).drawImage(e,0,0,r,a),i}function pue(e){let{Image:t,Canvas:n,Video:r}=Jle.getEnv();return e instanceof t||e instanceof n||e instanceof r}var hue=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach(((e,t)=>{if(vle(e))return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape);if(xle(e)){let n=e.shape[0];if(1!==n)throw new Error(`NetInput - tf.Tensor4D with batchSize ${n} passed, but not supported in input array`);return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape.slice(1))}let n=e instanceof Jle.getEnv().Canvas?e:cue(e);this._canvases[t]=n,this._inputDimensions[t]=[n.height,n.width,3]}))}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return Tle(this.batchSize,0,1).map(((e,t)=>this.getReshapedInputDimensions(t)))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if("number"!=typeof this.inputSize)throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");return Nle({width:this.getInputWidth(e),height:this.getInputHeight(e)},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,G$((()=>{let n=Tle(this.batchSize,0,1).map((n=>{let r=this.getInput(n);if(r instanceof QC){let n=xle(r)?r:rA(r);return n=function(e,t=!1){return G$((()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let a=Math.abs(n-r),i=Math.round(a*(t?.5:1)),o=n>r?2:1,s=t=>{let n=e.shape.slice();return n[o]=t,r_(n,0,"float32")},l=s(i),u=a-l.shape[o],d=[t&&u?s(u):null,e,l].filter((e=>!!e)).map((e=>M$(e,"float32")));return BE(d,o)}))}(n,t),(n.shape[1]!==e||n.shape[2]!==e)&&(n=oM.resizeBilinear(n,[e,e],!1,!1)),n.as3D(e,e,3)}if(r instanceof Jle.getEnv().Canvas)return qM.fromPixels(function(e,t,n=!1){let{Image:r,Canvas:a}=Jle.getEnv();if(!(e instanceof r||e instanceof a))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return due({width:1,height:1});let i=uue(e),o=t/Math.max(i.height,i.width),s=o*i.width,l=o*i.height,u=due({width:t,height:t}),d=e instanceof a?e:cue(e),c=Math.abs(s-l)/2,p=n&&s<l?c:0,h=n&&l<s?c:0;return d.width>0&&d.height>0&&tue(u).drawImage(d,p,h,s,l),u}(r,e,t));throw new Error(`toBatchTensor - at batchIdx ${n}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${r}`)}));return bF(n.map((e=>M$(e,"float32")))).as4D(this.batchSize,e,e,3)}))}};async function fue(e){if(e instanceof hue)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=t=>Array.isArray(e)?` at input index ${t}:`:"",r=t.map(eue);return r.forEach(((e,r)=>{if(!pue(e)&&!vle(e)&&!xle(e))throw"string"==typeof t[r]?new Error(`toNetInput -${n(r)} string passed, but could not resolve HTMLElement for element id ${t[r]}`):new Error(`toNetInput -${n(r)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(xle(e)){let t=e.shape[0];if(1!==t)throw new Error(`toNetInput -${n(r)} tf.Tensor4D with batchSize ${t} passed, but not supported in input array`)}})),await Promise.all(r.map((e=>pue(e)&&function(e){return new Promise(((t,n)=>{function r(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),n(e))}function a(e){e.currentTarget&&(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),t(e))}(e instanceof Jle.getEnv().Canvas||lue(e))&&t(null),e.addEventListener("load",a),e.addEventListener("error",r)}))}(e)))),new hue(r,Array.isArray(e))}async function mue(e,t){let{Canvas:n}=Jle.getEnv(),r=e;if(!(e instanceof n)){let t=await fue(e);if(t.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let a=t.getInput(0);r=a instanceof n?a:await async function(e,t){let n=t||Jle.getEnv().createCanvasElement(),[r,a,i]=e.shape.slice(xle(e)?1:0),o=G$((()=>e.as3D(r,a,i).toInt()));return await qM.toPixels(o,n),o.dispose(),n}(a)}let a=tue(r);return t.map((e=>e instanceof Dle?e.forSize(r.width,r.height).box.floor():e)).map((e=>e.clipAtImageBorders(r.width,r.height))).map((({x:e,y:t,width:n,height:r})=>{let i=due({width:n,height:r});return n>0&&r>0&&tue(i).putImageData(a.getImageData(e,t,n,r),0,0),i}))}async function gue(e,t){if(!vle(e)&&!xle(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(xle(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return G$((()=>{let[n,r,a]=e.shape.slice(xle(e)?1:0);return t.map((e=>e instanceof Dle?e.forSize(r,n).box:e)).map((e=>e.clipAtImageBorders(r,n))).filter((e=>e.width>0&&e.height>0)).map((({x:t,y:i,width:o,height:s})=>sF(e.as3D(n,r,a),[i,t,0],[s,o,a])))}))}async function bue(e,t){let{fetch:n}=Jle.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function yue(e){let t=await bue(e),n=await t.blob();if(!n.type.startsWith("image/"))throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${n.type}, for url: ${t.url}`);return function(e){return new Promise(((t,n)=>{e instanceof Blob||n(new Error("bufferToImage - expected buf to be of type: Blob"));let r=new FileReader;r.onload=()=>{"string"!=typeof r.result&&n(new Error("bufferToImage - expected reader.result to be a string, in onload"));let e=Jle.getEnv().createImageElement();e.onload=()=>t(e),e.onerror=n,e.src=r.result},r.onerror=n,r.readAsDataURL(e)}))}(n)}function vue(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if("/"===e)return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"",a=(e=e.replace(r,"")).split("/").filter((e=>e)),i=e.endsWith(".json")?a[a.length-1]:n,o=r+(e.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return o=e.startsWith("/")?`/${o}`:o,{modelBaseUri:o,manifestUri:"/"===o?`/${i}`:`${o}/${i}`}}async function xue(e,t){let{manifestUri:n,modelBaseUri:r}=vue(e,t),a=await async function(e){return(await bue(e)).json()}(n);return IM.loadWeights(a,r)}var wue=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map((({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)})))}getTrainableParams(){return this.getParamList().filter((e=>e.tensor instanceof JC))}getFrozenParams(){return this.getParamList().filter((e=>!(e.tensor instanceof JC)))}variable(){this.getFrozenParams().forEach((({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())}))}freeze(){this.getTrainableParams().forEach((({path:e,tensor:t})=>{let n=zT(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)}))}dispose(e=!0){this.getParamList().forEach((t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()})),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map((({tensor:e})=>Array.from(e.dataSync()))).reduce(((e,t)=>e.concat(t))))}async load(e){e instanceof Float32Array?this.extractWeights(e):await this.loadFromUri(e)}async loadFromUri(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await xue(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=Jle.getEnv(),{manifestUri:n,modelBaseUri:r}=vue(e,this.getDefaultModelName()),a=IM.weightsLoaderFactory((e=>Promise.all(e.map((e=>t(e).then((e=>e.buffer))))))),i=JSON.parse((await t(n)).toString()),o=await a(i,r);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce(((t,n)=>{if(!t.nextObj.hasOwnProperty(n))throw new Error(`traversePropertyPath - object does not have property ${n}, for path ${e}`);return{obj:t.nextObj,objProp:n,nextObj:t.nextObj[n]}}),{nextObj:this.params}),{obj:n,objProp:r}=t;if(!(n&&r&&n[r]instanceof QC))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function kue(e,t,n){return G$((()=>{let r=eF(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=iE(r,t.bias),r}))}function Sue(e,t,n=!1){return G$((()=>{let r=jR(n?iE(u_(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):kue(e,t.conv0,[2,2])),a=kue(r,t.conv1,[1,1]),i=kue(jR(iE(r,a)),t.conv2,[1,1]);return jR(iE(r,iE(a,i)))}))}function Iue(e,t,n=!1,r=!0){return G$((()=>{let a=jR(n?iE(u_(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):kue(e,t.conv0,r?[2,2]:[1,1])),i=kue(a,t.conv1,[1,1]),o=kue(jR(iE(a,i)),t.conv2,[1,1]),s=kue(jR(iE(a,iE(i,o))),t.conv3,[1,1]);return jR(iE(a,iE(i,iE(o,s))))}))}function Nue(e,t,n="same",r=!1){return G$((()=>{let a=iE(u_(e,t.filters,[1,1],n),t.bias);return r?jR(a):a}))}function Cue(e,t){Object.keys(e).forEach((n=>{t.some((e=>e.originalPath===n))||e[n].dispose()}))}function Tue(e,t){return(n,r,a,i)=>{let o=IF(e(n*r*a*a),[a,a,n,r]),s=wF(e(r));return t.push({paramPath:`${i}/filters`},{paramPath:`${i}/bias`}),{filters:o,bias:s}}}function $ue(e,t){return(n,r,a)=>{let i=kF(e(n*r),[n,r]),o=wF(e(r));return t.push({paramPath:`${a}/weights`},{paramPath:`${a}/bias`}),{weights:i,bias:o}}}var Eue=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function _ue(e,t){return(n,r,a)=>{let i=IF(e(9*n),[3,3,n,1]),o=IF(e(n*r),[1,1,n,r]),s=wF(e(r));return t.push({paramPath:`${a}/depthwise_filter`},{paramPath:`${a}/pointwise_filter`},{paramPath:`${a}/bias`}),new Eue(i,o,s)}}function Aue(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),a=e(`${t}/bias`,1);return new Eue(n,r,a)}}function Rue(e,t){return(n,r,a)=>{let i=e[n];if(!gle(i,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${i}`);return t.push({originalPath:n,paramPath:a||n}),i}}function Fue(e){let t=e;return{extractWeights:function(e){let n=t.slice(0,e);return t=t.slice(e),n},getRemainingWeights:function(){return t}}}function Due(e,t){let n=Tue(e,t),r=_ue(e,t);function a(e,t,a,i=!1){return{conv0:i?n(e,t,3,`${a}/conv0`):r(e,t,`${a}/conv0`),conv1:r(t,t,`${a}/conv1`),conv2:r(t,t,`${a}/conv2`)}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:function(e,t,n,i=!1){let{conv0:o,conv1:s,conv2:l}=a(e,t,n,i);return{conv0:o,conv1:s,conv2:l,conv3:r(t,t,`${n}/conv3`)}}}}function Mue(e){return t=>({filters:e(`${t}/filters`,4),bias:e(`${t}/bias`,1)})}function Oue(e,t){let n=Rue(e,t),r=Mue(n),a=Aue(n);return{extractDenseBlock3Params:function(e,t=!1){return{conv0:t?r(`${e}/conv0`):a(`${e}/conv0`),conv1:a(`${e}/conv1`),conv2:a(`${e}/conv2`)}},extractDenseBlock4Params:function(e,t=!1){return{conv0:t?r(`${e}/conv0`):a(`${e}/conv0`),conv1:a(`${e}/conv1`),conv2:a(`${e}/conv2`),conv3:a(`${e}/conv3`)}}}}var zue=class extends wue{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return G$((()=>{let n=Iue(Ole(M$(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return n=Iue(n,t.dense1),n=Iue(n,t.dense2),n=Iue(n,t.dense3),n=PE(n,[7,7],[2,2],"valid"),n}))}async forward(e){return this.forwardInput(await fue(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractDenseBlock4Params:n}=Oue(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return Cue(e,t),{params:r,paramMappings:t}}(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Fue(e),{extractDenseBlock4Params:a}=Due(n,t),i=a(3,32,"dense0",!0),o=a(32,64,"dense1"),s=a(64,128,"dense2"),l=a(128,256,"dense3");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:i,dense1:o,dense2:s,dense3:l}}}(e)}};function Pue(e,t){return G$((()=>iE(WE(e,t.weights),t.bias)))}function Lue(e){let t={},n={};return Object.keys(e).forEach((r=>{(r.startsWith("fc")?n:t)[r]=e[r]})),{featureExtractorMap:t,classifierMap:n}}var Bue=class extends wue{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return G$((()=>{let n=e instanceof hue?this.faceFeatureExtractor.forwardInput(e):e;return Pue(n.as2D(n.shape[0],-1),t.fc)}))}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function(e,t,n){let r=[],{extractWeights:a,getRemainingWeights:i}=Fue(e),o=$ue(a,r)(t,n,"fc");if(0!==i().length)throw new Error(`weights remaing after extract: ${i().length}`);return{paramMappings:r,params:{fc:o}}}(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=Lue(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function(e){let t=[],n=Rue(e,t),r={fc:(a="fc",{weights:n(`${a}/weights`,2),bias:n(`${a}/bias`,1)})};var a;return Cue(e,t),{params:r,paramMappings:t}}(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,a=e.slice(0,e.length-r),i=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(i)}},Wue=["neutral","happy","sad","angry","fearful","disgusted","surprised"],Vue=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,7!==e.length)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);Wue.forEach(((t,n)=>{this[t]=e[n]}))}asSortedArray(){return Wue.map((e=>({expression:e,probability:this[e]}))).sort(((e,t)=>t.probability-e.probability))}};function Uue(e,t){return{...e,expressions:t}}function jue(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach((t=>{let a=t instanceof Vue?t:function(e){return e.expressions instanceof Vue}(t)?t.expressions:void 0;if(!a)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let i=a.asSortedArray().filter((e=>e.probability>n)),o=jle(t)?t.detection.box.bottomLeft:r||new _le(0,0);new aue(i.map((e=>`${e.expression} (${Sle(e.probability)})`)),o).draw(e)}))}function Hue(e){return jle(e)&&e.landmarks instanceof Ble&&e.unshiftedLandmarks instanceof Ble&&e.alignedRect instanceof Dle}function Gue(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),a=r.align(),{imageDims:i}=e.detection,o=new Dle(e.detection.score,a.rescale(i.reverse()),i),s=function(e){let t=e=>180*e/Math.PI,n=(e,t)=>Math.sqrt((e._x-t._x)**2+(e._y-t._y)**2),r={roll:void 0,pitch:void 0,yaw:void 0};if(!e||!e._positions||68!==e._positions.length)return r;let a=e._positions;return r.roll=((e,n)=>{let r=Math.hypot(n._x-e._x,n._y-e._y),a=n._y-e._y,i=Math.asin(a/r),o=t(i);return Math.floor(90-o)*(n._x-e._x<0?-1:1)})(a[27],a[66]),r.pitch=((e,r,a)=>{let i=n(e,a),o={_x:(e._x+a._x)/2,_y:(e._y+a._y)/2},s=n(r,o),l=Math.atan(s/i);return Math.floor(t(l))*(o._y-r._y<0?-1:1)})(a[14],a[30],a[2]),r.yaw=((e,t,n)=>Math.floor(e._x-t._x)-Math.floor(t._x-n._x))(a[14],a[33],a[2]),r}(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:o,angle:s}}var que=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:a,pointSize:i,pointColor:o}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=i||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=o||"rgba(255, 0, 255, 1)"}},Kue=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new que(t)}draw(e){let t=tue(e),{drawLines:n,drawPoints:r,lineWidth:a,lineColor:i,pointSize:o,pointColor:s}=this.options;if(n&&this.faceLandmarks instanceof Wle&&(t.strokeStyle=i,t.lineWidth=a,fle(t,this.faceLandmarks.getJawOutline()),fle(t,this.faceLandmarks.getLeftEyeBrow()),fle(t,this.faceLandmarks.getRightEyeBrow()),fle(t,this.faceLandmarks.getNose()),fle(t,this.faceLandmarks.getLeftEye(),!0),fle(t,this.faceLandmarks.getRightEye(),!0),fle(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=s,t.fillStyle=s;let e=e=>{t.beginPath(),t.arc(e.x,e.y,o,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(e)}}};function Xue(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof Ble?t:Hue(t)?t.landmarks:void 0;if(!n)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new Kue(n).draw(e)}))}function Yue(e,t){let n=[],{extractWeights:r,getRemainingWeights:a}=Fue(e),{extractConvParams:i,extractSeparableConvParams:o,extractReductionBlockParams:s,extractMainBlockParams:l}=function(e,t){let n=Tue(e,t),r=_ue(e,t);return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:function(e,t,a){return{separable_conv0:r(e,t,`${a}/separable_conv0`),separable_conv1:r(t,t,`${a}/separable_conv1`),expansion_conv:n(e,t,1,`${a}/expansion_conv`)}},extractMainBlockParams:function(e,t){return{separable_conv0:r(e,e,`${t}/separable_conv0`),separable_conv1:r(e,e,`${t}/separable_conv1`),separable_conv2:r(e,e,`${t}/separable_conv2`)}}}}(r,n),u={conv_in:i(3,32,3,"entry_flow/conv_in"),reduction_block_0:s(32,64,"entry_flow/reduction_block_0"),reduction_block_1:s(64,128,"entry_flow/reduction_block_1")},d={};Tle(t,0,1).forEach((e=>{d[`main_block_${e}`]=l(128,`middle_flow/main_block_${e}`)}));let c={reduction_block:s(128,256,"exit_flow/reduction_block"),separable_conv:o(256,512,"exit_flow/separable_conv")};if(0!==a().length)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:n,params:{entry_flow:u,middle_flow:d,exit_flow:c}}}function Que(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:i,extractMainBlockParams:o}=function(e,t){let n=Rue(e,t),r=Mue(n),a=Aue(n);return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:function(e){return{separable_conv0:a(`${e}/separable_conv0`),separable_conv1:a(`${e}/separable_conv1`),expansion_conv:r(`${e}/expansion_conv`)}},extractMainBlockParams:function(e){return{separable_conv0:a(`${e}/separable_conv0`),separable_conv1:a(`${e}/separable_conv1`),separable_conv2:a(`${e}/separable_conv2`)}}}}(e,n),s={conv_in:r("entry_flow/conv_in"),reduction_block_0:i("entry_flow/reduction_block_0"),reduction_block_1:i("entry_flow/reduction_block_1")},l={};Tle(t,0,1).forEach((e=>{l[`main_block_${e}`]=o(`middle_flow/main_block_${e}`)}));let u={reduction_block:i("exit_flow/reduction_block"),separable_conv:a("exit_flow/separable_conv")};return Cue(e,n),{params:{entry_flow:s,middle_flow:l,exit_flow:u},paramMappings:n}}function Zue(e,t,n){return iE(u_(e,t.filters,n,"same"),t.bias)}function Jue(e,t,n=!0){let r=n?jR(e):e;return r=kue(r,t.separable_conv0,[1,1]),r=kue(jR(r),t.separable_conv1,[1,1]),r=VA(r,[3,3],[2,2],"same"),r=iE(r,Zue(e,t.expansion_conv,[2,2])),r}var ede=class extends wue{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return G$((()=>{let n=Ole(M$(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),r=jR(Zue(n,t.entry_flow.conv_in,[2,2]));return r=Jue(r,t.entry_flow.reduction_block_0,!1),r=Jue(r,t.entry_flow.reduction_block_1),Tle(this._numMainBlocks,0,1).forEach((e=>{r=function(e,t){let n=kue(jR(e),t.separable_conv0,[1,1]);return n=kue(jR(n),t.separable_conv1,[1,1]),n=kue(jR(n),t.separable_conv2,[1,1]),n=iE(n,e),n}(r,t.middle_flow[`main_block_${e}`])})),r=Jue(r,t.exit_flow.reduction_block),r=jR(kue(r,t.exit_flow.separable_conv,[1,1])),r}))}async forward(e){return this.forwardInput(await fue(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return Que(e,this._numMainBlocks)}extractParams(e){return Yue(e,this._numMainBlocks)}},tde=(e=>(e.FEMALE="female",e.MALE="male",e))(tde||{}),nde=class extends Bue{postProcess(e,t,n){let r=n.map((({width:e,height:n})=>{let r=t/Math.max(n,e);return{width:e*r,height:n*r}})),a=r.length;return G$((()=>{let n=(e,t)=>bF([r_([68],e,"float32"),r_([68],t,"float32")],1).as2D(1,136).as1D(),i=(e,t)=>{let{width:n,height:a}=r[e];return t(n,a)?Math.abs(n-a)/2:0};return e.mul(r_([a,136],t,"float32")).sub(bF(Array.from(Array(a),((e,t)=>n((e=>i(e,((e,t)=>e<t)))(t),(e=>i(e,((e,t)=>t<e)))(t)))))).div(bF(Array.from(Array(a),((e,t)=>n(r[t].width,r[t].height)))))}))}forwardInput(e){return G$((()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map((([e,t])=>({height:e,width:t}))))}))}async forward(e){return this.forwardInput(await fue(e))}async detectLandmarks(e){let t=await fue(e),n=G$((()=>OF(this.forwardInput(t)))),r=await Promise.all(n.map((async(e,n)=>{let r=Array.from(e.dataSync()),a=r.filter(((e,t)=>kle(t))),i=r.filter(((e,t)=>!kle(t)));return new Wle(Array(68).fill(0).map(((e,t)=>new _le(a[t],i[t]))),{height:t.getInputHeight(n),width:t.getInputWidth(n)})})));return n.forEach((e=>e.dispose())),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},rde=class extends wue{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return G$((()=>{let n=Sue(Ole(M$(e.toBatchTensor(112,!0),"float32"),[122.782,117.001,104.298]).div(255),t.dense0,!0);return n=Sue(n,t.dense1),n=Sue(n,t.dense2),n=PE(n,[14,14],[2,2],"valid"),n}))}async forward(e){return this.forwardInput(await fue(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractDenseBlock3Params:n}=Oue(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return Cue(e,t),{params:r,paramMappings:t}}(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Fue(e),{extractDenseBlock3Params:a}=Due(n,t),i=a(3,32,"dense0",!0),o=a(32,64,"dense1"),s=a(64,128,"dense2");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:i,dense1:o,dense2:s}}}(e)}};function ade(e,t,n,r,a="same"){let{filters:i,bias:o}=t.conv,s=u_(e,i,n,a);return s=iE(s,o),s=function(e,t){return iE(lE(e,t.weights),t.biases)}(s,t.scale),r?jR(s):s}function ide(e,t){return ade(e,t,[1,1],!1)}function ode(e,t){return ade(e,t,[2,2],!0,"valid")}function sde(e,t){function n(n,r,a,i){let o=function(t,n,r){let a=e(t),i=a.length/(n*r*r);if(wle(i))throw new Error(`depth has to be an integer: ${i}, weights.length: ${a.length}, numFilters: ${n}, filterSize: ${r}`);return G$((()=>VF(IF(a,[n,i,r,r]),[2,3,1,0])))}(n,r,a),s=wF(e(r));return t.push({paramPath:`${i}/filters`},{paramPath:`${i}/bias`}),{filters:o,bias:s}}function r(r,a,i,o){let s=n(r,a,i,`${o}/conv`),l=function(n,r){let a=wF(e(n)),i=wF(e(n));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/biases`}),{weights:a,biases:i}}(a,`${o}/scale`);return{conv:s,scale:l}}return{extractConvLayerParams:r,extractResidualLayerParams:function(e,t,n,a,i=!1){return{conv1:r((i?.5:1)*e,t,n,`${a}/conv1`),conv2:r(e,t,n,`${a}/conv2`)}}}}function lde(e,t){let n=Rue(e,t);function r(e){let t=n(`${e}/conv/filters`,4),r=n(`${e}/conv/bias`,1),a=function(e){return{weights:n(`${e}/scale/weights`,1),biases:n(`${e}/scale/biases`,1)}}(e);return{conv:{filters:t,bias:r},scale:a}}return{extractConvLayerParams:r,extractResidualLayerParams:function(e){return{conv1:r(`${e}/conv1`),conv2:r(`${e}/conv2`)}}}}function ude(e,t){let n=function(e,t){return ade(e,t,[1,1],!0)}(e,t.conv1);return n=ide(n,t.conv2),n=iE(n,e),n=jR(n),n}function dde(e,t){let n=ode(e,t.conv1);n=ide(n,t.conv2);let r=PE(e,2,2,"valid"),a=qA(r.shape),i=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let e=[...n.shape];e[1]=1;let t=qA(e);n=BE([n,t],1);let r=[...n.shape];r[2]=1;let a=qA(r);n=BE([n,a],2)}return r=i?BE([r,a],3):r,n=iE(r,n),n=jR(n),n}function cde(e,t){return{...e,descriptor:t}}function pde(e,t){return{...e,age:t}}function hde(e,t,n){return{...e,gender:t,genderProbability:n}}function fde(e,t){function n(n,r,a,i,o){let s=IF(e(n*r*a*a),[a,a,n,r]),l=wF(e(r));return t.push({paramPath:`${i}/filters`},{paramPath:`${i}/${o?"batch_norm_offset":"bias"}`}),{filters:s,bias:l}}function r(e,t,r,a){let{filters:i,bias:o}=n(e,t,r,a,!0);return{filters:i,batch_norm_offset:o}}function a(n,a,i){let o=function(n,r){let a=IF(e(9*n),[3,3,n,1]),i=wF(e(n)),o=wF(e(n)),s=wF(e(n)),l=wF(e(n));return t.push({paramPath:`${r}/filters`},{paramPath:`${r}/batch_norm_scale`},{paramPath:`${r}/batch_norm_offset`},{paramPath:`${r}/batch_norm_mean`},{paramPath:`${r}/batch_norm_variance`}),{filters:a,batch_norm_scale:i,batch_norm_offset:o,batch_norm_mean:s,batch_norm_variance:l}}(n,`${i}/depthwise_conv`);return{depthwise_conv:o,pointwise_conv:r(n,a,1,`${i}/pointwise_conv`)}}return{extractMobilenetV1Params:function(){return{conv_0:r(3,32,3,"mobilenetv1/conv_0"),conv_1:a(32,64,"mobilenetv1/conv_1"),conv_2:a(64,128,"mobilenetv1/conv_2"),conv_3:a(128,128,"mobilenetv1/conv_3"),conv_4:a(128,256,"mobilenetv1/conv_4"),conv_5:a(256,256,"mobilenetv1/conv_5"),conv_6:a(256,512,"mobilenetv1/conv_6"),conv_7:a(512,512,"mobilenetv1/conv_7"),conv_8:a(512,512,"mobilenetv1/conv_8"),conv_9:a(512,512,"mobilenetv1/conv_9"),conv_10:a(512,512,"mobilenetv1/conv_10"),conv_11:a(512,512,"mobilenetv1/conv_11"),conv_12:a(512,1024,"mobilenetv1/conv_12"),conv_13:a(1024,1024,"mobilenetv1/conv_13")}},extractPredictionLayerParams:function(){return{conv_0:r(1024,256,1,"prediction_layer/conv_0"),conv_1:r(256,512,3,"prediction_layer/conv_1"),conv_2:r(512,128,1,"prediction_layer/conv_2"),conv_3:r(128,256,3,"prediction_layer/conv_3"),conv_4:r(256,128,1,"prediction_layer/conv_4"),conv_5:r(128,256,3,"prediction_layer/conv_5"),conv_6:r(256,64,1,"prediction_layer/conv_6"),conv_7:r(64,128,3,"prediction_layer/conv_7"),box_predictor_0:{box_encoding_predictor:n(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),class_predictor:n(512,9,1,"prediction_layer/box_predictor_0/class_predictor")},box_predictor_1:{box_encoding_predictor:n(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),class_predictor:n(1024,18,1,"prediction_layer/box_predictor_1/class_predictor")},box_predictor_2:{box_encoding_predictor:n(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),class_predictor:n(512,18,1,"prediction_layer/box_predictor_2/class_predictor")},box_predictor_3:{box_encoding_predictor:n(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),class_predictor:n(256,18,1,"prediction_layer/box_predictor_3/class_predictor")},box_predictor_4:{box_encoding_predictor:n(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),class_predictor:n(256,18,1,"prediction_layer/box_predictor_4/class_predictor")},box_predictor_5:{box_encoding_predictor:n(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),class_predictor:n(128,18,1,"prediction_layer/box_predictor_5/class_predictor")}}}}}function mde(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=function(e,t){let n=Rue(e,t);function r(e,t,r){return{filters:n(`${e}/Conv2d_${t}_pointwise/weights`,4,`${r}/filters`),batch_norm_offset:n(`${e}/Conv2d_${t}_pointwise/convolution_bn_offset`,1,`${r}/batch_norm_offset`)}}function a(e){let t=`mobilenetv1/conv_${e}`,a=`MobilenetV1/Conv2d_${e}_depthwise`,i=`${t}/depthwise_conv`,o=`${t}/pointwise_conv`;return{depthwise_conv:{filters:n(`${a}/depthwise_weights`,4,`${i}/filters`),batch_norm_scale:n(`${a}/BatchNorm/gamma`,1,`${i}/batch_norm_scale`),batch_norm_offset:n(`${a}/BatchNorm/beta`,1,`${i}/batch_norm_offset`),batch_norm_mean:n(`${a}/BatchNorm/moving_mean`,1,`${i}/batch_norm_mean`),batch_norm_variance:n(`${a}/BatchNorm/moving_variance`,1,`${i}/batch_norm_variance`)},pointwise_conv:r("MobilenetV1",e,o)}}function i(e,t){return{filters:n(`${e}/weights`,4,`${t}/filters`),bias:n(`${e}/biases`,1,`${t}/bias`)}}function o(e){return{box_encoding_predictor:i(`Prediction/BoxPredictor_${e}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${e}/box_encoding_predictor`),class_predictor:i(`Prediction/BoxPredictor_${e}/ClassPredictor`,`prediction_layer/box_predictor_${e}/class_predictor`)}}return{extractMobilenetV1Params:function(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}},extractPredictionLayerParams:function(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}}}(e,t),a=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!vle(a))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${a}`);let i={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:a}};return Cue(e,t),{params:i,paramMappings:t}}function gde(e,t,n){return G$((()=>{let r=u_(e,t.filters,n,"same");return r=iE(r,t.batch_norm_offset),a_(r,0,6)}))}var bde=.0010000000474974513;function yde(e,t){return G$((()=>{let n,r=gde(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach(((e,t)=>{let a=t+1,i=function(e){return[2,4,6,12].some((t=>t===e))?[2,2]:[1,1]}(a);r=function(e,t,n){return G$((()=>{let r=k_(e,t.filters,n,"same");return r=KE(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,bde),a_(r,0,6)}))}(r,e.depthwise_conv,i),r=gde(r,e.pointwise_conv,[1,1]),11===a&&(n=r)})),null===n)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}}))}function vde(e,t,n){let r=e.arraySync(),a=Math.min(r[t][0],r[t][2]),i=Math.min(r[t][1],r[t][3]),o=Math.max(r[t][0],r[t][2]),s=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),u=Math.min(r[n][1],r[n][3]),d=Math.max(r[n][0],r[n][2]),c=Math.max(r[n][1],r[n][3]),p=(o-a)*(s-i),h=(d-l)*(c-u);if(p<=0||h<=0)return 0;let f=Math.max(a,l),m=Math.max(i,u),g=Math.min(o,d),b=Math.min(s,c),y=Math.max(g-f,0)*Math.max(b-m,0);return y/(p+h-y)}function xde(e,t){let{sizes:n,centers:r}=function(e){let t=OF(VF(e,[1,0])),n=[RA(t[2],t[0]),RA(t[3],t[1])];return{sizes:n,centers:[iE(t[0],sE(n[0],2)),iE(t[1],sE(n[1],2))]}}(e),a=OF(VF(t,[1,0])),i=sE(lE(nA(sE(a[2],5)),n[0]),2),o=iE(lE(sE(a[0],10),n[0]),r[0]),s=sE(lE(nA(sE(a[3],5)),n[1]),2),l=iE(lE(sE(a[1],10),n[1]),r[1]);return VF(bF([RA(o,i),RA(l,s),iE(o,i),iE(l,s)]),[1,0])}function wde(e,t){return G$((()=>{let n=e.shape[0];return{boxPredictionEncoding:zE(Nue(e,t.box_encoding_predictor),[n,-1,1,4]),classPrediction:zE(Nue(e,t.class_predictor),[n,-1,3])}}))}var kde=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,"number"!=typeof this._minConfidence||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if("number"!=typeof this._maxResults)throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},Sde=[new _le(.738768,.874946),new _le(2.42204,2.65704),new _le(4.30971,7.04493),new _le(10.246,4.59428),new _le(12.6868,11.8741)],Ide=[new _le(1.603231,2.094468),new _le(6.041143,7.080126),new _le(2.882459,3.518061),new _le(4.266906,5.178857),new _le(9.041765,10.66308)],Nde=[117.001,114.697,97.404],Cde=e=>"number"==typeof e;function Tde(e){return G$((()=>{let t=lE(e,X_(.10000000149011612));return iE(jR(RA(e,t)),t)}))}function $de(e,t){return G$((()=>{let n=oR(e,[[0,0],[1,1],[1,1],[0,0]]);return n=u_(n,t.conv.filters,[1,1],"valid"),n=RA(n,t.bn.sub),n=lE(n,t.bn.truediv),n=iE(n,t.conv.bias),Tde(n)}))}function Ede(e,t){return G$((()=>{let n=oR(e,[[0,0],[1,1],[1,1],[0,0]]);return n=eF(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=iE(n,t.bias),Tde(n)}))}function _de(e,t){let n=Tue(e,t),r=_ue(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:function(r,a,i){let o=n(r,a,3,`${i}/conv`),s=function(n,r){let a=wF(e(n)),i=wF(e(n));return t.push({paramPath:`${r}/sub`},{paramPath:`${r}/truediv`}),{sub:a,truediv:i}}(a,`${i}/bn`);return{conv:o,bn:s}},extractSeparableConvParams:r}}function Ade(e,t){let n=Rue(e,t);function r(e){return{filters:n(`${e}/filters`,4),bias:n(`${e}/bias`,1)}}return{extractConvParams:r,extractConvWithBatchNormParams:function(e){let t=r(`${e}/conv`),a=function(e){return{sub:n(`${e}/sub`,1),truediv:n(`${e}/truediv`,1)}}(`${e}/bn`);return{conv:t,bn:a}},extractSeparableConvParams:Aue(n)}}var Rde=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,"number"!=typeof this._inputSize||this._inputSize%32!=0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if("number"!=typeof this._scoreThreshold||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},Fde=class extends wue{constructor(e){super("TinyYolov2"),function(e){if(!e)throw new Error(`invalid config: ${e}`);if("boolean"!=typeof e.withSeparableConvs)throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!Cde(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every((e=>"string"==typeof e)))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map((e=>e||{})).every((e=>Cde(e.x)&&Cde(e.y))))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||3!==e.meanRgb.length||!e.meanRgb.every(Cde)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}(e),this._config=e}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(e,t){let n=$de(e,t.conv0);return n=VA(n,[2,2],[2,2],"same"),n=$de(n,t.conv1),n=VA(n,[2,2],[2,2],"same"),n=$de(n,t.conv2),n=VA(n,[2,2],[2,2],"same"),n=$de(n,t.conv3),n=VA(n,[2,2],[2,2],"same"),n=$de(n,t.conv4),n=VA(n,[2,2],[2,2],"same"),n=$de(n,t.conv5),n=VA(n,[2,2],[1,1],"same"),n=$de(n,t.conv6),n=$de(n,t.conv7),Nue(n,t.conv8,"valid",!1)}runMobilenet(e,t){let n=this.config.isFirstLayerConv2d?Tde(Nue(e,t.conv0,"valid",!1)):Ede(e,t.conv0);return n=VA(n,[2,2],[2,2],"same"),n=Ede(n,t.conv1),n=VA(n,[2,2],[2,2],"same"),n=Ede(n,t.conv2),n=VA(n,[2,2],[2,2],"same"),n=Ede(n,t.conv3),n=VA(n,[2,2],[2,2],"same"),n=Ede(n,t.conv4),n=VA(n,[2,2],[2,2],"same"),n=Ede(n,t.conv5),n=VA(n,[2,2],[1,1],"same"),n=t.conv6?Ede(n,t.conv6):n,n=t.conv7?Ede(n,t.conv7):n,Nue(n,t.conv8,"valid",!1)}forwardInput(e,t){let{params:n}=this;if(!n)throw new Error("TinyYolov2 - load model before inference");return G$((()=>{let r=M$(e.toBatchTensor(t,!1),"float32");return r=this.config.meanRgb?Ole(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,n):this.runTinyYolov2(r,n)}))}async forward(e,t){return this.forwardInput(await fue(e),t)}async detect(e,t={}){let{inputSize:n,scoreThreshold:r}=new Rde(t),a=await fue(e),i=await this.forwardInput(a,n),o=G$((()=>OF(i)[0].expandDims())),s={width:a.getInputWidth(0),height:a.getInputHeight(0)},l=await this.extractBoxes(o,a.getReshapedInputDimensions(0),r);i.dispose(),o.dispose();let u=l.map((e=>e.box)),d=l.map((e=>e.score)),c=l.map((e=>e.classScore)),p=l.map((e=>this.config.classes[e.label]));return function(e,t,n,r=!0){let a=t.map(((e,t)=>({score:e,boxIndex:t}))).sort(((e,t)=>e.score-t.score)).map((e=>e.boxIndex)),i=[];for(;a.length>0;){let t=a.pop();i.push(t);let o=a,s=[];for(let n=0;n<o.length;n++){let a=o[n],i=e[t],l=e[a];s.push(Mle(i,l,r))}a=a.filter(((e,t)=>s[t]<=n))}return i}(u.map((e=>e.rescale(n))),d,this.config.iouThreshold,!0).map((e=>new Fle(d[e],c[e],p[e],u[e],s)))}getDefaultModelName(){return""}extractParamsFromWeightMap(e){return function(e,t){let n,r=[],{extractConvParams:a,extractConvWithBatchNormParams:i,extractSeparableConvParams:o}=Ade(e,r);if(t.withSeparableConvs){let e=t.filterSizes&&t.filterSizes.length||9;n={conv0:t.isFirstLayerConv2d?a("conv0"):o("conv0"),conv1:o("conv1"),conv2:o("conv2"),conv3:o("conv3"),conv4:o("conv4"),conv5:o("conv5"),conv6:e>7?o("conv6"):void 0,conv7:e>8?o("conv7"):void 0,conv8:a("conv8")}}else n={conv0:i("conv0"),conv1:i("conv1"),conv2:i("conv2"),conv3:i("conv3"),conv4:i("conv4"),conv5:i("conv5"),conv6:i("conv6"),conv7:i("conv7"),conv8:a("conv8")};return Cue(e,r),{params:n,paramMappings:r}}(e,this.config)}extractParams(e){let t=this.config.filterSizes||Fde.DEFAULT_FILTER_SIZES,n=t?t.length:void 0;if(7!==n&&8!==n&&9!==n)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${n} filterSizes in config`);return function(e,t,n,r){let a,{extractWeights:i,getRemainingWeights:o}=Fue(e),s=[],{extractConvParams:l,extractConvWithBatchNormParams:u,extractSeparableConvParams:d}=_de(i,s);if(t.withSeparableConvs){let[e,i,o,s,u,c,p,h,f]=r;a={conv0:t.isFirstLayerConv2d?l(e,i,3,"conv0"):d(e,i,"conv0"),conv1:d(i,o,"conv1"),conv2:d(o,s,"conv2"),conv3:d(s,u,"conv3"),conv4:d(u,c,"conv4"),conv5:d(c,p,"conv5"),conv6:h?d(p,h,"conv6"):void 0,conv7:f?d(h,f,"conv7"):void 0,conv8:l(f||h||p,5*n,1,"conv8")}}else{let[e,t,i,o,s,d,c,p,h]=r;a={conv0:u(e,t,"conv0"),conv1:u(t,i,"conv1"),conv2:u(i,o,"conv2"),conv3:u(o,s,"conv3"),conv4:u(s,d,"conv4"),conv5:u(d,c,"conv5"),conv6:u(c,p,"conv6"),conv7:u(p,h,"conv7"),conv8:l(h,5*n,1,"conv8")}}if(0!==o().length)throw new Error(`weights remaing after extract: ${o().length}`);return{params:a,paramMappings:s}}(e,this.config,this.boxEncodingSize,t)}async extractBoxes(e,t,n){let{width:r,height:a}=t,i=Math.max(r,a),o=i/r,s=i/a,l=e.shape[1],u=this.config.anchors.length,[d,c,p]=G$((()=>{let t=e.reshape([l,l,u,this.boxEncodingSize]);return[t.slice([0,0,0,0],[l,l,u,4]),t.slice([0,0,0,4],[l,l,u,1]),this.withClassScores?uF(t.slice([0,0,0,5],[l,l,u,this.config.classes.length]),3):X_(0)]})),h=[],f=await c.array(),m=await d.array();for(let g=0;g<l;g++)for(let e=0;e<l;e++)for(let t=0;t<u;t++){let r=zle(f[g][e][t][0]);if(!n||r>n){let n=(e+zle(m[g][e][t][0]))/l*o,a=(g+zle(m[g][e][t][1]))/l*s,i=Math.exp(m[g][e][t][2])*this.config.anchors[t].x/l*o,u=Math.exp(m[g][e][t][3])*this.config.anchors[t].y/l*s,d=n-i/2,c=a-u/2,f={row:g,col:e,anchor:t},{classScore:b,label:y}=this.withClassScores?await this.extractPredictedClass(p,f):{classScore:1,label:0};h.push({box:new Rle(d,c,d+i,c+u),score:r,classScore:r*b,label:y,...f})}}return d.dispose(),c.dispose(),p.dispose(),h}async extractPredictedClass(e,t){let{row:n,col:r,anchor:a}=t,i=await e.array();return Array(this.config.classes.length).fill(0).map(((e,t)=>i[n][r][a][t])).map(((e,t)=>({classScore:e,label:t}))).reduce(((e,t)=>e.classScore>t.classScore?e:t))}},Dde=Fde;Dde.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var Mde=class extends Rde{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Ode=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function zde(e,t,n,r,a=(({alignedRect:e})=>e)){let i=e.map((e=>Hue(e)?a(e):e.detection)),o=r||(t instanceof QC?await gue(t,i):await mue(t,i)),s=await n(o);return o.forEach((e=>e instanceof QC&&e.dispose())),s}async function Pde(e,t,n,r,a){return zde([e],t,(async e=>n(e[0])),r,a)}var Lde=[new _le(1.603231,2.094468),new _le(6.041143,7.080126),new _le(2.882459,3.518061),new _le(4.266906,5.178857),new _le(9.041765,10.66308)],Bde=[117.001,114.697,97.404],Wde={ssdMobilenetv1:new class extends wue{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return G$((()=>{let n=M$(e.toBatchTensor(512,!1),"float32"),r=yde(RA(sE(n,127.5),1),t.mobilenetv1),{boxPredictions:a,classPredictions:i}=function(e,t,n){return G$((()=>{let r=gde(e,n.conv_0,[1,1]),a=gde(r,n.conv_1,[2,2]),i=gde(a,n.conv_2,[1,1]),o=gde(i,n.conv_3,[2,2]),s=gde(o,n.conv_4,[1,1]),l=gde(s,n.conv_5,[2,2]),u=gde(l,n.conv_6,[1,1]),d=gde(u,n.conv_7,[2,2]),c=wde(t,n.box_predictor_0),p=wde(e,n.box_predictor_1),h=wde(a,n.box_predictor_2),f=wde(o,n.box_predictor_3),m=wde(l,n.box_predictor_4),g=wde(d,n.box_predictor_5);return{boxPredictions:BE([c.boxPredictionEncoding,p.boxPredictionEncoding,h.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),classPredictions:BE([c.classPrediction,p.classPrediction,h.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1)}}))}(r.out,r.conv11,t.prediction_layer);return function(e,t,n){return G$((()=>{let r=e.shape[0],a=xde(zE(iA(n.extra_dim,[r,1,1]),[-1,4]),zE(e,[-1,4]));a=zE(a,[r,a.shape[0]/r,4]);let i=VE(UE(t,[0,0,1],[-1,-1,-1])),o=UE(i,[0,0,0],[-1,-1,1]);return o=zE(o,[r,o.shape[1]]),{boxes:OF(a),scores:OF(o)}}))}(a,i,t.output_layer)}))}async forward(e){return this.forwardInput(await fue(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:r}=new kde(t),a=await fue(e),{boxes:i,scores:o}=this.forwardInput(a),s=i[0],l=o[0];for(let b=1;b<i.length;b++)i[b].dispose(),o[b].dispose();let u=Array.from(l.dataSync()),d=function(e,t,n,r,a){let i=e.shape[0],o=Math.min(n,i),s=t.map(((e,t)=>({score:e,boxIndex:t}))).filter((e=>e.score>a)).sort(((e,t)=>t.score-e.score)),l=e=>e<=r?1:0,u=[];return s.forEach((t=>{if(u.length>=o)return;let n=t.score;for(let r=u.length-1;r>=0;--r){let n=vde(e,t.boxIndex,u[r]);if(0!==n&&(t.score*=l(n),t.score<=a))break}n===t.score&&u.push(t.boxIndex)})),u}(s,u,n,.5,r),c=a.getReshapedInputDimensions(0),p=a.inputSize,h=p/c.width,f=p/c.height,m=s.arraySync(),g=d.map((e=>{let[t,n]=[Math.max(0,m[e][0]),Math.min(1,m[e][2])].map((e=>e*f)),[r,i]=[Math.max(0,m[e][1]),Math.min(1,m[e][3])].map((e=>e*h));return new Dle(u[e],new Lle(r,t,i-r,n-t),{height:a.getInputHeight(0),width:a.getInputWidth(0)})}));return s.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return mde(e)}extractParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Fue(e),{extractMobilenetV1Params:a,extractPredictionLayerParams:i}=fde(n,t),o=a(),s=i(),l={extra_dim:SF(n(20472),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:o,prediction_layer:s,output_layer:l},paramMappings:t}}(e)}},tinyFaceDetector:new class extends Dde{constructor(){super({withSeparableConvs:!0,iouThreshold:.4,classes:["face"],anchors:Lde,meanRgb:Bde,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]})}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new Dle(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},tinyYolov2:new class extends Dde{constructor(e=!0){super({withSeparableConvs:e,iouThreshold:.4,classes:["face"],...e?{anchors:Ide,meanRgb:Nde}:{anchors:Sde,withClassScores:!0}})}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new Dle(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return this.withSeparableConvs?"tiny_yolov2_separable_conv_model":"tiny_yolov2_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},faceLandmark68Net:new class extends nde{constructor(e=new zue){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}},faceLandmark68TinyNet:new class extends nde{constructor(e=new rde){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}},faceRecognitionNet:new class extends wue{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return G$((()=>{let n=ode(Ole(M$(e.toBatchTensor(150,!0),"float32"),[122.782,117.001,104.298]).div(255),t.conv32_down);n=VA(n,3,2,"valid"),n=ude(n,t.conv32_1),n=ude(n,t.conv32_2),n=ude(n,t.conv32_3),n=dde(n,t.conv64_down),n=ude(n,t.conv64_1),n=ude(n,t.conv64_2),n=ude(n,t.conv64_3),n=dde(n,t.conv128_down),n=ude(n,t.conv128_1),n=ude(n,t.conv128_2),n=dde(n,t.conv256_down),n=ude(n,t.conv256_1),n=ude(n,t.conv256_2),n=dde(n,t.conv256_down_out);let r=n.mean([1,2]);return WE(r,t.fc)}))}async forward(e){return this.forwardInput(await fue(e))}async computeFaceDescriptor(e){var t;if(null!=(t=null==e?void 0:e.shape)&&t.some((e=>e<=0)))return new Float32Array(128);let n=await fue(e),r=G$((()=>OF(this.forwardInput(n)))),a=await Promise.all(r.map((e=>e.data())));return r.forEach((e=>e.dispose())),n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return function(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=lde(e,t),a=n("conv32_down"),i=r("conv32_1"),o=r("conv32_2"),s=r("conv32_3"),l=r("conv64_down"),u=r("conv64_1"),d=r("conv64_2"),c=r("conv64_3"),p=r("conv128_down"),h=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),b=r("conv256_2"),y=r("conv256_down_out"),{fc:v}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!yle(v))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${v}`);let x={conv32_down:a,conv32_1:i,conv32_2:o,conv32_3:s,conv64_down:l,conv64_1:u,conv64_2:d,conv64_3:c,conv128_down:p,conv128_1:h,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:b,conv256_down_out:y,fc:v};return Cue(e,t),{params:x,paramMappings:t}}(e)}extractParams(e){return function(e){let{extractWeights:t,getRemainingWeights:n}=Fue(e),r=[],{extractConvLayerParams:a,extractResidualLayerParams:i}=sde(t,r),o=a(4704,32,7,"conv32_down"),s=i(9216,32,3,"conv32_1"),l=i(9216,32,3,"conv32_2"),u=i(9216,32,3,"conv32_3"),d=i(36864,64,3,"conv64_down",!0),c=i(36864,64,3,"conv64_1"),p=i(36864,64,3,"conv64_2"),h=i(36864,64,3,"conv64_3"),f=i(147456,128,3,"conv128_down",!0),m=i(147456,128,3,"conv128_1"),g=i(147456,128,3,"conv128_2"),b=i(589824,256,3,"conv256_down",!0),y=i(589824,256,3,"conv256_1"),v=i(589824,256,3,"conv256_2"),x=i(589824,256,3,"conv256_down_out"),w=G$((()=>VF(kF(t(32768),[128,256]),[1,0])));if(r.push({paramPath:"fc"}),0!==n().length)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:o,conv32_1:s,conv32_2:l,conv32_3:u,conv64_down:d,conv64_1:c,conv64_2:p,conv64_3:h,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:b,conv256_1:y,conv256_2:v,conv256_down_out:x,fc:w},paramMappings:r}}(e)}},faceExpressionNet:new class extends Bue{constructor(e=new zue){super("FaceExpressionNet",e)}forwardInput(e){return G$((()=>uF(this.runNet(e))))}async forward(e){return this.forwardInput(await fue(e))}async predictExpressions(e){let t=await fue(e),n=await this.forwardInput(t),r=await Promise.all(OF(n).map((async e=>{let t=e.dataSync();return e.dispose(),t})));n.dispose();let a=r.map((e=>new Vue(e)));return t.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}},ageGenderNet:new class extends wue{constructor(e=new ede(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return G$((()=>{let n=e instanceof hue?this.faceFeatureExtractor.forwardInput(e):e,r=PE(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1);return{age:Pue(r,t.fc.age).as1D(),gender:Pue(r,t.fc.gender)}}))}forwardInput(e){return G$((()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:uF(n)}}))}async forward(e){return this.forwardInput(await fue(e))}async predictAgeAndGender(e){let t=await fue(e),n=await this.forwardInput(t),r=OF(n.age),a=OF(n.gender),i=r.map(((e,t)=>({ageTensor:e,genderTensor:a[t]}))),o=await Promise.all(i.map((async({ageTensor:e,genderTensor:t})=>{let n=e.dataSync()[0],r=t.dataSync()[0],a=r>.5,i=a?"male":"female",o=a?r:1-r;return e.dispose(),t.dispose(),{age:n,gender:i,genderProbability:o}})));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?o:o[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return function(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Fue(e),a=$ue(n,t),i=a(512,1,"fc/age"),o=a(512,2,"fc/gender");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:i,gender:o}}}}(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=Lue(e);return this.faceFeatureExtractor.loadFromWeightMap(t),function(e){let t=[],n=Rue(e,t);function r(e){return{weights:n(`${e}/weights`,2),bias:n(`${e}/bias`,1)}}let a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return Cue(e,t),{params:a,paramMappings:t}}(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}}},Vde=class extends Ode{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Ude=class extends Vde{async run(){let e=await this.parentTask,t=await zde(e,this.input,(async e=>Promise.all(e.map((e=>Wde.faceExpressionNet.predictExpressions(e))))),this.extractedFaces);return e.map(((e,n)=>Uue(e,t[n])))}withAgeAndGender(){return new Kde(this,this.input)}},jde=class extends Vde{async run(){let e=await this.parentTask;if(!e)return;let t=await Pde(e,this.input,(e=>Wde.faceExpressionNet.predictExpressions(e)),this.extractedFaces);return Uue(e,t)}withAgeAndGender(){return new Xde(this,this.input)}},Hde=class extends Ude{withAgeAndGender(){return new Yde(this,this.input)}withFaceDescriptors(){return new Jde(this,this.input)}},Gde=class extends jde{withAgeAndGender(){return new Qde(this,this.input)}withFaceDescriptor(){return new ece(this,this.input)}},qde=class extends Ode{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Kde=class extends qde{async run(){let e=await this.parentTask,t=await zde(e,this.input,(async e=>Promise.all(e.map((e=>Wde.ageGenderNet.predictAgeAndGender(e))))),this.extractedFaces);return e.map(((e,n)=>{let{age:r,gender:a,genderProbability:i}=t[n];return pde(hde(e,a,i),r)}))}withFaceExpressions(){return new Ude(this,this.input)}},Xde=class extends qde{async run(){let e=await this.parentTask;if(!e)return;let{age:t,gender:n,genderProbability:r}=await Pde(e,this.input,(e=>Wde.ageGenderNet.predictAgeAndGender(e)),this.extractedFaces);return pde(hde(e,n,r),t)}withFaceExpressions(){return new jde(this,this.input)}},Yde=class extends Kde{withFaceExpressions(){return new Hde(this,this.input)}withFaceDescriptors(){return new Jde(this,this.input)}},Qde=class extends Xde{withFaceExpressions(){return new Gde(this,this.input)}withFaceDescriptor(){return new ece(this,this.input)}},Zde=class extends Ode{constructor(e,t){super(),this.parentTask=e,this.input=t}},Jde=class extends Zde{async run(){let e=await this.parentTask;return(await zde(e,this.input,(e=>Promise.all(e.map((e=>Wde.faceRecognitionNet.computeFaceDescriptor(e))))),null,(e=>e.landmarks.align(null,{useDlibAlignment:!0})))).map(((t,n)=>cde(e[n],t)))}withFaceExpressions(){return new Hde(this,this.input)}withAgeAndGender(){return new Yde(this,this.input)}},ece=class extends Zde{async run(){let e=await this.parentTask;if(!e)return;let t=await Pde(e,this.input,(e=>Wde.faceRecognitionNet.computeFaceDescriptor(e)),null,(e=>e.landmarks.align(null,{useDlibAlignment:!0})));return cde(e,t)}withFaceExpressions(){return new Gde(this,this.input)}withAgeAndGender(){return new Qde(this,this.input)}},tce=class extends Ode{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?Wde.faceLandmark68TinyNet:Wde.faceLandmark68Net}},nce=class extends tce{async run(){let e=await this.parentTask,t=e.map((e=>e.detection)),n=this.input instanceof QC?await gue(this.input,t):await mue(this.input,t),r=await Promise.all(n.map((e=>this.landmarkNet.detectLandmarks(e))));return n.forEach((e=>e instanceof QC&&e.dispose())),e.filter(((e,t)=>r[t])).map(((e,t)=>Gue(e,r[t])))}withFaceExpressions(){return new Hde(this,this.input)}withAgeAndGender(){return new Yde(this,this.input)}withFaceDescriptors(){return new Jde(this,this.input)}},rce=class extends tce{async run(){let e=await this.parentTask;if(!e)return;let{detection:t}=e,n=this.input instanceof QC?await gue(this.input,[t]):await mue(this.input,[t]),r=await this.landmarkNet.detectLandmarks(n[0]);return n.forEach((e=>e instanceof QC&&e.dispose())),Gue(e,r)}withFaceExpressions(){return new Gde(this,this.input)}withAgeAndGender(){return new Qde(this,this.input)}withFaceDescriptor(){return new ece(this,this.input)}},ace=class extends Ode{constructor(e,t=new kde){super(),this.input=e,this.options=t}},ice=class extends ace{async run(){let e,{input:t,options:n}=this;if(n instanceof Mde)e=Wde.tinyFaceDetector.locateFaces(t,n);else if(n instanceof kde)e=Wde.ssdMobilenetv1.locateFaces(t,n);else{if(!(n instanceof Rde))throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");e=Wde.tinyYolov2.locateFaces(t,n)}return e}runAndExtendWithFaceDetections(){return new Promise(((e,t)=>{this.run().then((t=>e(t.map((e=>Hle({},e)))))).catch((e=>t(e)))}))}withFaceLandmarks(e=!1){return new nce(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new Ude(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new Kde(this.runAndExtendWithFaceDetections(),this.input)}},oce=class extends ace{async run(){let e=await new ice(this.input,this.options),t=e[0];return e.forEach((e=>{e.score>t.score&&(t=e)})),t}runAndExtendWithFaceDetection(){return new Promise((async e=>{let t=await this.run();e(t?Hle({},t):void 0)}))}withFaceLandmarks(e=!1){return new rce(this.runAndExtendWithFaceDetection(),this.input,e)}withFaceExpressions(){return new jde(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new Xde(this.runAndExtendWithFaceDetection(),this.input)}};function sce(e,t=new kde){return new oce(e,t)}var lce=class{constructor(e,t=.6){this._distanceThreshold=t;let n=Array.isArray(e)?e:[e];if(!n.length)throw new Error("FaceRecognizer.constructor - expected atleast one input");let r=1,a=()=>"person "+r++;this._labeledDescriptors=n.map((e=>{if(e instanceof Ule)return e;if(e instanceof Float32Array)return new Ule(a(),[e]);if(e.descriptor&&e.descriptor instanceof Float32Array)return new Ule(a(),[e.descriptor]);throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>")}))}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(e,t){return t.map((t=>function(e,t){if(e.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let n=Array.from(e),r=Array.from(t);return Math.sqrt(n.map(((e,t)=>e-r[t])).reduce(((e,t)=>e+t*t),0))}(t,e))).reduce(((e,t)=>e+t),0)/(t.length||1)}matchDescriptor(e){return this.labeledDescriptors.map((({descriptors:t,label:n})=>new Vle(n,this.computeMeanDistance(e,t)))).reduce(((e,t)=>e.distance<t.distance?e:t))}findBestMatch(e){let t=this.matchDescriptor(e);return t.distance<this._distanceThreshold?t:new Vle("unknown",t.distance)}toJSON(){return{distanceThreshold:this._distanceThreshold,labeledDescriptors:this._labeledDescriptors.map((e=>e.toJSON()))}}static fromJSON(e){let t=e.labeledDescriptors.map((e=>Ule.fromJSON(e)));return new lce(t,e.distanceThreshold)}};function uce(e,t){let{width:n,height:r}=new mle(t.width,t.height);if(n<=0||r<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:r})}`);if(Array.isArray(e))return e.map((e=>uce(e,{width:n,height:r})));if(Hue(e)){let t=e.detection.forSize(n,r),a=e.unshiftedLandmarks.forSize(t.box.width,t.box.height);return Gue(Hle(e,t),a)}return jle(e)?Hle(e,e.detection.forSize(n,r)):e instanceof Ble||e instanceof Dle?e.forSize(n,r):e}const dce=()=>{const e=W.useRef(null),t=W.useRef(null);return W.useEffect((()=>{const n=async()=>{const n=await(async()=>Promise.all(["Yeongseo","jane","Daegwon"].map((async e=>{const t=[];for(let n=1;n<=2;n++){const r=await yue(`./labels/${e}/${n}.jpg`),a=await sce(r).withFaceLandmarks().withFaceDescriptor();t.push(a.descriptor)}return new Ule(e,t)}))))(),r=new lce(n,.5),a=e.current,i=t.current,o={width:a.width,height:a.height};!function(e,t,n=!1){let{width:r,height:a}=n?uue(t):t;e.width=r,e.height=a}(i,o),setInterval((async()=>{if(!a.paused&&!a.ended){const e=await function(e,t=new kde){return new ice(e,t)}(a).withFaceLandmarks().withFaceDescriptors(),t=uce(e,o);i.getContext("2d").clearRect(0,0,i.width,i.height);const n=t.map((e=>r.findBestMatch(e.descriptor)));n.forEach(((e,n)=>{const r=t[n].detection.box;let a=e.toString();e.distance>.5&&(a="Unknown");const o=i.getContext("2d");o.lineWidth=2,o.strokeStyle="red",o.fillStyle="red",o.font="100px Arial";const s=t[n].landmarks,l=s.getLeftEye(),u=s.getRightEye(),d=(l[0].x+u[3].x)/2,c=(l[0].y+u[3].y)/2,p=o.measureText(a).width,h=parseInt(o.font),f=d-p/2,m=c-r.height/2-h;o.fillText(a,f,m+h),o.strokeRect(r.x,r.y,r.width,r.height)}))}}),100)};Promise.all([Wde.ssdMobilenetv1.loadFromUri("/models"),Wde.faceRecognitionNet.loadFromUri("/models"),Wde.faceLandmark68Net.loadFromUri("/models")]).then((()=>(async()=>{try{const t=await navigator.mediaDevices.getUserMedia({video:!0,audio:!1});e.current&&(e.current.srcObject=t)}catch(t){console.error("Error accessing webcam:",t)}})().then(n)))}),[]),Y.jsxs(Y.Fragment,{children:[Y.jsx("video",{ref:e,id:"video",width:"720",height:"560",autoPlay:!0,muted:!0,style:{width:"100%",height:"100%",marginBottom:"20px"}}),Y.jsx("canvas",{ref:t,style:{width:"100%",height:"100%",position:"absolute",top:0,left:0}})]})},cce=()=>Y.jsxs("div",{children:[Y.jsx("h1",{children:"Face Recognition App"}),Y.jsx(dce,{})]});Lx({mode:"md"});const pce=()=>{const[e,t]=W.useState("회원번호 입력 (5자리)"),[n,r]=W.useState(!1),a=a=>{0==n&&(t(""+a.target.textContent),r(!0)),3==e.length||8==e.length?t(e+"-"+a.target.textContent):e.length>=13?e.length>13&&t(a.target.textContent):t(e+a.target.textContent)};return Y.jsxs(Y.Fragment,{children:[Y.jsx(Jv,{}),Y.jsx(Qv,{children:Y.jsxs(Zv,{class:"input_box",children:[Y.jsx(nx,{class:"input_segment",children:Y.jsxs(rx,{class:"input_segment",onIonChange:e=>(e=>{"clubID"==e?t("회원번호 입력 (5자리)"):"Tel"==e&&t("010-"),r(!1)})(e.target.value),children:[Y.jsx(ax,{class:"input_segment",value:"clubID",children:Y.jsx(ex,{children:"회원번호"})}),Y.jsx(ax,{class:"input_segment",value:"Tel",children:Y.jsx(ex,{children:"휴대폰번호"})})]})}),Y.jsx(nx,{class:"input_div_row",children:Y.jsx(Yv,{class:"input_box",children:Y.jsx("div",{className:"input_div ion-text-center",children:e})})}),Y.jsxs(nx,{class:"input_desc",children:[Y.jsx("div",{className:"hr"}),Y.jsx("div",{className:"input_desc",children:"만약 얼굴인식이 안되는 경우, \n본인의 회원번호(5자리) 혹은 휴대폰번호를 입력해주세요."})]}),Y.jsxs(nx,{class:"input_pad",children:[Y.jsx(nx,{class:"input_row",children:Y.jsxs(Yv,{class:"input_box",children:[Y.jsx(dx,{class:"input_btn",onClick:a,children:"1"}),Y.jsx(dx,{class:"input_btn",onClick:a,children:"2"}),Y.jsx(dx,{class:"input_btn",onClick:a,children:"3"})]})}),Y.jsx(nx,{class:"input_row",children:Y.jsxs(Yv,{class:"input_box",children:[Y.jsx(dx,{class:"input_btn",onClick:a,children:"4"}),Y.jsx(dx,{class:"input_btn",onClick:a,children:"5"}),Y.jsx(dx,{class:"input_btn",onClick:a,children:"6"})]})}),Y.jsx(nx,{class:"input_row",children:Y.jsxs(Yv,{class:"input_box",children:[Y.jsx(dx,{class:"input_btn",onClick:a,children:"7"}),Y.jsx(dx,{class:"input_btn",onClick:a,children:"8"}),Y.jsx(dx,{class:"input_btn",onClick:a,children:"9"})]})}),Y.jsx(nx,{class:"input_row",children:Y.jsxs(Yv,{class:"input_box",children:[Y.jsx(dx,{class:"input_btn",onClick:()=>{t("")},children:"취소"}),Y.jsx(dx,{class:"input_btn",onClick:a,children:"0"}),Y.jsx(dx,{class:"input_btn",onClick:()=>{5==e.length||10==e.length?t(e.slice(0,-2)):t(e.slice(0,-1))},children:"←"})]})})]})]})})]})},hce=()=>Y.jsxs(Y.Fragment,{children:[Y.jsx(Jv,{children:Y.jsxs(ox,{children:[Y.jsx(Xv,{slot:"start",children:Y.jsx(Fx,{})}),Y.jsx(ix,{children:"입장"})]})}),Y.jsxs(Qv,{class:"ion-padding",children:[Y.jsx(Zv,{children:Y.jsx(nx,{children:Y.jsx(Yv,{children:Y.jsx("br",{})})})}),Y.jsx(Zv,{children:Y.jsx(nx,{children:Y.jsx(Yv,{id:"frist",children:Y.jsxs("div",{className:"text_container",children:[Y.jsx("h2",{children:"체육관 출결관리 시스템"}),Y.jsx("p",{children:"현재 연동된 체육관 : 홀리데이 피트니스클럽(광주효천점)"})]})})})}),Y.jsx(Zv,{children:Y.jsxs(nx,{children:[Y.jsxs(Yv,{id:"second",children:[" ",Y.jsx(tx,{routerDirection:"forward",component:()=>Y.jsx(InputId,{}),children:Y.jsx(dx,{className:"enumButton",children:"회원번호로 입장"})})]}),Y.jsx(Yv,{children:Y.jsx(tx,{routerDirection:"forward",component:()=>Y.jsx(pce,{}),children:Y.jsx(dx,{className:"pnumButton",children:"전화번호로 입장"})})})]})})]})]}),fce=()=>Y.jsxs(Y.Fragment,{children:[Y.jsx(Jv,{children:Y.jsxs(ox,{children:[Y.jsx(Xv,{slot:"start",children:Y.jsx(Fx,{})}),Y.jsx(ix,{children:"퇴장"})]})}),Y.jsxs(Qv,{class:"ion-padding",children:[Y.jsx(Zv,{children:Y.jsx(nx,{children:Y.jsx(Yv,{children:Y.jsx("br",{})})})}),Y.jsx(Zv,{children:Y.jsx(nx,{children:Y.jsx(Yv,{id:"frist",children:Y.jsxs("div",{className:"text_container",children:[Y.jsx("h2",{children:"체육관 출결관리 시스템"}),Y.jsx("p",{children:"현재 연동된 체육관 : 홀리데이 피트니스클럽(광주효천점)"})]})})})}),Y.jsx(Zv,{children:Y.jsxs(nx,{children:[Y.jsxs(Yv,{id:"second",children:[" ",Y.jsx(tx,{routerDirection:"forward",component:()=>Y.jsx(pce,{}),children:Y.jsx(dx,{className:"enumButton",children:"회원번호로 퇴장"})})]}),Y.jsx(Yv,{children:Y.jsx(tx,{routerDirection:"forward",component:()=>Y.jsx(pce,{}),children:Y.jsx(dx,{className:"pnumButton",children:"전화번호로 퇴장"})})})]})})]})]}),mce="/assets/test-03c7e081.svg";function gce(){const[e,t]=W.useState(window.innerWidth);W.useState(window.innerHeight);const n=()=>{t(window.innerWidth)};return W.useEffect((()=>(window.addEventListener("resize",n),()=>{window.removeEventListener("resize",n)})),[]),Y.jsx(Y.Fragment,{children:window.innerWidth<=window.innerHeight?Y.jsxs(Zv,{style:{border:"0px"},children:[Y.jsx(nx,{style:{border:"0px"},children:Y.jsx(Yv,{size:"12",style:{border:"0px"},children:Y.jsx("img",{style:{width:"13%"},src:mce,alt:"Logo"})})}),Y.jsx(nx,{children:Y.jsx(Yv,{style:{border:"0px"},children:Y.jsx("div",{style:{textAlign:"center",fontSize:"180%",fontWeight:700,letterSpacing:"-3.12%",color:"white",marginTop:"3%",marginBottom:"5%"},children:"홀리데이 피트니스클럽(광주효천점)"})})})]}):Y.jsx(Zv,{style:{border:"0px"},children:Y.jsxs(nx,{style:{border:"0px"},children:[Y.jsx(Yv,{size:"auto",style:{marginLeft:"3%",marginBottom:"18%",border:"0px"},children:Y.jsx("img",{style:{width:"100%",marginLeft:"5%"},src:mce,alt:"Logo"})}),Y.jsx(Yv,{size:"auto",style:{marginLeft:"0.7%",marginBottom:"18%",border:"0px"},children:Y.jsx("div",{style:{textAlign:"center",color:"white",fontWeight:700,letterSpacing:"-3.12%",fontSize:"190%",marginTop:"3.3%"},children:"홀리데이 피트니스클럽(광주효천점)"})})]})})})}function bce(){const[e,t]=W.useState(window.innerWidth);W.useState(window.innerHeight);const n=()=>{t(window.innerWidth)};return W.useEffect((()=>(window.addEventListener("resize",n),()=>{window.removeEventListener("resize",n)})),[]),Y.jsx(Y.Fragment,{children:window.innerWidth<=window.innerHeight?Y.jsx(Zv,{children:Y.jsx(nx,{style:{height:"280px"},children:Y.jsx(Yv,{style:{border:"0px",margin:"0px auto",padding:"5px 5px"},children:Y.jsxs("div",{style:{width:"100%",height:"100%",backgroundColor:"white",borderRadius:"1.2%",color:"black",textAlign:"left",paddingLeft:"6%",paddingTop:"5%",fontSize:"125%",fontWeight:400,lineHeight:"190%"},children:["∙ 여름시즌 다이어트 프로그램 안내",Y.jsx("br",{}),"∙ 이번달 회원 등록시 운동복 무료 이용권 증정"]})})})}):Y.jsx(Zv,{})})}function yce(){console.log("check")}function vce(){return Y.jsx(Y.Fragment,{children:Y.jsxs(Zv,{class:"btns",children:[Y.jsxs(nx,{children:[Y.jsx(Yv,{class:"out_btn",children:Y.jsx(dx,{class:"out_btn",onClick:yce,children:"퇴소하기"})}),Y.jsx(Yv,{class:"call_btn",children:Y.jsx(dx,{class:"call_btn",onClick:yce,children:"직원호출"})})]}),Y.jsx(nx,{children:Y.jsx(Yv,{class:"in_btn",children:Y.jsx(dx,{class:"in_btn",onClick:yce,children:"출석하기"})})})]})})}function xce(){const[e,t]=W.useState(window.innerWidth);W.useState(window.innerHeight);const n=()=>{t(window.innerWidth)};return W.useEffect((()=>(window.addEventListener("resize",n),()=>{window.removeEventListener("resize",n)})),[]),Y.jsx(Y.Fragment,{children:Y.jsxs(Qv,{children:[Y.jsx("div",{className:"background-image-init"}),Y.jsx("div",{className:"background-image-img"}),Y.jsx("div",{className:"background-image-gradient"}),Y.jsx("div",{className:"content",children:Y.jsxs(Zv,{class:"window",children:[Y.jsx(nx,{class:"title",children:Y.jsx(Yv,{children:Y.jsx(gce,{})})}),window.innerWidth<=window.innerHeight?Y.jsx(nx,{class:"announcement",children:Y.jsx(Yv,{class:"announcement",children:Y.jsx(bce,{})})}):Y.jsx("div",{}),Y.jsxs(nx,{class:"bottom_side",children:[Y.jsx(Yv,{size:"8",class:"main_input_box",children:Y.jsx("div",{className:"main_input_box",children:Y.jsx(pce,{})})}),Y.jsx(Yv,{size:"4",class:"btn_and_face",children:Y.jsxs(Zv,{children:[Y.jsx(nx,{children:Y.jsx(Yv,{class:"face"})}),Y.jsx(nx,{children:Y.jsx(Yv,{class:"btn",children:Y.jsx(vce,{})})})]})})]})]})})]})})}Lx();const wce=()=>Y.jsx(vx,{children:Y.jsx(Zx,{children:Y.jsxs($x,{children:[Y.jsxs(bh,{exact:!0,path:"/home",children:[Y.jsx(Ix,{root:()=>Y.jsx(cce,{})}),";"]}),Y.jsx(bh,{exact:!0,path:"/Exit",children:Y.jsx(fce,{})}),Y.jsx(bh,{exact:!0,path:"/Entrance",children:Y.jsx(hce,{})}),Y.jsx(bh,{exact:!0,path:"/Main",children:Y.jsx(xce,{})}),Y.jsx(bh,{exact:!0,path:"/",children:Y.jsx(ph,{to:"/Main"})}),Y.jsx(bh,{exact:!0,path:"/logo",children:Y.jsx(gce,{})}),Y.jsx(bh,{exact:!0,path:"/announcement",children:Y.jsx(bce,{})}),Y.jsx(bh,{exact:!0,path:"/numpad",children:Y.jsx(pce,{})})]})})});oc(document.getElementById("root")).render(Y.jsx(V.StrictMode,{children:Y.jsx(wce,{})}))}}}));
